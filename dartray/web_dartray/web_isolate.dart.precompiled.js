// Generated by dart2js, the Dart to JavaScript compiler.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
(function($) {
function dart(){ this.x = 0 }var A = new dart;
delete A.x;
var B = new dart;
delete B.x;
var C = new dart;
delete C.x;
var D = new dart;
delete D.x;
var E = new dart;
delete E.x;
var F = new dart;
delete F.x;
var G = new dart;
delete G.x;
var H = new dart;
delete H.x;
var J = new dart;
delete J.x;
var K = new dart;
delete K.x;
var L = new dart;
delete L.x;
var M = new dart;
delete M.x;
var N = new dart;
delete N.x;
var O = new dart;
delete O.x;
var P = new dart;
delete P.x;
var Q = new dart;
delete Q.x;
var R = new dart;
delete R.x;
var S = new dart;
delete S.x;
var T = new dart;
delete T.x;
var U = new dart;
delete U.x;
var V = new dart;
delete V.x;
var W = new dart;
delete W.x;
var X = new dart;
delete X.x;
var Y = new dart;
delete Y.x;
var Z = new dart;
delete Z.x;
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
var $$ = {};

// Native classes
(function (reflectionData) {
  "use strict";
  function map(x){x={x:x};delete x.x;return x}
    function processStatics(descriptor) {
      for (var property in descriptor) {
        if (!hasOwnProperty.call(descriptor, property)) continue;
        if (property === "^") continue;
        var element = descriptor[property];
        var firstChar = property.substring(0, 1);
        var previousProperty;
        if (firstChar === "+") {
          mangledGlobalNames[previousProperty] = property.substring(1);
          var flag = descriptor[property];
          if (flag > 0) descriptor[previousProperty].$reflectable = flag;
          if (element && element.length) init.typeInformation[previousProperty] = element;
        } else if (firstChar === "@") {
          property = property.substring(1);
          $[property]["@"] = element;
        } else if (firstChar === "*") {
          globalObject[previousProperty].$defaultValues = element;
          var optionalMethods = descriptor.$methodsWithOptionalArguments;
          if (!optionalMethods) {
            descriptor.$methodsWithOptionalArguments = optionalMethods = {}
          }
          optionalMethods[property] = previousProperty;
        } else if (typeof element === "function") {
          globalObject[previousProperty = property] = element;
          functions.push(property);
          init.globalFunctions[property] = element;
        } else if (element.constructor === Array) {
          addStubs(globalObject, element, property, true, descriptor, functions);
        } else {
          previousProperty = property;
          var newDesc = {};
          var previousProp;
          for (var prop in element) {
            if (!hasOwnProperty.call(element, prop)) continue;
            firstChar = prop.substring(0, 1);
            if (prop === "static") {
              processStatics(init.statics[property] = element[prop]);
            } else if (firstChar === "+") {
              mangledNames[previousProp] = prop.substring(1);
              var flag = element[prop];
              if (flag > 0) element[previousProp].$reflectable = flag;
            } else if (firstChar === "@" && prop !== "@") {
              newDesc[prop.substring(1)]["@"] = element[prop];
            } else if (firstChar === "*") {
              newDesc[previousProp].$defaultValues = element[prop];
              var optionalMethods = newDesc.$methodsWithOptionalArguments;
              if (!optionalMethods) {
                newDesc.$methodsWithOptionalArguments = optionalMethods={}
              }
              optionalMethods[prop] = previousProp;
            } else {
              var elem = element[prop];
              if (prop !== "^" && elem != null && elem.constructor === Array && prop !== "<>") {
                addStubs(newDesc, elem, prop, false, element, []);
              } else {
                newDesc[previousProp = prop] = elem;
              }
            }
          }
          $$[property] = [globalObject, newDesc];
          classes.push(property);
        }
      }
    }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var f, funcs = [originalDescriptor[name] = descriptor[name] = f = array[0]];
    f.$stubName = name;
    functions.push(name);
    for (var index = 0; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function") break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++) {
      funcs[i].$callName = array[index + 1];
    }
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex =  2 * optionalParameterCount + requiredParameterCount + 3;
    var isReflectable = array.length > unmangledNameIndex;

    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic) init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName) functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
      if (isIntercepted) init.interceptedNames[getterStubName] = true;
    }
    if (isReflectable) {
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].$reflectable = 1;
        funcs[i].$reflectionInfo = array;
      }
      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
      var unmangledName = array[unmangledNameIndex];
      var reflectionName = unmangledName;
      if (getterStubName) mangledNames[getterStubName] = reflectionName;
      if (isSetter) {
        reflectionName += "=";
      } else if (!isGetter) {
        reflectionName += ":" + requiredParameterCount + ":" + optionalParameterCount;
      }
      mangledNames[name] = reflectionName;
      funcs[0].$reflectionName = reflectionName;
      funcs[0].$metadataIndex = unmangledNameIndex + 1;
      if (optionalParameterCount) descriptor[unmangledName + "*"] = funcs[0];
    }
  }
  function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted
        ? new Function("funcs", "reflectionInfo", "name", "H", "c",
            "return function tearOff_" + name + (functionCounter++)+ "(x) {" +
              "if (c === null) c = H.closureFromTearOff(" +
                  "this, funcs, reflectionInfo, false, [x], name);" +
              "return new c(this, funcs[0], x, name);" +
            "}")(funcs, reflectionInfo, name, H, null)
        : new Function("funcs", "reflectionInfo", "name", "H", "c",
            "return function tearOff_" + name + (functionCounter++)+ "() {" +
              "if (c === null) c = H.closureFromTearOff(" +
                  "this, funcs, reflectionInfo, false, [], name);" +
              "return new c(this, funcs[0], null, name);" +
            "}")(funcs, reflectionInfo, name, H, null)
  }
  function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {
    var cache = null;
    return isIntercepted
        ? function(x) {
            if (cache === null) cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [x], name);
            return new cache(this, funcs[0], x, name)
          }
        : function() {
            if (cache === null) cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [], name);
            return new cache(this, funcs[0], null, name)
          }
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic
        ? function() {
            if (cache === void 0) cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
            return cache;
          }
        : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  var tearOffGetter = (typeof dart_precompiled == "function")
      ? tearOffGetterCsp : tearOffGetterNoCsp;
  if (!init.libraries) init.libraries = [];
  if (!init.mangledNames) init.mangledNames = map();
  if (!init.mangledGlobalNames) init.mangledGlobalNames = map();
  if (!init.statics) init.statics = map();
  if (!init.typeInformation) init.typeInformation = map();
  if (!init.globalFunctions) init.globalFunctions = map();
  if (!init.interceptedNames) init.interceptedNames = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    var classes = [];
    var functions = [];
    processStatics(descriptor);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot,
                    globalObject]);
  }
})
([
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  makeDispatchRecord: function(interceptor, proto, extension, indexability) {
    return {i: interceptor, p: proto, e: extension, x: indexability};
  },
  getNativeInterceptor: function(object) {
    var record, proto, objectProto, interceptor;
    record = object[init.dispatchPropertyName];
    if (record == null)
      if ($.initNativeDispatchFlag == null) {
        H.initNativeDispatch();
        record = object[init.dispatchPropertyName];
      }
    if (record != null) {
      proto = record.p;
      if (false === proto)
        return record.i;
      if (true === proto)
        return object;
      objectProto = Object.getPrototypeOf(object);
      if (proto === objectProto)
        return record.i;
      if (record.e === objectProto)
        throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
    }
    interceptor = H.lookupAndCacheInterceptor(object);
    if (interceptor == null) {
      proto = Object.getPrototypeOf(object);
      if (proto == null || proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      else
        return C.UnknownJavaScriptObject_methods;
    }
    return interceptor;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    },
    "%": "MediaError|MediaKeyError|Navigator|PositionError|SQLError|SVGAnimatedEnumeration|SVGAnimatedLength|SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedString|SVGAnimatedTransformList|SVGPointList"
  },
  JSBool: {
    "^": "bool/Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    $isbool: true
  },
  JSNull: {
    "^": "Null/Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    }
  },
  JavaScriptObject: {
    "^": "Interceptor;",
    get$hashCode: function(_) {
      return 0;
    }
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  JSArray: {
    "^": "List/Interceptor;",
    add$1: function(receiver, value) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    },
    removeAt$1: function(receiver, index) {
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeAt"));
      return receiver.splice(index, 1)[0];
    },
    remove$1: function(receiver, element) {
      var i;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("remove"));
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    addAll$1: function(receiver, collection) {
      var t1;
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        this.add$1(receiver, t1._current);
    },
    forEach$1: function(receiver, f) {
      return H.IterableMixinWorkaround_forEach(receiver, f);
    },
    skip$1: function(receiver, n) {
      return H.SubListIterable$(receiver, n, null, null);
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      if (start == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof start !== "number" || Math.floor(start) !== start)
        throw H.wrapException(P.ArgumentError$(start));
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length));
      if (end == null)
        end = receiver.length;
      else {
        if (typeof end !== "number" || Math.floor(end) !== end)
          throw H.wrapException(P.ArgumentError$(end));
        if (end < start || end > receiver.length)
          throw H.wrapException(P.RangeError$range(end, start, receiver.length));
      }
      if (start === end)
        return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("set range"));
      H.IterableMixinWorkaround_setRangeList(receiver, start, end, iterable, skipCount);
    },
    fillRange$3: function(receiver, start, end, fillValue) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("fill range"));
      H.IterableMixinWorkaround_fillRangeList(receiver, start, end, fillValue);
    },
    sort$1: function(receiver, compare) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("sort"));
      H.IterableMixinWorkaround_sortList(receiver, compare);
    },
    lastIndexOf$2: function(receiver, element, start) {
      return H.Lists_lastIndexOf(receiver, element, receiver.length - 1);
    },
    lastIndexOf$1: function($receiver, element) {
      return this.lastIndexOf$2($receiver, element, null);
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return H.IterableMixinWorkaround_toStringIterable(receiver, "[", "]");
    },
    toList$1$growable: function(receiver, growable) {
      var t1;
      if (growable)
        return H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
      else {
        t1 = H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
        t1.fixed$length = init;
        return t1;
      }
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$iterator: function(receiver) {
      return new H.ListIterator(receiver, receiver.length, 0, null);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    length$0: function($receiver) {
      return this.get$length($receiver).call$0();
    },
    set$length: function(receiver, newLength) {
      if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
        throw H.wrapException(P.ArgumentError$(newLength));
      if (newLength < 0)
        throw H.wrapException(P.RangeError$value(newLength));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("set length"));
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      receiver[index] = value;
    },
    $isList: true,
    $isJSIndexable: true,
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    static: {JSArray_JSArray$fixed: function($length, $E) {
        var t1;
        if (typeof $length !== "number" || Math.floor($length) !== $length || $length < 0)
          throw H.wrapException(P.ArgumentError$("Length must be a non-negative integer: " + H.S($length)));
        t1 = H.setRuntimeTypeInfo(new Array($length), [$E]);
        t1.fixed$length = init;
        return t1;
      }}
  },
  JSNumber: {
    "^": "num/Interceptor;",
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (this.get$isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$isNaN: function(receiver) {
      return isNaN(receiver);
    },
    get$isInfinite: function(receiver) {
      return receiver == Infinity || receiver == -Infinity;
    },
    remainder$1: function(receiver, b) {
      return receiver % b;
    },
    abs$0: function(receiver) {
      return Math.abs(receiver);
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$('' + receiver));
    },
    ceil$0: function(receiver) {
      return this.toInt$0(Math.ceil(receiver));
    },
    floor$0: function(receiver) {
      return this.toInt$0(Math.floor(receiver));
    },
    round$0: function(receiver) {
      return this.toInt$0(this.roundToDouble$0(receiver));
    },
    roundToDouble$0: function(receiver) {
      if (receiver < 0)
        return -Math.round(-receiver);
      else
        return Math.round(receiver);
    },
    clamp$2: function(receiver, lowerLimit, upperLimit) {
      if (typeof lowerLimit !== "number")
        throw H.wrapException(P.ArgumentError$(lowerLimit));
      if (typeof upperLimit !== "number")
        throw H.wrapException(P.ArgumentError$(upperLimit));
      if (this.compareTo$1(lowerLimit, upperLimit) > 0)
        throw H.wrapException(P.ArgumentError$(lowerLimit));
      if (this.compareTo$1(receiver, lowerLimit) < 0)
        return lowerLimit;
      if (this.compareTo$1(receiver, upperLimit) > 0)
        return upperLimit;
      return receiver;
    },
    toDouble$0: function(receiver) {
      return receiver;
    },
    toRadixString$1: function(receiver, radix) {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$(radix));
      return receiver.toString(radix);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $negate: function(receiver) {
      return -receiver;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $div: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver / other;
    },
    $mul: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver * other;
    },
    $mod: function(receiver, other) {
      var result;
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else {
        if (typeof other !== "number")
          H.throwExpression(P.ArgumentError$(other));
        return this.toInt$0(receiver / other);
      }
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    $shl: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shlPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    $shr: function(receiver, other) {
      var t1;
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver >>> other;
    },
    _shrBothPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver >>> other;
    },
    $and: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver & other) >>> 0;
    },
    $or: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver | other) >>> 0;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver > other;
    },
    $le: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver <= other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver >= other;
    },
    $isnum: true,
    static: {"^": "JSNumber__MIN_INT32,JSNumber__MAX_INT32"}
  },
  JSInt: {
    "^": "int/JSNumber;",
    $isdouble: true,
    $isnum: true,
    $isint: true
  },
  JSDouble: {
    "^": "double/JSNumber;",
    $isdouble: true,
    $isnum: true
  },
  JSString: {
    "^": "String/Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index));
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      return receiver.charCodeAt(index);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    substring$2: function(receiver, startIndex, endIndex) {
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
        H.throwExpression(P.ArgumentError$(endIndex));
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex));
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toLowerCase$0: function(receiver) {
      return receiver.toLowerCase();
    },
    trim$0: function(receiver) {
      var result, endIndex, startIndex, t1, endIndex0;
      result = receiver.trim();
      endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this.codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    $mul: function(receiver, times) {
      var s, result;
      if (typeof times !== "number")
        return H.iae(times);
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    get$codeUnits: function(receiver) {
      return new J._CodeUnits(receiver);
    },
    indexOf$2: function(receiver, pattern, start) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length));
      return receiver.indexOf(pattern, start);
    },
    lastIndexOf$2: function(receiver, pattern, start) {
      var t1, t2;
      start = receiver.length;
      t1 = pattern.length;
      t2 = receiver.length;
      if (start + t1 > t2)
        start = t2 - t1;
      return receiver.lastIndexOf(pattern, start);
    },
    lastIndexOf$1: function($receiver, pattern) {
      return this.lastIndexOf$2($receiver, pattern, null);
    },
    contains$2: function(receiver, other, startIndex) {
      if (startIndex > receiver.length)
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    length$0: function($receiver) {
      return this.get$length($receiver).call$0();
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $isJSIndexable: true,
    $isString: true,
    static: {JSString__isWhitespace: function(codeUnit) {
        if (codeUnit < 256)
          switch (codeUnit) {
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 32:
            case 133:
            case 160:
              return true;
            default:
              return false;
          }
        switch (codeUnit) {
          case 5760:
          case 6158:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8232:
          case 8233:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }, JSString__skipLeadingWhitespace: function(string, index) {
        var t1, codeUnit;
        for (t1 = string.length; index < t1;) {
          if (index >= t1)
            H.throwExpression(P.RangeError$value(index));
          codeUnit = string.charCodeAt(index);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
          ++index;
        }
        return index;
      }, JSString__skipTrailingWhitespace: function(string, index) {
        var t1, index0, codeUnit;
        for (t1 = string.length; index > 0; index = index0) {
          index0 = index - 1;
          if (index0 >= t1)
            H.throwExpression(P.RangeError$value(index0));
          codeUnit = string.charCodeAt(index0);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
        }
        return index;
      }}
  },
  _CodeUnits: {
    "^": "UnmodifiableListBase;_string",
    get$length: function(_) {
      return this._string.length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    $index: function(_, i) {
      var t1, t2;
      t1 = this._string;
      if (typeof i !== "number" || Math.floor(i) !== i)
        H.throwExpression(P.ArgumentError$(i));
      t2 = J.getInterceptor$n(i);
      if (t2.$lt(i, 0))
        H.throwExpression(P.RangeError$value(i));
      if (t2.$ge(i, t1.length))
        H.throwExpression(P.RangeError$value(i));
      return t1.charCodeAt(i);
    },
    $asUnmodifiableListBase: function() {
      return [J.JSInt];
    },
    $asListBase: function() {
      return [J.JSInt];
    },
    $asList: function() {
      return [J.JSInt];
    }
  }
}],
["_isolate_helper", "dart:_isolate_helper", , H, {
  "^": "",
  _callInIsolate: function(isolate, $function) {
    var result = isolate.eval$1($function);
    init.globalState.topEventLoop.run$0();
    return result;
  },
  leaveJsAsync: function() {
    --init.globalState.topEventLoop._activeJsAsyncCount;
  },
  startRootIsolate: function(entry, args) {
    var t1, t2, t3, t4, t5, rootContext;
    t1 = {};
    t1.args_0 = args;
    args = args;
    t1.args_0 = args;
    if (args == null) {
      args = [];
      t1.args_0 = args;
      t2 = args;
    } else
      t2 = args;
    if (!J.getInterceptor(t2).$isList)
      throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
    t2 = new H._Manager(0, 0, 1, null, null, null, null, null, null, null, null, null, entry);
    t2._Manager$1(entry);
    init.globalState = t2;
    if (init.globalState.isWorker === true)
      return;
    t2 = init.globalState.nextIsolateId++;
    t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, J.JSInt, H.RawReceivePortImpl);
    t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, J.JSInt);
    t5 = new H.RawReceivePortImpl(0, null, false);
    rootContext = new H._IsolateContext(t2, t3, t4, new Isolate(), t5, P.Capability_Capability(), P.Capability_Capability(), false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, false);
    t4.add$1(0, 0);
    rootContext._addRegistration$2(0, t5);
    init.globalState.rootContext = rootContext;
    init.globalState.currentContext = rootContext;
    t2 = H.getDynamicRuntimeType();
    t3 = H.buildFunctionType(t2, [t2])._isTest$1(entry);
    if (t3)
      rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
    else {
      t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(entry);
      if (t2)
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
    }
    init.globalState.topEventLoop.run$0();
  },
  IsolateNatives_computeThisScript: function() {
    var currentScript = init.currentScript;
    if (currentScript != null)
      return String(currentScript.src);
    if (typeof version == "function" && typeof os == "object" && "system" in os)
      return H.IsolateNatives_computeThisScriptFromTrace();
    if (typeof version == "function" && typeof system == "function")
      return thisFilename();
    if (init.globalState.isWorker === true)
      return H.IsolateNatives_computeThisScriptFromTrace();
    return;
  },
  IsolateNatives_computeThisScriptFromTrace: function() {
    var stack, matches;
    stack = new Error().stack;
    if (stack == null) {
      stack = (function() {try { throw new Error() } catch(e) { return e.stack }})();
      if (stack == null)
        throw H.wrapException(P.UnsupportedError$("No stack trace"));
    }
    matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
    if (matches != null)
      return matches[1];
    matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
    if (matches != null)
      return matches[1];
    throw H.wrapException(P.UnsupportedError$("Cannot extract URI from \"" + H.S(stack) + "\""));
  },
  IsolateNatives__processWorkerMessage: function(sender, e) {
    var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, context;
    msg = H._deserializeMessage(e.data);
    t1 = J.getInterceptor$asx(msg);
    switch (t1.$index(msg, "command")) {
      case "start":
        init.globalState.currentManagerId = t1.$index(msg, "id");
        functionName = t1.$index(msg, "functionName");
        entryPoint = functionName == null ? init.globalState.entry : init.globalFunctions[functionName]();
        args = t1.$index(msg, "args");
        message = H._deserializeMessage(t1.$index(msg, "msg"));
        isSpawnUri = t1.$index(msg, "isSpawnUri");
        startPaused = t1.$index(msg, "startPaused");
        replyTo = H._deserializeMessage(t1.$index(msg, "replyTo"));
        t1 = init.globalState.nextIsolateId++;
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, J.JSInt, H.RawReceivePortImpl);
        t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, J.JSInt);
        t4 = new H.RawReceivePortImpl(0, null, false);
        context = new H._IsolateContext(t1, t2, t3, new Isolate(), t4, P.Capability_Capability(), P.Capability_Capability(), false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, false);
        t3.add$1(0, 0);
        context._addRegistration$2(0, t4);
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start"));
        init.globalState.currentContext = context;
        init.globalState.topEventLoop.run$0();
        break;
      case "spawn-worker":
        H.IsolateNatives__spawnWorker(t1.$index(msg, "functionName"), t1.$index(msg, "uri"), t1.$index(msg, "args"), t1.$index(msg, "msg"), t1.$index(msg, "isSpawnUri"), t1.$index(msg, "startPaused"), t1.$index(msg, "replyPort"));
        break;
      case "message":
        if (t1.$index(msg, "port") != null)
          J.send$1$x(t1.$index(msg, "port"), t1.$index(msg, "msg"));
        init.globalState.topEventLoop.run$0();
        break;
      case "close":
        init.globalState.managers.remove$1(0, $.get$IsolateNatives_workerIds().$index(0, sender));
        sender.terminate();
        init.globalState.topEventLoop.run$0();
        break;
      case "log":
        H.IsolateNatives__log(t1.$index(msg, "msg"));
        break;
      case "print":
        if (init.globalState.isWorker === true) {
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", msg], null, null));
          t1.toString;
          self.postMessage(t2);
        } else
          P.print(t1.$index(msg, "msg"));
        break;
      case "error":
        throw H.wrapException(t1.$index(msg, "msg"));
    }
  },
  IsolateNatives__log: function(msg) {
    var trace, t1, t2, exception;
    if (init.globalState.isWorker === true) {
      t1 = init.globalState.mainManager;
      t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "log", "msg", msg], null, null));
      t1.toString;
      self.postMessage(t2);
    } else
      try {
        $.get$globalThis().console.log(msg);
      } catch (exception) {
        H.unwrapException(exception);
        trace = new H._StackTrace(exception, null);
        throw H.wrapException(P.Exception_Exception(trace));
      }

  },
  IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
    var context, t1, t2;
    context = init.globalState.currentContext;
    t1 = context.id;
    $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
    $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
    t1 = context.controlPort.get$sendPort();
    t2 = context.pauseCapability;
    J.send$1$x(replyTo, ["spawned", t1, t2, context.terminateCapability]);
    t1 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri);
    if (startPaused === true) {
      context.addPause$2(t2, t2);
      init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, t1, "start isolate"));
    } else
      t1.call$0();
  },
  IsolateNatives__spawnWorker: function(functionName, uri, args, message, isSpawnUri, startPaused, replyPort) {
    var worker, t1;
    if (uri == null)
      uri = $.get$IsolateNatives_thisScript();
    worker = new Worker(uri);
    worker.onmessage = function(e) { H.IsolateNatives__processWorkerMessage(worker, e); };
    t1 = init.globalState.nextManagerId++;
    $.get$IsolateNatives_workerIds().$indexSet(0, worker, t1);
    init.globalState.managers.$indexSet(0, t1, worker);
    worker.postMessage(H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "start", "id", t1, "replyTo", H._serializeMessage(replyPort), "args", args, "msg", H._serializeMessage(message), "isSpawnUri", isSpawnUri, "startPaused", startPaused, "functionName", functionName], null, null)));
  },
  _serializeMessage: function(message) {
    var t1;
    if (init.globalState.supportsWorkers === true) {
      t1 = new H._JsSerializer(0, new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    } else {
      t1 = new H._JsCopier(new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    }
  },
  _deserializeMessage: function(message) {
    if (init.globalState.supportsWorkers === true)
      return new H._JsDeserializer(null).deserialize$1(message);
    else
      return message;
  },
  _MessageTraverser_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  _Deserializer_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  startRootIsolate_closure: {
    "^": "Closure:86;box_0,entry_1",
    call$0: function() {
      this.entry_1.call$1(this.box_0.args_0);
    }
  },
  startRootIsolate_closure0: {
    "^": "Closure:86;box_0,entry_2",
    call$0: function() {
      this.entry_2.call$2(this.box_0.args_0, null);
    }
  },
  _Manager: {
    "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
    _Manager$1: function(entry) {
      var t1, t2, t3, $function;
      t1 = $.get$globalWindow() == null;
      t2 = $.get$globalWorker();
      t3 = t1 && $.get$globalPostMessageDefined() === true;
      this.isWorker = t3;
      if (!t3)
        t2 = t2 != null && $.get$IsolateNatives_thisScript() != null;
      else
        t2 = true;
      this.supportsWorkers = t2;
      this.fromCommandLine = t1 && !t3;
      t2 = H._IsolateEvent;
      t3 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t2]);
      t3.ListQueue$1(null, t2);
      this.topEventLoop = new H._EventLoop(t3, 0);
      this.isolates = P.LinkedHashMap_LinkedHashMap(null, null, null, J.JSInt, H._IsolateContext);
      this.managers = P.LinkedHashMap_LinkedHashMap(null, null, null, J.JSInt, null);
      if (this.isWorker === true) {
        t1 = new H._MainManagerStub();
        this.mainManager = t1;
        $function = function (e) { H.IsolateNatives__processWorkerMessage(t1, e); };
        $.get$globalThis().onmessage = $function;
        $.get$globalThis().dartPrint = function (object) {};
      }
    }
  },
  _IsolateContext: {
    "^": "Object;id>,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,isPaused<,delayedEvents,pauseTokens,doneHandlers,errorsAreFatal",
    addPause$2: function(authentification, resume) {
      if (!this.pauseCapability.$eq(0, authentification))
        return;
      if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
        this.isPaused = true;
      this._updateGlobalState$0();
    },
    removePause$1: function(resume) {
      var t1, t2, $event, t3, t4, t5;
      if (!this.isPaused)
        return;
      t1 = this.pauseTokens;
      t1.remove$1(0, resume);
      if (t1._collection$_length === 0) {
        for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          $event = t1.pop();
          t2 = init.globalState.topEventLoop.events;
          t3 = t2._head;
          t4 = t2._collection$_table;
          t5 = t4.length;
          t3 = (t3 - 1 & t5 - 1) >>> 0;
          t2._head = t3;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t4, t3);
          t4[t3] = $event;
          if (t3 === t2._tail)
            t2._grow$0();
          ++t2._modificationCount;
        }
        this.isPaused = false;
      }
      this._updateGlobalState$0();
    },
    addDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null) {
        t1 = [];
        this.doneHandlers = t1;
      }
      if (J.contains$1$asx(t1, responsePort))
        return;
      this.doneHandlers.push(responsePort);
    },
    removeDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null)
        return;
      J.remove$1$ax(t1, responsePort);
    },
    setErrorsFatal$2: function(authentification, errorsAreFatal) {
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      this.errorsAreFatal = errorsAreFatal;
    },
    handlePing$2: function(responsePort, pingType) {
      if (J.$eq(pingType, 2))
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(this, new H._IsolateContext_handlePing_closure(responsePort), "ping"));
      else
        J.send$1$x(responsePort, null);
    },
    eval$1: function(code) {
      var old, result;
      old = init.globalState.currentContext;
      init.globalState.currentContext = this;
      $ = this.isolateStatics;
      result = null;
      try {
        result = code.call$0();
      } finally {
        init.globalState.currentContext = old;
        if (old != null)
          $ = old.get$isolateStatics();
      }
      return result;
    },
    handleControlMessage$1: function(message) {
      var t1 = J.getInterceptor$asx(message);
      switch (t1.$index(message, 0)) {
        case "pause":
          this.addPause$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "resume":
          this.removePause$1(t1.$index(message, 1));
          break;
        case "add-ondone":
          this.addDoneListener$1(t1.$index(message, 1));
          break;
        case "remove-ondone":
          this.removeDoneListener$1(t1.$index(message, 1));
          break;
        case "set-errors-fatal":
          this.setErrorsFatal$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "ping":
          this.handlePing$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        default:
          P.print("UNKNOWN MESSAGE: " + H.S(message));
      }
    },
    lookup$1: function(portId) {
      return this.ports.$index(0, portId);
    },
    _addRegistration$2: function(portId, port) {
      var t1 = this.ports;
      if (t1.containsKey$1(portId))
        throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
      t1.$indexSet(0, portId, port);
    },
    _updateGlobalState$0: function() {
      if (this.ports._collection$_length - this.weakPorts._collection$_length > 0 || this.isPaused)
        init.globalState.isolates.$indexSet(0, this.id, this);
      else
        this._shutdown$0();
    },
    _shutdown$0: function() {
      init.globalState.isolates.remove$1(0, this.id);
      var t1 = this.doneHandlers;
      if (t1 != null)
        for (t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
          J.send$1$x(t1._current, null);
    }
  },
  _IsolateContext_handlePing_closure: {
    "^": "Closure:86;responsePort_0",
    call$0: function() {
      J.send$1$x(this.responsePort_0, null);
    }
  },
  _EventLoop: {
    "^": "Object;events,_activeJsAsyncCount",
    dequeue$0: function() {
      var t1, t2, t3, t4, result;
      t1 = this.events;
      t2 = t1._head;
      if (t2 === t1._tail)
        return;
      ++t1._modificationCount;
      t3 = t1._collection$_table;
      t4 = t3.length;
      if (t2 >= t4)
        return H.ioore(t3, t2);
      result = t3[t2];
      t3[t2] = null;
      t1._head = (t2 + 1 & t4 - 1) >>> 0;
      return result;
    },
    runIteration$0: function() {
      var $event, t1, t2;
      $event = this.dequeue$0();
      if ($event == null) {
        if (init.globalState.rootContext != null && init.globalState.isolates.containsKey$1(init.globalState.rootContext.id) && init.globalState.fromCommandLine === true && init.globalState.rootContext.ports._collection$_length === 0)
          H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
        t1 = init.globalState;
        if (t1.isWorker === true && t1.isolates._collection$_length === 0 && t1.topEventLoop._activeJsAsyncCount === 0) {
          t1 = t1.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "close"], null, null));
          t1.toString;
          self.postMessage(t2);
        }
        return false;
      }
      $event.process$0();
      return true;
    },
    _runHelper$0: function() {
      if ($.get$globalWindow() != null)
        new H._EventLoop__runHelper_next(this).call$0();
      else
        for (; this.runIteration$0();)
          ;
    },
    run$0: function() {
      var e, trace, exception, t1, t2;
      if (init.globalState.isWorker !== true)
        this._runHelper$0();
      else
        try {
          this._runHelper$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          trace = new H._StackTrace(exception, null);
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)], null, null));
          t1.toString;
          self.postMessage(t2);
        }

    }
  },
  _EventLoop__runHelper_next: {
    "^": "Closure:10;this_0",
    call$0: function() {
      if (!this.this_0.runIteration$0())
        return;
      P.Timer_Timer(C.Duration_0, this);
    }
  },
  _IsolateEvent: {
    "^": "Object;isolate,fn,message",
    process$0: function() {
      var t1 = this.isolate;
      if (t1.get$isPaused()) {
        t1.delayedEvents.push(this);
        return;
      }
      t1.eval$1(this.fn);
    }
  },
  _MainManagerStub: {
    "^": "Object;"
  },
  IsolateNatives__processWorkerMessage_closure: {
    "^": "Closure:86;entryPoint_0,args_1,message_2,isSpawnUri_3,startPaused_4,replyTo_5",
    call$0: function() {
      H.IsolateNatives__startIsolate(this.entryPoint_0, this.args_1, this.message_2, this.isSpawnUri_3, this.startPaused_4, this.replyTo_5);
    }
  },
  IsolateNatives__startIsolate_runStartFunction: {
    "^": "Closure:10;topLevel_0,args_1,message_2,isSpawnUri_3",
    call$0: function() {
      var t1, t2, t3;
      if (this.isSpawnUri_3 !== true)
        this.topLevel_0.call$1(this.message_2);
      else {
        t1 = this.topLevel_0;
        t2 = H.getDynamicRuntimeType();
        t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t3)
          t1.call$2(this.args_1, this.message_2);
        else {
          t2 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
          if (t2)
            t1.call$1(this.args_1);
          else
            t1.call$0();
        }
      }
    }
  },
  _BaseSendPort: {
    "^": "Object;",
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort: {
    "^": "_BaseSendPort;_receivePort,_isolateId",
    send$1: function(_, message) {
      var t1, t2, isolate, t3, shouldSerialize;
      t1 = {};
      t2 = this._isolateId;
      isolate = init.globalState.isolates.$index(0, t2);
      if (isolate == null)
        return;
      t3 = this._receivePort;
      if (t3.get$_isClosed())
        return;
      shouldSerialize = init.globalState.currentContext != null && init.globalState.currentContext.id !== t2;
      t1.msg_0 = message;
      if (shouldSerialize)
        t1.msg_0 = H._serializeMessage(message);
      if (J.$eq(isolate.get$controlPort(), t3)) {
        isolate.handleControlMessage$1(t1.msg_0);
        return;
      }
      t2 = init.globalState.topEventLoop;
      t3 = "receive " + H.S(message);
      t2.events._add$1(new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(t1, this, shouldSerialize), t3));
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_NativeJsSendPort && J.$eq(this._receivePort, other._receivePort);
    },
    get$hashCode: function(_) {
      return this._receivePort.get$_id();
    },
    $is_NativeJsSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort_send_closure: {
    "^": "Closure:86;box_0,this_1,shouldSerialize_2",
    call$0: function() {
      var t1, t2;
      t1 = this.this_1._receivePort;
      if (!t1.get$_isClosed()) {
        if (this.shouldSerialize_2) {
          t2 = this.box_0;
          t2.msg_0 = H._deserializeMessage(t2.msg_0);
        }
        t1.__isolate_helper$_add$1(this.box_0.msg_0);
      }
    }
  },
  _WorkerSendPort: {
    "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
    send$1: function(_, message) {
      var workerMessage, manager;
      workerMessage = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "message", "port", this, "msg", message], null, null));
      if (init.globalState.isWorker === true) {
        init.globalState.mainManager.toString;
        self.postMessage(workerMessage);
      } else {
        manager = init.globalState.managers.$index(0, this._workerId);
        if (manager != null)
          manager.postMessage(workerMessage);
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_WorkerSendPort && J.$eq(this._workerId, other._workerId) && J.$eq(this._isolateId, other._isolateId) && J.$eq(this._receivePortId, other._receivePortId);
    },
    get$hashCode: function(_) {
      var t1, t2, t3;
      t1 = this._workerId;
      if (typeof t1 !== "number")
        return t1.$shl();
      t2 = this._isolateId;
      if (typeof t2 !== "number")
        return t2.$shl();
      t3 = this._receivePortId;
      if (typeof t3 !== "number")
        return H.iae(t3);
      return (t1 << 16 ^ t2 << 8 ^ t3) >>> 0;
    },
    $is_WorkerSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  RawReceivePortImpl: {
    "^": "Object;_id<,_handler,_isClosed<",
    _handler$1: function(arg0) {
      return this._handler.call$1(arg0);
    },
    close$0: function(_) {
      var t1, t2;
      if (this._isClosed)
        return;
      this._isClosed = true;
      this._handler = null;
      t1 = init.globalState.currentContext;
      t2 = this._id;
      t1.ports.remove$1(0, t2);
      t1.weakPorts.remove$1(0, t2);
      t1._updateGlobalState$0();
    },
    __isolate_helper$_add$1: function(dataEvent) {
      if (this._isClosed)
        return;
      this._handler$1(dataEvent);
    },
    get$sendPort: function() {
      return new H._NativeJsSendPort(this, init.globalState.currentContext.id);
    },
    static: {"^": "RawReceivePortImpl__nextFreeId"}
  },
  ReceivePortImpl: {
    "^": "Stream;_rawPort,_controller",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = this._controller;
      t1.toString;
      return H.setRuntimeTypeInfo(new P._ControllerStream(t1), [null]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    close$0: [function(_) {
      this._rawPort.close$0(0);
      this._controller.close$0(0);
    }, "call$0", "get$close", 0, 0, 10],
    ReceivePortImpl$fromRawReceivePort$1: function(_rawPort) {
      var t1 = P.StreamController_StreamController(this.get$close(this), null, null, null, true, null);
      this._controller = t1;
      this._rawPort._handler = t1.get$add(t1);
    },
    $asStream: function() {
      return [null];
    }
  },
  _JsSerializer: {
    "^": "_Serializer;_nextFreeRefId,_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return ["sendport", init.globalState.currentManagerId, x._isolateId, x._receivePort.get$_id()];
      if (!!x.$is_WorkerSendPort)
        return ["sendport", x._workerId, x._isolateId, x._receivePortId];
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return ["capability", x._id];
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsCopier: {
    "^": "_Copier;_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return new H._NativeJsSendPort(x._receivePort, x._isolateId);
      if (!!x.$is_WorkerSendPort)
        return new H._WorkerSendPort(x._workerId, x._receivePortId, x._isolateId);
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return new H.CapabilityImpl(x._id);
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsDeserializer: {
    "^": "_Deserializer;_deserialized",
    deserializeSendPort$1: function(list) {
      var t1, managerId, isolateId, receivePortId, isolate, receivePort;
      t1 = J.getInterceptor$asx(list);
      managerId = t1.$index(list, 1);
      isolateId = t1.$index(list, 2);
      receivePortId = t1.$index(list, 3);
      if (J.$eq(managerId, init.globalState.currentManagerId)) {
        isolate = init.globalState.isolates.$index(0, isolateId);
        if (isolate == null)
          return;
        receivePort = isolate.lookup$1(receivePortId);
        if (receivePort == null)
          return;
        return new H._NativeJsSendPort(receivePort, isolateId);
      } else
        return new H._WorkerSendPort(managerId, receivePortId, isolateId);
    },
    deserializeCapability$1: function(list) {
      return new H.CapabilityImpl(J.$index$asx(list, 1));
    }
  },
  _JsVisitedMap: {
    "^": "Object;tagged",
    $index: function(_, object) {
      return object.__MessageTraverser__attached_info__;
    },
    $indexSet: function(_, object, info) {
      this.tagged.push(object);
      object.__MessageTraverser__attached_info__ = info;
    },
    reset$0: function(_) {
      this.tagged = [];
    },
    cleanup$0: function() {
      var $length, i, t1;
      for ($length = this.tagged.length, i = 0; i < $length; ++i) {
        t1 = this.tagged;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].__MessageTraverser__attached_info__ = null;
      }
      this.tagged = null;
    }
  },
  _MessageTraverserVisitedMap: {
    "^": "Object;",
    $index: function(_, object) {
      return;
    },
    $indexSet: function(_, object, info) {
    },
    reset$0: function(_) {
    },
    cleanup$0: function() {
    }
  },
  _MessageTraverser: {
    "^": "Object;",
    traverse$1: function(x) {
      var result;
      if (H._MessageTraverser_isPrimitive(x))
        return this.visitPrimitive$1(x);
      this._visited.reset$0(0);
      result = null;
      try {
        result = this._dispatch$1(x);
      } finally {
        this._visited.cleanup$0();
      }
      return result;
    },
    _dispatch$1: function(x) {
      var t1;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return this.visitPrimitive$1(x);
      t1 = J.getInterceptor(x);
      if (!!t1.$isList)
        return this.visitList$1(x);
      if (!!t1.$isMap)
        return this.visitMap$1(x);
      if (!!t1.$isSendPort)
        return this.visitSendPort$1(x);
      if (!!t1.$isCapability)
        return this.visitCapability$1(x);
      return this.visitObject$1(x);
    },
    visitObject$1: function(x) {
      throw H.wrapException("Message serialization: Illegal value " + H.S(x) + " passed");
    }
  },
  _Copier: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copy, t1, len, i;
      copy = this._visited.$index(0, list);
      if (copy != null)
        return copy;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      copy = Array(len);
      copy.fixed$length = init;
      this._visited.$indexSet(0, list, copy);
      for (i = 0; i < len; ++i)
        copy[i] = this._dispatch$1(t1.$index(list, i));
      return copy;
    },
    visitMap$1: function(map) {
      var t1, copy;
      t1 = {};
      copy = this._visited.$index(0, map);
      t1.copy_0 = copy;
      if (copy != null)
        return copy;
      copy = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1.copy_0 = copy;
      this._visited.$indexSet(0, map, copy);
      map.forEach$1(0, new H._Copier_visitMap_closure(t1, this));
      return t1.copy_0;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Copier_visitMap_closure: {
    "^": "Closure:87;box_0,this_1",
    call$2: function(key, val) {
      var t1 = this.this_1;
      J.$indexSet$ax(this.box_0.copy_0, t1._dispatch$1(key), t1._dispatch$1(val));
    }
  },
  _Serializer: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copyId, t1;
      copyId = this._visited.$index(0, list);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, list, t1);
      return ["list", t1, this._serializeList$1(list)];
    },
    visitMap$1: function(map) {
      var copyId, t1;
      copyId = this._visited.$index(0, map);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, map, t1);
      return ["map", t1, this._serializeList$1(J.toList$0$ax(map.get$keys())), this._serializeList$1(J.toList$0$ax(map.get$values(map)))];
    },
    _serializeList$1: function(list) {
      var t1, len, result, i, t2;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      result = [];
      C.JSArray_methods.set$length(result, len);
      for (i = 0; i < len; ++i) {
        t2 = this._dispatch$1(t1.$index(list, i));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t2;
      }
      return result;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Deserializer: {
    "^": "Object;",
    deserialize$1: function(x) {
      if (H._Deserializer_isPrimitive(x))
        return x;
      this._deserialized = P.HashMap_HashMap(null, null, null, null, null);
      return this._deserializeHelper$1(x);
    },
    _deserializeHelper$1: function(x) {
      var t1, id;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      t1 = J.getInterceptor$asx(x);
      switch (t1.$index(x, 0)) {
        case "ref":
          id = t1.$index(x, 1);
          return this._deserialized.$index(0, id);
        case "list":
          return this._deserializeList$1(x);
        case "map":
          return this._deserializeMap$1(x);
        case "sendport":
          return this.deserializeSendPort$1(x);
        case "capability":
          return this.deserializeCapability$1(x);
        default:
          return this.deserializeObject$1(x);
      }
    },
    _deserializeList$1: function(x) {
      var t1, id, dartList, len, i;
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      dartList = t1.$index(x, 2);
      this._deserialized.$indexSet(0, id, dartList);
      t1 = J.getInterceptor$asx(dartList);
      len = t1.get$length(dartList);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        t1.$indexSet(dartList, i, this._deserializeHelper$1(t1.$index(dartList, i)));
      return dartList;
    },
    _deserializeMap$1: function(x) {
      var result, t1, id, keys, values, len, t2, i;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      this._deserialized.$indexSet(0, id, result);
      keys = t1.$index(x, 2);
      values = t1.$index(x, 3);
      t1 = J.getInterceptor$asx(keys);
      len = t1.get$length(keys);
      if (typeof len !== "number")
        return H.iae(len);
      t2 = J.getInterceptor$asx(values);
      i = 0;
      for (; i < len; ++i)
        result.$indexSet(0, this._deserializeHelper$1(t1.$index(keys, i)), this._deserializeHelper$1(t2.$index(values, i)));
      return result;
    },
    deserializeObject$1: function(x) {
      throw H.wrapException("Unexpected serialized object");
    }
  },
  TimerImpl: {
    "^": "Object;_once,_inEventLoop,_handle",
    TimerImpl$2: function(milliseconds, callback) {
      var t1, t2;
      if (milliseconds === 0)
        t1 = $.get$globalThis().setTimeout == null || init.globalState.isWorker === true;
      else
        t1 = false;
      if (t1) {
        this._handle = 1;
        t1 = init.globalState.topEventLoop;
        t2 = init.globalState.currentContext;
        t1.events._add$1(new H._IsolateEvent(t2, new H.TimerImpl_internalCallback(this, callback), "timer"));
        this._inEventLoop = true;
      } else {
        t1 = $.get$globalThis();
        if (t1.setTimeout != null) {
          ++init.globalState.topEventLoop._activeJsAsyncCount;
          this._handle = t1.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, callback), 0), milliseconds);
        } else
          throw H.wrapException(P.UnsupportedError$("Timer greater than 0."));
      }
    },
    static: {TimerImpl$: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(true, false, null);
        t1.TimerImpl$2(milliseconds, callback);
        return t1;
      }}
  },
  TimerImpl_internalCallback: {
    "^": "Closure:10;this_0,callback_1",
    call$0: function() {
      this.this_0._handle = null;
      this.callback_1.call$0();
    }
  },
  TimerImpl_internalCallback0: {
    "^": "Closure:10;this_2,callback_3",
    call$0: function() {
      this.this_2._handle = null;
      H.leaveJsAsync();
      this.callback_3.call$0();
    }
  },
  CapabilityImpl: {
    "^": "Object;_id<",
    get$hashCode: function(_) {
      var hash = this._id;
      if (typeof hash !== "number")
        return hash.$shr();
      hash = C.JSNumber_methods._shrOtherPositive$1(hash, 0) ^ C.JSNumber_methods._tdivFast$1(hash, 4294967296);
      hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
      hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
      hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
      return (hash ^ hash >>> 16) >>> 0;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other === this)
        return true;
      if (!!J.getInterceptor(other).$isCapabilityImpl) {
        t1 = this._id;
        t2 = other._id;
        return t1 == null ? t2 == null : t1 === t2;
      }
      return false;
    },
    $isCapabilityImpl: true,
    $isCapability: true
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  isJsIndexable: function(object, record) {
    var result;
    if (record != null) {
      result = record.x;
      if (result != null)
        return result;
    }
    return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
  },
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives__throwFormatException: [function(string) {
    throw H.wrapException(P.FormatException$(string));
  }, "call$1", "Primitives__throwFormatException$closure", 2, 0, 0],
  Primitives_parseInt: function(source, radix, handleError) {
    var match, t1, maxCharCode, digitsPart, i, t2;
    handleError = H.Primitives__throwFormatException$closure();
    if (typeof source !== "string")
      H.throwExpression(P.ArgumentError$(source));
    match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
    if (radix == null) {
      if (match != null) {
        t1 = match.length;
        if (2 >= t1)
          return H.ioore(match, 2);
        if (match[2] != null)
          return parseInt(source, 16);
        if (3 >= t1)
          return H.ioore(match, 3);
        if (match[3] != null)
          return parseInt(source, 10);
        return handleError.call$1(source);
      }
      radix = 10;
    } else {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$("Radix " + H.S(radix) + " not in range 2..36"));
      if (match != null) {
        if (radix === 10) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] != null;
        } else
          t1 = false;
        if (t1)
          return parseInt(source, 10);
        if (!(radix < 10)) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] == null;
        } else
          t1 = true;
        if (t1) {
          maxCharCode = radix <= 10 ? 48 + radix - 1 : 97 + radix - 10 - 1;
          if (1 >= match.length)
            return H.ioore(match, 1);
          digitsPart = match[1];
          t1 = J.getInterceptor$asx(digitsPart);
          i = 0;
          while (true) {
            t2 = t1.get$length(digitsPart);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t1.codeUnitAt$1(digitsPart, 0);
            if (i >= digitsPart.length)
              H.throwExpression(P.RangeError$value(i));
            if (digitsPart.charCodeAt(i) > maxCharCode)
              return handleError.call$1(source);
            ++i;
          }
        }
      }
    }
    if (match == null)
      return handleError.call$1(source);
    return parseInt(source, radix);
  },
  Primitives_parseDouble: function(source, handleError) {
    var result, trimmed;
    if (typeof source !== "string")
      H.throwExpression(P.ArgumentError$(source));
    handleError = H.Primitives__throwFormatException$closure();
    if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
      return handleError.call$1(source);
    result = parseFloat(source);
    if (isNaN(result)) {
      trimmed = J.trim$0$s(source);
      if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
        return result;
      return handleError.call$1(source);
    }
    return result;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_IX5(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = decompiled;
    }
    if (J.getInterceptor$s($name).codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return $name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null);
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives_numMicroseconds: function() {
    if (typeof window != "undefined" && window !== null) {
      var performance = window.performance;
      if (performance != null && typeof performance.webkitNow == "function")
        return C.JSNumber_methods.toInt$0(Math.floor(1000 * performance.webkitNow()));
    }
    return 1000 * Date.now();
  },
  Primitives__fromCharCodeApply: function(array) {
    var end, t1, result, i, subarray, t2;
    end = array.length;
    for (t1 = end <= 500, result = "", i = 0; i < end; i += 500) {
      if (t1)
        subarray = array;
      else {
        t2 = i + 500;
        t2 = t2 < end ? t2 : end;
        subarray = array.slice(i, t2);
      }
      result += String.fromCharCode.apply(null, subarray);
    }
    return result;
  },
  Primitives_stringFromCodePoints: function(codePoints) {
    var a, t1, i;
    a = [];
    a.$builtinTypeInfo = [J.JSInt];
    for (t1 = new H.ListIterator(codePoints, codePoints.length, 0, null); t1.moveNext$0();) {
      i = t1._current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i <= 65535)
        a.push(i);
      else if (i <= 1114111) {
        a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
        a.push(56320 + (i & 1023));
      } else
        throw H.wrapException(P.ArgumentError$(i));
    }
    return H.Primitives__fromCharCodeApply(a);
  },
  Primitives_stringFromCharCodes: function(charCodes) {
    var t1, i;
    for (t1 = new H.ListIterator(charCodes, charCodes.length, 0, null); t1.moveNext$0();) {
      i = t1._current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i < 0)
        throw H.wrapException(P.ArgumentError$(i));
      if (i > 65535)
        return H.Primitives_stringFromCodePoints(charCodes);
    }
    return H.Primitives__fromCharCodeApply(charCodes);
  },
  Primitives_stringFromCharCode: function(charCode) {
    var bits;
    if (typeof charCode !== "number")
      return H.iae(charCode);
    if (0 <= charCode) {
      if (charCode <= 65535)
        return String.fromCharCode(charCode);
      if (charCode <= 1114111) {
        bits = charCode - 65536;
        return String.fromCharCode((55296 | C.JSNumber_methods._shrOtherPositive$1(bits, 10)) >>> 0, (56320 | bits & 1023) >>> 0);
      }
    }
    throw H.wrapException(P.RangeError$range(charCode, 0, 1114111));
  },
  Primitives_lazyAsJsDate: function(receiver) {
    if (receiver.date === void 0)
      receiver.date = new Date(receiver.millisecondsSinceEpoch);
    return receiver.date;
  },
  Primitives_getProperty: function(object, key) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    return object[key];
  },
  Primitives_setProperty: function(object, key, value) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    object[key] = value;
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$asx(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index));
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", { get: H.toStringWrapper });
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  unwrapException: function(ex) {
    var t1, message, number, ieErrorCode, t2, t3, t4, nullLiteralCall, t5, t6, t7, t8, t9, match;
    t1 = new H.unwrapException_saveStackTrace(ex);
    if (ex == null)
      return;
    if (typeof ex !== "object")
      return ex;
    if ("dartException" in ex)
      return t1.call$1(ex.dartException);
    else if (!("message" in ex))
      return ex;
    message = ex.message;
    if ("number" in ex && typeof ex.number == "number") {
      number = ex.number;
      ieErrorCode = number & 65535;
      if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
        switch (ieErrorCode) {
          case 438:
            return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          case 445:
          case 5007:
            t2 = H.S(message) + " (Error " + ieErrorCode + ")";
            return t1.call$1(new H.NullError(t2, null));
        }
    }
    if (ex instanceof TypeError) {
      t2 = $.get$TypeErrorDecoder_noSuchMethodPattern();
      t3 = $.get$TypeErrorDecoder_notClosurePattern();
      t4 = $.get$TypeErrorDecoder_nullCallPattern();
      nullLiteralCall = $.get$TypeErrorDecoder_nullLiteralCallPattern();
      t5 = $.get$TypeErrorDecoder_undefinedCallPattern();
      t6 = $.get$TypeErrorDecoder_undefinedLiteralCallPattern();
      t7 = $.get$TypeErrorDecoder_nullPropertyPattern();
      $.get$TypeErrorDecoder_nullLiteralPropertyPattern();
      t8 = $.get$TypeErrorDecoder_undefinedPropertyPattern();
      t9 = $.get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
      match = t2.matchTypeError$1(message);
      if (match != null)
        return t1.call$1(H.JsNoSuchMethodError$(message, match));
      else {
        match = t3.matchTypeError$1(message);
        if (match != null) {
          match.method = "call";
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        } else {
          match = t4.matchTypeError$1(message);
          if (match == null) {
            match = nullLiteralCall.matchTypeError$1(message);
            if (match == null) {
              match = t5.matchTypeError$1(message);
              if (match == null) {
                match = t6.matchTypeError$1(message);
                if (match == null) {
                  match = t7.matchTypeError$1(message);
                  if (match == null) {
                    match = nullLiteralCall.matchTypeError$1(message);
                    if (match == null) {
                      match = t8.matchTypeError$1(message);
                      if (match == null) {
                        match = t9.matchTypeError$1(message);
                        t2 = match != null;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2) {
            t2 = match == null ? null : match.method;
            return t1.call$1(new H.NullError(message, t2));
          }
        }
      }
      t2 = typeof message === "string" ? message : "";
      return t1.call$1(new H.UnknownJsTypeError(t2));
    }
    if (ex instanceof RangeError) {
      if (typeof message === "string" && message.indexOf("call stack") !== -1)
        return new P.StackOverflowError();
      return t1.call$1(new P.ArgumentError(null));
    }
    if (typeof InternalError == "function" && ex instanceof InternalError)
      if (typeof message === "string" && message === "too much recursion")
        return new P.StackOverflowError();
    return ex;
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  fillLiteralMap: function(keyValuePairs, result) {
    var $length, index, index0, index1;
    $length = keyValuePairs.length;
    for (index = 0; index < $length; index = index1) {
      index0 = index + 1;
      index1 = index0 + 1;
      result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
    }
    return result;
  },
  invokeClosure: function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    var t1 = J.getInterceptor(numberOfArguments);
    if (t1.$eq(numberOfArguments, 0))
      return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
    else if (t1.$eq(numberOfArguments, 1))
      return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
    else if (t1.$eq(numberOfArguments, 2))
      return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
    else if (t1.$eq(numberOfArguments, 3))
      return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
    else if (t1.$eq(numberOfArguments, 4))
      return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
    else
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
  },
  convertDartClosureToJS: function(closure, arity) {
    var $function;
    if (closure == null)
      return;
    $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = (function(closure, arity, context, invoke) {  return function(a1, a2, a3, a4) {     return invoke(closure, context, arity, a1, a2, a3, a4);  };})(closure,arity,init.globalState.currentContext,H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    $function.$reflectionInfo = reflectionInfo;
    functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function(){this.$initialize()};
    else if (typeof dart_precompiled == "function") {
      t1 = function(a,b,c,d) {this.$initialize(a,b,c,d)};
      $constructor = t1;
    } else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = (function(s){return function(){return init.metadata[s]}})(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f,r){return function(){return f.apply({$receiver:r(this)},arguments)}}(functionType,getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n,S){return function(){return S(this)[n]()}}(stubName,getSelf);
      case 1:
        return function(n,S){return function(a){return S(this)[n](a)}}(stubName,getSelf);
      case 2:
        return function(n,S){return function(a,b){return S(this)[n](a,b)}}(stubName,getSelf);
      case 3:
        return function(n,S){return function(a,b,c){return S(this)[n](a,b,c)}}(stubName,getSelf);
      case 4:
        return function(n,S){return function(a,b,c,d){return S(this)[n](a,b,c,d)}}(stubName,getSelf);
      case 5:
        return function(n,S){return function(a,b,c,d,e){return S(this)[n](a,b,c,d,e)}}(stubName,getSelf);
      default:
        return function(f,s){return function(){return f.apply(s(this),arguments)}}($function,getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (typeof dart_precompiled == "function" || !t1 || arity >= 27)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n,s,r){return function(){return s(this)[n](r(this))}}($name,getSelf,getReceiver);
      case 2:
        return function(n,s,r){return function(a){return s(this)[n](r(this),a)}}($name,getSelf,getReceiver);
      case 3:
        return function(n,s,r){return function(a,b){return s(this)[n](r(this),a,b)}}($name,getSelf,getReceiver);
      case 4:
        return function(n,s,r){return function(a,b,c){return s(this)[n](r(this),a,b,c)}}($name,getSelf,getReceiver);
      case 5:
        return function(n,s,r){return function(a,b,c,d){return s(this)[n](r(this),a,b,c,d)}}($name,getSelf,getReceiver);
      case 6:
        return function(n,s,r){return function(a,b,c,d,e){return s(this)[n](r(this),a,b,c,d,e)}}($name,getSelf,getReceiver);
      default:
        return function(f,s,r,a){return function(){a=[r(this)];Array.prototype.push.apply(a,arguments);return f.apply(s(this),a)}}($function,getSelf,getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, isCsp, lookedUpFunction, t2, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    isCsp = typeof dart_precompiled == "function";
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (isCsp || !t2 || arity >= 28)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    functions.fixed$length = init;
    reflectionInfo.fixed$length = init;
    return H.Closure_fromTearOff(receiver, functions, reflectionInfo, !!isStatic, jsArguments, $name);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(P.CyclicInitializationError$("Cyclic initialization for static " + H.S(staticName)));
  },
  buildFunctionType: function(returnType, parameterTypes, optionalParameterTypes) {
    return new H.RuntimeFunctionType(returnType, parameterTypes, optionalParameterTypes, null);
  },
  getDynamicRuntimeType: function() {
    return C.C_DynamicRuntimeType;
  },
  createRuntimeType: function($name) {
    return new H.TypeImpl($name, null);
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  getRuntimeTypeArguments: function(target, substitutionName) {
    return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
  },
  getRuntimeTypeArgument: function(target, substitutionName, index) {
    var $arguments = H.getRuntimeTypeArguments(target, substitutionName);
    return $arguments == null ? null : $arguments[index];
  },
  getTypeArgumentByIndex: function(target, index) {
    var rti = H.getRuntimeTypeInfo(target);
    return rti == null ? null : rti[index];
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, argument, str;
    if (types == null)
      return "";
    buffer = P.StringBuffer$("");
    for (index = startIndex, firstArgument = true, allDynamic = true; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      str = H.runtimeTypeToString(argument, onTypeVariable);
      buffer._contents += typeof str === "string" ? str : H.S(str);
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  substitute: function(substitution, $arguments) {
    if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
      $arguments = substitution;
    else if (typeof substitution == "function") {
      substitution = H.invokeOn(substitution, null, $arguments);
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        $arguments = substitution;
      else if (typeof substitution == "function")
        $arguments = H.invokeOn(substitution, null, $arguments);
    }
    return $arguments;
  },
  checkSubtype: function(object, isField, checks, asField) {
    var $arguments, interceptor;
    if (object == null)
      return false;
    $arguments = H.getRuntimeTypeInfo(object);
    interceptor = J.getInterceptor(object);
    if (interceptor[isField] == null)
      return false;
    return H.areSubtypes(H.substitute(interceptor[asField], $arguments), checks);
  },
  areSubtypes: function(s, t) {
    var len, i;
    if (s == null || t == null)
      return true;
    len = s.length;
    for (i = 0; i < len; ++i)
      if (!H.isSubtype(s[i], t[i]))
        return false;
    return true;
  },
  computeSignature: function(signature, context, contextName) {
    return H.invokeOn(signature, context, H.getRuntimeTypeArguments(context, contextName));
  },
  isSubtype: function(s, t) {
    var targetSignatureFunction, t1, typeOfS, t2, typeOfT, $name, substitution;
    if (s === t)
      return true;
    if (s == null || t == null)
      return true;
    if ("func" in t) {
      if (!("func" in s)) {
        if ("$is_" + H.S(t.func) in s)
          return true;
        targetSignatureFunction = s.$signature;
        if (targetSignatureFunction == null)
          return false;
        s = targetSignatureFunction.apply(s, null);
      }
      return H.isFunctionSubtype(s, t);
    }
    if (t.builtin$cls === "Function" && "func" in s)
      return true;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    typeOfS = t1 ? s[0] : s;
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    typeOfT = t2 ? t[0] : t;
    $name = H.runtimeTypeToString(typeOfT, null);
    if (typeOfT !== typeOfS) {
      if (!("$is" + H.S($name) in typeOfS))
        return false;
      substitution = typeOfS["$as" + H.S(H.runtimeTypeToString(typeOfT, null))];
    } else
      substitution = null;
    if (!t1 && substitution == null || !t2)
      return true;
    t1 = t1 ? s.slice(1) : null;
    t2 = t2 ? t.slice(1) : null;
    return H.areSubtypes(H.substitute(substitution, t1), t2);
  },
  areAssignable: function(s, t, allowShorter) {
    var sLength, tLength, i, t1, t2;
    if (t == null && s == null)
      return true;
    if (t == null)
      return allowShorter;
    if (s == null)
      return false;
    sLength = s.length;
    tLength = t.length;
    if (allowShorter) {
      if (sLength < tLength)
        return false;
    } else if (sLength !== tLength)
      return false;
    for (i = 0; i < tLength; ++i) {
      t1 = s[i];
      t2 = t[i];
      if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
        return false;
    }
    return true;
  },
  areAssignableMaps: function(s, t) {
    var t1, names, i, $name, tType, sType;
    if (t == null)
      return true;
    if (s == null)
      return false;
    t1 = Object.getOwnPropertyNames(t);
    t1.fixed$length = init;
    names = t1;
    for (t1 = names.length, i = 0; i < t1; ++i) {
      $name = names[i];
      if (!Object.hasOwnProperty.call(s, $name))
        return false;
      tType = t[$name];
      sType = s[$name];
      if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
        return false;
    }
    return true;
  },
  isFunctionSubtype: function(s, t) {
    var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
    if (!("func" in s))
      return false;
    if ("void" in s) {
      if (!("void" in t) && "ret" in t)
        return false;
    } else if (!("void" in t)) {
      sReturnType = s.ret;
      tReturnType = t.ret;
      if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
        return false;
    }
    sParameterTypes = s.args;
    tParameterTypes = t.args;
    sOptionalParameterTypes = s.opt;
    tOptionalParameterTypes = t.opt;
    sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
    tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
    sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
    tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
    if (sParametersLen > tParametersLen)
      return false;
    if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
      return false;
    if (sParametersLen === tParametersLen) {
      if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
        return false;
      if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
        return false;
    } else {
      for (pos = 0; pos < sParametersLen; ++pos) {
        t1 = sParameterTypes[pos];
        t2 = tParameterTypes[pos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tOptionalParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
    }
    return H.areAssignableMaps(s.named, t.named);
  },
  invokeOn: function($function, receiver, $arguments) {
    return $function.apply(receiver, $arguments);
  },
  toStringForNativeObject: function(obj) {
    var t1 = $.getTagFunction;
    return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
  },
  hashCodeForNativeObject: function(object) {
    return H.Primitives_objectHashCode(object);
  },
  defineProperty: function(obj, property, value) {
    Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
  },
  lookupAndCacheInterceptor: function(obj) {
    var tag, record, interceptor, interceptorClass, mark, t1;
    tag = $.getTagFunction.call$1(obj);
    record = $.dispatchRecordsForInstanceTags[tag];
    if (record != null) {
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    interceptor = $.interceptorsForUncacheableTags[tag];
    if (interceptor != null)
      return interceptor;
    interceptorClass = init.interceptorsByTag[tag];
    if (interceptorClass == null) {
      tag = $.alternateTagFunction.call$2(obj, tag);
      if (tag != null) {
        record = $.dispatchRecordsForInstanceTags[tag];
        if (record != null) {
          Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
          return record.i;
        }
        interceptor = $.interceptorsForUncacheableTags[tag];
        if (interceptor != null)
          return interceptor;
        interceptorClass = init.interceptorsByTag[tag];
      }
    }
    if (interceptorClass == null)
      return;
    interceptor = interceptorClass.prototype;
    mark = tag[0];
    if (mark === "!") {
      record = H.makeLeafDispatchRecord(interceptor);
      $.dispatchRecordsForInstanceTags[tag] = record;
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    if (mark === "~") {
      $.interceptorsForUncacheableTags[tag] = interceptor;
      return interceptor;
    }
    if (mark === "-") {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    }
    if (mark === "+")
      return H.patchInteriorProto(obj, interceptor);
    if (mark === "*")
      throw H.wrapException(P.UnimplementedError$(tag));
    if (init.leafTags[tag] === true) {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    } else
      return H.patchInteriorProto(obj, interceptor);
  },
  patchInteriorProto: function(obj, interceptor) {
    var proto, record;
    proto = Object.getPrototypeOf(obj);
    record = J.makeDispatchRecord(interceptor, proto, null, null);
    Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
    return interceptor;
  },
  makeLeafDispatchRecord: function(interceptor) {
    return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
  },
  makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
    var interceptor = interceptorClass.prototype;
    if (init.leafTags[tag] === true)
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    else
      return J.makeDispatchRecord(interceptor, proto, null, null);
  },
  initNativeDispatch: function() {
    if (true === $.initNativeDispatchFlag)
      return;
    $.initNativeDispatchFlag = true;
    H.initNativeDispatchContinue();
  },
  initNativeDispatchContinue: function() {
    var map, tags, i, tag, proto, record, interceptorClass;
    $.dispatchRecordsForInstanceTags = Object.create(null);
    $.interceptorsForUncacheableTags = Object.create(null);
    H.initHooks();
    map = init.interceptorsByTag;
    tags = Object.getOwnPropertyNames(map);
    if (typeof window != "undefined") {
      window;
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        proto = $.prototypeForTagFunction.call$1(tag);
        if (proto != null) {
          record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
          if (record != null)
            Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        }
      }
    }
    for (i = 0; i < tags.length; ++i) {
      tag = tags[i];
      if (/^[A-Za-z_]/.test(tag)) {
        interceptorClass = map[tag];
        map["!" + tag] = interceptorClass;
        map["~" + tag] = interceptorClass;
        map["-" + tag] = interceptorClass;
        map["+" + tag] = interceptorClass;
        map["*" + tag] = interceptorClass;
      }
    }
  },
  initHooks: function() {
    var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
    hooks = C.JS_CONST_aQP();
    hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc, H.applyHooksTransformer(C.JS_CONST_U4w, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_IX5), hooks)))))));
    if (typeof dartNativeDispatchHooksTransformer != "undefined") {
      transformers = dartNativeDispatchHooksTransformer;
      if (typeof transformers == "function")
        transformers = [transformers];
      if (transformers.constructor == Array)
        for (i = 0; i < transformers.length; ++i) {
          transformer = transformers[i];
          if (typeof transformer == "function")
            hooks = transformer(hooks) || hooks;
        }
    }
    getTag = hooks.getTag;
    getUnknownTag = hooks.getUnknownTag;
    prototypeForTag = hooks.prototypeForTag;
    $.getTagFunction = new H.initHooks_closure(getTag);
    $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
    $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
  },
  applyHooksTransformer: function(transformer, hooks) {
    return transformer(hooks) || hooks;
  },
  stringContainsUnchecked: function(receiver, other, startIndex) {
    return C.JSString_methods.indexOf$2(receiver, other, startIndex) !== -1;
  },
  ConstantMap: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return J.$eq(this.get$length(this), 0);
    },
    get$isNotEmpty: function(_) {
      return !J.$eq(this.get$length(this), 0);
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    _throwUnmodifiable$0: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    $indexSet: function(_, key, val) {
      return this._throwUnmodifiable$0();
    },
    $isMap: true
  },
  ConstantStringMap: {
    "^": "ConstantMap;length>,_jsObject,__js_helper$_keys",
    length$0: function($receiver) {
      return this.length.call$0();
    },
    containsKey$1: function(key) {
      if (typeof key !== "string")
        return false;
      if ("__proto__" === key)
        return false;
      return this._jsObject.hasOwnProperty(key);
    },
    $index: function(_, key) {
      if (!this.containsKey$1(key))
        return;
      return this._fetch$1(key);
    },
    _fetch$1: function(key) {
      return this._jsObject[key];
    },
    forEach$1: function(_, f) {
      var keys, i, key;
      keys = this.__js_helper$_keys;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        f.call$2(key, this._fetch$1(key));
      }
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new H._ConstantMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(this.__js_helper$_keys, new H.ConstantStringMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    $isEfficientLength: true
  },
  ConstantStringMap_values_closure: {
    "^": "Closure:88;this_0",
    call$1: function(key) {
      return this.this_0._fetch$1(key);
    }
  },
  _ConstantMapKeyIterable: {
    "^": "IterableBase;__js_helper$_map",
    get$iterator: function(_) {
      return J.get$iterator$ax(this.__js_helper$_map.__js_helper$_keys);
    }
  },
  GeneralConstantMap: {
    "^": "ConstantMap;_jsData",
    _getMap$0: function() {
      if (!this.$map)
        this.$map = H.fillLiteralMap(this._jsData, P.LinkedHashMap_LinkedHashMap(null, null, null, H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)));
      return this.$map;
    },
    containsKey$1: function(key) {
      return this._getMap$0().containsKey$1(key);
    },
    $index: function(_, key) {
      return this._getMap$0().$index(0, key);
    },
    forEach$1: function(_, f) {
      this._getMap$0().forEach$1(0, f);
    },
    get$keys: function() {
      return this._getMap$0().get$keys();
    },
    get$values: function(_) {
      var t1 = this._getMap$0();
      return t1.get$values(t1);
    },
    get$length: function(_) {
      var t1 = this._getMap$0();
      return t1.get$length(t1);
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    }
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data>,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    static: {"^": "ReflectionInfo_REQUIRED_PARAMETERS_INFO,ReflectionInfo_OPTIONAL_PARAMETERS_INFO,ReflectionInfo_FUNCTION_TYPE_INDEX,ReflectionInfo_FIRST_DEFAULT_ARGUMENT", ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, requiredParameterCount, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = init;
        data = data;
        requiredParametersInfo = data[0];
        requiredParameterCount = requiredParametersInfo >> 1;
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParameterCount, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  TypeErrorDecoder: {
    "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver",
    matchTypeError$1: function(message) {
      var match, result, t1;
      match = new RegExp(this._pattern).exec(message);
      if (match == null)
        return;
      result = {};
      t1 = this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    },
    static: {"^": "TypeErrorDecoder_noSuchMethodPattern,TypeErrorDecoder_notClosurePattern,TypeErrorDecoder_nullCallPattern,TypeErrorDecoder_nullLiteralCallPattern,TypeErrorDecoder_undefinedCallPattern,TypeErrorDecoder_undefinedLiteralCallPattern,TypeErrorDecoder_nullPropertyPattern,TypeErrorDecoder_nullLiteralPropertyPattern,TypeErrorDecoder_undefinedPropertyPattern,TypeErrorDecoder_undefinedLiteralPropertyPattern", TypeErrorDecoder_extractPattern: function(message) {
        var match, $arguments, argumentsExpr, expr, method, receiver;
        message = message.replace(String({}), '$receiver$').replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), '\\$&');
        match = message.match(/\\\$[a-zA-Z]+\\\$/g);
        if (match == null)
          match = [];
        $arguments = match.indexOf("\\$arguments\\$");
        argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
        expr = match.indexOf("\\$expr\\$");
        method = match.indexOf("\\$method\\$");
        receiver = match.indexOf("\\$receiver\\$");
        return new H.TypeErrorDecoder(message.replace('\\$arguments\\$', '((?:x|[^x])*)').replace('\\$argumentsExpr\\$', '((?:x|[^x])*)').replace('\\$expr\\$', '((?:x|[^x])*)').replace('\\$method\\$', '((?:x|[^x])*)').replace('\\$receiver\\$', '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
      }, TypeErrorDecoder_provokeCallErrorOn: function(expression) {
        return function($expr$) {
  var $argumentsExpr$ = '$arguments$'
  try {
    $expr$.$method$($argumentsExpr$);
  } catch (e) {
    return e.message;
  }
}(expression);
      }, TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
        return function($expr$) {
  try {
    $expr$.$method$;
  } catch (e) {
    return e.message;
  }
}(expression);
      }}
  },
  NullError: {
    "^": "Error;_message,_method",
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NullError: " + H.S(this._message);
      return "NullError: Cannot call \"" + H.S(t1) + "\" on null";
    },
    $isError: true
  },
  JsNoSuchMethodError: {
    "^": "Error;_message,_method,_receiver",
    toString$0: function(_) {
      var t1, t2;
      t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      t2 = this._receiver;
      if (t2 == null)
        return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" (" + H.S(this._message) + ")";
      return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" on \"" + H.S(t2) + "\" (" + H.S(this._message) + ")";
    },
    $isError: true,
    static: {JsNoSuchMethodError$: function(_message, match) {
        var t1, t2;
        t1 = match == null;
        t2 = t1 ? null : match.method;
        t1 = t1 ? null : match.receiver;
        return new H.JsNoSuchMethodError(_message, t2, t1);
      }}
  },
  UnknownJsTypeError: {
    "^": "Error;_message",
    toString$0: function(_) {
      var t1 = this._message;
      return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
    }
  },
  unwrapException_saveStackTrace: {
    "^": "Closure:88;ex_0",
    call$1: function(error) {
      if (!!J.getInterceptor(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex_0;
      return error;
    }
  },
  _StackTrace: {
    "^": "Object;_exception,_trace",
    toString$0: function(_) {
      var t1, trace;
      t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = typeof t1 === "object" ? t1.stack : null;
      t1 = trace == null ? "" : trace;
      this._trace = t1;
      return t1;
    }
  },
  invokeClosure_closure: {
    "^": "Closure:86;closure_0",
    call$0: function() {
      return this.closure_0.call$0();
    }
  },
  invokeClosure_closure0: {
    "^": "Closure:86;closure_1,arg1_2",
    call$0: function() {
      return this.closure_1.call$1(this.arg1_2);
    }
  },
  invokeClosure_closure1: {
    "^": "Closure:86;closure_3,arg1_4,arg2_5",
    call$0: function() {
      return this.closure_3.call$2(this.arg1_4, this.arg2_5);
    }
  },
  invokeClosure_closure2: {
    "^": "Closure:86;closure_6,arg1_7,arg2_8,arg3_9",
    call$0: function() {
      return this.closure_6.call$3(this.arg1_7, this.arg2_8, this.arg3_9);
    }
  },
  invokeClosure_closure3: {
    "^": "Closure:86;closure_10,arg1_11,arg2_12,arg3_13,arg4_14",
    call$0: function() {
      return this.closure_10.call$4(this.arg1_11, this.arg2_12, this.arg3_13, this.arg4_14);
    }
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,__js_helper$_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$isBoundClosure)
        return false;
      return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      t1 = H.Primitives_objectHashCode(this._target);
      if (typeof receiverHashCode !== "number")
        return receiverHashCode.$xor();
      return (receiverHashCode ^ t1) >>> 0;
    },
    $isBoundClosure: true,
    static: {"^": "BoundClosure_selfFieldNameCache,BoundClosure_receiverFieldNameCache", BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = init;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  },
  RuntimeType: {
    "^": "Object;"
  },
  RuntimeFunctionType: {
    "^": "RuntimeType;returnType,parameterTypes,optionalParameterTypes,namedParameters",
    _isTest$1: function(expression) {
      var functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, this.toRti$0());
    },
    _extractFunctionTypeObjectFrom$1: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    toRti$0: function() {
      var result, t1, t2, namedRti, keys, i, $name;
      result = { "func": "dynafunc" };
      t1 = this.returnType;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVoidRuntimeType)
        result.void = true;
      else if (!t2.$isDynamicRuntimeType)
        result.ret = t1.toRti$0();
      t1 = this.parameterTypes;
      if (t1 != null && t1.length !== 0)
        result.args = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0)
        result.opt = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.namedParameters;
      if (t1 != null) {
        namedRti = {};
        keys = H.extractKeys(t1);
        for (t2 = keys.length, i = 0; i < t2; ++i) {
          $name = keys[i];
          namedRti[$name] = t1[$name].toRti$0();
        }
        result.named = namedRti;
      }
      return result;
    },
    toString$0: function(_) {
      var t1, t2, result, needsComma, i, type, keys, $name;
      t1 = this.parameterTypes;
      if (t1 != null)
        for (t2 = t1.length, result = "(", needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
      else {
        result = "(";
        needsComma = false;
      }
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0) {
        result = (needsComma ? result + ", " : result) + "[";
        for (t2 = t1.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
        result += "]";
      } else {
        t1 = this.namedParameters;
        if (t1 != null) {
          result = (needsComma ? result + ", " : result) + "{";
          keys = H.extractKeys(t1);
          for (t2 = keys.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
            $name = keys[i];
            if (needsComma)
              result += ", ";
            result += H.S(t1[$name].toRti$0()) + " " + $name;
          }
          result += "}";
        }
      }
      return result + (") -> " + H.S(this.returnType));
    },
    static: {"^": "RuntimeFunctionType_inAssert", RuntimeFunctionType_listToRti: function(list) {
        var result, t1, i;
        list = list;
        result = [];
        for (t1 = list.length, i = 0; i < t1; ++i)
          result.push(list[i].toRti$0());
        return result;
      }}
  },
  DynamicRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "dynamic";
    },
    toRti$0: function() {
      return;
    },
    $isDynamicRuntimeType: true
  },
  TypeImpl: {
    "^": "Object;_typeName,_unmangledName",
    toString$0: function(_) {
      var t1, unmangledName, unmangledName0;
      t1 = this._unmangledName;
      if (t1 != null)
        return t1;
      unmangledName = this._typeName;
      unmangledName0 = init.mangledGlobalNames[unmangledName];
      unmangledName = unmangledName0 == null ? unmangledName : unmangledName0;
      this._unmangledName = unmangledName;
      return unmangledName;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this._typeName);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isTypeImpl && J.$eq(this._typeName, other._typeName);
    },
    $isTypeImpl: true
  },
  initHooks_closure: {
    "^": "Closure:88;getTag_0",
    call$1: function(o) {
      return this.getTag_0(o);
    }
  },
  initHooks_closure0: {
    "^": "Closure:89;getUnknownTag_1",
    call$2: function(o, tag) {
      return this.getUnknownTag_1(o, tag);
    }
  },
  initHooks_closure1: {
    "^": "Closure:0;prototypeForTag_2",
    call$1: function(tag) {
      return this.prototypeForTag_2(tag);
    }
  }
}],
["accelerators", "package:dartray/accelerators/accelerators.dart", , E, {
  "^": "",
  BruteForceAccel: {
    "^": "Aggregate;primitives,bounds@,primitiveId",
    worldBound$0: function() {
      return this.bounds;
    },
    canIntersect$0: function() {
      return true;
    },
    intersect$2: function(ray, isect) {
      var rayT, hitSomething, i, t1;
      rayT = [0];
      if (this.bounds.inside$1(ray.pointAt$1(ray.get$minDistance())))
        rayT[0] = ray.minDistance;
      else if (!this.bounds.intersectP$2(ray, rayT))
        return false;
      for (hitSomething = false, i = 0; t1 = this.primitives, i < t1.length; ++i)
        if (t1[i].intersect$2(ray, isect))
          hitSomething = true;
      return hitSomething;
    },
    intersectP$1: function(ray) {
      var i, t1;
      for (i = 0; t1 = this.primitives, i < t1.length; ++i)
        if (t1[i].intersectP$1(ray))
          return true;
      return false;
    },
    BruteForceAccel$1: function(p) {
      var t1, i, t2, t3, t4, t5;
      $.Log.call$2(0, "Building Brute Force Acceleration Structures.");
      t1 = J.getInterceptor$asx(p);
      i = 0;
      while (true) {
        t2 = t1.get$length(p);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        t1.$index(p, i).fullyRefine$1(this.primitives);
        ++i;
      }
      for (i = 0; t1 = this.primitives, i < t1.length; ++i) {
        t2 = this.bounds;
        t1 = t1[i].worldBound$0();
        t3 = t2.pMin;
        t4 = t3.x;
        t5 = t3.y;
        t3 = t3.z;
        t2 = t2.pMax;
        this.bounds = new G.BBox(new G.Point(t4, t5, t3), new G.Point(t2.x, t2.y, t2.z)).union$1(t1);
      }
    },
    static: {BruteForceAccel_Create: [function(prims, ps) {
        return E.BruteForceAccel$(prims);
      }, "call$2", "BruteForceAccel_Create$closure", 4, 0, 1], BruteForceAccel$: function(p) {
        var t1, t2;
        t1 = G.BBox$(null, null);
        t2 = $.Primitive__nextprimitiveId;
        $.Primitive__nextprimitiveId = t2 + 1;
        t2 = new E.BruteForceAccel([], t1, t2);
        t2.BruteForceAccel$1(p);
        return t2;
      }}
  },
  BVHAccel: {
    "^": "Aggregate;maxPrimsInNode,splitMethod,primitives,nodes,primitiveId",
    worldBound$0: function() {
      var t1 = this.nodes;
      if (t1 != null) {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0].get$bounds();
      } else
        t1 = G.BBox$(null, null);
      return t1;
    },
    canIntersect$0: function() {
      return true;
    },
    intersect$2: function(ray, isect) {
      var t1, t2, t3, invDir, dirIsNeg, todo, hit, todoOffset, nodeNum, node, i, todoOffset0, nodeNum0;
      if (this.nodes == null)
        return false;
      t1 = J.get$x$x(ray.get$direction());
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = 1 / t1;
      t2 = J.get$y$x(ray.direction);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = 1 / t2;
      t3 = J.get$z$x(ray.direction);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = 1 / t3;
      invDir = new G.Vector(t1, t2, t3);
      t1 = t1 < 0 ? 1 : 0;
      t2 = t2 < 0 ? 1 : 0;
      dirIsNeg = [t1, t2, t3 < 0 ? 1 : 0];
      todo = new Uint32Array(64);
      for (hit = false, todoOffset = 0, nodeNum = 0; true;) {
        t1 = this.nodes;
        if (nodeNum >>> 0 !== nodeNum || nodeNum >= t1.length)
          return H.ioore(t1, nodeNum);
        node = t1[nodeNum];
        if (E.BVHAccel__intersectP(node.get$bounds(), ray, invDir, dirIsNeg)) {
          t1 = node.get$nPrimitives();
          if (typeof t1 !== "number")
            return t1.$gt();
          if (t1 > 0) {
            i = 0;
            while (true) {
              t1 = node.get$nPrimitives();
              if (typeof t1 !== "number")
                return H.iae(t1);
              if (!(i < t1))
                break;
              t1 = this.primitives;
              t2 = J.$add$ns(node.get$offset(node), i);
              if (t2 >>> 0 !== t2 || t2 >= t1.length)
                return H.ioore(t1, t2);
              t1 = this.primitives;
              t2 = J.$add$ns(node.offset, i);
              if (t2 >>> 0 !== t2 || t2 >= t1.length)
                return H.ioore(t1, t2);
              t2 = t1[t2].intersect$2(ray, isect);
              t1 = node.offset;
              t3 = this.primitives;
              if (t2) {
                t1 = J.$add$ns(t1, i);
                if (t1 >>> 0 !== t1 || t1 >= t3.length)
                  return H.ioore(t3, t1);
                hit = true;
              } else {
                t1 = J.$add$ns(t1, i);
                if (t1 >>> 0 !== t1 || t1 >= t3.length)
                  return H.ioore(t3, t1);
              }
              ++i;
            }
            if (todoOffset === 0)
              break;
            --todoOffset;
            if (todoOffset < 0 || todoOffset >= 64)
              return H.ioore(todo, todoOffset);
            nodeNum = todo[todoOffset];
          } else {
            t1 = node.get$axis();
            if (t1 >>> 0 !== t1 || t1 >= 3)
              return H.ioore(dirIsNeg, t1);
            t1 = J.$eq(dirIsNeg[t1], 0);
            todoOffset0 = todoOffset + 1;
            nodeNum0 = node.offset;
            ++nodeNum;
            if (!t1) {
              if (todoOffset < 0 || todoOffset >= 64)
                return H.ioore(todo, todoOffset);
              todo[todoOffset] = nodeNum;
              nodeNum = nodeNum0;
              todoOffset = todoOffset0;
            } else {
              if (todoOffset < 0 || todoOffset >= 64)
                return H.ioore(todo, todoOffset);
              todo[todoOffset] = nodeNum0;
              todoOffset = todoOffset0;
            }
          }
        } else {
          if (todoOffset === 0)
            break;
          --todoOffset;
          if (todoOffset < 0 || todoOffset >= 64)
            return H.ioore(todo, todoOffset);
          nodeNum = todo[todoOffset];
        }
      }
      return hit;
    },
    intersectP$1: function(ray) {
      var t1, t2, t3, invDir, dirIsNeg, todo, todoOffset, nodeNum, node, i, nodeNum0, todoOffset0;
      if (this.nodes == null)
        return false;
      t1 = J.get$x$x(ray.direction);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = 1 / t1;
      t2 = J.get$y$x(ray.direction);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = 1 / t2;
      t3 = J.get$z$x(ray.direction);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = 1 / t3;
      invDir = new G.Vector(t1, t2, t3);
      t1 = t1 < 0 ? 1 : 0;
      t2 = t2 < 0 ? 1 : 0;
      dirIsNeg = [t1, t2, t3 < 0 ? 1 : 0];
      todo = new Uint32Array(64);
      for (todoOffset = 0, nodeNum = 0; true;) {
        t1 = this.nodes;
        if (nodeNum >>> 0 !== nodeNum || nodeNum >= t1.length)
          return H.ioore(t1, nodeNum);
        node = t1[nodeNum];
        if (E.BVHAccel__intersectP(node.get$bounds(), ray, invDir, dirIsNeg)) {
          t1 = node.get$nPrimitives();
          if (typeof t1 !== "number")
            return t1.$gt();
          if (t1 > 0) {
            i = 0;
            while (true) {
              t1 = node.get$nPrimitives();
              if (typeof t1 !== "number")
                return H.iae(t1);
              if (!(i < t1))
                break;
              t1 = this.primitives;
              t2 = J.$add$ns(node.get$offset(node), i);
              if (t2 >>> 0 !== t2 || t2 >= t1.length)
                return H.ioore(t1, t2);
              t1 = this.primitives;
              t2 = J.$add$ns(node.offset, i);
              if (t2 >>> 0 !== t2 || t2 >= t1.length)
                return H.ioore(t1, t2);
              t2 = t1[t2].intersectP$1(ray);
              t1 = node.offset;
              t3 = this.primitives;
              if (t2) {
                t1 = J.$add$ns(t1, i);
                if (t1 >>> 0 !== t1 || t1 >= t3.length)
                  return H.ioore(t3, t1);
                return true;
              } else {
                t1 = J.$add$ns(t1, i);
                if (t1 >>> 0 !== t1 || t1 >= t3.length)
                  return H.ioore(t3, t1);
              }
              ++i;
            }
            if (todoOffset === 0)
              break;
            --todoOffset;
            if (todoOffset < 0 || todoOffset >= 64)
              return H.ioore(todo, todoOffset);
            nodeNum = todo[todoOffset];
          } else {
            t1 = node.get$axis();
            if (t1 >>> 0 !== t1 || t1 >= 3)
              return H.ioore(dirIsNeg, t1);
            t1 = J.$eq(dirIsNeg[t1], 0);
            nodeNum0 = node.offset;
            todoOffset0 = todoOffset + 1;
            ++nodeNum;
            if (!t1) {
              if (todoOffset < 0 || todoOffset >= 64)
                return H.ioore(todo, todoOffset);
              todo[todoOffset] = nodeNum;
              nodeNum = nodeNum0;
              todoOffset = todoOffset0;
            } else {
              if (todoOffset < 0 || todoOffset >= 64)
                return H.ioore(todo, todoOffset);
              todo[todoOffset] = nodeNum0;
              todoOffset = todoOffset0;
            }
          }
        } else {
          if (todoOffset === 0)
            break;
          --todoOffset;
          if (todoOffset < 0 || todoOffset >= 64)
            return H.ioore(todo, todoOffset);
          nodeNum = todo[todoOffset];
        }
      }
      return false;
    },
    _recursiveBuild$5: function(buildData, start, end, totalNodes, orderedPrims) {
      var t1, node, bbox, i, t2, t3, t4, t5, t6, nPrimitives, firstPrimOffset, primNum, centroidBounds, dim, mid, mid0, buckets, t7, b, t8, t9, t10, cost, b0, b1, count0, j, j0, count1, minCost, c2;
      t1 = {};
      totalNodes[0] = J.$add$ns(totalNodes[0], 1);
      node = new E._BVHBuildNode(G.BBox$(null, null), [null, null], null, null, null);
      bbox = G.BBox$(null, null);
      for (i = start; i < end; ++i) {
        if (i >= buildData.length)
          return H.ioore(buildData, i);
        t2 = buildData[i].get$bounds();
        t3 = bbox.pMin;
        t4 = t3.x;
        t5 = t3.y;
        t3 = t3.z;
        t6 = bbox.pMax;
        bbox = new G.BBox(new G.Point(t4, t5, t3), new G.Point(t6.x, t6.y, t6.z)).union$1(t2);
      }
      nPrimitives = end - start;
      if (nPrimitives === 1) {
        firstPrimOffset = orderedPrims.length;
        for (i = start; i < end; ++i) {
          if (i >= buildData.length)
            return H.ioore(buildData, i);
          primNum = buildData[i].get$primitiveNumber();
          t1 = this.primitives;
          if (primNum >= t1.length)
            return H.ioore(t1, primNum);
          orderedPrims.push(t1[primNum]);
        }
        node.firstPrimOffset = firstPrimOffset;
        node.nPrimitives = nPrimitives;
        t1 = node.bounds;
        t1.pMin.copy$1(bbox.pMin);
        t1.pMax.copy$1(bbox.pMax);
      } else {
        centroidBounds = G.BBox$(null, null);
        t1.centroidBounds_0 = centroidBounds;
        for (t2 = centroidBounds, i = start; i < end; ++i, t2 = centroidBounds) {
          if (i >= buildData.length)
            return H.ioore(buildData, i);
          t3 = buildData[i].get$centroid();
          t4 = t2.pMin;
          t5 = t4.x;
          t6 = t4.y;
          t4 = t4.z;
          t2 = t2.pMax;
          centroidBounds = new G.BBox(new G.Point(t5, t6, t4), new G.Point(t2.x, t2.y, t2.z)).unionPoint$1(t3);
          t1.centroidBounds_0 = centroidBounds;
        }
        dim = t2.maximumExtent$0();
        mid = C.JSInt_methods._tdivFast$1(start + end, 2);
        if (J.$eq(t1.centroidBounds_0.pMax.$index(0, dim), t1.centroidBounds_0.pMin.$index(0, dim))) {
          firstPrimOffset = orderedPrims.length;
          for (i = start; i < end; ++i) {
            if (i >= buildData.length)
              return H.ioore(buildData, i);
            primNum = buildData[i].get$primitiveNumber();
            t1 = this.primitives;
            if (primNum >= t1.length)
              return H.ioore(t1, primNum);
            orderedPrims.push(t1[primNum]);
          }
          node.firstPrimOffset = firstPrimOffset;
          node.nPrimitives = nPrimitives;
          t1 = node.bounds;
          t1.pMin.copy$1(bbox.pMin);
          t1.pMax.copy$1(bbox.pMax);
          return node;
        }
        t2 = new E.BVHAccel__recursiveBuild_ComparePoints(dim);
        switch (this.splitMethod) {
          case 0:
            t1 = J.$add$ns(t1.centroidBounds_0.pMin.$index(0, dim), t1.centroidBounds_0.pMax.$index(0, dim));
            if (typeof t1 !== "number")
              return H.iae(t1);
            mid0 = G.partition(buildData, new E.BVHAccel__recursiveBuild_CompareToMid(dim, 0.5 * t1), start, end);
            if (mid0 !== start && mid0 !== end) {
              mid = mid0;
              break;
            }
            G.nth_element(buildData, start, mid, end, t2);
            break;
          case 1:
            G.nth_element(buildData, start, mid, end, t2);
            break;
          case 2:
            if (nPrimitives <= 4)
              G.nth_element(buildData, start, mid, end, t2);
            else {
              buckets = H.setRuntimeTypeInfo(Array(12), [E._BVHBucketInfo]);
              for (t2 = buckets.length, i = 0; i < 12; ++i) {
                t3 = G.BBox$(null, null);
                if (i >= t2)
                  return H.ioore(buckets, i);
                buckets[i] = new E._BVHBucketInfo(0, t3);
              }
              for (t3 = dim === 1, t4 = dim === 0, i = start; i < end; ++i) {
                if (i >= buildData.length)
                  return H.ioore(buildData, i);
                t5 = buildData[i].get$centroid();
                if (t4)
                  t5 = t5.x;
                else
                  t5 = t3 ? t5.y : t5.z;
                t6 = t1.centroidBounds_0.pMin;
                if (t4)
                  t6 = t6.x;
                else
                  t6 = t3 ? t6.y : t6.z;
                t6 = J.$sub$n(t5, t6);
                t5 = t1.centroidBounds_0;
                t7 = t5.pMax;
                if (t4)
                  t7 = t7.x;
                else
                  t7 = t3 ? t7.y : t7.z;
                t5 = t5.pMin;
                if (t4)
                  t5 = t5.x;
                else
                  t5 = t3 ? t5.y : t5.z;
                t5 = J.$div$n(t6, J.$sub$n(t7, t5));
                if (typeof t5 !== "number")
                  return H.iae(t5);
                b = C.JSNumber_methods.toInt$0(Math.floor(12 * t5));
                if (b === 12)
                  b = 11;
                if (b < 0 || b >= t2)
                  return H.ioore(buckets, b);
                t5 = buckets[b];
                t5.set$count(J.$add$ns(t5.get$count(), 1));
                t5 = buckets[b];
                t6 = t5.get$bounds();
                if (i >= buildData.length)
                  return H.ioore(buildData, i);
                t7 = buildData[i].get$bounds();
                t8 = t6.get$pMin();
                t9 = t8.x;
                t10 = t8.y;
                t8 = t8.z;
                t6 = t6.pMax;
                t5.set$bounds(new G.BBox(new G.Point(t9, t10, t8), new G.Point(t6.x, t6.y, t6.z)).union$1(t7));
              }
              cost = H.setRuntimeTypeInfo(Array(11), [J.JSDouble]);
              for (t3 = cost.length, i = 0; i < 11; i = j) {
                b0 = G.BBox$(null, null);
                b1 = G.BBox$(null, null);
                for (count0 = 0, j = 0; j <= i; ++j) {
                  if (j >= t2)
                    return H.ioore(buckets, j);
                  t4 = buckets[j].get$bounds();
                  t5 = b0.pMin;
                  t6 = t5.x;
                  t7 = t5.y;
                  t5 = t5.z;
                  t8 = b0.pMax;
                  b0 = new G.BBox(new G.Point(t6, t7, t5), new G.Point(t8.x, t8.y, t8.z)).union$1(t4);
                  t4 = buckets[j].get$count();
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  count0 += t4;
                }
                for (j = i + 1, j0 = j, count1 = 0; j0 < 12; ++j0) {
                  if (j0 >= t2)
                    return H.ioore(buckets, j0);
                  t4 = buckets[j0].get$bounds();
                  t5 = b1.pMin;
                  t6 = t5.x;
                  t7 = t5.y;
                  t5 = t5.z;
                  t8 = b1.pMax;
                  b1 = new G.BBox(new G.Point(t6, t7, t5), new G.Point(t8.x, t8.y, t8.z)).union$1(t4);
                  t4 = buckets[j0].get$count();
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  count1 += t4;
                }
                t4 = b0.surfaceArea$0();
                t5 = b1.surfaceArea$0();
                t6 = bbox.surfaceArea$0();
                if (i >= t3)
                  return H.ioore(cost, i);
                cost[i] = 0.125 + (count0 * t4 + count1 * t5) / t6;
              }
              if (0 >= t3)
                return H.ioore(cost, 0);
              minCost = cost[0];
              t1.minCostSplit_1 = 0;
              for (i = 1; i < 11; ++i) {
                if (i >= t3)
                  return H.ioore(cost, i);
                if (J.$lt$n(cost[i], minCost)) {
                  minCost = cost[i];
                  t1.minCostSplit_1 = i;
                }
              }
              if (nPrimitives > this.maxPrimsInNode || J.$lt$n(minCost, nPrimitives))
                mid = G.partition(buildData, new E.BVHAccel__recursiveBuild_CompareToBucket(t1, dim, 12), start, end);
              else {
                firstPrimOffset = orderedPrims.length;
                for (i = start; i < end; ++i) {
                  if (i >= buildData.length)
                    return H.ioore(buildData, i);
                  primNum = buildData[i].get$primitiveNumber();
                  t1 = this.primitives;
                  if (primNum >= t1.length)
                    return H.ioore(t1, primNum);
                  orderedPrims.push(t1[primNum]);
                }
                node.firstPrimOffset = firstPrimOffset;
                node.nPrimitives = nPrimitives;
                t1 = node.bounds;
                t1.pMin.copy$1(bbox.pMin);
                t1.pMax.copy$1(bbox.pMax);
                return node;
              }
            }
            break;
          default:
            if (nPrimitives <= 4)
              G.nth_element(buildData, start, mid, end, t2);
            else {
              buckets = H.setRuntimeTypeInfo(Array(12), [E._BVHBucketInfo]);
              for (t2 = buckets.length, i = 0; i < 12; ++i) {
                t3 = G.BBox$(null, null);
                if (i >= t2)
                  return H.ioore(buckets, i);
                buckets[i] = new E._BVHBucketInfo(0, t3);
              }
              for (t3 = dim === 1, t4 = dim === 0, i = start; i < end; ++i) {
                if (i >= buildData.length)
                  return H.ioore(buildData, i);
                t5 = buildData[i].get$centroid();
                if (t4)
                  t5 = t5.x;
                else
                  t5 = t3 ? t5.y : t5.z;
                t6 = t1.centroidBounds_0.pMin;
                if (t4)
                  t6 = t6.x;
                else
                  t6 = t3 ? t6.y : t6.z;
                t6 = J.$sub$n(t5, t6);
                t5 = t1.centroidBounds_0;
                t7 = t5.pMax;
                if (t4)
                  t7 = t7.x;
                else
                  t7 = t3 ? t7.y : t7.z;
                t5 = t5.pMin;
                if (t4)
                  t5 = t5.x;
                else
                  t5 = t3 ? t5.y : t5.z;
                t5 = J.$div$n(t6, J.$sub$n(t7, t5));
                if (typeof t5 !== "number")
                  return H.iae(t5);
                b = C.JSNumber_methods.toInt$0(Math.floor(12 * t5));
                if (b === 12)
                  b = 11;
                if (b < 0 || b >= t2)
                  return H.ioore(buckets, b);
                t5 = buckets[b];
                t5.set$count(J.$add$ns(t5.get$count(), 1));
                t5 = buckets[b];
                t6 = t5.get$bounds();
                if (i >= buildData.length)
                  return H.ioore(buildData, i);
                t7 = buildData[i].get$bounds();
                t8 = t6.get$pMin();
                t9 = t8.x;
                t10 = t8.y;
                t8 = t8.z;
                t6 = t6.pMax;
                t5.set$bounds(new G.BBox(new G.Point(t9, t10, t8), new G.Point(t6.x, t6.y, t6.z)).union$1(t7));
              }
              cost = H.setRuntimeTypeInfo(Array(11), [J.JSDouble]);
              for (t3 = cost.length, i = 0; i < 11; i = j) {
                b0 = G.BBox$(null, null);
                b1 = G.BBox$(null, null);
                for (count0 = 0, j = 0; j <= i; ++j) {
                  if (j >= t2)
                    return H.ioore(buckets, j);
                  t4 = buckets[j].get$bounds();
                  t5 = b0.pMin;
                  t6 = t5.x;
                  t7 = t5.y;
                  t5 = t5.z;
                  t8 = b0.pMax;
                  b0 = new G.BBox(new G.Point(t6, t7, t5), new G.Point(t8.x, t8.y, t8.z)).union$1(t4);
                  t4 = buckets[j].get$count();
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  count0 += t4;
                }
                for (j = i + 1, j0 = j, count1 = 0; j0 < 12; ++j0) {
                  if (j0 >= t2)
                    return H.ioore(buckets, j0);
                  t4 = buckets[j0].get$bounds();
                  t5 = b1.pMin;
                  t6 = t5.x;
                  t7 = t5.y;
                  t5 = t5.z;
                  t8 = b1.pMax;
                  b1 = new G.BBox(new G.Point(t6, t7, t5), new G.Point(t8.x, t8.y, t8.z)).union$1(t4);
                  t4 = buckets[j0].get$count();
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  count1 += t4;
                }
                t4 = b0.surfaceArea$0();
                t5 = b1.surfaceArea$0();
                t6 = bbox.surfaceArea$0();
                if (i >= t3)
                  return H.ioore(cost, i);
                cost[i] = 0.125 + (count0 * t4 + count1 * t5) / t6;
              }
              if (0 >= t3)
                return H.ioore(cost, 0);
              minCost = cost[0];
              t1.minCostSplit_1 = 0;
              for (i = 1; i < 11; ++i) {
                if (i >= t3)
                  return H.ioore(cost, i);
                if (J.$lt$n(cost[i], minCost)) {
                  minCost = cost[i];
                  t1.minCostSplit_1 = i;
                }
              }
              if (nPrimitives > this.maxPrimsInNode || J.$lt$n(minCost, nPrimitives))
                mid = G.partition(buildData, new E.BVHAccel__recursiveBuild_CompareToBucket(t1, dim, 12), start, end);
              else {
                firstPrimOffset = orderedPrims.length;
                for (i = start; i < end; ++i) {
                  if (i >= buildData.length)
                    return H.ioore(buildData, i);
                  primNum = buildData[i].get$primitiveNumber();
                  t1 = this.primitives;
                  if (primNum >= t1.length)
                    return H.ioore(t1, primNum);
                  orderedPrims.push(t1[primNum]);
                }
                node.firstPrimOffset = firstPrimOffset;
                node.nPrimitives = nPrimitives;
                t1 = node.bounds;
                t1.pMin.copy$1(bbox.pMin);
                t1.pMax.copy$1(bbox.pMax);
                return node;
              }
            }
            break;
        }
        c2 = this._recursiveBuild$5(buildData, mid, end, totalNodes, orderedPrims);
        node.initInterior$3(dim, this._recursiveBuild$5(buildData, start, mid, totalNodes, orderedPrims), c2);
      }
      return node;
    },
    _flattenBVHTree$2: function(node, offset) {
      var t1, t2, linearNode, myOffset;
      t1 = this.nodes;
      t2 = offset[0];
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      linearNode = t1[t2];
      linearNode.set$bounds(G.BBox$from(node.get$bounds()));
      myOffset = offset[0];
      offset[0] = J.$add$ns(myOffset, 1);
      t1 = node.get$nPrimitives();
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 0) {
        J.set$offset$x(linearNode, node.get$firstPrimOffset());
        linearNode.set$nPrimitives(node.nPrimitives);
      } else {
        linearNode.set$axis(node.get$splitAxis());
        linearNode.set$nPrimitives(0);
        this._flattenBVHTree$2(node.get$children(node)[0], offset);
        linearNode.offset = this._flattenBVHTree$2(node.children[1], offset);
      }
      return myOffset;
    },
    BVHAccel$3: function(p, maxPrims, splitMethod) {
      var t1, i, t2, buildData, bbox, t3, t4, t5, t6, t7, totalNodes, orderedPrims, root, len;
      $.Log.call$2(0, "Building BVH Acceleration Structures.");
      this.maxPrimsInNode = P.min(255, maxPrims);
      t1 = J.getInterceptor$asx(p);
      i = 0;
      while (true) {
        t2 = t1.get$length(p);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        t1.$index(p, i).fullyRefine$1(this.primitives);
        ++i;
      }
      if (this.primitives.length === 0) {
        this.nodes = null;
        return;
      }
      buildData = [];
      for (i = 0; t1 = this.primitives, t2 = t1.length, i < t2; ++i) {
        bbox = t1[i].worldBound$0();
        t1 = new E._BVHPrimitiveInfo(i, null, bbox);
        if (bbox == null) {
          t2 = G.BBox$(null, null);
          t1.bounds = t2;
        } else
          t2 = bbox;
        t3 = t2.get$pMin();
        t4 = J.$mul$ns(t3.x, 0.5);
        t5 = J.$mul$ns(t3.y, 0.5);
        t3 = J.$mul$ns(t3.z, 0.5);
        t2 = t2.pMax;
        t6 = J.$mul$ns(t2.x, 0.5);
        t7 = J.$mul$ns(t2.y, 0.5);
        t2 = J.$mul$ns(t2.z, 0.5);
        t1.centroid = new G.Point(J.$add$ns(t4, t6), J.$add$ns(t5, t7), J.$add$ns(t3, t2));
        buildData.push(t1);
      }
      totalNodes = [0];
      orderedPrims = [];
      root = this._recursiveBuild$5(buildData, 0, t2, totalNodes, orderedPrims);
      this.primitives = orderedPrims;
      t1 = "BVH created with " + H.S(totalNodes[0]) + " nodes for " + this.primitives.length + " primitives";
      $.Log.call$2(0, t1);
      t1 = totalNodes[0];
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.nodes = H.setRuntimeTypeInfo(Array(t1), [E._LinearBVHNode]);
      len = totalNodes[0];
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i) {
        t1 = this.nodes;
        t2 = G.BBox$(null, null);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = new E._LinearBVHNode(t2, null, null, null);
      }
      this._flattenBVHTree$2(root, [0]);
    },
    static: {"^": "BVHAccel_SPLIT_MIDDLE,BVHAccel_SPLIT_EQUAL_COUNTS,BVHAccel_SPLIT_SAH", BVHAccel$: function(p, maxPrims, splitMethod) {
        var t1 = $.Primitive__nextprimitiveId;
        $.Primitive__nextprimitiveId = t1 + 1;
        t1 = new E.BVHAccel(null, splitMethod, [], null, t1);
        t1.BVHAccel$3(p, maxPrims, splitMethod);
        return t1;
      }, BVHAccel_Create: [function(prims, ps) {
        var splitMethod, maxPrimsInNode, t1, sm;
        splitMethod = ps.findOneString$2("splitmethod", "sah");
        maxPrimsInNode = ps.findOneInt$2("maxnodeprims", 4);
        t1 = J.getInterceptor(splitMethod);
        if (t1.$eq(splitMethod, "sah"))
          sm = 2;
        else if (t1.$eq(splitMethod, "middle"))
          sm = 0;
        else {
          t1 = t1.$eq(splitMethod, "equal") ? 1 : 2;
          sm = t1;
        }
        return E.BVHAccel$(prims, maxPrimsInNode, sm);
      }, "call$2", "BVHAccel_Create$closure", 4, 0, 2], BVHAccel__intersectP: function(bounds, ray, invDir, dirIsNeg) {
        var t1, tmin, t2, tmax, tymin, tymax, tzmin, tzmax;
        t1 = J.getInterceptor$asx(bounds);
        tmin = J.$mul$ns(J.$sub$n(J.get$x$x(t1.$index(bounds, dirIsNeg[0])), J.get$x$x(ray.origin)), invDir.x);
        t2 = dirIsNeg[0];
        if (typeof t2 !== "number")
          return H.iae(t2);
        tmax = J.$mul$ns(J.$sub$n(J.get$x$x(t1.$index(bounds, 1 - t2)), J.get$x$x(ray.origin)), invDir.x);
        tymin = J.$mul$ns(J.$sub$n(J.get$y$x(t1.$index(bounds, dirIsNeg[1])), J.get$y$x(ray.origin)), invDir.y);
        t2 = dirIsNeg[1];
        if (typeof t2 !== "number")
          return H.iae(t2);
        tymax = J.$mul$ns(J.$sub$n(J.get$y$x(t1.$index(bounds, 1 - t2)), J.get$y$x(ray.origin)), invDir.y);
        if (J.$gt$n(tmin, tymax) || J.$gt$n(tymin, tmax))
          return false;
        if (J.$gt$n(tymin, tmin))
          tmin = tymin;
        if (J.$lt$n(tymax, tmax))
          tmax = tymax;
        tzmin = J.$mul$ns(J.$sub$n(J.get$z$x(t1.$index(bounds, dirIsNeg[2])), J.get$z$x(ray.origin)), invDir.z);
        t2 = dirIsNeg[2];
        if (typeof t2 !== "number")
          return H.iae(t2);
        tzmax = J.$mul$ns(J.$sub$n(J.get$z$x(t1.$index(bounds, 1 - t2)), J.get$z$x(ray.origin)), invDir.z);
        if (J.$gt$n(tmin, tzmax) || J.$gt$n(tzmin, tmax))
          return false;
        if (J.$gt$n(tzmin, tmin))
          tmin = tzmin;
        if (J.$lt$n(tzmax, tmax))
          tmax = tzmax;
        return J.$lt$n(tmin, ray.maxDistance) && J.$gt$n(tmax, ray.minDistance);
      }}
  },
  BVHAccel__recursiveBuild_ComparePoints: {
    "^": "Closure:90;dim_1",
    call$2: function(a, b) {
      var t1 = this.dim_1;
      return J.$lt$n(a.get$centroid().$index(0, t1), b.get$centroid().$index(0, t1));
    }
  },
  BVHAccel__recursiveBuild_CompareToMid: {
    "^": "Closure:91;dim_2,pmid_3",
    call$1: function(a) {
      return J.$lt$n(a.get$centroid().$index(0, this.dim_2), this.pmid_3);
    }
  },
  BVHAccel__recursiveBuild_CompareToBucket: {
    "^": "Closure:91;box_0,dim_4,nBuckets_5",
    call$1: function(p) {
      var t1, t2, t3, b;
      t1 = this.nBuckets_5;
      t2 = this.dim_4;
      t3 = this.box_0;
      t2 = J.$div$n(J.$sub$n(p.get$centroid().$index(0, t2), t3.centroidBounds_0.pMin.$index(0, t2)), J.$sub$n(t3.centroidBounds_0.pMax.$index(0, t2), t3.centroidBounds_0.pMin.$index(0, t2)));
      if (typeof t2 !== "number")
        return H.iae(t2);
      b = C.JSNumber_methods.toInt$0(Math.floor(t1 * t2));
      if (b === t1)
        b = t1 - 1;
      return b <= t3.minCostSplit_1;
    }
  },
  _BVHPrimitiveInfo: {
    "^": "Object;primitiveNumber<,centroid<,bounds@"
  },
  _BVHBucketInfo: {
    "^": "Object;count@,bounds@"
  },
  _BVHBuildNode: {
    "^": "Object;bounds@,children>,splitAxis<,firstPrimOffset<,nPrimitives<",
    initInterior$3: function(axis, c0, c1) {
      var t1, t2;
      t1 = this.children;
      t1[0] = c0;
      t1[1] = c1;
      t1 = c0.get$bounds();
      t2 = c1.get$bounds();
      this.bounds = G.BBox$from(t1).union$1(t2);
      this.splitAxis = axis;
      this.nPrimitives = 0;
    }
  },
  _LinearBVHNode: {
    "^": "Object;bounds@,offset*,nPrimitives@,axis@"
  },
  GridAccel: {
    "^": "Aggregate;primitives,nVoxels,bounds@,width>,invWidth,voxels,primitiveId",
    worldBound$0: function() {
      return G.BBox$from(this.bounds);
    },
    canIntersect$0: function() {
      return true;
    },
    intersect$2: function(ray, isect) {
      var rayT, t1, t2, gridIntersect, nextCrossingT, deltaT, step, out, pos, axis, t3, t4, t5, hitSomething, voxel, stepAxis;
      rayT = [0];
      if (this.bounds.inside$1(ray.pointAt$1(ray.get$minDistance())))
        rayT[0] = ray.minDistance;
      else if (!this.bounds.intersectP$2(ray, rayT))
        return false;
      t1 = rayT[0];
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t1));
      t2 = J.getInterceptor$x(t1);
      gridIntersect = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
      nextCrossingT = [0, 0, 0];
      deltaT = [0, 0, 0];
      step = [0, 0, 0];
      out = [0, 0, 0];
      pos = [0, 0, 0];
      for (axis = 0; axis < 3; ++axis) {
        pos[axis] = this.posToVoxel$2(gridIntersect, axis);
        t1 = J.$ge$n(J.$index$asx(ray.direction, axis), 0);
        t2 = rayT[0];
        t3 = pos[axis];
        if (t1) {
          t1 = J.$add$ns(t3, 1);
          t3 = this.bounds.pMin;
          t4 = axis === 0;
          if (t4)
            t3 = t3.x;
          else
            t3 = axis === 1 ? t3.y : t3.z;
          t5 = this.width;
          if (t4)
            t5 = t5.x;
          else
            t5 = axis === 1 ? t5.y : t5.z;
          t5 = J.$add$ns(t3, J.$mul$ns(t1, t5));
          if (t4)
            t1 = gridIntersect.x;
          else
            t1 = axis === 1 ? gridIntersect.y : gridIntersect.z;
          nextCrossingT[axis] = J.$add$ns(t2, J.$div$n(J.$sub$n(t5, t1), J.$index$asx(ray.direction, axis)));
          t1 = this.width;
          if (t4)
            t1 = t1.x;
          else
            t1 = axis === 1 ? t1.y : t1.z;
          deltaT[axis] = J.$div$n(t1, J.$index$asx(ray.direction, axis));
          step[axis] = 1;
          out[axis] = this.nVoxels[axis];
        } else {
          t1 = this.bounds.pMin;
          t4 = axis === 0;
          if (t4)
            t1 = t1.x;
          else
            t1 = axis === 1 ? t1.y : t1.z;
          t5 = this.width;
          if (t4)
            t5 = t5.x;
          else
            t5 = axis === 1 ? t5.y : t5.z;
          t5 = J.$add$ns(t1, J.$mul$ns(t3, t5));
          if (t4)
            t1 = gridIntersect.x;
          else
            t1 = axis === 1 ? gridIntersect.y : gridIntersect.z;
          nextCrossingT[axis] = J.$add$ns(t2, J.$div$n(J.$sub$n(t5, t1), J.$index$asx(ray.direction, axis)));
          t1 = this.width;
          if (t4)
            t1 = t1.x;
          else
            t1 = axis === 1 ? t1.y : t1.z;
          deltaT[axis] = J.$div$n(J.$negate$n(t1), J.$index$asx(ray.direction, axis));
          step[axis] = -1;
          out[axis] = -1;
        }
      }
      for (t1 = this.nVoxels, hitSomething = false; true;) {
        t2 = this.voxels;
        t3 = pos[0];
        t4 = pos[1];
        t3 = J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(pos[2], t1[0]), t1[1]), J.$mul$ns(t4, t1[0])), t3);
        if (t3 >>> 0 !== t3 || t3 >= t2.length)
          return H.ioore(t2, t3);
        voxel = t2[t3];
        t2 = voxel != null;
        if (t2)
          J.size$0$x(voxel);
        if (t2)
          hitSomething = voxel.intersect$2(ray, isect) ? true : hitSomething;
        t2 = J.$lt$n(nextCrossingT[0], nextCrossingT[1]) ? 4 : 0;
        t3 = J.$lt$n(nextCrossingT[0], nextCrossingT[2]) ? 2 : 0;
        t4 = J.$lt$n(nextCrossingT[1], nextCrossingT[2]) ? 1 : 0;
        stepAxis = C.List_2Vk0[t2 + t3 + t4];
        t2 = ray.maxDistance;
        if (stepAxis >>> 0 !== stepAxis || stepAxis >= 3)
          return H.ioore(nextCrossingT, stepAxis);
        if (J.$lt$n(t2, nextCrossingT[stepAxis]))
          break;
        t2 = J.$add$ns(pos[stepAxis], step[stepAxis]);
        pos[stepAxis] = t2;
        if (J.$eq(t2, out[stepAxis]))
          break;
        nextCrossingT[stepAxis] = J.$add$ns(nextCrossingT[stepAxis], deltaT[stepAxis]);
      }
      return hitSomething;
    },
    intersectP$1: function(ray) {
      var rayT, t1, t2, t3, gridIntersect, nextCrossingT, deltaT, step, out, pos, axis, t4, t5, o, voxel, stepAxis;
      rayT = [0];
      t1 = this.bounds;
      t2 = ray.minDistance;
      t2 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t2));
      t3 = J.getInterceptor$x(t2);
      if (t1.inside$1(new G.Point(t3.get$x(t2), t3.get$y(t2), t3.get$z(t2))))
        rayT[0] = ray.minDistance;
      else if (!this.bounds.intersectP$2(ray, rayT))
        return false;
      t1 = rayT[0];
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t1));
      t2 = J.getInterceptor$x(t1);
      gridIntersect = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
      nextCrossingT = [0, 0, 0];
      deltaT = [0, 0, 0];
      step = [0, 0, 0];
      out = [0, 0, 0];
      pos = [0, 0, 0];
      for (axis = 0; axis < 3; ++axis) {
        pos[axis] = this.posToVoxel$2(gridIntersect, axis);
        t1 = J.$ge$n(J.$index$asx(ray.direction, axis), 0);
        t2 = pos[axis];
        t3 = rayT[0];
        if (t1) {
          t1 = J.$add$ns(t2, 1);
          t2 = this.bounds.pMin;
          t4 = axis === 0;
          if (t4)
            t2 = t2.x;
          else
            t2 = axis === 1 ? t2.y : t2.z;
          t5 = this.width;
          if (t4)
            t5 = t5.x;
          else
            t5 = axis === 1 ? t5.y : t5.z;
          t5 = J.$add$ns(t2, J.$mul$ns(t1, t5));
          if (t4)
            t1 = gridIntersect.x;
          else
            t1 = axis === 1 ? gridIntersect.y : gridIntersect.z;
          nextCrossingT[axis] = J.$add$ns(t3, J.$div$n(J.$sub$n(t5, t1), J.$index$asx(ray.direction, axis)));
          t1 = this.width;
          if (t4)
            t1 = t1.x;
          else
            t1 = axis === 1 ? t1.y : t1.z;
          deltaT[axis] = J.$div$n(t1, J.$index$asx(ray.direction, axis));
          step[axis] = 1;
          out[axis] = this.nVoxels[axis];
        } else {
          t1 = this.bounds.pMin;
          t4 = axis === 0;
          if (t4)
            t1 = t1.x;
          else
            t1 = axis === 1 ? t1.y : t1.z;
          t5 = this.width;
          if (t4)
            t5 = t5.x;
          else
            t5 = axis === 1 ? t5.y : t5.z;
          t5 = J.$add$ns(t1, J.$mul$ns(t2, t5));
          if (t4)
            t1 = gridIntersect.x;
          else
            t1 = axis === 1 ? gridIntersect.y : gridIntersect.z;
          nextCrossingT[axis] = J.$add$ns(t3, J.$div$n(J.$sub$n(t5, t1), J.$index$asx(ray.direction, axis)));
          t1 = this.width;
          if (t4)
            t1 = t1.x;
          else
            t1 = axis === 1 ? t1.y : t1.z;
          deltaT[axis] = J.$div$n(J.$negate$n(t1), J.$index$asx(ray.direction, axis));
          step[axis] = -1;
          out[axis] = -1;
        }
      }
      for (t1 = this.nVoxels; true;) {
        t2 = pos[0];
        t3 = pos[1];
        o = J.$add$ns(J.$add$ns(J.$mul$ns(J.$mul$ns(pos[2], t1[0]), t1[1]), J.$mul$ns(t3, t1[0])), t2);
        t2 = this.voxels;
        if (o >>> 0 !== o || o >= t2.length)
          return H.ioore(t2, o);
        voxel = t2[o];
        t2 = voxel != null;
        if (t2)
          J.size$0$x(voxel);
        if (t2 && voxel.intersectP$1(ray))
          return true;
        t2 = J.$lt$n(nextCrossingT[0], nextCrossingT[1]) ? 4 : 0;
        t3 = J.$lt$n(nextCrossingT[0], nextCrossingT[2]) ? 2 : 0;
        t4 = J.$lt$n(nextCrossingT[1], nextCrossingT[2]) ? 1 : 0;
        stepAxis = C.List_2Vk0[t2 + t3 + t4];
        t2 = ray.maxDistance;
        if (stepAxis >>> 0 !== stepAxis || stepAxis >= 3)
          return H.ioore(nextCrossingT, stepAxis);
        if (J.$lt$n(t2, nextCrossingT[stepAxis]))
          break;
        t2 = J.$add$ns(pos[stepAxis], step[stepAxis]);
        pos[stepAxis] = t2;
        if (J.$eq(t2, out[stepAxis]))
          break;
        nextCrossingT[stepAxis] = J.$add$ns(nextCrossingT[stepAxis], deltaT[stepAxis]);
      }
      return false;
    },
    posToVoxel$2: function($P, axis) {
      var t1, t2, t3, v;
      t1 = axis === 0;
      if (t1)
        t2 = $P.x;
      else
        t2 = axis === 1 ? $P.y : $P.z;
      t3 = this.bounds.pMin;
      if (t1)
        t3 = t3.x;
      else
        t3 = axis === 1 ? t3.y : t3.z;
      t3 = J.$sub$n(t2, t3);
      t2 = this.invWidth;
      if (t1)
        t1 = t2.x;
      else
        t1 = axis === 1 ? t2.y : t2.z;
      v = J.toInt$0$n(J.$mul$ns(t3, t1));
      t1 = this.nVoxels;
      if (axis >= 3)
        return H.ioore(t1, axis);
      return C.JSInt_methods.clamp$2(v, 0, J.$sub$n(t1[axis], 1));
    },
    GridAccel$2: function(p, refineImmediately) {
      var t1, i, t2, t3, t4, t5, delta, voxelsPerUnitDist, axis, nv, vmin, vmax, prim, pb, z, y, x, o, t6, t7;
      $.Log.call$2(0, "Building Hierarchical Grid Acceleration Structures.");
      t1 = J.getInterceptor$asx(p);
      t1.get$length(p);
      if (refineImmediately === true) {
        i = 0;
        while (true) {
          t2 = t1.get$length(p);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.$index(p, i).fullyRefine$1(this.primitives);
          ++i;
        }
      } else
        this.primitives = p;
      i = 0;
      while (true) {
        t1 = J.get$length$asx(this.primitives);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this.bounds;
        if (!(i < t1))
          break;
        t1 = J.$index$asx(this.primitives, i).worldBound$0();
        t3 = t2.pMin;
        t4 = t3.x;
        t5 = t3.y;
        t3 = t3.z;
        t2 = t2.pMax;
        this.bounds = new G.BBox(new G.Point(t4, t5, t3), new G.Point(t2.x, t2.y, t2.z)).union$1(t1);
        ++i;
      }
      delta = t2.pMax.$sub(0, t2.pMin);
      t1 = delta.$index(0, this.bounds.maximumExtent$0());
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.get$length$asx(this.primitives);
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      voxelsPerUnitDist = 3 * Math.pow(t2, 0.3333333333333333) * (1 / t1);
      for (t1 = this.nVoxels, axis = 0; axis < 3; ++axis) {
        if (axis === 0)
          t2 = delta.x;
        else
          t2 = axis === 1 ? delta.y : delta.z;
        t2 = J.round$0$n(J.$mul$ns(t2, voxelsPerUnitDist));
        t1[axis] = t2;
        t1[axis] = C.JSInt_methods.clamp$2(t2, 1, 64);
      }
      for (t2 = this.invWidth, axis = 0; axis < 3; ++axis) {
        t3 = this.width;
        t4 = axis === 0;
        if (t4)
          t5 = delta.x;
        else
          t5 = axis === 1 ? delta.y : delta.z;
        t5 = J.$div$n(t5, t1[axis]);
        if (t4)
          t3.x = t5;
        else if (axis === 1)
          t3.y = t5;
        else
          t3.z = t5;
        t3 = this.width;
        if (t4)
          t3 = t3.x;
        else
          t3 = axis === 1 ? t3.y : t3.z;
        if (J.$eq(t3, 0))
          t3 = 0;
        else {
          t3 = this.width;
          if (t4)
            t3 = t3.x;
          else
            t3 = axis === 1 ? t3.y : t3.z;
          if (typeof t3 !== "number")
            return H.iae(t3);
          t3 = 1 / t3;
        }
        if (t4)
          t2.x = t3;
        else if (axis === 1)
          t2.y = t3;
        else
          t2.z = t3;
      }
      nv = J.$mul$ns(J.$mul$ns(t1[0], t1[1]), t1[2]);
      if (typeof nv !== "number")
        return H.iae(nv);
      this.voxels = H.setRuntimeTypeInfo(Array(nv), [E._Voxel]);
      vmin = [0, 0, 0];
      vmax = [0, 0, 0];
      i = 0;
      while (true) {
        t2 = J.get$length$asx(this.primitives);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        prim = J.$index$asx(this.primitives, i);
        pb = prim.worldBound$0();
        for (axis = 0; axis < 3; ++axis) {
          vmin[axis] = this.posToVoxel$2(pb.get$pMin(), axis);
          vmax[axis] = this.posToVoxel$2(pb.pMax, axis);
        }
        for (z = vmin[2]; t2 = J.getInterceptor$n(z), t2.$le(z, vmax[2]); z = t2.$add(z, 1))
          for (y = vmin[1]; t3 = J.getInterceptor$n(y), t3.$le(y, vmax[1]); y = t3.$add(y, 1))
            for (x = vmin[0]; t4 = J.getInterceptor$n(x), t4.$le(x, vmax[0]); x = t4.$add(x, 1)) {
              o = J.$add$ns(J.$add$ns(J.$mul$ns(t2.$mul(z, t1[0]), t1[1]), t3.$mul(y, t1[0])), x);
              t5 = this.voxels;
              if (o >>> 0 !== o || o >= t5.length)
                return H.ioore(t5, o);
              t6 = t5[o];
              if (t6 == null) {
                t6 = [];
                t7 = new E._Voxel(t6, null);
                t7.allCanIntersect = false;
                t6.push(prim);
                t5[o] = t7;
              } else
                t6.addPrimitive$1(prim);
            }
        ++i;
      }
    },
    static: {GridAccel_Create: [function(prims, ps) {
        return E.GridAccel$(prims, ps.findOneBool$2("refineimmediately", true));
      }, "call$2", "GridAccel_Create$closure", 4, 0, 3], GridAccel$: function(p, refineImmediately) {
        var t1, t2;
        t1 = G.BBox$(null, null);
        t2 = $.Primitive__nextprimitiveId;
        $.Primitive__nextprimitiveId = t2 + 1;
        t2 = new E.GridAccel([], [0, 0, 0], t1, new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), null, t2);
        t2.GridAccel$2(p, refineImmediately);
        return t2;
      }}
  },
  _Voxel: {
    "^": "Object;primitives,allCanIntersect",
    size$0: [function(_) {
      return this.primitives.length;
    }, "call$0", "get$size", 0, 0, 92],
    addPrimitive$1: function(prim) {
      this.primitives.push(prim);
    },
    intersect$2: function(ray, isect) {
      var ei, i, t1, prim, p, t2, hitSomething;
      ei = this.primitives.length;
      if (!this.allCanIntersect) {
        for (i = 0; i < ei; ++i) {
          t1 = this.primitives;
          if (i >= t1.length)
            return H.ioore(t1, i);
          prim = t1[i];
          if (!prim.canIntersect$0()) {
            p = [];
            prim.fullyRefine$1(p);
            t1 = p.length;
            t2 = this.primitives;
            if (t1 === 1) {
              if (0 >= t1)
                return H.ioore(p, 0);
              t1 = p[0];
              if (i >= t2.length)
                return H.ioore(t2, i);
              t2[i] = t1;
            } else {
              t1 = E.GridAccel$(p, false);
              if (i >= t2.length)
                return H.ioore(t2, i);
              t2[i] = t1;
            }
          }
        }
        this.allCanIntersect = true;
      }
      for (hitSomething = false, i = 0; i < ei; ++i) {
        t1 = this.primitives;
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (t1[i].intersect$2(ray, isect))
          hitSomething = true;
      }
      return hitSomething;
    },
    intersectP$1: function(ray) {
      var i, t1, prim, p, t2;
      if (!this.allCanIntersect) {
        for (i = 0; t1 = this.primitives, i < t1.length; ++i) {
          prim = t1[i];
          if (!prim.canIntersect$0()) {
            p = [];
            prim.fullyRefine$1(p);
            t1 = p.length;
            t2 = this.primitives;
            if (t1 === 1) {
              if (0 >= t1)
                return H.ioore(p, 0);
              t1 = p[0];
              if (i >= t2.length)
                return H.ioore(t2, i);
              t2[i] = t1;
            } else {
              t1 = E.GridAccel$(p, false);
              if (i >= t2.length)
                return H.ioore(t2, i);
              t2[i] = t1;
            }
          }
        }
        this.allCanIntersect = true;
      }
      for (i = 0; t1 = this.primitives, i < t1.length; ++i)
        if (t1[i].intersectP$1(ray))
          return true;
      return false;
    }
  },
  KdTreeAccel: {
    "^": "Aggregate;isectCost,traversalCost,maxPrims,maxDepth,emptyBonus,primitives,nodes,nAllocedNodes,nextFreeNode,bounds@,primitiveId",
    worldBound$0: function() {
      return this.bounds;
    },
    canIntersect$0: function() {
      return true;
    },
    intersect$2: function(ray, isect) {
      var tmin, tmax, t1, t2, t3, invDir, todo, node, todoPos, hit, nodeIndex, firstChildIndex, secondChildIndex, axis, tplane, belowFirst, t4, firstChild, secondChild, prims, i;
      tmin = [0];
      tmax = [0];
      if (!this.bounds.intersectP$3(ray, tmin, tmax))
        return false;
      t1 = J.get$x$x(ray.get$direction());
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.get$y$x(ray.direction);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = J.get$z$x(ray.direction);
      if (typeof t3 !== "number")
        return H.iae(t3);
      invDir = new G.Vector(1 / t1, 1 / t2, 1 / t3);
      todo = H.setRuntimeTypeInfo(Array(64), [E._KdToDo]);
      t3 = this.nodes;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      node = t3[0];
      for (t1 = todo.length, todoPos = 0, hit = false, nodeIndex = 0, firstChildIndex = 0, secondChildIndex = 0; node != null;) {
        if (J.$lt$n(ray.maxDistance, tmin[0]))
          break;
        t2 = node.isLeaf$0();
        t3 = node.flags;
        if (!t2) {
          if (typeof t3 !== "number")
            return t3.$and();
          axis = t3 & 3;
          t2 = J.$sub$n(node.split, J.$index$asx(ray.origin, axis));
          if (axis === 0)
            t3 = invDir.x;
          else
            t3 = axis === 1 ? invDir.y : invDir.z;
          tplane = J.$mul$ns(t2, t3);
          if (!J.$lt$n(J.$index$asx(ray.origin, axis), node.split))
            belowFirst = J.$eq(J.$index$asx(ray.origin, axis), node.split) && J.$le$n(J.$index$asx(ray.direction, axis), 0);
          else
            belowFirst = true;
          t2 = this.nodes;
          t3 = node.flags;
          if (belowFirst) {
            if (typeof nodeIndex !== "number")
              return nodeIndex.$add();
            firstChildIndex = nodeIndex + 1;
            t4 = t2.length;
            if (firstChildIndex >= t4)
              return H.ioore(t2, firstChildIndex);
            firstChild = t2[firstChildIndex];
            if (typeof t3 !== "number")
              return t3.$shr();
            secondChildIndex = C.JSInt_methods._shrOtherPositive$1(t3, 2);
            if (secondChildIndex >= t4)
              return H.ioore(t2, secondChildIndex);
            secondChild = t2[secondChildIndex];
          } else {
            if (typeof t3 !== "number")
              return t3.$shr();
            firstChildIndex = C.JSInt_methods._shrOtherPositive$1(t3, 2);
            t3 = t2.length;
            if (firstChildIndex >= t3)
              return H.ioore(t2, firstChildIndex);
            firstChild = t2[firstChildIndex];
            if (typeof nodeIndex !== "number")
              return nodeIndex.$add();
            secondChildIndex = nodeIndex + 1;
            if (secondChildIndex >= t3)
              return H.ioore(t2, secondChildIndex);
            secondChild = t2[secondChildIndex];
          }
          t2 = J.getInterceptor$n(tplane);
          if (t2.$gt(tplane, tmax[0]) || t2.$le(tplane, 0)) {
            node = firstChild;
            nodeIndex = firstChildIndex;
          } else if (t2.$lt(tplane, tmin[0])) {
            node = secondChild;
            nodeIndex = secondChildIndex;
          } else {
            if (todoPos < 0 || todoPos >= t1)
              return H.ioore(todo, todoPos);
            t2 = todo[todoPos];
            if (t2 == null) {
              t2 = new E._KdToDo(null, null, null, null);
              todo[todoPos] = t2;
            }
            t2.set$node(secondChild);
            t2.nodeIndex = secondChildIndex;
            t2.tmin = tplane;
            t2.tmax = tmax[0];
            ++todoPos;
            tmax[0] = tplane;
            node = firstChild;
            nodeIndex = firstChildIndex;
          }
        } else {
          if (typeof t3 !== "number")
            return t3.$shr();
          t2 = C.JSInt_methods._shrOtherPositive$1(t3, 2);
          if (t2 === 1) {
            t2 = this.primitives;
            t3 = node.onePrimitive;
            if (t3 >>> 0 !== t3 || t3 >= t2.length)
              return H.ioore(t2, t3);
            if (t2[t3].intersect$2(ray, isect))
              hit = true;
          } else {
            prims = node.primitives;
            for (i = 0; i < t2; ++i) {
              t3 = this.primitives;
              if (i >= prims.length)
                return H.ioore(prims, i);
              t4 = prims[i];
              if (t4 >= t3.length)
                return H.ioore(t3, t4);
              if (t3[t4].intersect$2(ray, isect))
                hit = true;
            }
          }
          if (todoPos > 0) {
            --todoPos;
            if (todoPos >= t1)
              return H.ioore(todo, todoPos);
            t2 = todo[todoPos];
            node = t2.get$node();
            nodeIndex = t2.nodeIndex;
            tmin[0] = t2.tmin;
            tmax[0] = t2.tmax;
          } else
            break;
        }
      }
      return hit;
    },
    intersectP$1: function(ray) {
      var tmin, tmax, t1, t2, t3, invDir, todo, node, todoPos, nodeIndex, firstChildIndex, secondChildIndex, axis, tplane, belowFirst, t4, firstChild, secondChild, prims, i;
      tmin = [0];
      tmax = [0];
      if (!this.bounds.intersectP$3(ray, tmin, tmax))
        return false;
      t1 = J.get$x$x(ray.direction);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.get$y$x(ray.direction);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = J.get$z$x(ray.direction);
      if (typeof t3 !== "number")
        return H.iae(t3);
      invDir = new G.Vector(1 / t1, 1 / t2, 1 / t3);
      todo = H.setRuntimeTypeInfo(Array(64), [E._KdToDo]);
      t3 = this.nodes;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      node = t3[0];
      for (t1 = todo.length, todoPos = 0, nodeIndex = 0, firstChildIndex = 0, secondChildIndex = 0; node != null;) {
        if (J.$lt$n(ray.maxDistance, tmin[0]))
          break;
        t2 = node.isLeaf$0();
        t3 = node.flags;
        if (!t2) {
          if (typeof t3 !== "number")
            return t3.$and();
          axis = t3 & 3;
          t2 = J.$sub$n(node.split, J.$index$asx(ray.origin, axis));
          if (axis === 0)
            t3 = invDir.x;
          else
            t3 = axis === 1 ? invDir.y : invDir.z;
          tplane = J.$mul$ns(t2, t3);
          if (!J.$lt$n(J.$index$asx(ray.origin, axis), node.split))
            belowFirst = J.$eq(J.$index$asx(ray.origin, axis), node.split) && J.$le$n(J.$index$asx(ray.direction, axis), 0);
          else
            belowFirst = true;
          t2 = node.flags;
          t3 = this.nodes;
          if (belowFirst) {
            if (typeof nodeIndex !== "number")
              return nodeIndex.$add();
            firstChildIndex = nodeIndex + 1;
            t4 = t3.length;
            if (firstChildIndex >= t4)
              return H.ioore(t3, firstChildIndex);
            firstChild = t3[firstChildIndex];
            if (typeof t2 !== "number")
              return t2.$shr();
            secondChildIndex = C.JSInt_methods._shrOtherPositive$1(t2, 2);
            if (secondChildIndex >= t4)
              return H.ioore(t3, secondChildIndex);
            secondChild = t3[secondChildIndex];
          } else {
            if (typeof t2 !== "number")
              return t2.$shr();
            firstChildIndex = C.JSInt_methods._shrOtherPositive$1(t2, 2);
            t2 = t3.length;
            if (firstChildIndex >= t2)
              return H.ioore(t3, firstChildIndex);
            firstChild = t3[firstChildIndex];
            if (typeof nodeIndex !== "number")
              return nodeIndex.$add();
            secondChildIndex = nodeIndex + 1;
            if (secondChildIndex >= t2)
              return H.ioore(t3, secondChildIndex);
            secondChild = t3[secondChildIndex];
          }
          t2 = J.getInterceptor$n(tplane);
          if (t2.$gt(tplane, tmax[0]) || t2.$le(tplane, 0)) {
            node = firstChild;
            nodeIndex = firstChildIndex;
          } else if (t2.$lt(tplane, tmin[0])) {
            node = secondChild;
            nodeIndex = secondChildIndex;
          } else {
            if (todoPos < 0 || todoPos >= t1)
              return H.ioore(todo, todoPos);
            t2 = todo[todoPos];
            if (t2 == null) {
              t2 = new E._KdToDo(null, null, null, null);
              todo[todoPos] = t2;
            }
            t2.set$node(secondChild);
            t2.nodeIndex = secondChildIndex;
            t2.tmin = tplane;
            t2.tmax = tmax[0];
            ++todoPos;
            tmax[0] = tplane;
            node = firstChild;
            nodeIndex = firstChildIndex;
          }
        } else {
          if (typeof t3 !== "number")
            return t3.$shr();
          t2 = C.JSInt_methods._shrOtherPositive$1(t3, 2);
          if (t2 === 1) {
            t2 = this.primitives;
            t3 = node.onePrimitive;
            if (t3 >>> 0 !== t3 || t3 >= t2.length)
              return H.ioore(t2, t3);
            if (t2[t3].intersectP$1(ray))
              return true;
          } else {
            prims = node.primitives;
            for (i = 0; i < t2; ++i) {
              t3 = this.primitives;
              if (i >= prims.length)
                return H.ioore(prims, i);
              t4 = prims[i];
              if (t4 >= t3.length)
                return H.ioore(t3, t4);
              if (t3[t4].intersectP$1(ray))
                return true;
            }
          }
          if (todoPos > 0) {
            --todoPos;
            if (todoPos >= t1)
              return H.ioore(todo, todoPos);
            t2 = todo[todoPos];
            node = t2.get$node();
            nodeIndex = t2.nodeIndex;
            tmin[0] = t2.tmin;
            tmax[0] = t2.tmax;
          } else
            break;
        }
      }
      return false;
    },
    _buildTree$11: function(nodeNum, nodeBounds, allPrimBounds, primNums, nPrimitives, depth, edges, prims0, prims1, prims1Offset, badRefines) {
      var t1, t2, nAlloc, n, i, t3, i0, t4, oldCost, invTotalSA, d, axis, t5, eb, t6, t7, bestAxis, bestOffset, bestCost, retries, t8, t9, t10, pn, bbox, t11, t12, t13, nAbove, nBelow, edget, otherAxis0, otherAxis1, t14, t15, t16, t17, eb0, cost, n0, n00, n1, n10, tsplit, aboveChild;
      t1 = this.nextFreeNode;
      t2 = this.nAllocedNodes;
      if (t1 === t2) {
        nAlloc = P.max(2 * t2, 512);
        n = H.setRuntimeTypeInfo(Array(nAlloc), [E._KdAccelNode]);
        i = this.nAllocedNodes;
        if (i > 0) {
          for (t1 = this.nodes, t2 = t1.length, t3 = n.length, i0 = 0; i0 < i; ++i0) {
            if (i0 >= t2)
              return H.ioore(t1, i0);
            t4 = t1[i0];
            if (i0 >= t3)
              return H.ioore(n, i0);
            n[i0] = t4;
          }
          for (; i < t3; ++i) {
            if (i >>> 0 !== i || i >= t3)
              return H.ioore(n, i);
            n[i] = new E._KdAccelNode(null, null, null, null);
          }
        } else
          for (t1 = n.length, i = 0; i < t1; ++i)
            n[i] = new E._KdAccelNode(null, null, null, null);
        this.nodes = n;
        this.nAllocedNodes = nAlloc;
      }
      ++this.nextFreeNode;
      t1 = this.maxPrims;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (nPrimitives <= t1 || J.$eq(depth, 0)) {
        t1 = this.nodes;
        if (nodeNum >= t1.length)
          return H.ioore(t1, nodeNum);
        t1[nodeNum].initLeaf$2(primNums, nPrimitives);
        return;
      }
      t1 = this.isectCost;
      t2 = J.getInterceptor$ns(t1);
      oldCost = t2.$mul(t1, nPrimitives);
      invTotalSA = 1 / nodeBounds.surfaceArea$0();
      d = nodeBounds.pMax.$sub(0, nodeBounds.pMin);
      axis = nodeBounds.maximumExtent$0();
      for (t3 = 2 * nPrimitives, t4 = this.traversalCost, t5 = J.getInterceptor$ns(t4), eb = this.emptyBonus, t6 = primNums.length, t7 = allPrimBounds.length, bestAxis = -1, bestOffset = -1, bestCost = 1 / 0, retries = 0; true;) {
        for (t8 = axis === 1, t9 = axis === 0, i = 0; t10 = edges[axis], i < nPrimitives; ++i) {
          if (i >= t6)
            return H.ioore(primNums, i);
          pn = primNums[i];
          if (pn >= t7)
            return H.ioore(allPrimBounds, pn);
          bbox = allPrimBounds[pn];
          if (axis < 0 || axis >= 3)
            return H.ioore(edges, axis);
          t11 = 2 * i;
          t12 = bbox.get$pMin();
          if (t9)
            t12 = t12.x;
          else
            t12 = t8 ? t12.y : t12.z;
          t13 = new E._BoundEdge(null, null, null);
          t13.t = t12;
          t13.primNum = pn;
          t13.type = 1;
          J.$indexSet$ax(t10, t11, t13);
          t10 = edges[axis];
          t12 = bbox.pMax;
          if (t9)
            t12 = t12.x;
          else
            t12 = t8 ? t12.y : t12.z;
          t13 = new E._BoundEdge(null, null, null);
          t13.t = t12;
          t13.primNum = pn;
          t13.type = 0;
          J.$indexSet$ax(t10, t11 + 1, t13);
        }
        if (axis < 0 || axis >= 3)
          return H.ioore(edges, axis);
        J.sort$1$ax(t10, new E.KdTreeAccel__buildTree_closure());
        for (t10 = axis + 1, t11 = axis + 2, nAbove = nPrimitives, nBelow = 0, i = 0; i < t3; ++i) {
          if (J.$eq(J.get$type$x(J.$index$asx(edges[axis], i)), 0))
            --nAbove;
          edget = J.$index$asx(edges[axis], i).get$t();
          t12 = nodeBounds.pMin;
          if (t9)
            t12 = t12.x;
          else
            t12 = t8 ? t12.y : t12.z;
          t13 = J.getInterceptor$n(edget);
          if (t13.$gt(edget, t12)) {
            t12 = nodeBounds.pMax;
            if (t9)
              t12 = t12.x;
            else
              t12 = t8 ? t12.y : t12.z;
            t12 = t13.$lt(edget, t12);
          } else
            t12 = false;
          if (t12) {
            otherAxis0 = C.JSInt_methods.$mod(t10, 3);
            otherAxis1 = C.JSInt_methods.$mod(t11, 3);
            t12 = otherAxis0 === 0;
            if (t12)
              t14 = d.x;
            else
              t14 = otherAxis0 === 1 ? d.y : d.z;
            t15 = otherAxis1 === 0;
            if (t15)
              t16 = d.x;
            else
              t16 = otherAxis1 === 1 ? d.y : d.z;
            t16 = J.$mul$ns(t14, t16);
            t14 = nodeBounds.pMin;
            if (t9)
              t14 = t14.x;
            else
              t14 = t8 ? t14.y : t14.z;
            t14 = t13.$sub(edget, t14);
            if (t12)
              t13 = d.x;
            else
              t13 = otherAxis0 === 1 ? d.y : d.z;
            if (t15)
              t17 = d.x;
            else
              t17 = otherAxis1 === 1 ? d.y : d.z;
            t17 = J.$add$ns(t16, J.$mul$ns(t14, J.$add$ns(t13, t17)));
            if (typeof t17 !== "number")
              return H.iae(t17);
            if (t12)
              t13 = d.x;
            else
              t13 = otherAxis0 === 1 ? d.y : d.z;
            if (t15)
              t14 = d.x;
            else
              t14 = otherAxis1 === 1 ? d.y : d.z;
            t14 = J.$mul$ns(t13, t14);
            t13 = nodeBounds.pMax;
            if (t9)
              t13 = t13.x;
            else
              t13 = t8 ? t13.y : t13.z;
            t13 = J.$sub$n(t13, edget);
            if (t12)
              t12 = d.x;
            else
              t12 = otherAxis0 === 1 ? d.y : d.z;
            if (t15)
              t15 = d.x;
            else
              t15 = otherAxis1 === 1 ? d.y : d.z;
            t15 = J.$add$ns(t14, J.$mul$ns(t13, J.$add$ns(t12, t15)));
            if (typeof t15 !== "number")
              return H.iae(t15);
            eb0 = nAbove === 0 || nBelow === 0 ? eb : 0;
            if (typeof eb0 !== "number")
              return H.iae(eb0);
            cost = t5.$add(t4, J.$mul$ns(t2.$mul(t1, 1 - eb0), 2 * t17 * invTotalSA * nBelow + 2 * t15 * invTotalSA * nAbove));
            if (J.$lt$n(cost, bestCost)) {
              bestCost = cost;
              bestOffset = i;
              bestAxis = axis;
            }
          }
          if (J.$eq(J.get$type$x(J.$index$asx(edges[axis], i)), 1))
            ++nBelow;
        }
        if (bestAxis === -1 && retries < 2) {
          ++retries;
          axis = C.JSInt_methods.$mod(t10, 3);
          continue;
        }
        break;
      }
      t1 = J.getInterceptor$n(bestCost);
      if (t1.$gt(bestCost, oldCost))
        ++badRefines;
      if (typeof oldCost !== "number")
        return H.iae(oldCost);
      if (t1.$gt(bestCost, 4 * oldCost) && nPrimitives < 16 || bestAxis === -1 || badRefines === 3) {
        t1 = this.nodes;
        if (nodeNum >= t1.length)
          return H.ioore(t1, nodeNum);
        t1[nodeNum].initLeaf$2(primNums, nPrimitives);
        return;
      }
      for (t1 = prims0.length, n0 = 0, i = 0; i < bestOffset; ++i) {
        if (bestAxis < 0 || bestAxis >= 3)
          return H.ioore(edges, bestAxis);
        if (J.$eq(J.get$type$x(J.$index$asx(edges[bestAxis], i)), 1)) {
          n00 = n0 + 1;
          t2 = J.$index$asx(edges[bestAxis], i).get$primNum();
          if (n0 >= t1)
            return H.ioore(prims0, n0);
          prims0[n0] = t2;
          n0 = n00;
        }
      }
      for (i = bestOffset + 1, t1 = prims1.length, n1 = 0; i < t3; ++i) {
        if (bestAxis < 0 || bestAxis >= 3)
          return H.ioore(edges, bestAxis);
        if (J.$eq(J.get$type$x(J.$index$asx(edges[bestAxis], i)), 0)) {
          n10 = n1 + 1;
          t2 = prims1Offset + n1;
          t4 = J.$index$asx(edges[bestAxis], i).get$primNum();
          if (t2 >= t1)
            return H.ioore(prims1, t2);
          prims1[t2] = t4;
          n1 = n10;
        }
      }
      if (bestAxis < 0 || bestAxis >= 3)
        return H.ioore(edges, bestAxis);
      tsplit = J.$index$asx(edges[bestAxis], bestOffset).get$t();
      t1 = nodeBounds.pMax;
      nodeBounds.pMin.$indexSet(0, bestAxis, tsplit);
      t1.$indexSet(0, bestAxis, tsplit);
      t1 = J.getInterceptor$n(depth);
      this._buildTree$11(nodeNum + 1, nodeBounds, allPrimBounds, prims0, n0, t1.$sub(depth, 1), edges, prims0, prims1, nPrimitives, badRefines);
      aboveChild = this.nextFreeNode;
      t2 = this.nodes;
      if (nodeNum >= t2.length)
        return H.ioore(t2, nodeNum);
      t2[nodeNum].initInterior$3(bestAxis, aboveChild, tsplit);
      this._buildTree$11(aboveChild, nodeBounds, allPrimBounds, prims1, n1, t1.$sub(depth, 1), edges, prims0, prims1, nPrimitives, badRefines);
    },
    _buildTree$10: function(nodeNum, nodeBounds, allPrimBounds, primNums, nPrimitives, depth, edges, prims0, prims1, prims1Offset) {
      return this._buildTree$11(nodeNum, nodeBounds, allPrimBounds, primNums, nPrimitives, depth, edges, prims0, prims1, prims1Offset, 0);
    },
    KdTreeAccel$6: function(p, isectCost, traversalCost, emptyBonus, maxPrims, maxDepth) {
      var t1, i, t2, primBounds, b, t3, t4, t5, edges, len, j, prims0, prims1, primNums;
      $.Log.call$2(0, "Building Kd-Tree Acceleration Structures.");
      t1 = J.getInterceptor$asx(p);
      i = 0;
      while (true) {
        t2 = t1.get$length(p);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        t1.$index(p, i).fullyRefine$1(this.primitives);
        ++i;
      }
      this.nextFreeNode = 0;
      this.nAllocedNodes = 0;
      if (J.$le$n(this.maxDepth, 0)) {
        t1 = this.primitives.length;
        t1 = Math.log(t1);
        t2 = $.get$_invLog2();
        if (typeof t2 !== "number")
          return H.iae(t2);
        this.maxDepth = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(8 + 1.3 * C.JSDouble_methods.toInt$0(t1 * t2)));
      }
      this.bounds = G.BBox$(null, null);
      primBounds = H.setRuntimeTypeInfo(Array(this.primitives.length), [G.BBox]);
      for (t1 = primBounds.length, i = 0; t2 = this.primitives, i < t2.length; ++i) {
        b = t2[i].worldBound$0();
        t2 = this.bounds;
        t3 = t2.pMin;
        t4 = t3.x;
        t5 = t3.y;
        t3 = t3.z;
        t2 = t2.pMax;
        this.bounds = new G.BBox(new G.Point(t4, t5, t3), new G.Point(t2.x, t2.y, t2.z)).union$1(b);
        if (i >= t1)
          return H.ioore(primBounds, i);
        primBounds[i] = b;
      }
      edges = H.setRuntimeTypeInfo(Array(3), [[J.JSArray, E._BoundEdge]]);
      for (i = 0; t1 = this.primitives, i < 3; ++i) {
        len = 2 * t1.length;
        t1 = Array(len);
        t1.fixed$length = init;
        t1.$builtinTypeInfo = [E._BoundEdge];
        edges[i] = t1;
        for (j = 0; j < len; ++j) {
          t1 = edges[i];
          t2 = new E._BoundEdge(null, null, null);
          t2.t = 0;
          t2.primNum = 0;
          t2.type = 0;
          J.$indexSet$ax(t1, j, t2);
        }
      }
      t1 = t1.length;
      prims0 = new Uint32Array(t1);
      t1 = J.$mul$ns(J.$add$ns(this.maxDepth, 1), this.primitives.length);
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      prims1 = new Uint32Array(t1);
      t1 = this.primitives.length;
      primNums = new Uint32Array(t1);
      for (t2 = this.primitives.length, i = 0; i < t2; ++i) {
        if (i >= t1)
          return H.ioore(primNums, i);
        primNums[i] = i;
      }
      this._buildTree$10(0, this.bounds, primBounds, primNums, t2, this.maxDepth, edges, prims0, prims1, 0);
    },
    static: {KdTreeAccel_Create: [function(prims, ps) {
        return E.KdTreeAccel$(prims, ps.findOneInt$2("intersectcost", 80), ps.findOneInt$2("traversalcost", 1), ps.findOneFloat$2("emptybonus", 0.5), ps.findOneInt$2("maxprims", 1), ps.findOneInt$2("maxdepth", -1));
      }, "call$2", "KdTreeAccel_Create$closure", 4, 0, 4], KdTreeAccel$: function(p, isectCost, traversalCost, emptyBonus, maxPrims, maxDepth) {
        var t1 = $.Primitive__nextprimitiveId;
        $.Primitive__nextprimitiveId = t1 + 1;
        t1 = new E.KdTreeAccel(isectCost, traversalCost, maxPrims, maxDepth, emptyBonus, [], [], null, null, null, t1);
        t1.KdTreeAccel$6(p, isectCost, traversalCost, emptyBonus, maxPrims, maxDepth);
        return t1;
      }}
  },
  KdTreeAccel__buildTree_closure: {
    "^": "Closure:87;",
    call$2: function(a, b) {
      return J.$lt$n(a, b) ? -1 : 1;
    }
  },
  _KdToDo: {
    "^": "Object;node@,nodeIndex,tmin,tmax"
  },
  _KdAccelNode: {
    "^": "Object;split,onePrimitive,primitives,flags",
    initLeaf$2: function(primNums, np) {
      var t1, t2, i, t3;
      this.flags = 3;
      this.flags = (3 | np << 2) >>> 0;
      if (np === 0)
        this.onePrimitive = 0;
      else if (np === 1) {
        if (0 >= primNums.length)
          return H.ioore(primNums, 0);
        this.onePrimitive = primNums[0];
      } else {
        t1 = new Uint32Array(np);
        this.primitives = t1;
        for (t2 = primNums.length, i = 0; i < np; ++i) {
          if (i >= t2)
            return H.ioore(primNums, i);
          t3 = primNums[i];
          if (i >= np)
            return H.ioore(t1, i);
          t1[i] = t3;
        }
      }
    },
    initInterior$3: function(axis, ac, s) {
      this.split = s;
      this.flags = axis;
      this.flags = (axis | ac << 2) >>> 0;
    },
    splitPos$0: [function() {
      return this.split;
    }, "call$0", "get$splitPos", 0, 0, 93],
    nPrimitives$0: [function() {
      var t1 = this.flags;
      if (typeof t1 !== "number")
        return t1.$shr();
      return C.JSInt_methods._shrOtherPositive$1(t1, 2);
    }, "call$0", "get$nPrimitives", 0, 0, 92],
    splitAxis$0: [function() {
      var t1 = this.flags;
      if (typeof t1 !== "number")
        return t1.$and();
      return t1 & 3;
    }, "call$0", "get$splitAxis", 0, 0, 92],
    isLeaf$0: function() {
      var t1 = this.flags;
      if (typeof t1 !== "number")
        return t1.$and();
      return (t1 & 3) === 3;
    }
  },
  _BoundEdge: {
    "^": "Object;t<,primNum<,type>",
    $lt: function(_, e) {
      if (J.$eq(this.t, e.get$t()))
        return this.type < e.get$type(e);
      else
        return J.$lt$n(this.t, e.get$t());
    },
    static: {"^": "_BoundEdge_START,_BoundEdge_END"}
  }
}],
["archive", "package:archive/archive.dart", , T, {
  "^": "",
  getAdler32: function(array, adler) {
    var s1, s2, len, len0, i, n, i0;
    s1 = adler & 65535;
    s2 = adler >>> 16;
    len = array.length;
    for (len0 = len, i = 0; len0 > 0;) {
      n = 3800 > len0 ? len0 : 3800;
      len0 -= n;
      for (; --n, n >= 0; i = i0) {
        i0 = i + 1;
        if (i < 0 || i >= len)
          return H.ioore(array, i);
        s1 += array[i] & 255;
        s2 += s1;
      }
      s1 = C.JSInt_methods.$mod(s1, 65521);
      s2 = C.JSInt_methods.$mod(s2, 65521);
    }
    return (s2 << 16 | s1) >>> 0;
  },
  getCrc32: function(array, crc) {
    var t1, len, ip, ip0, t2;
    t1 = J.getInterceptor$asx(array);
    len = t1.get$length(array);
    crc ^= 4294967295;
    for (ip = 0; len >= 8;) {
      ip0 = ip + 1;
      t2 = C.List_B8J[(crc ^ t1.$index(array, ip)) & 255];
      if (typeof t2 !== "number")
        return t2.$xor();
      crc = t2 ^ crc >>> 8;
      ip = ip0 + 1;
      t2 = C.List_B8J[(crc ^ t1.$index(array, ip0)) & 255];
      if (typeof t2 !== "number")
        return t2.$xor();
      crc = t2 ^ crc >>> 8;
      ip0 = ip + 1;
      t2 = C.List_B8J[(crc ^ t1.$index(array, ip)) & 255];
      if (typeof t2 !== "number")
        return t2.$xor();
      crc = t2 ^ crc >>> 8;
      ip = ip0 + 1;
      t2 = C.List_B8J[(crc ^ t1.$index(array, ip0)) & 255];
      if (typeof t2 !== "number")
        return t2.$xor();
      crc = t2 ^ crc >>> 8;
      ip0 = ip + 1;
      t2 = C.List_B8J[(crc ^ t1.$index(array, ip)) & 255];
      if (typeof t2 !== "number")
        return t2.$xor();
      crc = t2 ^ crc >>> 8;
      ip = ip0 + 1;
      t2 = C.List_B8J[(crc ^ t1.$index(array, ip0)) & 255];
      if (typeof t2 !== "number")
        return t2.$xor();
      crc = t2 ^ crc >>> 8;
      ip0 = ip + 1;
      t2 = C.List_B8J[(crc ^ t1.$index(array, ip)) & 255];
      if (typeof t2 !== "number")
        return t2.$xor();
      crc = t2 ^ crc >>> 8;
      ip = ip0 + 1;
      t2 = C.List_B8J[(crc ^ t1.$index(array, ip0)) & 255];
      if (typeof t2 !== "number")
        return t2.$xor();
      crc = t2 ^ crc >>> 8;
      len -= 8;
    }
    if (len > 0)
      do {
        ip0 = ip + 1;
        t2 = C.List_B8J[(crc ^ t1.$index(array, ip)) & 255];
        if (typeof t2 !== "number")
          return t2.$xor();
        crc = t2 ^ crc >>> 8;
        if (--len, len > 0) {
          ip = ip0;
          continue;
        } else
          break;
      } while (true);
    return (crc ^ 4294967295) >>> 0;
  },
  ArchiveException: {
    "^": "Object;message",
    toString$0: function(_) {
      return "ArchiveException: " + this.message;
    },
    static: {ArchiveException$: function(message) {
        return new T.ArchiveException(message);
      }}
  },
  InputStream: {
    "^": "Object;buffer>,offset*,start>,byteOrder,_archive$_length",
    get$length: function(_) {
      var t1, t2, t3;
      t1 = this._archive$_length;
      t2 = this.offset;
      t3 = this.start;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (typeof t1 !== "number")
        return t1.$sub();
      return t1 - (t2 - t3);
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    $index: function(_, index) {
      var t1, t2;
      t1 = this.buffer;
      t2 = this.offset;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof index !== "number")
        return H.iae(index);
      t2 += index;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    subset$2: function(position, $length) {
      var t1 = this.start;
      if (typeof t1 !== "number")
        return H.iae(t1);
      position += t1;
      return T.InputStream$(this.buffer, this.byteOrder, $length, position);
    },
    skip$1: function(_, count) {
      var t1 = this.offset;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof count !== "number")
        return H.iae(count);
      this.offset = t1 + count;
    },
    readUint32$0: function() {
      var t1, t2, b1, b2, b3, b4;
      t1 = this.buffer;
      t2 = this.offset;
      if (typeof t2 !== "number")
        return t2.$add();
      this.offset = t2 + 1;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      b1 = J.$and$n(t1[t2], 255);
      t2 = this.offset;
      if (typeof t2 !== "number")
        return t2.$add();
      this.offset = t2 + 1;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      b2 = J.$and$n(t1[t2], 255);
      t2 = this.offset;
      if (typeof t2 !== "number")
        return t2.$add();
      this.offset = t2 + 1;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      b3 = J.$and$n(t1[t2], 255);
      t2 = this.offset;
      if (typeof t2 !== "number")
        return t2.$add();
      this.offset = t2 + 1;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      b4 = J.$and$n(t1[t2], 255);
      if (this.byteOrder === 1)
        return (b1 << 24 | b2 << 16 | b3 << 8 | b4) >>> 0;
      return (b4 << 24 | b3 << 16 | b2 << 8 | b1) >>> 0;
    },
    InputStream$4$byteOrder$length$start: function(buffer, byteOrder, $length, start) {
      this._archive$_length = $length == null ? buffer.length : $length;
      this.offset = start;
    },
    static: {InputStream$: function(buffer, byteOrder, $length, start) {
        var t1 = new T.InputStream(buffer, null, start, byteOrder, null);
        t1.InputStream$4$byteOrder$length$start(buffer, byteOrder, $length, start);
        return t1;
      }}
  },
  OutputStream: {
    "^": "Object;length*,byteOrder,_archive$_buffer",
    length$0: function($receiver) {
      return this.length.call$0();
    },
    getBytes$0: function() {
      return H.NativeUint8List_NativeUint8List$view(this._archive$_buffer.buffer, 0, this.length);
    },
    writeBytes$2: function(bytes, len) {
      var t1, t2;
      len = bytes.length;
      for (; t1 = J.$gt$n(J.$add$ns(this.length, len), this._archive$_buffer.length), t2 = this.length, t1;)
        this._archive$_expandBuffer$1(J.$sub$n(J.$add$ns(t2, len), this._archive$_buffer.length));
      C.NativeUint8List_methods.setRange$3(this._archive$_buffer, t2, J.$add$ns(t2, len), bytes);
      this.length = J.$add$ns(this.length, len);
    },
    writeBytes$1: function(bytes) {
      return this.writeBytes$2(bytes, null);
    },
    writeInputStream$1: function(bytes) {
      var t1, t2, t3, t4, t5;
      t1 = bytes.start;
      while (true) {
        t2 = this.length;
        t3 = bytes._archive$_length;
        t4 = bytes.offset;
        if (typeof t4 !== "number")
          return t4.$sub();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (typeof t3 !== "number")
          return t3.$sub();
        t4 = J.$gt$n(J.$add$ns(t2, t3 - (t4 - t1)), this._archive$_buffer.length);
        t3 = bytes._archive$_length;
        t2 = this.length;
        t5 = bytes.offset;
        if (!t4)
          break;
        if (typeof t5 !== "number")
          return t5.$sub();
        if (typeof t3 !== "number")
          return t3.$sub();
        this._archive$_expandBuffer$1(J.$sub$n(J.$add$ns(t2, t3 - (t5 - t1)), this._archive$_buffer.length));
      }
      t4 = this._archive$_buffer;
      if (typeof t5 !== "number")
        return t5.$sub();
      if (typeof t3 !== "number")
        return t3.$sub();
      C.NativeUint8List_methods.setRange$4(t4, t2, J.$add$ns(t2, t3 - (t5 - t1)), bytes.buffer, bytes.offset);
      t5 = this.length;
      t3 = bytes._archive$_length;
      t2 = bytes.offset;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t3 !== "number")
        return t3.$sub();
      this.length = J.$add$ns(t5, t3 - (t2 - t1));
    },
    subset$2: function(start, end) {
      if (J.$lt$n(start, 0))
        start = J.$add$ns(this.length, start);
      if (end == null)
        end = this.length;
      else if (J.$lt$n(end, 0))
        end = J.$add$ns(this.length, end);
      return H.NativeUint8List_NativeUint8List$view(this._archive$_buffer.buffer, start, J.$sub$n(end, start));
    },
    subset$1: function(start) {
      return this.subset$2(start, null);
    },
    _archive$_expandBuffer$1: function(required) {
      var blockSize, t1, newBuffer;
      blockSize = required != null ? J.$gt$n(required, 32768) ? required : 32768 : 32768;
      t1 = this._archive$_buffer;
      if (typeof blockSize !== "number")
        return H.iae(blockSize);
      t1 = t1.length + blockSize;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      newBuffer = new Uint8Array(t1);
      t1 = this._archive$_buffer;
      C.NativeUint8List_methods.setRange$3(newBuffer, 0, t1.length, t1);
      this._archive$_buffer = newBuffer;
    },
    _archive$_expandBuffer$0: function() {
      return this._archive$_expandBuffer$1(null);
    },
    static: {"^": "OutputStream__BLOCK_SIZE", OutputStream$: function(byteOrder, size) {
        return new T.OutputStream(0, byteOrder, new Uint8Array(32768));
      }}
  },
  HuffmanTable: {
    "^": "Object;table,maxCodeLength,minCodeLength",
    HuffmanTable$1: function(lengths) {
      var listSize, i, t1, size, bitLength, code, skip, rtemp, reversed, j, t2, t3;
      listSize = lengths.length;
      for (i = 0; i < listSize; ++i) {
        if (i >= lengths.length)
          return H.ioore(lengths, i);
        if (J.$gt$n(lengths[i], this.maxCodeLength)) {
          if (i >= lengths.length)
            return H.ioore(lengths, i);
          this.maxCodeLength = lengths[i];
        }
        if (i >= lengths.length)
          return H.ioore(lengths, i);
        if (J.$lt$n(lengths[i], this.minCodeLength)) {
          if (i >= lengths.length)
            return H.ioore(lengths, i);
          this.minCodeLength = lengths[i];
        }
      }
      t1 = this.maxCodeLength;
      if (typeof t1 !== "number")
        return H.iae(t1);
      size = C.JSInt_methods.$shl(1, t1);
      this.table = new Uint32Array(size);
      bitLength = 1;
      code = 0;
      skip = 2;
      while (true) {
        t1 = this.maxCodeLength;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(bitLength <= t1))
          break;
        for (t1 = bitLength << 16, i = 0; i < listSize; ++i) {
          if (i >= lengths.length)
            return H.ioore(lengths, i);
          if (J.$eq(lengths[i], bitLength)) {
            for (rtemp = code, reversed = 0, j = 0; j < bitLength; ++j) {
              reversed = (reversed << 1 | rtemp & 1) >>> 0;
              rtemp = rtemp >>> 1;
            }
            for (t2 = this.table, t3 = (t1 | i) >>> 0, j = reversed; j < size; j += skip) {
              if (j < 0 || j >= t2.length)
                return H.ioore(t2, j);
              t2[j] = t3;
            }
            ++code;
          }
        }
        ++bitLength;
        code = code << 1 >>> 0;
        skip = skip << 1 >>> 0;
      }
    },
    static: {HuffmanTable$: function(lengths) {
        var t1 = new T.HuffmanTable(null, 0, 2147483647);
        t1.HuffmanTable$1(lengths);
        return t1;
      }}
  },
  Inflate: {
    "^": "Object;input,output,_bitBuffer,_bitBufferLen,_blockPos,_fixedLiteralLengthTable,_fixedDistanceTable",
    getBytes$0: function() {
      var t1 = this.output;
      return H.NativeUint8List_NativeUint8List$view(t1._archive$_buffer.buffer, 0, t1.length);
    },
    _inflate$0: function() {
      this._bitBuffer = 0;
      this._bitBufferLen = 0;
      var t1 = this.output;
      t1._archive$_buffer = new Uint8Array(32768);
      t1.length = 0;
      for (; this._parseBlock$0();)
        ;
    },
    _parseBlock$0: function() {
      var t1, t2, t3, hdr, btype, len, t4, bytes, t5;
      t1 = this.input;
      t2 = t1.offset;
      t3 = t1.start;
      t1 = t1._archive$_length;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (typeof t2 !== "number")
        return t2.$ge();
      if (t2 >= t3 + t1)
        return false;
      hdr = this._readBits$1(3);
      btype = hdr >>> 1;
      switch (btype) {
        case 0:
          this._bitBuffer = 0;
          this._bitBufferLen = 0;
          len = this._readBits$1(16);
          if (len === ~this._readBits$1(16) >>> 0)
            H.throwExpression(T.ArchiveException$("Invalid uncompressed block header"));
          t1 = this.input;
          t2 = t1._archive$_length;
          t3 = t1.offset;
          t4 = t1.start;
          if (typeof t3 !== "number")
            return t3.$sub();
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = t3 - t4;
          if (typeof t2 !== "number")
            return t2.$sub();
          if (len > t2 - t4)
            H.throwExpression(T.ArchiveException$("Input buffer is broken"));
          bytes = t1.subset$2(t4, len);
          t2 = t1.offset;
          t3 = bytes._archive$_length;
          t4 = bytes.offset;
          t5 = bytes.start;
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (typeof t3 !== "number")
            return t3.$sub();
          if (typeof t2 !== "number")
            return t2.$add();
          t1.offset = t2 + (t3 - (t4 - t5));
          this.output.writeInputStream$1(bytes);
          break;
        case 1:
          this._decodeHuffman$2(this._fixedLiteralLengthTable, this._fixedDistanceTable);
          break;
        case 2:
          this._parseDynamicHuffmanBlock$0();
          break;
        default:
          throw H.wrapException(T.ArchiveException$("unknown BTYPE: " + btype));
      }
      return (hdr & 1) === 0;
    },
    _readBits$1: function($length) {
      var t1, t2, t3, t4, t5, octet;
      if (J.$eq($length, 0))
        return 0;
      if (typeof $length !== "number")
        return H.iae($length);
      for (; t1 = this._bitBufferLen, t1 < $length;) {
        t2 = this.input;
        t3 = t2.offset;
        t4 = t2.start;
        t5 = t2._archive$_length;
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof t3 !== "number")
          return t3.$ge();
        if (t3 >= t4 + t5)
          throw H.wrapException(T.ArchiveException$("input buffer is broken"));
        t4 = t2.buffer;
        t2.offset = t3 + 1;
        if (t3 >>> 0 !== t3 || t3 >= t4.length)
          return H.ioore(t4, t3);
        octet = t4[t3];
        t3 = this._bitBuffer;
        if (typeof octet !== "number")
          return octet.$shl();
        this._bitBuffer = (t3 | C.JSNumber_methods.$shl(octet, t1)) >>> 0;
        this._bitBufferLen = t1 + 8;
      }
      t2 = this._bitBuffer;
      t3 = C.JSInt_methods.$shl(1, $length);
      this._bitBuffer = C.JSInt_methods._shrReceiverPositive$1(t2, $length);
      this._bitBufferLen = t1 - $length;
      return (t2 & t3 - 1) >>> 0;
    },
    _readCodeByTable$1: function(table) {
      var codeTable, maxCodeLength, t1, t2, t3, t4, t5, octet, codeWithLength, codeLength;
      codeTable = table.table;
      maxCodeLength = table.maxCodeLength;
      if (typeof maxCodeLength !== "number")
        return H.iae(maxCodeLength);
      for (; t1 = this._bitBufferLen, t1 < maxCodeLength;) {
        t2 = this.input;
        t3 = t2.offset;
        t4 = t2.start;
        t5 = t2._archive$_length;
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof t3 !== "number")
          return t3.$ge();
        if (t3 >= t4 + t5)
          break;
        t4 = t2.buffer;
        t2.offset = t3 + 1;
        if (t3 >>> 0 !== t3 || t3 >= t4.length)
          return H.ioore(t4, t3);
        octet = t4[t3];
        t3 = this._bitBuffer;
        if (typeof octet !== "number")
          return octet.$shl();
        this._bitBuffer = (t3 | C.JSNumber_methods.$shl(octet, t1)) >>> 0;
        this._bitBufferLen = t1 + 8;
      }
      t2 = this._bitBuffer;
      t3 = (t2 & C.JSInt_methods.$shl(1, maxCodeLength) - 1) >>> 0;
      if (t3 >= codeTable.length)
        return H.ioore(codeTable, t3);
      codeWithLength = codeTable[t3];
      codeLength = codeWithLength >>> 16;
      this._bitBuffer = C.JSInt_methods._shrBothPositive$1(t2, codeLength);
      this._bitBufferLen = t1 - codeLength;
      return codeWithLength & 65535;
    },
    _parseDynamicHuffmanBlock$0: function() {
      var numLitLengthCodes, numDistanceCodes, numCodeLengths, codeLengths, i, t1, t2, codeLengthsTable, litlenLengths, distLengths, litlen, dist;
      numLitLengthCodes = this._readBits$1(5) + 257;
      numDistanceCodes = this._readBits$1(5) + 1;
      numCodeLengths = this._readBits$1(4) + 4;
      codeLengths = new Uint8Array(19);
      for (i = 0; i < numCodeLengths; ++i) {
        if (i >= 19)
          return H.ioore(C.List_uSC, i);
        t1 = C.List_uSC[i];
        t2 = this._readBits$1(3);
        if (t1 >>> 0 !== t1 || t1 >= 19)
          return H.ioore(codeLengths, t1);
        codeLengths[t1] = t2;
      }
      codeLengthsTable = T.HuffmanTable$(codeLengths);
      litlenLengths = new Uint8Array(numLitLengthCodes);
      distLengths = new Uint8Array(numDistanceCodes);
      litlen = this._decode$3(numLitLengthCodes, codeLengthsTable, litlenLengths);
      dist = this._decode$3(numDistanceCodes, codeLengthsTable, distLengths);
      this._decodeHuffman$2(T.HuffmanTable$(litlen), T.HuffmanTable$(dist));
    },
    _decodeHuffman$2: function(litlen, dist) {
      var code, t1, t2, t3, ti, codeLength, distCode, distance;
      for (; true;) {
        code = this._readCodeByTable$1(litlen);
        if (code > 285)
          throw H.wrapException(T.ArchiveException$("Invalid Huffman Code " + code));
        if (code === 256)
          break;
        if (code < 256) {
          t1 = this.output;
          if (J.$eq(t1.length, t1._archive$_buffer.length))
            t1._archive$_expandBuffer$0();
          t2 = t1._archive$_buffer;
          t3 = t1.length;
          t1.length = J.$add$ns(t3, 1);
          if (t3 >>> 0 !== t3 || t3 >= t2.length)
            return H.ioore(t2, t3);
          t2[t3] = code & 255 & 255;
          continue;
        }
        ti = code - 257;
        if (ti < 0 || ti >= 29)
          return H.ioore(C.List_qQn, ti);
        codeLength = J.$add$ns(C.List_qQn[ti], this._readBits$1(C.List_eea[ti]));
        distCode = this._readCodeByTable$1(dist);
        if (distCode <= 29) {
          if (distCode >= 30)
            return H.ioore(C.List_i3t, distCode);
          distance = J.$add$ns(C.List_i3t[distCode], this._readBits$1(C.List_X3d0[distCode]));
          for (t1 = this.output, t2 = J.getInterceptor$n(distance); t3 = J.getInterceptor$n(codeLength), t3.$gt(codeLength, distance);) {
            t1.writeBytes$1(t1.subset$1(t2.$negate(distance)));
            codeLength = t3.$sub(codeLength, distance);
          }
          if (t3.$eq(codeLength, distance))
            t1.writeBytes$1(t1.subset$1(t2.$negate(distance)));
          else
            t1.writeBytes$1(t1.subset$2(t2.$negate(distance), t3.$sub(codeLength, distance)));
        } else
          throw H.wrapException(T.ArchiveException$("Illegal unused distance symbol"));
      }
      for (; t1 = this._bitBufferLen, t1 >= 8;) {
        this._bitBufferLen = t1 - 8;
        t1 = this.input;
        t2 = t1.offset;
        if (typeof t2 !== "number")
          return t2.$sub();
        t1.offset = t2 - 1;
      }
    },
    _decode$3: function(num, table, lengths) {
      var t1, prev, i, code, repeat, repeat0, i0;
      for (t1 = lengths.length, prev = 0, i = 0; i < num;) {
        code = this._readCodeByTable$1(table);
        switch (code) {
          case 16:
            repeat = 3 + this._readBits$1(2);
            for (; repeat0 = repeat - 1, repeat > 0; repeat = repeat0, i = i0) {
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(lengths, i);
              lengths[i] = prev;
            }
            break;
          case 17:
            repeat = 3 + this._readBits$1(3);
            for (; repeat0 = repeat - 1, repeat > 0; repeat = repeat0, i = i0) {
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(lengths, i);
              lengths[i] = 0;
            }
            prev = 0;
            break;
          case 18:
            repeat = 11 + this._readBits$1(7);
            for (; repeat0 = repeat - 1, repeat > 0; repeat = repeat0, i = i0) {
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(lengths, i);
              lengths[i] = 0;
            }
            prev = 0;
            break;
          default:
            if (code > 15)
              throw H.wrapException(T.ArchiveException$("Invalid Huffman Code: " + code));
            i0 = i + 1;
            if (i < 0 || i >= t1)
              return H.ioore(lengths, i);
            lengths[i] = code;
            i = i0;
            prev = code;
            break;
        }
      }
      return lengths;
    },
    Inflate$2: function(bytes, uncompressedSize) {
      this._inflate$0();
    },
    static: {"^": "Inflate__BLOCK_UNCOMPRESSED,Inflate__BLOCK_FIXED_HUFFMAN,Inflate__BLOCK_DYNAMIC_HUFFMAN,Inflate__FIXED_LITERAL_LENGTHS,Inflate__FIXED_DISTANCE_TABLE,Inflate__MAX_BACKWARD_LENGTH,Inflate__MAX_COPY_LENGTH,Inflate__ORDER,Inflate__LENGTH_CODE_TABLE,Inflate__LENGTH_EXTRA_TABLE,Inflate__DIST_CODE_TABLE,Inflate__DIST_EXTRA_TABLE", Inflate$: function(bytes, uncompressedSize) {
        var t1, t2;
        t1 = T.HuffmanTable$(C.List_2Bc);
        t2 = T.HuffmanTable$(C.List_X3d);
        t2 = new T.Inflate(T.InputStream$(bytes, 0, null, 0), T.OutputStream$(0, uncompressedSize), 0, 0, 0, t1, t2);
        t2.Inflate$2(bytes, uncompressedSize);
        return t2;
      }}
  },
  ZLibDecoder: {
    "^": "Object;",
    decodeBuffer$2$verify: function(input, verify) {
      var t1, t2, t3, t4, cmf, flg, method, buffer, adler32;
      t1 = input.buffer;
      t2 = input.offset;
      if (typeof t2 !== "number")
        return t2.$add();
      t3 = t2 + 1;
      input.offset = t3;
      t4 = t1.length;
      if (t2 >>> 0 !== t2 || t2 >= t4)
        return H.ioore(t1, t2);
      cmf = t1[t2];
      input.offset = t3 + 1;
      if (t3 >>> 0 !== t3 || t3 >= t4)
        return H.ioore(t1, t3);
      flg = t1[t3];
      method = J.getInterceptor$n(cmf).$and(cmf, 8);
      if (typeof cmf !== "number")
        return cmf.$shr();
      C.JSNumber_methods._shrOtherPositive$1(cmf, 3);
      if (method !== 8)
        throw H.wrapException(T.ArchiveException$("Only DEFLATE compression supported: " + method));
      t1 = J.getInterceptor$n(flg);
      t1.$and(flg, 16);
      t2 = t1.$and(flg, 32);
      t1.$and(flg, 64);
      if (typeof flg !== "number")
        return H.iae(flg);
      if (C.JSNumber_methods.$mod((cmf << 8 >>> 0) + flg, 31) !== 0)
        throw H.wrapException(T.ArchiveException$("Invalid FCHECK"));
      if (t2 >>> 5 !== 0) {
        input.readUint32$0();
        throw H.wrapException(T.ArchiveException$("FDICT Encoding not currently supported"));
      }
      t1 = T.HuffmanTable$(C.List_2Bc);
      t2 = T.HuffmanTable$(C.List_X3d);
      t3 = T.OutputStream$(0, null);
      new T.Inflate(input, t3, 0, 0, 0, t1, t2)._inflate$0();
      buffer = H.NativeUint8List_NativeUint8List$view(t3._archive$_buffer.buffer, 0, t3.length);
      adler32 = input.readUint32$0();
      if (verify)
        if (adler32 !== T.getAdler32(buffer, 1))
          throw H.wrapException(T.ArchiveException$("Invalid adler-32 checksum"));
      return buffer;
    },
    static: {"^": "ZLibDecoder_DEFLATE"}
  }
}],
["cameras", "package:dartray/cameras/cameras.dart", , K, {
  "^": "",
  EnvironmentCamera: {
    "^": "Camera;cameraToWorld,shutterOpen,shutterClose,film",
    generateRay$2: function(sample, ray) {
      var t1, t2, t3, theta, phi, t4;
      t1 = sample.get$imageY();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.film;
      t3 = t2.yResolution;
      if (typeof t3 !== "number")
        return H.iae(t3);
      theta = 3.141592653589793 * t1 / t3;
      t3 = sample.imageX;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t2 = t2.xResolution;
      if (typeof t2 !== "number")
        return H.iae(t2);
      phi = 6.283185307179586 * t3 / t2;
      t1 = Math.sin(theta);
      t2 = Math.cos(phi);
      t3 = Math.cos(theta);
      t4 = Math.sin(theta);
      ray.set$5(new G.Point(0, 0, 0), new G.Vector(t1 * t2, t3, t4 * Math.sin(phi)), 0, 1 / 0, sample.time);
      this.cameraToWorld.transformRay$2(ray, ray);
      return 1;
    },
    static: {EnvironmentCamera_Create: [function(params, cam2world, film) {
        var shutteropen, shutterclose, t1, t0, frame, sw, $screen;
        shutteropen = params.findOneFloat$2("shutteropen", 0);
        shutterclose = params.findOneFloat$2("shutterclose", 1);
        if (J.$lt$n(shutterclose, shutteropen)) {
          t1 = "Shutter close time [" + H.S(shutterclose) + "] < shutter open [" + H.S(shutteropen) + "]. Swapping them.";
          $.Log.call$2(1, t1);
          t0 = shutterclose;
          shutterclose = shutteropen;
          shutteropen = t0;
        }
        frame = params.findOneFloat$2("frameaspectratio", J.$div$n(film.get$xResolution(), film.yResolution));
        sw = params.findFloat$1("screenwindow");
        if (sw != null && J.$eq(J.get$length$asx(sw), 4))
          ;
        else {
          $screen = [0, 0, 0, 0];
          if (J.$gt$n(frame, 1)) {
            if (typeof frame !== "number")
              return frame.$negate();
            $screen[0] = -frame;
            $screen[1] = frame;
            $screen[2] = -1;
            $screen[3] = 1;
          } else {
            $screen[0] = -1;
            $screen[1] = 1;
            if (typeof frame !== "number")
              return H.iae(frame);
            $screen[2] = -1 / frame;
            $screen[3] = 1 / frame;
          }
        }
        return new K.EnvironmentCamera(cam2world, shutteropen, shutterclose, film);
      }, "call$3", "EnvironmentCamera_Create$closure", 6, 0, 5]}
  },
  OrthographicCamera: {
    "^": "ProjectiveCamera;dxCamera,dyCamera,cameraToScreen,rasterToCamera,screenToRaster,rasterToScreen,lensRadius,focalDistance,cameraToWorld,shutterOpen,shutterClose,film",
    generateRay$2: function(sample, ray) {
      var t1, t2, Pcamera, lensU, lensV, ft, t3, t4;
      t1 = sample.get$imageX();
      t2 = sample.imageY;
      Pcamera = new G.Point(0, 0, 0);
      this.rasterToCamera.transformPoint$2(new G.Point(t1, t2, 0), Pcamera);
      ray.set$5(Pcamera, new G.Vector(0, 0, 1), 0, 1 / 0, sample.time);
      t1 = this.lensRadius;
      if (J.$gt$n(t1, 0)) {
        lensU = [0];
        lensV = [0];
        G.ConcentricSampleDisk(sample.lensU, sample.lensV, lensU, lensV);
        lensU[0] = J.$mul$ns(lensU[0], t1);
        lensV[0] = J.$mul$ns(lensV[0], t1);
        ft = J.$div$n(this.focalDistance, J.get$z$x(ray.direction));
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, ft));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        t2 = new G.Point(lensU[0], lensV[0], 0);
        ray.origin = t2;
        t2 = new G.Point(t3, t4, t1).$sub(0, t2);
        ray.direction = t2.$div(0, t2.length$0(0));
      }
      this.cameraToWorld.transformRay$2(ray, ray);
      return 1;
    },
    generateRayDifferential$2: function(sample, ray) {
      var t1, t2, Pcamera, lensU, lensV, ft, t3, t4;
      t1 = sample.get$imageX();
      t2 = sample.imageY;
      Pcamera = new G.Point(0, 0, 0);
      this.rasterToCamera.transformPoint$2(new G.Point(t1, t2, 0), Pcamera);
      ray.set$5(Pcamera, new G.Vector(0, 0, 1), 0, 1 / 0, sample.time);
      t1 = this.lensRadius;
      if (J.$gt$n(t1, 0)) {
        lensU = [0];
        lensV = [0];
        G.ConcentricSampleDisk(sample.lensU, sample.lensV, lensU, lensV);
        lensU[0] = J.$mul$ns(lensU[0], t1);
        lensV[0] = J.$mul$ns(lensV[0], t1);
        ft = J.$div$n(this.focalDistance, J.get$z$x(ray.direction));
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, ft));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        t2 = new G.Point(lensU[0], lensV[0], 0);
        ray.origin = t2;
        t2 = new G.Point(t3, t4, t1).$sub(0, t2);
        ray.direction = t2.$div(0, t2.length$0(0));
      }
      ray.set$rxOrigin(J.$add$ns(ray.origin, this.dxCamera));
      ray.ryOrigin = J.$add$ns(ray.origin, this.dyCamera);
      t1 = ray.direction;
      ray.ryDirection = t1;
      ray.rxDirection = t1;
      ray.hasDifferentials = true;
      this.cameraToWorld.transformRay$2(ray, ray);
      return 1;
    },
    OrthographicCamera$7: function(cam2world, screenWindow, sopen, sclose, lensr, focald, film) {
      this.dxCamera = this.rasterToCamera.transformVector$1(new G.Vector(1, 0, 0));
      this.dyCamera = this.rasterToCamera.transformVector$1(new G.Vector(0, 1, 0));
    },
    static: {OrthographicCamera_Create: [function(params, cam2world, film) {
        var shutteropen, shutterclose, t1, t0, lensradius, focaldistance, frame, sw, $screen, t2;
        shutteropen = params.findOneFloat$2("shutteropen", 0);
        shutterclose = params.findOneFloat$2("shutterclose", 1);
        if (J.$lt$n(shutterclose, shutteropen)) {
          t1 = "Shutter close time [" + H.S(shutterclose) + "] < shutter open [" + H.S(shutteropen) + "].  Swapping them.";
          $.Log.call$2(1, t1);
          t0 = shutterclose;
          shutterclose = shutteropen;
          shutteropen = t0;
        }
        lensradius = params.findOneFloat$2("lensradius", 0);
        focaldistance = params.findOneFloat$2("focaldistance", 1000000000000000019884624838656);
        frame = params.findOneFloat$2("frameaspectratio", J.$div$n(film.get$xResolution(), film.yResolution));
        sw = params.findFloat$1("screenwindow");
        if (sw != null && J.$eq(J.get$length$asx(sw), 4))
          $screen = sw;
        else {
          $screen = [0, 0, 0, 0];
          if (J.$gt$n(frame, 1)) {
            if (typeof frame !== "number")
              return frame.$negate();
            $screen[0] = -frame;
            $screen[1] = frame;
            $screen[2] = -1;
            $screen[3] = 1;
          } else {
            $screen[0] = -1;
            $screen[1] = 1;
            if (typeof frame !== "number")
              return H.iae(frame);
            $screen[2] = -1 / frame;
            $screen[3] = 1 / frame;
          }
        }
        t1 = G.Transform_Scale(1, 1, 1).$mul(0, G.Transform_Translate(new G.Vector(0, 0, -0.0)));
        t2 = new K.OrthographicCamera(null, null, t1, null, null, null, lensradius, focaldistance, cam2world, shutteropen, shutterclose, film);
        t2.ProjectiveCamera$8(cam2world, t1, $screen, shutteropen, shutterclose, lensradius, focaldistance, film);
        t2.OrthographicCamera$7(cam2world, $screen, shutteropen, shutterclose, lensradius, focaldistance, film);
        return t2;
      }, "call$3", "OrthographicCamera_Create$closure", 6, 0, 6]}
  },
  PerspectiveCamera: {
    "^": "ProjectiveCamera;dxCamera,dyCamera,cameraToScreen,rasterToCamera,screenToRaster,rasterToScreen,lensRadius,focalDistance,cameraToWorld,shutterOpen,shutterClose,film",
    generateRay$2: function(sample, ray) {
      var t1, t2, Pcamera, lensU, lensV, ft, t3, t4;
      t1 = sample.get$imageX();
      t2 = sample.imageY;
      Pcamera = new G.Point(0, 0, 0);
      this.rasterToCamera.transformPoint$2(new G.Point(t1, t2, 0), Pcamera);
      J.set$origin$x(ray, new G.Point(0, 0, 0));
      ray.direction = Pcamera.$div(0, Pcamera.length$0(0));
      ray.minDistance = 0;
      ray.maxDistance = 1 / 0;
      t1 = this.lensRadius;
      if (J.$gt$n(t1, 0)) {
        lensU = [0];
        lensV = [0];
        G.ConcentricSampleDisk(sample.lensU, sample.lensV, lensU, lensV);
        lensU[0] = J.$mul$ns(lensU[0], t1);
        lensV[0] = J.$mul$ns(lensV[0], t1);
        ft = J.$div$n(this.focalDistance, J.get$z$x(ray.direction));
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, ft));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        t2 = new G.Point(lensU[0], lensV[0], 0);
        ray.origin = t2;
        t2 = new G.Point(t3, t4, t1).$sub(0, t2);
        ray.direction = t2.$div(0, t2.length$0(0));
      }
      ray.time = sample.time;
      this.cameraToWorld.transformRay$2(ray, ray);
      return 1;
    },
    generateRayDifferential$2: function(sample, ray) {
      var t1, t2, Pcamera, dir, lensU, lensV, ft, t3, t4;
      t1 = sample.get$imageX();
      t2 = sample.imageY;
      Pcamera = new G.Point(0, 0, 0);
      this.rasterToCamera.transformPoint$2(new G.Point(t1, t2, 0), Pcamera);
      dir = Pcamera.$div(0, Pcamera.length$0(0));
      J.set$origin$x(ray, new G.Point(0, 0, 0));
      ray.direction = dir;
      ray.minDistance = 0;
      ray.maxDistance = 1 / 0;
      t1 = this.lensRadius;
      if (J.$gt$n(t1, 0)) {
        lensU = [0];
        lensV = [0];
        G.ConcentricSampleDisk(sample.lensU, sample.lensV, lensU, lensV);
        lensU[0] = J.$mul$ns(lensU[0], t1);
        lensV[0] = J.$mul$ns(lensV[0], t1);
        ft = J.$div$n(this.focalDistance, J.get$z$x(ray.direction));
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, ft));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        t2 = new G.Point(lensU[0], lensV[0], 0);
        ray.origin = t2;
        t2 = new G.Point(t3, t4, t1).$sub(0, t2);
        ray.direction = t2.$div(0, t2.length$0(0));
      }
      t1 = ray.origin;
      t2 = J.getInterceptor$x(t1);
      ray.set$rxOrigin(new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1)));
      t1 = ray.origin;
      t2 = J.getInterceptor$x(t1);
      ray.ryOrigin = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
      t1 = Pcamera.$add(0, this.dxCamera);
      ray.rxDirection = t1.$div(0, t1.length$0(0));
      t1 = Pcamera.$add(0, this.dyCamera);
      ray.ryDirection = t1.$div(0, t1.length$0(0));
      ray.time = sample.time;
      this.cameraToWorld.transformRayDifferential$2(ray, ray);
      ray.hasDifferentials = true;
      return 1;
    },
    PerspectiveCamera$8: function(cam2world, screenWindow, sopen, sclose, lensr, focald, fov, film) {
      this.dxCamera = this.rasterToCamera.transformPoint$1(new G.Point(1, 0, 0)).$sub(0, this.rasterToCamera.transformPoint$1(new G.Point(0, 0, 0)));
      this.dyCamera = this.rasterToCamera.transformPoint$1(new G.Point(0, 1, 0)).$sub(0, this.rasterToCamera.transformPoint$1(new G.Point(0, 0, 0)));
    },
    static: {PerspectiveCamera_Create: [function(params, cam2world, film) {
        var shutteropen, shutterclose, t0, lensradius, focaldistance, frame, sw, $screen, fov, halffov, t1, t2;
        shutteropen = params.findOneFloat$2("shutteropen", 0);
        shutterclose = params.findOneFloat$2("shutterclose", 1);
        if (J.$lt$n(shutterclose, shutteropen)) {
          t0 = shutterclose;
          shutterclose = shutteropen;
          shutteropen = t0;
        }
        lensradius = params.findOneFloat$2("lensradius", 0);
        focaldistance = params.findOneFloat$2("focaldistance", 1000000000000000019884624838656);
        frame = params.findOneFloat$2("frameaspectratio", J.$div$n(film.get$xResolution(), film.yResolution));
        sw = params.findFloat$1("screenwindow");
        if (sw != null && J.$eq(J.get$length$asx(sw), 4))
          $screen = sw;
        else {
          $screen = [0, 0, 0, 0];
          if (J.$gt$n(frame, 1)) {
            if (typeof frame !== "number")
              return frame.$negate();
            $screen[0] = -frame;
            $screen[1] = frame;
            $screen[2] = -1;
            $screen[3] = 1;
          } else {
            $screen[0] = -1;
            $screen[1] = 1;
            if (typeof frame !== "number")
              return H.iae(frame);
            $screen[2] = -1 / frame;
            $screen[3] = 1 / frame;
          }
        }
        fov = params.findOneFloat$2("fov", 60);
        halffov = params.findOneFloat$2("halffov", -1);
        if (J.$gt$n(halffov, 0)) {
          if (typeof halffov !== "number")
            return H.iae(halffov);
          fov = 2 * halffov;
        }
        t1 = G.Transform_Perspective(fov, 0.01, 1000);
        t2 = new K.PerspectiveCamera(null, null, t1, null, null, null, lensradius, focaldistance, cam2world, shutteropen, shutterclose, film);
        t2.ProjectiveCamera$8(cam2world, t1, $screen, shutteropen, shutterclose, lensradius, focaldistance, film);
        t2.PerspectiveCamera$8(cam2world, $screen, shutteropen, shutterclose, lensradius, focaldistance, fov, film);
        return t2;
      }, "call$3", "PerspectiveCamera_Create$closure", 6, 0, 7]}
  }
}],
["core", "package:dartray/core/core.dart", , G, {
  "^": "",
  RoundUpPow2: function(v) {
    v = J.$sub$n(v, 1);
    if (typeof v !== "number")
      return v.$shr();
    v |= C.JSNumber_methods._shrOtherPositive$1(v, 1);
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    return ((v | v >>> 16) >>> 0) + 1;
  },
  SmoothStep: function(min, max, value) {
    var v = C.JSNumber_methods.clamp$2((value - min) / (max - min), 0, 1);
    return v * v * (-2 * v + 3);
  },
  Quadratic: function($A, $B, $C, t00, t1) {
    var discrim, rootDiscrim, q, t2, t;
    if (typeof $A !== "number")
      return H.iae($A);
    if (typeof $C !== "number")
      return H.iae($C);
    discrim = $B * $B - 4 * $A * $C;
    if (discrim < 0)
      return false;
    rootDiscrim = Math.sqrt(discrim);
    q = $B < 0 ? -0.5 * ($B - rootDiscrim) : -0.5 * ($B + rootDiscrim);
    t00[0] = q / $A;
    t2 = $C / q;
    if (0 >= t1.length)
      return H.ioore(t1, 0);
    t1[0] = t2;
    if (J.$gt$n(t00[0], t2)) {
      t = t00[0];
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t00[0] = t1[0];
      t1[0] = t;
    }
    return true;
  },
  less_than: [function(a, b) {
    return J.compareTo$1$ns(a, b) < 0;
  }, "call$2", "less_than$closure", 4, 0, 8],
  partition: function(list, pred, first, last) {
    var t1, t;
    for (; first < last;) {
      while (true) {
        if (first < 0 || first >= list.length)
          return H.ioore(list, first);
        if (!(pred.call$1(list[first]) === true))
          break;
        ++first;
        if (first === last)
          return first;
      }
      do {
        --last;
        if (first === last)
          return first;
        if (last < 0 || last >= list.length)
          return H.ioore(list, last);
      } while (pred.call$1(list[last]) !== true);
      t1 = list.length;
      if (first >= t1)
        return H.ioore(list, first);
      t = list[first];
      if (last >= t1)
        return H.ioore(list, last);
      list[first] = list[last];
      list[last] = t;
      ++first;
    }
    return first;
  },
  nth_element: function(list, first, nth, last, pred) {
    var l, t1, i, j, t2;
    l = C.JSArray_methods.sublist$2(list, first, last);
    H.IterableMixinWorkaround_sortList(l, new G.nth_element_closure(pred));
    for (t1 = list.length, i = first, j = 0; J.$lt$n(i, last); ++i, ++j) {
      if (j >= l.length)
        return H.ioore(l, j);
      t2 = l[j];
      if (i >>> 0 !== i || i >= t1)
        return H.ioore(list, i);
      list[i] = t2;
    }
  },
  upper_bound: function(list, value, compare, first, last) {
    var last0, count, step, index;
    if (J.get$isEmpty$asx(list))
      return -1;
    last0 = list.length;
    if (last0 === 1)
      return 0;
    if (last == null)
      last = last0;
    for (count = last; J.getInterceptor$n(count).$gt(count, 0);) {
      if (typeof count !== "number")
        return count.$shr();
      step = C.JSNumber_methods._shrOtherPositive$1(count, 1);
      index = first + step;
      if (index < 0 || index >= last0)
        return H.ioore(list, index);
      if (compare.call$2(value, list[index]) !== true) {
        ++index;
        count -= step + 1;
        first = index;
      } else
        count = step;
    }
    return first;
  },
  make_heap: function(list, first, last) {
    var t1, len, $parent, t2;
    t1 = J.getInterceptor$n(last);
    if (J.$lt$n(t1.$sub(last, first), 2))
      return;
    len = t1.$sub(last, first);
    $parent = J.$tdiv$n(J.$sub$n(len, 2), 2);
    for (t1 = list.length; true;) {
      if (typeof $parent !== "number")
        return H.iae($parent);
      t2 = first + $parent;
      if (t2 >>> 0 !== t2 || t2 >= t1)
        return H.ioore(list, t2);
      G._adjust_heap(list, first, $parent, len, list[t2]);
      if ($parent === 0)
        return;
      --$parent;
    }
  },
  _adjust_heap: function(list, first, holeIndex, len, value) {
    var secondChild, t1, holeIndex0, t2, secondChild0, t3;
    if (typeof holeIndex !== "number")
      return H.iae(holeIndex);
    secondChild = 2 * holeIndex + 2;
    if (typeof len !== "number")
      return H.iae(len);
    t1 = list.length;
    holeIndex0 = holeIndex;
    for (; secondChild < len; holeIndex0 = secondChild, secondChild = secondChild0) {
      t2 = first + secondChild;
      if (t2 >>> 0 !== t2 || t2 >= t1)
        return H.ioore(list, t2);
      t2 = list[t2];
      secondChild0 = secondChild - 1;
      t3 = first + secondChild0;
      if (t3 >>> 0 !== t3 || t3 >= t1)
        return H.ioore(list, t3);
      if (J.$lt$n(t2, list[t3]))
        secondChild = secondChild0;
      t2 = first + holeIndex0;
      t3 = first + secondChild;
      if (t3 >>> 0 !== t3 || t3 >= t1)
        return H.ioore(list, t3);
      t3 = list[t3];
      if (t2 >>> 0 !== t2 || t2 >= t1)
        return H.ioore(list, t2);
      list[t2] = t3;
      secondChild0 = 2 * (secondChild + 1);
    }
    if (secondChild === len) {
      t2 = first + holeIndex0;
      holeIndex0 = secondChild - 1;
      t3 = first + holeIndex0;
      if (t3 >>> 0 !== t3 || t3 >= t1)
        return H.ioore(list, t3);
      t3 = list[t3];
      if (t2 >>> 0 !== t2 || t2 >= t1)
        return H.ioore(list, t2);
      list[t2] = t3;
    }
    G._push_heap(list, first, holeIndex0, holeIndex, value);
  },
  _push_heap: function(list, first, holeIndex, topIndex, value) {
    var $parent, t1, t2, t3, parent0;
    $parent = J.$tdiv$n(J.$sub$n(holeIndex, 1), 2);
    t1 = list.length;
    while (true) {
      if (J.$gt$n(holeIndex, topIndex)) {
        if (typeof $parent !== "number")
          return H.iae($parent);
        t2 = first + $parent;
        if (t2 >>> 0 !== t2 || t2 >= t1)
          return H.ioore(list, t2);
        t2 = J.$lt$n(list[t2], value);
      } else
        t2 = false;
      if (!t2)
        break;
      if (typeof holeIndex !== "number")
        return H.iae(holeIndex);
      t2 = first + holeIndex;
      if (typeof $parent !== "number")
        return H.iae($parent);
      t3 = first + $parent;
      if (t3 >>> 0 !== t3 || t3 >= t1)
        return H.ioore(list, t3);
      t3 = list[t3];
      if (t2 >>> 0 !== t2 || t2 >= t1)
        return H.ioore(list, t2);
      list[t2] = t3;
      parent0 = C.JSNumber_methods._tdivFast$1($parent - 1, 2);
      holeIndex = $parent;
      $parent = parent0;
    }
    if (typeof holeIndex !== "number")
      return H.iae(holeIndex);
    t2 = first + holeIndex;
    if (t2 >>> 0 !== t2 || t2 >= t1)
      return H.ioore(list, t2);
    list[t2] = value;
  },
  Integrator_UniformSampleAllLights: function(scene, renderer, p, n, wo, rayEpsilon, time, bsdf, sample, rng, lightSampleOffsets, bsdfSampleOffsets) {
    var $L, t1, t2, t3, i, light, nSamples, Ld, j, lightSample, bsdfSample, t4;
    $L = G.Spectrum_Spectrum(0);
    for (t1 = scene.lights, t2 = lightSampleOffsets != null, t3 = bsdfSampleOffsets != null, i = 0; i < t1.length; ++i) {
      light = t1[i];
      if (t2) {
        if (i >= lightSampleOffsets.length)
          return H.ioore(lightSampleOffsets, i);
        nSamples = lightSampleOffsets[i].get$nSamples();
      } else
        nSamples = 1;
      Ld = G.Spectrum_Spectrum(0);
      if (typeof nSamples !== "number")
        return H.iae(nSamples);
      j = 0;
      for (; j < nSamples; ++j) {
        if (t2 && t3) {
          if (i >= lightSampleOffsets.length)
            return H.ioore(lightSampleOffsets, i);
          lightSample = G.LightSample$sample(sample, lightSampleOffsets[i], j);
          if (i >= bsdfSampleOffsets.length)
            return H.ioore(bsdfSampleOffsets, i);
          bsdfSample = G.BSDFSample$sample(sample, bsdfSampleOffsets[i], j);
        } else {
          t4 = Array(2);
          t4.$builtinTypeInfo = [J.JSDouble];
          lightSample = new G.LightSample(t4, 0);
          t4[0] = rng.randomFloat$0();
          t4[1] = (rng.randomUInt$0() & 16777215) / 16777216;
          lightSample.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
          t4 = Array(2);
          t4.$builtinTypeInfo = [J.JSDouble];
          bsdfSample = new G.BSDFSample(t4, 0);
          t4[0] = rng.randomFloat$0();
          t4[1] = (rng.randomUInt$0() & 16777215) / 16777216;
          bsdfSample.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
        }
        Ld = Ld.$add(0, G.Integrator_EstimateDirect(scene, renderer, light, p, n, wo, rayEpsilon, time, bsdf, rng, lightSample, bsdfSample, 15));
      }
      $L = $L.$add(0, Ld.$div(0, C.JSNumber_methods.toDouble$0(nSamples)));
    }
    return $L;
  },
  Integrator_UniformSampleOneLight: function(scene, renderer, p, n, wo, rayEpsilon, time, bsdf, sample, rng, lightNumOffset, lightSampleOffset, bsdfSampleOffset) {
    var t1, nLights, lightNum, light, lightSample, bsdfSample;
    t1 = scene.lights;
    nLights = t1.length;
    if (nLights === 0)
      return G.Spectrum_Spectrum(0);
    lightNum = !J.$eq(lightNumOffset, -1) ? J.floor$0$n(J.$mul$ns(J.$index$asx(J.$index$asx(sample.get$oneD(), lightNumOffset), 0), nLights)) : C.JSNumber_methods.toInt$0(Math.floor(rng.randomFloat$0() * nLights));
    lightNum = P.min(lightNum, nLights - 1);
    if (lightNum >>> 0 !== lightNum || lightNum >= t1.length)
      return H.ioore(t1, lightNum);
    light = t1[lightNum];
    if (lightSampleOffset != null && bsdfSampleOffset != null) {
      lightSample = G.LightSample$sample(sample, lightSampleOffset, 0);
      bsdfSample = G.BSDFSample$sample(sample, bsdfSampleOffset, 0);
    } else {
      t1 = Array(2);
      t1.$builtinTypeInfo = [J.JSDouble];
      lightSample = new G.LightSample(t1, 0);
      t1[0] = rng.randomFloat$0();
      t1[1] = (rng.randomUInt$0() & 16777215) / 16777216;
      lightSample.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
      t1 = Array(2);
      t1.$builtinTypeInfo = [J.JSDouble];
      bsdfSample = new G.BSDFSample(t1, 0);
      t1[0] = rng.randomFloat$0();
      t1[1] = (rng.randomUInt$0() & 16777215) / 16777216;
      bsdfSample.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
    }
    return G.Integrator_EstimateDirect(scene, renderer, light, p, n, wo, rayEpsilon, time, bsdf, rng, lightSample, bsdfSample, 15).$mul(0, nLights);
  },
  Integrator_EstimateDirect: function(scene, renderer, light, p, n, wo, rayEpsilon, time, bsdf, rng, lightSample, bsdfSample, flags) {
    var Ld, wi, lightPdf, bsdfPdf, visibility, Li, f, hit, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, weight, sampledType, lightIsect, ray, area;
    Ld = G.Spectrum_Spectrum(0);
    wi = new G.Vector(0, 0, 0);
    lightPdf = [0];
    bsdfPdf = [0];
    visibility = new G.VisibilityTester(null);
    Li = light.sampleLAtPoint$7(p, rayEpsilon, lightSample, time, wi, lightPdf, visibility);
    if (J.$gt$n(lightPdf[0], 0) && !Li.isBlack$0()) {
      f = bsdf.f$3(wo, wi, flags);
      if (!f.isBlack$0()) {
        hit = scene.aggregate.intersectP$1(visibility.r);
        t1 = $.get$Stats_shadowRays();
        t1.count = J.$add$ns(t1.count, 1);
        $.Stats_shadowRays = t1;
        t1 = !hit;
      } else
        t1 = false;
      if (t1) {
        t1 = visibility.r;
        t2 = t1.origin;
        t3 = J.getInterceptor$x(t2);
        t4 = t3.get$x(t2);
        t5 = t3.get$y(t2);
        t2 = t3.get$z(t2);
        t3 = t1.direction;
        t6 = J.getInterceptor$x(t3);
        t7 = t6.get$x(t3);
        t8 = t6.get$y(t3);
        t3 = t6.get$z(t3);
        t6 = t1.minDistance;
        t9 = t1.maxDistance;
        t10 = t1.time;
        t1 = t1.depth;
        t2 = new G.Point(t4, t5, t2);
        t3 = new G.Vector(t7, t8, t3);
        Li = J.$mul$ns(Li, renderer.transmittance$4(scene, new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t2, t3, t6, t9, t10, t1), null, rng));
        t1 = J.getInterceptor$x(n);
        if (light.isDeltaLight$0()) {
          t2 = f.$mul(0, Li);
          t1 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t1.get$x(n)), J.$mul$ns(wi.y, t1.get$y(n))), J.$mul$ns(wi.z, t1.get$z(n))));
          t3 = lightPdf[0];
          if (typeof t3 !== "number")
            return H.iae(t3);
          Ld = Ld.$add(0, t2.$mul(0, t1 / t3));
        } else {
          t2 = bsdf.pdf$3(wo, wi, flags);
          if (0 >= bsdfPdf.length)
            return H.ioore(bsdfPdf, 0);
          bsdfPdf[0] = t2;
          weight = G.PowerHeuristic(1, lightPdf[0], 1, t2);
          t2 = f.$mul(0, Li);
          t1 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t1.get$x(n)), J.$mul$ns(wi.y, t1.get$y(n))), J.$mul$ns(wi.z, t1.get$z(n))));
          if (typeof weight !== "number")
            return H.iae(weight);
          t3 = lightPdf[0];
          if (typeof t3 !== "number")
            return H.iae(t3);
          Ld = Ld.$add(0, t2.$mul(0, t1 * weight / t3));
        }
      }
    }
    if (!light.isDeltaLight$0()) {
      sampledType = [0];
      f = bsdf.sample_f$6(wo, wi, bsdfSample, bsdfPdf, flags, sampledType);
      if (!f.isBlack$0()) {
        if (0 >= bsdfPdf.length)
          return H.ioore(bsdfPdf, 0);
        t1 = J.$gt$n(bsdfPdf[0], 0);
      } else
        t1 = false;
      if (t1) {
        if (J.$and$n(sampledType[0], 16) === 0) {
          t1 = light.pdf$2(p, wi);
          lightPdf[0] = t1;
          if (t1 === 0)
            return Ld;
          if (0 >= bsdfPdf.length)
            return H.ioore(bsdfPdf, 0);
          weight = G.PowerHeuristic(1, bsdfPdf[0], 1, lightPdf[0]);
        } else
          weight = 1;
        lightIsect = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
        lightIsect.primitive = null;
        lightIsect.shapeId = 0;
        lightIsect.primitiveId = 0;
        lightIsect.rayEpsilon = 0;
        Li = G.Spectrum_Spectrum(0);
        t1 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
        t2 = new G.Vector(wi.x, wi.y, wi.z);
        ray = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t1, t2, rayEpsilon, 1 / 0, time, 0);
        hit = scene.aggregate.intersect$2(ray, lightIsect);
        t1 = $.get$Stats_nonShadowRays();
        t1.count = J.$add$ns(t1.count, 1);
        $.Stats_nonShadowRays = t1;
        if (hit) {
          if (J.$eq(lightIsect.primitive.areaLight, light)) {
            t1 = J.$negate$n(wi.x);
            t2 = J.$negate$n(wi.y);
            t3 = J.$negate$n(wi.z);
            area = lightIsect.primitive.areaLight;
            if (area != null) {
              t4 = lightIsect.dg;
              Li = area.L$3(t4.p, t4.nn, new G.Vector(t1, t2, t3));
            } else
              Li = G.Spectrum_Spectrum(0);
          }
        } else
          Li = light.Le$1(ray);
        if (!Li.isBlack$0()) {
          t1 = f.$mul(0, Li.$mul(0, renderer.transmittance$4(scene, ray, null, rng)));
          t2 = J.getInterceptor$x(n);
          t2 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t2.get$x(n)), J.$mul$ns(wi.y, t2.get$y(n))), J.$mul$ns(wi.z, t2.get$z(n))));
          if (typeof weight !== "number")
            return H.iae(weight);
          if (0 >= bsdfPdf.length)
            return H.ioore(bsdfPdf, 0);
          t3 = bsdfPdf[0];
          if (typeof t3 !== "number")
            return H.iae(t3);
          Ld = Ld.$add(0, t1.$mul(0, t2 * weight / t3));
        }
      }
    }
    return Ld;
  },
  Integrator_SpecularReflect: function(ray, bsdf, rng, isect, renderer, scene, sample) {
    var wo, wi, pdf, t1, p, n, f, $L, t2, rd, dndx, dndy, dwodx, dwody, dDNdx, dDNdy, t3;
    wo = J.$negate$n(ray.direction);
    wi = new G.Vector(0, 0, 0);
    pdf = [0];
    t1 = bsdf.dgShading;
    p = t1.p;
    n = t1.nn;
    f = bsdf.sample_f$5(wo, wi, G.BSDFSample$random(rng), pdf, 17);
    $L = G.Spectrum_Spectrum(0);
    if (0 >= pdf.length)
      return H.ioore(pdf, 0);
    if (J.$gt$n(pdf[0], 0) && !f.isBlack$0() && G.Vector_AbsDot(wi, n) !== 0) {
      t2 = isect.rayEpsilon;
      rd = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(p.get$x(p), p.get$y(p), p.get$z(p)), G.Vector$from(wi), t2, 1 / 0, ray.time, ray.depth + 1);
      if (ray.get$hasDifferentials()) {
        rd.hasDifferentials = true;
        rd.rxOrigin = p.$add(0, isect.dg.dpdx);
        rd.ryOrigin = p.$add(0, isect.dg.dpdy);
        dndx = t1.dndu.$mul(0, t1.dudx).$add(0, t1.dndv.$mul(0, t1.dvdx));
        dndy = t1.dndu.$mul(0, t1.dudy).$add(0, t1.dndv.$mul(0, t1.dvdy));
        dwodx = J.$sub$n(J.$negate$n(ray.rxDirection), wo);
        dwody = J.$sub$n(J.$negate$n(ray.ryDirection), wo);
        dDNdx = J.$add$ns(G.Vector_Dot(dwodx, n), G.Vector_Dot(wo, dndx));
        dDNdy = J.$add$ns(G.Vector_Dot(dwody, n), G.Vector_Dot(wo, dndy));
        t1 = J.getInterceptor$ns(n);
        rd.rxDirection = wi.$sub(0, dwodx).$add(0, G.Vector$from(dndx.$mul(0, G.Vector_Dot(wo, n)).$add(0, t1.$mul(n, dDNdx))).$mul(0, 2));
        rd.ryDirection = wi.$sub(0, dwody).$add(0, G.Vector$from(dndy.$mul(0, G.Vector_Dot(wo, n)).$add(0, t1.$mul(n, dDNdy))).$mul(0, 2));
      }
      t1 = $.get$Stats_specularReflectionRays();
      t1.count = J.$add$ns(t1.count, 1);
      $.Stats_specularReflectionRays = t1;
      t1 = J.$mul$ns(f, renderer.Li$4(scene, rd, sample, rng));
      t2 = G.Vector_AbsDot(wi, n);
      if (0 >= pdf.length)
        return H.ioore(pdf, 0);
      t3 = pdf[0];
      if (typeof t3 !== "number")
        return H.iae(t3);
      $L = J.$mul$ns(t1, t2 / t3);
    }
    return $L;
  },
  Integrator_SpecularTransmit: function(ray, bsdf, rng, isect, renderer, scene, sample) {
    var wo, wi, pdf, t1, p, n, f, $L, t2, rd, eta, w, dndx, dndy, dwodx, dwody, dDNdx, dDNdy, mu, dmudx, dmudy, t3;
    wo = J.$negate$n(ray.direction);
    wi = new G.Vector(0, 0, 0);
    pdf = [0];
    t1 = bsdf.dgShading;
    p = t1.p;
    n = t1.nn;
    f = bsdf.sample_f$5(wo, wi, G.BSDFSample$random(rng), pdf, 18);
    $L = G.Spectrum_Spectrum(0);
    if (0 >= pdf.length)
      return H.ioore(pdf, 0);
    if (J.$gt$n(pdf[0], 0) && !f.isBlack$0() && G.Vector_AbsDot(wi, n) !== 0) {
      t2 = isect.rayEpsilon;
      rd = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(p.get$x(p), p.get$y(p), p.get$z(p)), G.Vector$from(wi), t2, 1 / 0, ray.time, ray.depth + 1);
      if (ray.get$hasDifferentials()) {
        rd.hasDifferentials = true;
        rd.rxOrigin = p.$add(0, isect.dg.dpdx);
        rd.ryOrigin = p.$add(0, isect.dg.dpdy);
        eta = bsdf.eta;
        w = J.$negate$n(wo);
        if (J.$lt$n(G.Vector_Dot(wo, n), 0)) {
          if (typeof eta !== "number")
            return H.iae(eta);
          eta = 1 / eta;
        }
        dndx = t1.dndu.$mul(0, t1.dudx).$add(0, t1.dndv.$mul(0, t1.dvdx));
        dndy = t1.dndu.$mul(0, t1.dudy).$add(0, t1.dndv.$mul(0, t1.dvdy));
        dwodx = J.$sub$n(J.$negate$n(ray.rxDirection), wo);
        dwody = J.$sub$n(J.$negate$n(ray.ryDirection), wo);
        dDNdx = J.$add$ns(G.Vector_Dot(dwodx, n), G.Vector_Dot(wo, dndx));
        dDNdy = J.$add$ns(G.Vector_Dot(dwody, n), G.Vector_Dot(wo, dndy));
        t1 = J.getInterceptor$ns(eta);
        mu = J.$sub$n(t1.$mul(eta, G.Vector_Dot(w, n)), G.Vector_Dot(wi, n));
        dmudx = J.$mul$ns(t1.$sub(eta, J.$div$n(J.$mul$ns(t1.$mul(eta, eta), G.Vector_Dot(w, n)), G.Vector_Dot(wi, n))), dDNdx);
        dmudy = J.$mul$ns(t1.$sub(eta, J.$div$n(J.$mul$ns(t1.$mul(eta, eta), G.Vector_Dot(w, n)), G.Vector_Dot(wi, n))), dDNdy);
        t1 = J.getInterceptor$ns(n);
        rd.rxDirection = wi.$add(0, J.$mul$ns(dwodx, eta)).$sub(0, G.Vector$from(dndx.$mul(0, mu).$add(0, t1.$mul(n, dmudx))));
        rd.ryDirection = wi.$add(0, J.$mul$ns(dwody, eta)).$sub(0, G.Vector$from(dndy.$mul(0, mu).$add(0, t1.$mul(n, dmudy))));
      }
      t1 = $.get$Stats_specularRefractionRays();
      t1.count = J.$add$ns(t1.count, 1);
      $.Stats_specularRefractionRays = t1;
      t1 = J.$mul$ns(f, renderer.Li$4(scene, rd, sample, rng));
      t2 = G.Vector_AbsDot(wi, n);
      if (0 >= pdf.length)
        return H.ioore(pdf, 0);
      t3 = pdf[0];
      if (typeof t3 !== "number")
        return H.iae(t3);
      $L = J.$mul$ns(t1, t2 / t3);
    }
    return $L;
  },
  Integrator_ComputeLightSamplingCDF: function(scene) {
    var t1, nLights, lightPower, i;
    t1 = scene.lights;
    nLights = t1.length;
    lightPower = new Float32Array(nLights);
    for (i = 0; i < nLights; ++i) {
      if (i >= t1.length)
        return H.ioore(t1, i);
      lightPower[i] = J.get$y$x(t1[i].power$1(scene));
    }
    return G.Distribution1D$(lightPower, nLights);
  },
  PrintLogger: [function(type, msg) {
    if (type >= 5)
      return H.ioore(C.List_UgT, type);
    P.print(H.S(C.List_UgT[type]) + ": " + H.S(msg));
    if (type === 3)
      throw H.wrapException(P.Exception_Exception(msg));
  }, "call$2", "PrintLogger$closure", 4, 0, 9],
  Material_Bump: function(d, dgGeom, dgs, dgBump) {
    var dgEval, du, t1, t2, uDisplace, dv, vDisplace, displace;
    dgEval = new G.DifferentialGeometry(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    dgEval.DifferentialGeometry$from$1(dgs);
    du = 0.5 * (J.abs$0$n(dgs.dudx) + J.abs$0$n(dgs.dudy));
    if (du === 0)
      du = 0.01;
    dgEval.p = dgs.p.$add(0, dgs.dpdu.$mul(0, du));
    dgEval.u = dgs.u + du;
    t1 = G.Vector_Cross(dgs.dpdu, dgs.dpdv).$add(0, dgs.dndu.$mul(0, du));
    t1 = new G.Normal(t1.x, t1.y, t1.z);
    t2 = t1.lengthSquared$0();
    if (typeof t2 !== "number")
      H.throwExpression(P.ArgumentError$(t2));
    t1.invScale$1(Math.sqrt(t2));
    dgEval.nn = t1;
    uDisplace = d.evaluate$1(dgEval);
    dv = 0.5 * (J.abs$0$n(dgs.dvdx) + J.abs$0$n(dgs.dvdy));
    if (dv === 0)
      dv = 0.01;
    dgEval.p = dgs.p.$add(0, dgs.dpdv.$mul(0, dv));
    dgEval.u = dgs.u;
    dgEval.v = J.$add$ns(dgs.v, dv);
    t1 = G.Vector_Cross(dgs.dpdu, dgs.dpdv).$add(0, dgs.dndv.$mul(0, dv));
    t1 = new G.Normal(t1.x, t1.y, t1.z);
    t2 = t1.lengthSquared$0();
    if (typeof t2 !== "number")
      H.throwExpression(P.ArgumentError$(t2));
    t1.invScale$1(Math.sqrt(t2));
    dgEval.nn = t1;
    vDisplace = d.evaluate$1(dgEval);
    displace = d.evaluate$1(dgs);
    dgBump.copy$1(dgs);
    dgBump.dpdu = dgs.dpdu.$add(0, G.Vector$from(dgs.nn).$mul(0, J.$sub$n(uDisplace, displace)).$div(0, du)).$add(0, G.Vector$from(dgs.dndu).$mul(0, displace));
    t1 = dgs.dpdv.$add(0, G.Vector$from(dgs.nn).$mul(0, J.$sub$n(vDisplace, displace)).$div(0, dv)).$add(0, G.Vector$from(dgs.dndv).$mul(0, displace));
    dgBump.dpdv = t1;
    t1 = G.Vector_Cross(dgBump.dpdu, t1);
    t1 = t1.$div(0, t1.length$0(0));
    dgBump.nn = new G.Normal(t1.x, t1.y, t1.z);
    t1 = dgs.shape;
    t2 = t1.reverseOrientation;
    if ((t2 === true || t1.transformSwapsHandedness) && !J.$eq(t2, t1.transformSwapsHandedness))
      dgBump.nn = J.$mul$ns(dgBump.nn, -1);
    dgBump.nn = G.Normal_FaceForward(dgBump.nn, dgGeom.nn);
  },
  SolveLinearSystem2x2: function($A, $B, x0, x1) {
    var det = J.$sub$n(J.$mul$ns($A[0], $A[3]), J.$mul$ns($A[1], $A[2]));
    if (J.abs$0$n(det) < 1e-10)
      return false;
    x0[0] = J.$div$n(J.$sub$n(J.$mul$ns($A[3], $B[0]), J.$mul$ns($A[1], $B[1])), det);
    x1[0] = J.$div$n(J.$sub$n(J.$mul$ns($A[0], $B[1]), J.$mul$ns($A[2], $B[0])), det);
    if (J.get$isNaN$n(x0[0]) || J.get$isNaN$n(x1[0]))
      return false;
    return true;
  },
  UniformSampleSphere: function(u1, u2) {
    var z, t1, r, phi;
    if (typeof u1 !== "number")
      return H.iae(u1);
    z = 1 - 2 * u1;
    t1 = P.max(0, 1 - z * z);
    r = Math.sqrt(t1);
    if (typeof u2 !== "number")
      return H.iae(u2);
    phi = 6.283185307179586 * u2;
    t1 = Math.cos(phi);
    return new G.Vector(r * t1, r * Math.sin(phi), z);
  },
  UniformSampleCone: function(u1, u2, costhetamax) {
    var costheta, sintheta, phi, t1, t2;
    if (typeof u1 !== "number")
      return H.iae(u1);
    costheta = 1 - u1 + u1 * costhetamax;
    sintheta = Math.sqrt(1 - costheta * costheta);
    phi = J.$mul$ns(J.$mul$ns(u2, 2), 3.141592653589793);
    t1 = typeof phi !== "number";
    if (t1)
      H.throwExpression(P.ArgumentError$(phi));
    t2 = Math.cos(phi);
    if (t1)
      H.throwExpression(P.ArgumentError$(phi));
    return new G.Vector(t2 * sintheta, Math.sin(phi) * sintheta, costheta);
  },
  UniformSampleCone2: function(u1, u2, costhetamax, x, y, z) {
    var costheta, sintheta, phi, t1, t2, t3, t4, t5, t6;
    if (typeof u1 !== "number")
      return H.iae(u1);
    costheta = (1 - u1) * costhetamax + u1;
    sintheta = Math.sqrt(1 - costheta * costheta);
    phi = J.$mul$ns(J.$mul$ns(u2, 2), 3.141592653589793);
    t1 = typeof phi !== "number";
    if (t1)
      H.throwExpression(P.ArgumentError$(phi));
    t2 = Math.cos(phi) * sintheta;
    t3 = J.$mul$ns(x.x, t2);
    t4 = J.$mul$ns(x.y, t2);
    t2 = J.$mul$ns(x.z, t2);
    if (t1)
      H.throwExpression(P.ArgumentError$(phi));
    t1 = Math.sin(phi) * sintheta;
    t5 = J.$mul$ns(y.x, t1);
    t6 = J.$mul$ns(y.y, t1);
    t1 = J.$mul$ns(y.z, t1);
    t5 = J.$add$ns(t3, t5);
    t6 = J.$add$ns(t4, t6);
    t1 = J.$add$ns(t2, t1);
    t2 = J.$mul$ns(z, costheta);
    t4 = J.getInterceptor$x(t2);
    return new G.Vector(J.$add$ns(t5, t4.get$x(t2)), J.$add$ns(t6, t4.get$y(t2)), J.$add$ns(t1, t4.get$z(t2)));
  },
  UniformConePdf: function(cosThetaMax) {
    return 1 / (6.283185307179586 * (1 - cosThetaMax));
  },
  ConcentricSampleDisk: function(u1, u2, dx, dy) {
    var sx, sy, r, theta;
    if (typeof u1 !== "number")
      return H.iae(u1);
    sx = 2 * u1 - 1;
    if (typeof u2 !== "number")
      return H.iae(u2);
    sy = 2 * u2 - 1;
    if (sx === 0 && sy === 0) {
      dx[0] = 0;
      dy[0] = 0;
      return;
    }
    r = -sy;
    if (sx >= r)
      if (sx > sy) {
        theta = sy / sx;
        theta = sy > 0 ? theta : 8 + theta;
        r = sx;
      } else {
        theta = 2 - sx / sy;
        r = sy;
      }
    else if (sx <= sy) {
      r = -sx;
      theta = 4 - sy / r;
    } else
      theta = 6 + sx / r;
    theta *= 0.7853981633974483;
    dx[0] = r * Math.cos(theta);
    dy[0] = r * Math.sin(theta);
  },
  CosineSampleHemisphere: function(u1, u2) {
    var dx, dy, t1, t2, z;
    dx = [0];
    dy = [0];
    G.ConcentricSampleDisk(u1, u2, dx, dy);
    t1 = dx[0];
    t1 = J.$mul$ns(t1, t1);
    if (typeof t1 !== "number")
      return H.iae(t1);
    t2 = dy[0];
    t2 = J.$mul$ns(t2, t2);
    if (typeof t2 !== "number")
      return H.iae(t2);
    t2 = P.max(0, 1 - t1 - t2);
    z = Math.sqrt(t2);
    return new G.Vector(dx[0], dy[0], z);
  },
  StratifiedSample1D: function(samples, nSamples, rng, jitter) {
    var invTot, t1, t2, i, si, delta, si0, t3;
    if (typeof nSamples !== "number")
      return H.iae(nSamples);
    invTot = 1 / nSamples;
    for (t1 = samples.length, t2 = jitter === true, i = 0, si = 0; i < nSamples; ++i, si = si0) {
      delta = t2 ? (rng.randomUInt$0() & 16777215) / 16777216 : 0.5;
      si0 = si + 1;
      t3 = P.min((i + delta) * invTot, 0.9999999403953552);
      if (si >= t1)
        return H.ioore(samples, si);
      samples[si] = t3;
    }
  },
  StratifiedSample2D: function(samples, nx, ny, rng, jitter) {
    var dx, dy, t1, si, y, x, jx, jy, si0, t2;
    if (typeof nx !== "number")
      return H.iae(nx);
    dx = 1 / nx;
    if (typeof ny !== "number")
      return H.iae(ny);
    dy = 1 / ny;
    for (t1 = jitter === true, si = 0, y = 0; y < ny; ++y)
      for (x = 0; x < nx; ++x) {
        jx = t1 ? rng.randomFloat$0() : 0.5;
        jy = t1 ? rng.randomFloat$0() : 0.5;
        si0 = si + 1;
        t2 = P.min((x + jx) * dx, 0.9999999403953552);
        if (si < 0 || si >= samples.length)
          return H.ioore(samples, si);
        samples[si] = t2;
        si = si0 + 1;
        t2 = P.min((y + jy) * dy, 0.9999999403953552);
        if (si0 < 0 || si0 >= samples.length)
          return H.ioore(samples, si0);
        samples[si0] = t2;
      }
  },
  Shuffle: function(samples, offset, count, dims, rng) {
    var t1, i, t2, t3, j, t4, s, t5;
    if (typeof count !== "number")
      return H.iae(count);
    t1 = J.getInterceptor$asx(samples);
    i = 0;
    for (; i < count; ++i) {
      t2 = C.JSInt_methods.$mod(rng.randomUInt$0(), count - i);
      if (typeof dims !== "number")
        return H.iae(dims);
      t3 = offset + dims * i;
      t2 = offset + dims * (i + t2);
      j = 0;
      for (; j < dims; ++j) {
        t4 = t3 + j;
        s = t1.$index(samples, t4);
        t5 = t2 + j;
        t1.$indexSet(samples, t4, t1.$index(samples, t5));
        t1.$indexSet(samples, t5, s);
      }
    }
  },
  LatinHypercube: function(samples, nSamples, nDim, rng) {
    var delta, t1, i, t2, j, t3, t;
    if (typeof nSamples !== "number")
      return H.iae(nSamples);
    delta = 1 / nSamples;
    for (t1 = J.getInterceptor$asx(samples), i = 0; i < nSamples; ++i)
      for (t2 = nDim * i, j = 0; j < nDim; ++j)
        t1.$indexSet(samples, t2 + j, P.min((i + (rng.randomUInt$0() & 16777215) / 16777216) * delta, 0.9999999403953552));
    for (i = 0; i < nDim; ++i)
      for (j = 0; j < nSamples; ++j) {
        t2 = C.JSInt_methods.$mod(rng.randomUInt$0(), nSamples - j);
        t3 = nDim * j + i;
        t = t1.$index(samples, t3);
        t2 = nDim * (j + t2) + i;
        t1.$indexSet(samples, t3, t1.$index(samples, t2));
        t1.$indexSet(samples, t2, t);
      }
  },
  RadicalInverse: function(n, base) {
    var invBase, invBi, val;
    invBase = 1 / base;
    for (invBi = invBase, val = 0; n > 0;) {
      val += C.JSInt_methods.$mod(n, base) * invBi;
      n = C.JSInt_methods.toInt$0(n * invBase);
      invBi *= invBase;
    }
    return val;
  },
  GeneratePermutation: function(p, pi, b, rng) {
    var i, t1;
    for (i = 0; i < b; ++i) {
      t1 = pi + i;
      if (t1 >= p.length)
        return H.ioore(p, t1);
      p[t1] = i;
    }
    G.Shuffle(p, pi, b, 1, rng);
  },
  PermutedRadicalInverse: function(n, base, p, pi) {
    var invBase, invBi, val, t1;
    invBase = 1 / base;
    for (invBi = invBase, val = 0; n > 0;) {
      t1 = pi + C.JSInt_methods.$mod(n, base);
      if (t1 >= p.length)
        return H.ioore(p, t1);
      val += p[t1] * invBi;
      n = C.JSInt_methods.toInt$0(n * invBase);
      invBi *= invBase;
    }
    return val;
  },
  LDPixelSampleFloatsNeeded: function(sample, nPixelSamples) {
    var t1, t2, t3, n, i, t4;
    for (t1 = sample.get$n1D().length, t2 = sample.n1D, t3 = t2.length, n = 5, i = 0; i < t1; ++i) {
      if (i >= t3)
        return H.ioore(t2, i);
      t4 = t2[i];
      if (typeof t4 !== "number")
        return H.iae(t4);
      n += t4;
    }
    for (t1 = sample.n2D, t2 = t1.length, i = 0; i < t2; ++i) {
      t3 = t1[i];
      if (typeof t3 !== "number")
        return H.iae(t3);
      n += 2 * t3;
    }
    return J.$mul$ns(nPixelSamples, n);
  },
  LDPixelSample: function(xPos, yPos, shutterOpen, shutterClose, nPixelSamples, samples, buffer, rng) {
    var imageSamples, t1, buf, lensSamples, timeSamples, t2, n1D, count1D, n2D, count2D, oneDSamples, twoDSamples, i, t3, t4, t5, t6, t7, t8, t9, t10, j, startSamp, k;
    imageSamples = H.NativeFloat32List_NativeFloat32List$view(buffer.buffer, 0, null);
    if (typeof nPixelSamples !== "number")
      return H.iae(nPixelSamples);
    t1 = 2 * nPixelSamples * 4;
    buf = 0 + t1;
    lensSamples = H.NativeFloat32List_NativeFloat32List$view(buffer.buffer, buf, null);
    buf += t1;
    timeSamples = H.NativeFloat32List_NativeFloat32List$view(buffer.buffer, buf, null);
    buf += nPixelSamples * 4;
    t1 = samples.length;
    if (0 >= t1)
      return H.ioore(samples, 0);
    t2 = samples[0];
    n1D = t2.get$n1D();
    count1D = n1D.length;
    n2D = t2.n2D;
    count2D = n2D.length;
    n1D = count1D > 0 ? n1D : null;
    n2D = count2D > 0 ? n2D : null;
    oneDSamples = H.setRuntimeTypeInfo(Array(count1D), [P.Float32List]);
    twoDSamples = H.setRuntimeTypeInfo(Array(count2D), [P.Float32List]);
    for (t2 = oneDSamples.length, i = 0; i < count1D; ++i) {
      t3 = buffer.buffer;
      H._checkViewArguments(t3, buf, null);
      t3 = new Float32Array(t3, buf);
      if (i >= t2)
        return H.ioore(oneDSamples, i);
      oneDSamples[i] = t3;
      if (i >= n1D.length)
        return H.ioore(n1D, i);
      t3 = J.$mul$ns(J.$mul$ns(n1D[i], nPixelSamples), 4);
      if (typeof t3 !== "number")
        return H.iae(t3);
      buf += t3;
    }
    for (t3 = twoDSamples.length, i = 0; i < count2D; ++i) {
      t4 = buffer.buffer;
      H._checkViewArguments(t4, buf, null);
      t4 = new Float32Array(t4, buf);
      if (i >= t3)
        return H.ioore(twoDSamples, i);
      twoDSamples[i] = t4;
      if (i >= n2D.length)
        return H.ioore(n2D, i);
      t4 = n2D[i];
      if (typeof t4 !== "number")
        return H.iae(t4);
      buf += 2 * t4 * nPixelSamples * 4;
    }
    G.LDShuffleScrambled2D(1, nPixelSamples, imageSamples, rng);
    G.LDShuffleScrambled2D(1, nPixelSamples, lensSamples, rng);
    G.LDShuffleScrambled1D(1, nPixelSamples, timeSamples, rng);
    for (i = 0; i < count1D; ++i) {
      if (i >= n1D.length)
        return H.ioore(n1D, i);
      t4 = n1D[i];
      if (i >= t2)
        return H.ioore(oneDSamples, i);
      G.LDShuffleScrambled1D(t4, nPixelSamples, oneDSamples[i], rng);
    }
    for (i = 0; i < count2D; ++i) {
      if (i >= n2D.length)
        return H.ioore(n2D, i);
      t4 = n2D[i];
      if (i >= t3)
        return H.ioore(twoDSamples, i);
      G.LDShuffleScrambled2D(t4, nPixelSamples, twoDSamples[i], rng);
    }
    for (t4 = imageSamples.length, t5 = timeSamples.length, t6 = lensSamples.length, i = 0; i < nPixelSamples; ++i) {
      if (i >= t1)
        return H.ioore(samples, i);
      t7 = samples[i];
      t8 = 2 * i;
      if (t8 >= t4)
        return H.ioore(imageSamples, t8);
      t7.set$imageX(xPos + imageSamples[t8]);
      t9 = t8 + 1;
      if (t9 >= t4)
        return H.ioore(imageSamples, t9);
      t7.imageY = yPos + imageSamples[t9];
      if (i >= t5)
        return H.ioore(timeSamples, i);
      t10 = timeSamples[i];
      if (typeof shutterOpen !== "number")
        return H.iae(shutterOpen);
      if (typeof shutterClose !== "number")
        return H.iae(shutterClose);
      t7.time = (1 - t10) * shutterOpen + t10 * shutterClose;
      if (t8 >= t6)
        return H.ioore(lensSamples, t8);
      t7.lensU = lensSamples[t8];
      if (t9 >= t6)
        return H.ioore(lensSamples, t9);
      t7.lensV = lensSamples[t9];
      for (j = 0; j < count1D; ++j) {
        if (j >= n1D.length)
          return H.ioore(n1D, j);
        startSamp = J.$mul$ns(n1D[j], i);
        t7 = J.getInterceptor$ns(startSamp);
        k = 0;
        while (true) {
          if (j >= n1D.length)
            return H.ioore(n1D, j);
          t8 = n1D[j];
          if (typeof t8 !== "number")
            return H.iae(t8);
          if (!(k < t8))
            break;
          t8 = J.$index$asx(samples[i].get$oneD(), j);
          if (j >= t2)
            return H.ioore(oneDSamples, j);
          J.$indexSet$ax(t8, k, J.$index$asx(oneDSamples[j], t7.$add(startSamp, k)));
          ++k;
        }
      }
      for (j = 0; j < count2D; ++j) {
        if (j >= n2D.length)
          return H.ioore(n2D, j);
        t7 = n2D[j];
        if (typeof t7 !== "number")
          return H.iae(t7);
        startSamp = 2 * t7 * i;
        k = 0;
        while (true) {
          if (j >= n2D.length)
            return H.ioore(n2D, j);
          t7 = n2D[j];
          if (typeof t7 !== "number")
            return H.iae(t7);
          if (!(k < 2 * t7))
            break;
          t7 = samples[i].get$twoD();
          if (j >= t7.length)
            return H.ioore(t7, j);
          t7 = t7[j];
          if (j >= t3)
            return H.ioore(twoDSamples, j);
          J.$indexSet$ax(t7, k, J.$index$asx(twoDSamples[j], startSamp + k));
          ++k;
        }
      }
    }
  },
  PowerHeuristic: function(nf, fPdf, ng, gPdf) {
    var f, g, t1;
    f = J.$mul$ns(nf, fPdf);
    g = J.$mul$ns(ng, gPdf);
    t1 = J.getInterceptor$ns(f);
    return J.$div$n(t1.$mul(f, f), J.$add$ns(t1.$mul(f, f), J.$mul$ns(g, g)));
  },
  Sobol2: function(n, scramble) {
    var v;
    for (v = 2147483648; n !== 0; n = n >>> 1, v ^= v >>> 1)
      if ((n & 1) !== 0) {
        if (typeof scramble !== "number")
          return scramble.$xor();
        scramble = (scramble ^ v) >>> 0;
      }
    if (typeof scramble !== "number")
      return scramble.$shr();
    return P.min((C.JSNumber_methods._shrOtherPositive$1(scramble, 8) & 16777215) / 16777216, 0.9999999403953552);
  },
  VanDerCorput: function(n, scramble) {
    n = n << 16 | n >>> 16;
    n = (n & 16711935) << 8 | (n & 4278255360) >>> 8;
    n = (n & 252645135) << 4 | (n & 4042322160) >>> 4;
    n = (n & 858993459) << 2 | (n & 3435973836) >>> 2;
    if (typeof scramble !== "number")
      return H.iae(scramble);
    return P.min(((((n & 1431655765) << 1 | (n & 2863311530) >>> 1) ^ scramble) >>> 8 & 16777215) / 16777216, 0.9999999403953552);
  },
  LDShuffleScrambled1D: function(nSamples, nPixel, samples, rng) {
    var scramble, t1, t2, i, t3;
    scramble = rng.randomUInt$0();
    t1 = J.getInterceptor$ns(nSamples);
    t2 = J.getInterceptor$ax(samples);
    i = 0;
    while (true) {
      t3 = t1.$mul(nSamples, nPixel);
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (!(i < t3))
        break;
      t2.$indexSet(samples, i, G.VanDerCorput(i, scramble));
      ++i;
    }
    if (typeof nPixel !== "number")
      return H.iae(nPixel);
    i = 0;
    for (; i < nPixel; ++i) {
      if (typeof nSamples !== "number")
        return H.iae(nSamples);
      G.Shuffle(samples, i * nSamples, nSamples, 1, rng);
    }
    G.Shuffle(samples, 0, nPixel, nSamples, rng);
  },
  LDShuffleScrambled2D: function(nSamples, nPixel, samples, rng) {
    var scramble, t1, t2, i, t3;
    scramble = [rng.randomUInt$0(), rng.randomUInt$0()];
    t1 = J.getInterceptor$ns(nSamples);
    t2 = J.getInterceptor$ax(samples);
    i = 0;
    while (true) {
      t3 = t1.$mul(nSamples, nPixel);
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (!(i < t3))
        break;
      t3 = 2 * i;
      t2.$indexSet(samples, t3, G.VanDerCorput(i, scramble[0]));
      t2.$indexSet(samples, t3 + 1, G.Sobol2(i, scramble[1]));
      ++i;
    }
    if (typeof nPixel !== "number")
      return H.iae(nPixel);
    i = 0;
    for (; i < nPixel; ++i) {
      if (typeof nSamples !== "number")
        return H.iae(nSamples);
      G.Shuffle(samples, 2 * i * nSamples, nSamples, 2, rng);
    }
    if (typeof nSamples !== "number")
      return H.iae(nSamples);
    G.Shuffle(samples, 0, nPixel, 2 * nSamples, rng);
  },
  BRDFRemap: function(wo, wi) {
    var t1, cosi, t2, coso, t3, sini, sino, p, phii, dphi;
    t1 = J.getInterceptor$x(wi);
    cosi = t1.get$z(wi);
    t2 = J.getInterceptor$x(wo);
    coso = t2.get$z(wo);
    t3 = J.$mul$ns(t1.get$z(wi), t1.get$z(wi));
    if (typeof t3 !== "number")
      return H.iae(t3);
    t3 = P.max(0, 1 - t3);
    sini = Math.sqrt(t3);
    t3 = J.$mul$ns(t2.get$z(wo), t2.get$z(wo));
    if (typeof t3 !== "number")
      return H.iae(t3);
    t3 = P.max(0, 1 - t3);
    sino = Math.sqrt(t3);
    t3 = t1.get$y(wi);
    t1 = t1.get$x(wi);
    if (typeof t3 !== "number")
      H.throwExpression(P.ArgumentError$(t3));
    if (typeof t1 !== "number")
      H.throwExpression(P.ArgumentError$(t1));
    p = Math.atan2(t3, t1);
    phii = p < 0 ? p + 6.283185307179586 : p;
    t1 = t2.get$y(wo);
    t2 = t2.get$x(wo);
    if (typeof t1 !== "number")
      H.throwExpression(P.ArgumentError$(t1));
    if (typeof t2 !== "number")
      H.throwExpression(P.ArgumentError$(t2));
    p = Math.atan2(t1, t2);
    dphi = phii - (p < 0 ? p + 6.283185307179586 : p);
    if (dphi < 0)
      dphi += 6.283185307179586;
    if (dphi > 6.283185307179586)
      dphi -= 6.283185307179586;
    if (dphi > 3.141592653589793)
      dphi = 6.283185307179586 - dphi;
    return new G.Point(sini * sino, dphi / 3.141592653589793, J.$mul$ns(cosi, coso));
  },
  Sampler_ComputeSubWindow: function(w, h, num, count, extents) {
    var t1, nx, ny, t2, xo, yo, tx0, tx1, ty0, ty1;
    t1 = J.getInterceptor$ns(h);
    nx = count;
    ny = 1;
    while (true) {
      if (J.getInterceptor$n(nx).$and(nx, 1) === 0) {
        if (typeof w !== "number")
          return H.iae(w);
        t2 = t1.$mul(h, nx);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = 2 * w * ny < t2;
      } else
        t2 = false;
      if (!t2)
        break;
      if (typeof nx !== "number")
        return nx.$shr();
      nx = C.JSNumber_methods._shrOtherPositive$1(nx, 1);
      ny = ny << 1 >>> 0;
    }
    xo = J.getInterceptor$n(num).$mod(num, nx);
    if (typeof num !== "number")
      return num.$tdiv();
    if (typeof nx !== "number")
      return H.iae(nx);
    yo = C.JSNumber_methods.$tdiv(num, nx);
    if (typeof xo !== "number")
      return xo.$div();
    tx0 = xo / nx;
    tx1 = (xo + 1) / nx;
    ty0 = yo / ny;
    ty1 = (yo + 1) / ny;
    if (typeof w !== "number")
      return H.iae(w);
    extents[0] = C.JSNumber_methods.toInt$0(Math.floor((1 - tx0) * 0 + tx0 * w));
    extents[1] = P.min(C.JSNumber_methods.toInt$0(Math.floor((1 - tx1) * 0 + tx1 * w)), w - 1);
    if (typeof h !== "number")
      return H.iae(h);
    extents[2] = C.JSNumber_methods.toInt$0(Math.floor((1 - ty0) * 0 + ty0 * h));
    extents[3] = P.min(C.JSNumber_methods.toInt$0(Math.floor((1 - ty1) * 0 + ty1 * h)), h - 1);
  },
  Spectrum_Spectrum: function(v) {
    var t1, t2;
    t1 = $.Spectrum_type;
    if (t1 === 0) {
      t1 = new Float32Array(3);
      t2 = new G.RGBColor(t1);
      if (!J.$eq(v, 0))
        C.NativeFloat32List_methods.fillRange$3(t1, 0, 3, v);
      t1 = t2;
    } else if (t1 === 2) {
      t1 = new Float32Array(4);
      t2 = new G.SampledSpectrum(t1);
      if (!J.$eq(v, 0))
        C.NativeFloat32List_methods.fillRange$3(t1, 0, 4, v);
      t1 = t2;
    } else if (t1 === 1) {
      t1 = new Float32Array(3);
      t2 = new G.XYZColor(t1);
      if (!J.$eq(v, 0))
        C.NativeFloat32List_methods.fillRange$3(t1, 0, 3, v);
      t1 = t2;
    } else
      t1 = null;
    return t1;
  },
  Spectrum_Spectrum$from: function(other, type) {
    switch ($.Spectrum_type) {
      case 0:
        return G.RGBColor$from(other);
      case 1:
        return G.XYZColor$from(other);
      case 2:
        return G.SampledSpectrum$from(other, type);
    }
    $.Log.call$2(3, "Invalid Spectrum type");
    return;
  },
  Spectrum_Spectrum$rgb: function(r, g, b) {
    var t1, t2;
    t1 = $.Spectrum_type;
    if (t1 === 0)
      t1 = G.RGBColor$rgb(r, g, b);
    else if (t1 === 2) {
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.setRGB$3(r, g, b);
    } else if (t1 === 1) {
      t1 = new Float32Array(3);
      t2 = new G.XYZColor(t1);
      G.Spectrum_RGBToXYZ(r, g, b, t1);
      t1 = t2;
    } else
      t1 = null;
    return t1;
  },
  Spectrum_AllocateList: function(count) {
    var r, t1, i, t2;
    if (typeof count !== "number")
      return H.iae(count);
    r = H.setRuntimeTypeInfo(Array(count), [G.Spectrum]);
    for (t1 = r.length, i = 0; i < count; ++i) {
      t2 = G.Spectrum_Spectrum(0);
      if (i >= t1)
        return H.ioore(r, i);
      r[i] = t2;
    }
    return r;
  },
  Spectrum_XYZToRGB: function(x, y, z, rgb) {
    var t1;
    if (typeof x !== "number")
      return H.iae(x);
    if (typeof y !== "number")
      return H.iae(y);
    if (typeof z !== "number")
      return H.iae(z);
    t1 = rgb.length;
    if (0 >= t1)
      return H.ioore(rgb, 0);
    rgb[0] = 3.240479 * x - 1.53715 * y - 0.498535 * z;
    if (1 >= t1)
      return H.ioore(rgb, 1);
    rgb[1] = -0.969256 * x + 1.875991 * y + 0.041556 * z;
    if (2 >= t1)
      return H.ioore(rgb, 2);
    rgb[2] = 0.055648 * x - 0.204043 * y + 1.057311 * z;
  },
  Spectrum_RGBToXYZ: function(r, g, b, xyz) {
    var t1;
    if (typeof r !== "number")
      return H.iae(r);
    if (typeof g !== "number")
      return H.iae(g);
    if (typeof b !== "number")
      return H.iae(b);
    t1 = xyz.length;
    if (0 >= t1)
      return H.ioore(xyz, 0);
    xyz[0] = 0.412453 * r + 0.35758 * g + 0.180423 * b;
    if (1 >= t1)
      return H.ioore(xyz, 1);
    xyz[1] = 0.212671 * r + 0.71516 * g + 0.072169 * b;
    if (2 >= t1)
      return H.ioore(xyz, 2);
    xyz[2] = 0.019334 * r + 0.119193 * g + 0.950227 * b;
  },
  Spectrum_SpectrumSamplesSorted: function(lambda) {
    var t1, i, t2, t3;
    for (t1 = lambda.length - 1, i = 0; i < t1;) {
      t2 = lambda.length;
      if (i >= t2)
        return H.ioore(lambda, i);
      t3 = lambda[i];
      ++i;
      if (i >= t2)
        return H.ioore(lambda, i);
      if (J.$gt$n(t3, lambda[i]))
        return false;
    }
    return true;
  },
  Spectrum_SortSpectrumSamples: function(lambda, vals, offset) {
    var sortVec, n, i, t1, t2;
    sortVec = [];
    n = lambda.length;
    for (i = 0; i < n; ++i) {
      if (i >= lambda.length)
        return H.ioore(lambda, i);
      t1 = lambda[i];
      t2 = offset + i;
      if (t2 < 0 || t2 >= vals.length)
        return H.ioore(vals, t2);
      sortVec.push([t1, vals[t2]]);
    }
    H.IterableMixinWorkaround_sortList(sortVec, new G.Spectrum_SortSpectrumSamples_closure());
    for (t1 = J.getInterceptor$ax(lambda), t2 = J.getInterceptor$ax(vals), i = 0; i < n; ++i) {
      if (i >= sortVec.length)
        return H.ioore(sortVec, i);
      t1.$indexSet(lambda, i, J.$index$asx(sortVec[i], 0));
      if (i >= sortVec.length)
        return H.ioore(sortVec, i);
      t2.$indexSet(vals, offset + i, J.$index$asx(sortVec[i], 1));
    }
  },
  Spectrum_AverageSpectrumSamples: function(lambda, vals, lambdaStart, lambdaEnd, offset) {
    var n, t1, t2, t3, sum, i, i0, segStart, segEnd;
    n = lambda.length;
    if (0 >= n)
      return H.ioore(lambda, 0);
    t1 = lambda[0];
    if (typeof t1 !== "number")
      return H.iae(t1);
    if (lambdaEnd <= t1) {
      if (offset < 0 || offset >= vals.length)
        return H.ioore(vals, offset);
      return vals[offset];
    }
    t2 = n - 1;
    if (t2 < 0)
      return H.ioore(lambda, t2);
    t3 = lambda[t2];
    if (typeof t3 !== "number")
      return H.iae(t3);
    if (lambdaStart >= t3) {
      t1 = offset + n - 1;
      if (t1 < 0 || t1 >= vals.length)
        return H.ioore(vals, t1);
      return vals[t1];
    }
    if (n === 1) {
      if (offset < 0 || offset >= vals.length)
        return H.ioore(vals, offset);
      return vals[offset];
    }
    if (lambdaStart < t1) {
      if (offset < 0 || offset >= vals.length)
        return H.ioore(vals, offset);
      t1 = J.$mul$ns(vals[offset], t1 - lambdaStart);
      if (typeof t1 !== "number")
        return H.iae(t1);
      sum = 0 + t1;
    } else
      sum = 0;
    if (t2 >= lambda.length)
      return H.ioore(lambda, t2);
    t1 = lambda[t2];
    if (typeof t1 !== "number")
      return H.iae(t1);
    if (lambdaEnd > t1) {
      t2 = offset + n - 1;
      if (t2 < 0 || t2 >= vals.length)
        return H.ioore(vals, t2);
      t1 = J.$mul$ns(vals[t2], lambdaEnd - t1);
      if (typeof t1 !== "number")
        return H.iae(t1);
      sum += t1;
    }
    t1 = lambda.length;
    i = 0;
    while (true) {
      i0 = i + 1;
      if (i0 >= t1)
        return H.ioore(lambda, i0);
      t2 = lambda[i0];
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (!(lambdaStart > t2))
        break;
      i = i0;
    }
    t1 = new G.Spectrum_AverageSpectrumSamples_SEG_AVG(new G.Spectrum_AverageSpectrumSamples_INTERP(lambda, vals, offset));
    while (true) {
      i0 = i + 1;
      if (i0 < n) {
        if (i >= lambda.length)
          return H.ioore(lambda, i);
        t2 = lambda[i];
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = lambdaEnd >= t2;
      } else
        t2 = false;
      if (!t2)
        break;
      if (i >= lambda.length)
        return H.ioore(lambda, i);
      segStart = P.max(lambdaStart, lambda[i]);
      if (i0 >= lambda.length)
        return H.ioore(lambda, i0);
      segEnd = P.min(lambdaEnd, lambda[i0]);
      t2 = J.$mul$ns(t1.call$3(segStart, segEnd, i), segEnd - segStart);
      if (typeof t2 !== "number")
        return H.iae(t2);
      sum += t2;
      i = i0;
    }
    return sum / (lambdaEnd - lambdaStart);
  },
  Spectrum_Blackbody: function(wl, temp, vals) {
    var i, t1, norm, t2;
    if (J.$le$n(temp, 0)) {
      for (i = 0; i < 471; ++i)
        vals[i] = 0;
      return;
    }
    t1 = Math.pow(555, 5);
    if (typeof temp !== "number")
      return H.iae(temp);
    norm = t1 * (Math.exp(14388000 / (555 * temp)) - 1);
    for (i = 0; i < 471; ++i) {
      t1 = wl[i];
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      t1 = Math.pow(t1, 5);
      t2 = J.$mul$ns(wl[i], temp);
      if (typeof t2 !== "number")
        return H.iae(t2);
      vals[i] = norm / (t1 * (Math.exp(14388000 / t2) - 1));
    }
  },
  Spectrum_InterpolateSpectrumSamples: function(lambda, vals, l, offset) {
    var n, t1, t2, i, t3, t4, t5, t;
    n = lambda.length;
    if (0 >= n)
      return H.ioore(lambda, 0);
    t1 = J.getInterceptor$n(l);
    if (t1.$le(l, lambda[0])) {
      if (offset < 0 || offset >= vals.length)
        return H.ioore(vals, offset);
      return vals[offset];
    }
    t2 = n - 1;
    if (t2 < 0 || t2 >= lambda.length)
      return H.ioore(lambda, t2);
    if (t1.$ge(l, lambda[t2])) {
      t1 = offset + t2;
      if (t1 < 0 || t1 >= vals.length)
        return H.ioore(vals, t1);
      return vals[t1];
    }
    for (i = 0; i < t2; ++i) {
      if (i >= lambda.length)
        return H.ioore(lambda, i);
      if (t1.$ge(l, lambda[i])) {
        t3 = i + 1;
        if (t3 >= lambda.length)
          return H.ioore(lambda, t3);
        t3 = t1.$le(l, lambda[t3]);
      } else
        t3 = false;
      if (t3) {
        if (i >= lambda.length)
          return H.ioore(lambda, i);
        t2 = t1.$sub(l, lambda[i]);
        t3 = i + 1;
        t4 = lambda.length;
        if (t3 >= t4)
          return H.ioore(lambda, t3);
        t5 = lambda[t3];
        if (i >= t4)
          return H.ioore(lambda, i);
        t5 = J.$sub$n(t5, lambda[i]);
        if (typeof t2 !== "number")
          return t2.$div();
        if (typeof t5 !== "number")
          return H.iae(t5);
        t = t2 / t5;
        t5 = offset + i;
        t2 = vals.length;
        if (t5 < 0 || t5 >= t2)
          return H.ioore(vals, t5);
        t5 = vals[t5];
        if (t3 >= t2)
          return H.ioore(vals, t3);
        t3 = vals[t3];
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof t3 !== "number")
          return H.iae(t3);
        return (1 - t) * t5 + t * t3;
      }
    }
    $.Log.call$2(3, "Fatal logic error in InterpolateSpectrumSamples()");
    return 0;
  },
  SphericalHarmonics_Evaluate: function(w, lmax, out, outIndex) {
    var t1, t2, Klm, l, m, t3, t4, t5, t6, sins, coss, xyLen, i, sqrt2, t7, t8, t9;
    t1 = J.getInterceptor$n(lmax);
    if (t1.$gt(lmax, 28))
      $.Log.call$2(3, "SHEvaluate() runs out of numerical precision for lmax > 28.If you need more bands, try recompiling using doubles.");
    t2 = J.getInterceptor$x(w);
    G.SphericalHarmonics__legendrep(t2.get$z(w), lmax, out, outIndex);
    t1 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
    if (typeof t1 !== "number")
      return H.iae(t1);
    Klm = Array(t1);
    Klm.$builtinTypeInfo = [J.JSDouble];
    if (typeof lmax !== "number")
      return H.iae(lmax);
    t1 = Klm.length;
    l = 0;
    for (; l <= lmax; ++l)
      for (m = -l, t3 = l * l + l, t4 = (2 * l + 1) * 0.07957747154594767; m <= l; ++m) {
        t5 = t3 + m;
        t6 = G.SphericalHarmonics__divfact(l, m);
        t6 = Math.sqrt(t4 * t6);
        if (t5 < 0 || t5 >= t1)
          return H.ioore(Klm, t5);
        Klm[t5] = t6;
      }
    t3 = lmax + 1;
    sins = Array(t3);
    sins.$builtinTypeInfo = [J.JSDouble];
    coss = Array(t3);
    coss.$builtinTypeInfo = [J.JSDouble];
    t4 = J.$mul$ns(t2.get$z(w), t2.get$z(w));
    if (typeof t4 !== "number")
      return H.iae(t4);
    t4 = P.max(0, 1 - t4);
    xyLen = Math.sqrt(t4);
    if (xyLen === 0) {
      for (t2 = sins.length, i = 0; i <= lmax; ++i) {
        if (i >= t2)
          return H.ioore(sins, i);
        sins[i] = 0;
      }
      for (t2 = coss.length, i = 0; i <= lmax; ++i) {
        if (i >= t2)
          return H.ioore(coss, i);
        coss[i] = 1;
      }
    } else
      G.SphericalHarmonics__sinCosIndexed(J.$div$n(t2.get$y(w), xyLen), J.$div$n(t2.get$x(w), xyLen), t3, sins, coss);
    sqrt2 = Math.sqrt(2);
    for (t2 = coss.length, t3 = sins.length, l = 0; l <= lmax; ++l) {
      for (m = -l, t4 = l * l + l, t5 = out.length; m < 0; ++m) {
        t6 = t4 + m;
        if (t6 < 0 || t6 >= t1)
          return H.ioore(Klm, t6);
        t7 = Klm[t6];
        if (typeof t7 !== "number")
          return H.iae(t7);
        t8 = -m;
        t9 = t4 + t8;
        if (t9 < 0 || t9 >= t5)
          return H.ioore(out, t9);
        t9 = out[t9];
        if (typeof t9 !== "number")
          return H.iae(t9);
        if (t8 < 0 || t8 >= t3)
          return H.ioore(sins, t8);
        t8 = sins[t8];
        if (typeof t8 !== "number")
          return H.iae(t8);
        if (t6 >= t5)
          return H.ioore(out, t6);
        out[t6] = sqrt2 * t7 * t9 * t8;
      }
      if (t4 >= t5)
        return H.ioore(out, t4);
      t5 = out[t4];
      if (t4 >= t1)
        return H.ioore(Klm, t4);
      t5 = J.$mul$ns(t5, Klm[t4]);
      t6 = out.length;
      if (t4 >= t6)
        return H.ioore(out, t4);
      out[t4] = t5;
      for (t5 = t6, m = 1; m <= l; ++m, t5 = t7) {
        t6 = t4 + m;
        if (t6 >= t5)
          return H.ioore(out, t6);
        t5 = out[t6];
        if (t6 >= t1)
          return H.ioore(Klm, t6);
        t7 = Klm[t6];
        if (typeof t7 !== "number")
          return H.iae(t7);
        if (m >= t2)
          return H.ioore(coss, m);
        t8 = coss[m];
        if (typeof t8 !== "number")
          return H.iae(t8);
        t8 = J.$mul$ns(t5, sqrt2 * t7 * t8);
        t7 = out.length;
        if (t6 >= t7)
          return H.ioore(out, t6);
        out[t6] = t8;
      }
    }
  },
  SphericalHarmonics_ProjectCube: function(func, p, res, lmax, coeffs) {
    var t1, t2, Ylm, t3, t4, u, fu, v, fv, w, f, t5, t6, dA, k, t7;
    t1 = J.getInterceptor$ns(lmax);
    t2 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
    if (typeof t2 !== "number")
      return H.iae(t2);
    Ylm = H.setRuntimeTypeInfo(Array(t2), [J.JSDouble]);
    for (t2 = coeffs.length, t3 = Ylm.length, t4 = 4 / (res * res), u = 0; u < res; ++u) {
      fu = -1 + 2 * (u + 0.5) / res;
      for (v = 0; v < res; ++v) {
        fv = -1 + 2 * (v + 0.5) / res;
        w = new G.Vector(fu, fv, 1);
        G.SphericalHarmonics_Evaluate(w.$div(0, w.length$0(0)), lmax, Ylm, 0);
        f = func.call$4(u, v, p, w);
        t5 = w.x;
        t5 = J.$mul$ns(t5, t5);
        t6 = w.y;
        t6 = J.$add$ns(t5, J.$mul$ns(t6, t6));
        t5 = w.z;
        t5 = J.$add$ns(t6, J.$mul$ns(t5, t5));
        if (typeof t5 !== "number")
          H.throwExpression(P.ArgumentError$(t5));
        dA = 1 / Math.pow(t5, 1.5);
        t5 = J.getInterceptor$ns(f);
        k = 0;
        while (true) {
          t6 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
          if (typeof t6 !== "number")
            return H.iae(t6);
          if (!(k < t6))
            break;
          if (k >= t2)
            return H.ioore(coeffs, k);
          t6 = coeffs[k];
          t7 = t5.$mul(f, dA);
          if (k >= t3)
            return H.ioore(Ylm, k);
          coeffs[k] = J.$add$ns(t6, J.$mul$ns(J.$mul$ns(t7, Ylm[k]), t4));
          ++k;
        }
        w = new G.Vector(fu, fv, -1);
        G.SphericalHarmonics_Evaluate(w.$div(0, w.length$0(0)), lmax, Ylm, 0);
        f = func.call$4(u, v, p, w);
        t5 = J.getInterceptor$ns(f);
        k = 0;
        while (true) {
          t6 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
          if (typeof t6 !== "number")
            return H.iae(t6);
          if (!(k < t6))
            break;
          if (k >= t2)
            return H.ioore(coeffs, k);
          t6 = coeffs[k];
          if (k >= t3)
            return H.ioore(Ylm, k);
          coeffs[k] = J.$add$ns(t6, J.$mul$ns(J.$mul$ns(t5.$mul(f, Ylm[k]), dA), t4));
          ++k;
        }
        w = new G.Vector(fu, 1, fv);
        G.SphericalHarmonics_Evaluate(w.$div(0, w.length$0(0)), lmax, Ylm, 0);
        f = func.call$4(u, v, p, w);
        t5 = J.getInterceptor$ns(f);
        k = 0;
        while (true) {
          t6 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
          if (typeof t6 !== "number")
            return H.iae(t6);
          if (!(k < t6))
            break;
          if (k >= t2)
            return H.ioore(coeffs, k);
          t6 = coeffs[k];
          if (k >= t3)
            return H.ioore(Ylm, k);
          coeffs[k] = J.$add$ns(t6, J.$mul$ns(J.$mul$ns(t5.$mul(f, Ylm[k]), dA), t4));
          ++k;
        }
        w = new G.Vector(fu, -1, fv);
        G.SphericalHarmonics_Evaluate(w.$div(0, w.length$0(0)), lmax, Ylm, 0);
        f = func.call$4(u, v, p, w);
        t5 = J.getInterceptor$ns(f);
        k = 0;
        while (true) {
          t6 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
          if (typeof t6 !== "number")
            return H.iae(t6);
          if (!(k < t6))
            break;
          if (k >= t2)
            return H.ioore(coeffs, k);
          t6 = coeffs[k];
          if (k >= t3)
            return H.ioore(Ylm, k);
          coeffs[k] = J.$add$ns(t6, J.$mul$ns(J.$mul$ns(t5.$mul(f, Ylm[k]), dA), t4));
          ++k;
        }
        w = new G.Vector(1, fu, fv);
        G.SphericalHarmonics_Evaluate(w.$div(0, w.length$0(0)), lmax, Ylm, 0);
        f = func.call$4(u, v, p, w);
        t5 = J.getInterceptor$ns(f);
        k = 0;
        while (true) {
          t6 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
          if (typeof t6 !== "number")
            return H.iae(t6);
          if (!(k < t6))
            break;
          if (k >= t2)
            return H.ioore(coeffs, k);
          t6 = coeffs[k];
          if (k >= t3)
            return H.ioore(Ylm, k);
          coeffs[k] = J.$add$ns(t6, J.$mul$ns(J.$mul$ns(t5.$mul(f, Ylm[k]), dA), t4));
          ++k;
        }
        w = new G.Vector(-1, fu, fv);
        G.SphericalHarmonics_Evaluate(w.$div(0, w.length$0(0)), lmax, Ylm, 0);
        f = func.call$4(u, v, p, w);
        t5 = J.getInterceptor$ns(f);
        k = 0;
        while (true) {
          t6 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
          if (typeof t6 !== "number")
            return H.iae(t6);
          if (!(k < t6))
            break;
          if (k >= t2)
            return H.ioore(coeffs, k);
          t6 = coeffs[k];
          if (k >= t3)
            return H.ioore(Ylm, k);
          coeffs[k] = J.$add$ns(t6, J.$mul$ns(J.$mul$ns(t5.$mul(f, Ylm[k]), dA), t4));
          ++k;
        }
      }
    }
  },
  SphericalHarmonics_ProjectIncidentDirectRadiance: function(p, pEpsilon, time, scene, computeLightVisibility, lmax, rng, c_d) {
    var t1, t2, c, len, i, j, t3;
    t1 = J.getInterceptor$ns(lmax);
    t2 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
    if (typeof t2 !== "number")
      return H.iae(t2);
    c = H.setRuntimeTypeInfo(Array(t2), [G.Spectrum]);
    for (len = c.length, i = 0; i < len; ++i)
      c[i] = G.Spectrum_Spectrum(0);
    for (t2 = scene.lights, i = 0; i < t2.length; ++i) {
      t2[i].shProject$8(p, pEpsilon, lmax, scene, computeLightVisibility, time, rng, c);
      j = 0;
      while (true) {
        t3 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(j < t3))
          break;
        if (j >= c_d.length)
          return H.ioore(c_d, j);
        t3 = c_d[j];
        if (j >= len)
          return H.ioore(c, j);
        c_d[j] = J.$add$ns(t3, c[j]);
        ++j;
      }
    }
    G.SphericalHarmonics_ReduceRinging(c_d, lmax, 0.005);
  },
  SphericalHarmonics_ReduceRinging: function(c, lmax, lambda) {
    var l, l0, scale, m, t1, t2;
    if (typeof lmax !== "number")
      return H.iae(lmax);
    l = 0;
    for (; l <= lmax; l = l0) {
      l0 = l + 1;
      scale = 1 / (1 + lambda * l * l * l0 * l0);
      for (m = -l, t1 = l * l + l; m <= l; ++m) {
        t2 = t1 + m;
        if (t2 < 0 || t2 >= c.length)
          return H.ioore(c, t2);
        J.scale$1$x(c[t2], scale);
      }
    }
  },
  SphericalHarmonics_RotateZ: function(c_in, c_out, alpha, lmax) {
    var t1, t2, t3, t4, ct, st, t5, l, m, t6, t7, t8, t9;
    t1 = c_out.length;
    if (0 >= t1)
      return H.ioore(c_out, 0);
    t2 = c_out[0];
    t3 = c_in.length;
    if (0 >= t3)
      return H.ioore(c_in, 0);
    t2.copy$1(c_in[0]);
    t2 = J.getInterceptor(lmax);
    if (t2.$eq(lmax, 0))
      return;
    t4 = t2.$add(lmax, 1);
    if (typeof t4 !== "number")
      return H.iae(t4);
    ct = H.setRuntimeTypeInfo(Array(t4), [J.JSDouble]);
    t4 = t2.$add(lmax, 1);
    if (typeof t4 !== "number")
      return H.iae(t4);
    st = H.setRuntimeTypeInfo(Array(t4), [J.JSDouble]);
    t4 = typeof alpha !== "number";
    if (t4)
      H.throwExpression(P.ArgumentError$(alpha));
    t5 = Math.sin(alpha);
    if (t4)
      H.throwExpression(P.ArgumentError$(alpha));
    G.SphericalHarmonics__sinCosIndexed(t5, Math.cos(alpha), t2.$add(lmax, 1), st, ct);
    if (typeof lmax !== "number")
      return H.iae(lmax);
    t2 = ct.length;
    t4 = st.length;
    l = 1;
    for (; l <= lmax; ++l) {
      for (m = -l, t5 = l * l + l; m < 0; ++m) {
        t6 = t5 + m;
        if (t6 < 0 || t6 >= t3)
          return H.ioore(c_in, t6);
        t7 = c_in[t6];
        t8 = -m;
        if (t8 < 0 || t8 >= t2)
          return H.ioore(ct, t8);
        t7 = J.$mul$ns(t7, ct[t8]);
        t9 = t5 + t8;
        if (t9 >= t3)
          return H.ioore(c_in, t9);
        t9 = c_in[t9];
        if (t8 >= t4)
          return H.ioore(st, t8);
        t8 = J.$add$ns(t7, J.$mul$ns(t9, J.$negate$n(st[t8])));
        if (t6 >= t1)
          return H.ioore(c_out, t6);
        c_out[t6] = t8;
      }
      if (t5 >= t1)
        return H.ioore(c_out, t5);
      t6 = c_out[t5];
      if (t5 >= t3)
        return H.ioore(c_in, t5);
      t6.copy$1(c_in[t5]);
      for (m = 1; m <= l; ++m) {
        t6 = t5 + m;
        if (t6 >= t3)
          return H.ioore(c_in, t6);
        t7 = c_in[t6];
        if (m >= t2)
          return H.ioore(ct, m);
        t7 = J.$mul$ns(t7, ct[m]);
        t8 = t5 + -m;
        if (t8 < 0 || t8 >= t3)
          return H.ioore(c_in, t8);
        t8 = c_in[t8];
        if (m >= t4)
          return H.ioore(st, m);
        t8 = J.$add$ns(t7, J.$mul$ns(t8, st[m]));
        if (t6 >= t1)
          return H.ioore(c_out, t6);
        c_out[t6] = t8;
      }
    }
  },
  SphericalHarmonics_RotateXMinus: function(c_in, c_out, lmax) {
    var t1, l, s, t2, m, t3;
    G.SphericalHarmonics_RotateXPlus(c_in, c_out, lmax);
    if (typeof lmax !== "number")
      return H.iae(lmax);
    t1 = c_out.length;
    l = 1;
    for (; l <= lmax; ++l) {
      s = (l & 1) !== 0 ? -1 : 1;
      t2 = l * l + l;
      if (t2 >= t1)
        return H.ioore(c_out, t2);
      J.scale$1$x(c_out[t2], s);
      for (m = 1; m <= l; ++m) {
        s = -s;
        t3 = t2 + m;
        if (t3 >= t1)
          return H.ioore(c_out, t3);
        J.scale$1$x(c_out[t3], s);
        t3 = t2 + -m;
        if (t3 < 0 || t3 >= t1)
          return H.ioore(c_out, t3);
        J.scale$1$x(c_out[t3], -s);
      }
    }
  },
  SphericalHarmonics_RotateXPlus: function(c_in, c_out, lmax) {
    var t1, t2, t3, t4;
    t1 = new G.SphericalHarmonics_RotateXPlus_O(c_in);
    if (0 >= c_in.length)
      return H.ioore(c_in, 0);
    t2 = c_in[0];
    t3 = c_out.length;
    if (0 >= t3)
      return H.ioore(c_out, 0);
    c_out[0] = t2;
    t2 = J.getInterceptor$n(lmax);
    if (t2.$lt(lmax, 1))
      return;
    t4 = t1.call$2(1, 0);
    if (1 >= t3)
      return H.ioore(c_out, 1);
    c_out[1] = t4;
    t4 = J.$negate$n(t1.call$2(1, -1));
    if (2 >= t3)
      return H.ioore(c_out, 2);
    c_out[2] = t4;
    t4 = t1.call$2(1, 1);
    if (3 >= t3)
      return H.ioore(c_out, 3);
    c_out[3] = t4;
    if (t2.$lt(lmax, 2))
      return;
    t4 = t1.call$2(2, 1);
    if (4 >= t3)
      return H.ioore(c_out, 4);
    c_out[4] = t4;
    t4 = J.$negate$n(t1.call$2(2, -1));
    if (5 >= t3)
      return H.ioore(c_out, 5);
    c_out[5] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(2, 0), -0.5), J.$mul$ns(t1.call$2(2, 2), -0.8660254037844386));
    if (6 >= t3)
      return H.ioore(c_out, 6);
    c_out[6] = t4;
    t4 = J.$negate$n(t1.call$2(2, -2));
    if (7 >= t3)
      return H.ioore(c_out, 7);
    c_out[7] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(2, 0), -0.8660254037844386), J.$mul$ns(t1.call$2(2, 2), 0.5));
    if (8 >= t3)
      return H.ioore(c_out, 8);
    c_out[8] = t4;
    if (t2.$lt(lmax, 3))
      return;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(3, 0), -0.7905694150420949), J.$mul$ns(t1.call$2(3, 2), 0.6123724356957945));
    if (9 >= t3)
      return H.ioore(c_out, 9);
    c_out[9] = t4;
    t4 = J.$negate$n(t1.call$2(3, -2));
    if (10 >= t3)
      return H.ioore(c_out, 10);
    c_out[10] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(3, 0), -0.6123724356957945), J.$mul$ns(t1.call$2(3, 2), -0.7905694150420949));
    if (11 >= t3)
      return H.ioore(c_out, 11);
    c_out[11] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(3, -3), 0.7905694150420949), J.$mul$ns(t1.call$2(3, -1), 0.6123724356957945));
    if (12 >= t3)
      return H.ioore(c_out, 12);
    c_out[12] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(3, 1), -0.25), J.$mul$ns(t1.call$2(3, 3), -0.9682458365518543));
    if (13 >= t3)
      return H.ioore(c_out, 13);
    c_out[13] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(3, -3), -0.6123724356957945), J.$mul$ns(t1.call$2(3, -1), 0.7905694150420949));
    if (14 >= t3)
      return H.ioore(c_out, 14);
    c_out[14] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(3, 1), -0.9682458365518543), J.$mul$ns(t1.call$2(3, 3), 0.25));
    if (15 >= t3)
      return H.ioore(c_out, 15);
    c_out[15] = t4;
    if (t2.$lt(lmax, 4))
      return;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(4, 1), -0.9354143466934853), J.$mul$ns(t1.call$2(4, 3), 0.35355339059327373));
    if (16 >= t3)
      return H.ioore(c_out, 16);
    c_out[16] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(4, -3), -0.75), J.$mul$ns(t1.call$2(4, -1), 0.6614378277661477));
    if (17 >= t3)
      return H.ioore(c_out, 17);
    c_out[17] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(4, 1), -0.35355339059327373), J.$mul$ns(t1.call$2(4, 3), -0.9354143466934853));
    if (18 >= t3)
      return H.ioore(c_out, 18);
    c_out[18] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(4, -3), 0.6614378277661477), J.$mul$ns(t1.call$2(4, -1), 0.75));
    if (19 >= t3)
      return H.ioore(c_out, 19);
    c_out[19] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(4, 0), 0.375), J.$mul$ns(t1.call$2(4, 2), 0.5590169943749475)), J.$mul$ns(t1.call$2(4, 4), 0.739509972887452));
    if (20 >= t3)
      return H.ioore(c_out, 20);
    c_out[20] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(4, -4), 0.9354143466934853), J.$mul$ns(t1.call$2(4, -2), 0.35355339059327373));
    if (21 >= t3)
      return H.ioore(c_out, 21);
    c_out[21] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(4, 0), 0.5590169943749475), J.$mul$ns(t1.call$2(4, 2), 0.5)), J.$mul$ns(t1.call$2(4, 4), -0.6614378277661477));
    if (22 >= t3)
      return H.ioore(c_out, 22);
    c_out[22] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(4, -4), -0.35355339059327373), J.$mul$ns(t1.call$2(4, -2), 0.9354143466934853));
    if (23 >= t3)
      return H.ioore(c_out, 23);
    c_out[23] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(4, 0), 0.739509972887452), J.$mul$ns(t1.call$2(4, 2), -0.6614378277661477)), J.$mul$ns(t1.call$2(4, 4), 0.125));
    if (24 >= t3)
      return H.ioore(c_out, 24);
    c_out[24] = t4;
    if (t2.$lt(lmax, 5))
      return;
    t4 = J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(5, 0), 0.701560760020114), J.$mul$ns(t1.call$2(5, 2), 0.6846531968814576)), J.$mul$ns(t1.call$2(5, 4), 0.19764235376052372));
    if (25 >= t3)
      return H.ioore(c_out, 25);
    c_out[25] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(5, -4), -0.5), J.$mul$ns(t1.call$2(5, -2), 0.8660254037844386));
    if (26 >= t3)
      return H.ioore(c_out, 26);
    c_out[26] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(5, 0), 0.5229125165837972), J.$mul$ns(t1.call$2(5, 2), 0.30618621784789724)), J.$mul$ns(t1.call$2(5, 4), 0.795495128834866));
    if (27 >= t3)
      return H.ioore(c_out, 27);
    c_out[27] = t4;
    t4 = J.$add$ns(J.$mul$ns(t1.call$2(5, -4), 0.8660254037844386), J.$mul$ns(t1.call$2(5, -2), 0.5));
    if (28 >= t3)
      return H.ioore(c_out, 28);
    c_out[28] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(5, 0), 0.4841229182759271), J.$mul$ns(t1.call$2(5, 2), 0.6614378277661477)), J.$mul$ns(t1.call$2(5, 4), 0.57282196186948));
    if (29 >= t3)
      return H.ioore(c_out, 29);
    c_out[29] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(5, -5), -0.701560760020114), J.$mul$ns(t1.call$2(5, -3), 0.5229125165837972)), J.$mul$ns(t1.call$2(5, -1), 0.4841229182759271));
    if (30 >= t3)
      return H.ioore(c_out, 30);
    c_out[30] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(5, 1), 0.125), J.$mul$ns(t1.call$2(5, 3), 0.4050462936504913)), J.$mul$ns(t1.call$2(5, 5), 0.9057110466368399));
    if (31 >= t3)
      return H.ioore(c_out, 31);
    c_out[31] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(5, -5), 0.6846531968814576), J.$mul$ns(t1.call$2(5, -3), 0.30618621784789724)), J.$mul$ns(t1.call$2(5, -1), 0.6614378277661477));
    if (32 >= t3)
      return H.ioore(c_out, 32);
    c_out[32] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(5, 1), 0.4050462936504913), J.$mul$ns(t1.call$2(5, 3), 0.8125)), J.$mul$ns(t1.call$2(5, 5), 0.4192627457812106));
    if (33 >= t3)
      return H.ioore(c_out, 33);
    c_out[33] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(5, -5), -0.19764235376052372), J.$mul$ns(t1.call$2(5, -3), 0.795495128834866)), J.$mul$ns(t1.call$2(5, -1), 0.57282196186948));
    if (34 >= t3)
      return H.ioore(c_out, 34);
    c_out[34] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(5, 1), 0.9057110466368399), J.$mul$ns(t1.call$2(5, 3), 0.4192627457812106)), J.$mul$ns(t1.call$2(5, 5), 0.0625));
    if (35 >= t3)
      return H.ioore(c_out, 35);
    c_out[35] = t4;
    if (t2.$lt(lmax, 6))
      return;
    t4 = J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(6, 1), 0.879452954966893), J.$mul$ns(t1.call$2(6, 3), 0.46351240544347894)), J.$mul$ns(t1.call$2(6, 5), 0.10825317547305482));
    if (36 >= t3)
      return H.ioore(c_out, 36);
    c_out[36] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(6, -5), -0.3125), J.$mul$ns(t1.call$2(6, -3), 0.8028270361665706)), J.$mul$ns(t1.call$2(6, -1), 0.5077524002897476));
    if (37 >= t3)
      return H.ioore(c_out, 37);
    c_out[37] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(6, 1), 0.4330127018922193), J.$mul$ns(t1.call$2(6, 3), 0.6846531968814576)), J.$mul$ns(t1.call$2(6, 5), 0.5863019699779287));
    if (38 >= t3)
      return H.ioore(c_out, 38);
    c_out[38] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(6, -5), 0.8028270361665706), J.$mul$ns(t1.call$2(6, -3), 0.0625)), J.$mul$ns(t1.call$2(6, -1), 0.5929270612815711));
    if (39 >= t3)
      return H.ioore(c_out, 39);
    c_out[39] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(6, 1), 0.19764235376052372), J.$mul$ns(t1.call$2(6, 3), 0.5625)), J.$mul$ns(t1.call$2(6, 5), 0.8028270361665706));
    if (40 >= t3)
      return H.ioore(c_out, 40);
    c_out[40] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(6, -5), -0.5077524002897476), J.$mul$ns(t1.call$2(6, -3), 0.5929270612815711)), J.$mul$ns(t1.call$2(6, -1), 0.625));
    if (41 >= t3)
      return H.ioore(c_out, 41);
    c_out[41] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(6, 0), -0.3125), J.$mul$ns(t1.call$2(6, 2), 0.45285552331841994)), J.$mul$ns(t1.call$2(6, 4), 0.49607837082461076)), J.$mul$ns(t1.call$2(6, 6), 0.6716932893813962));
    if (42 >= t3)
      return H.ioore(c_out, 42);
    c_out[42] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(6, -6), -0.879452954966893), J.$mul$ns(t1.call$2(6, -4), 0.4330127018922193)), J.$mul$ns(t1.call$2(6, -2), 0.19764235376052372));
    if (43 >= t3)
      return H.ioore(c_out, 43);
    c_out[43] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(6, 0), -0.45285552331841994), J.$mul$ns(t1.call$2(6, 2), 0.53125)), J.$mul$ns(t1.call$2(6, 4), 0.1711632992203644)), J.$mul$ns(t1.call$2(6, 6), 0.6952686081652184));
    if (44 >= t3)
      return H.ioore(c_out, 44);
    c_out[44] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(6, -6), 0.46351240544347894), J.$mul$ns(t1.call$2(6, -4), 0.6846531968814576)), J.$mul$ns(t1.call$2(6, -2), 0.5625));
    if (45 >= t3)
      return H.ioore(c_out, 45);
    c_out[45] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(6, 0), -0.49607837082461076), J.$mul$ns(t1.call$2(6, 2), 0.1711632992203644)), J.$mul$ns(t1.call$2(6, 4), 0.8125)), J.$mul$ns(t1.call$2(6, 6), 0.2538762001448738));
    if (46 >= t3)
      return H.ioore(c_out, 46);
    c_out[46] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(6, -6), -0.10825317547305482), J.$mul$ns(t1.call$2(6, -4), 0.5863019699779287)), J.$mul$ns(t1.call$2(6, -2), 0.8028270361665706));
    if (47 >= t3)
      return H.ioore(c_out, 47);
    c_out[47] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(6, 0), -0.6716932893813962), J.$mul$ns(t1.call$2(6, 2), 0.6952686081652184)), J.$mul$ns(t1.call$2(6, 4), 0.2538762001448738)), J.$mul$ns(t1.call$2(6, 6), 0.03125));
    if (48 >= t3)
      return H.ioore(c_out, 48);
    c_out[48] = t4;
    if (t2.$lt(lmax, 7))
      return;
    t4 = J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(7, 0), -0.6472598492877494), J.$mul$ns(t1.call$2(7, 2), 0.6991205412874092)), J.$mul$ns(t1.call$2(7, 4), 0.2981060004427955)), J.$mul$ns(t1.call$2(7, 6), 0.05846339666834283));
    if (49 >= t3)
      return H.ioore(c_out, 49);
    c_out[49] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(7, -6), -0.1875), J.$mul$ns(t1.call$2(7, -4), 0.6373774391990981)), J.$mul$ns(t1.call$2(7, -2), 0.7473912964438374));
    if (50 >= t3)
      return H.ioore(c_out, 50);
    c_out[50] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(7, 0), -0.47495887979908324), J.$mul$ns(t1.call$2(7, 2), 0.07328774624724109)), J.$mul$ns(t1.call$2(7, 4), 0.78125)), J.$mul$ns(t1.call$2(7, 6), 0.3983608994994363));
    if (51 >= t3)
      return H.ioore(c_out, 51);
    c_out[51] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(7, -6), 0.6373774391990981), J.$mul$ns(t1.call$2(7, -4), 0.5)), J.$mul$ns(t1.call$2(7, -2), 0.5863019699779287));
    if (52 >= t3)
      return H.ioore(c_out, 52);
    c_out[52] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(7, 0), -0.42961647140211), J.$mul$ns(t1.call$2(7, 2), 0.41984465132951254)), J.$mul$ns(t1.call$2(7, 4), 0.10364452469860624)), J.$mul$ns(t1.call$2(7, 6), 0.7927281808728639));
    if (53 >= t3)
      return H.ioore(c_out, 53);
    c_out[53] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(7, -6), -0.7473912964438374), J.$mul$ns(t1.call$2(7, -4), 0.5863019699779287)), J.$mul$ns(t1.call$2(7, -2), 0.3125));
    if (54 >= t3)
      return H.ioore(c_out, 54);
    c_out[54] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(7, 0), -0.41339864235384227), J.$mul$ns(t1.call$2(7, 2), 0.5740991584648073)), J.$mul$ns(t1.call$2(7, 4), 0.5385527481129402)), J.$mul$ns(t1.call$2(7, 6), 0.4576818286211503));
    if (55 >= t3)
      return H.ioore(c_out, 55);
    c_out[55] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(7, -7), 0.6472598492877494), J.$mul$ns(t1.call$2(7, -5), 0.47495887979908324)), J.$mul$ns(t1.call$2(7, -3), 0.42961647140211)), J.$mul$ns(t1.call$2(7, -1), 0.41339864235384227));
    if (56 >= t3)
      return H.ioore(c_out, 56);
    c_out[56] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(7, 1), -0.078125), J.$mul$ns(t1.call$2(7, 3), 0.24356964481437335)), J.$mul$ns(t1.call$2(7, 5), 0.4487939567607835)), J.$mul$ns(t1.call$2(7, 7), 0.8562442974262661));
    if (57 >= t3)
      return H.ioore(c_out, 57);
    c_out[57] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(7, -7), -0.6991205412874092), J.$mul$ns(t1.call$2(7, -5), 0.07328774624724109)), J.$mul$ns(t1.call$2(7, -3), 0.41984465132951254)), J.$mul$ns(t1.call$2(7, -1), 0.5740991584648073));
    if (58 >= t3)
      return H.ioore(c_out, 58);
    c_out[58] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(7, 1), -0.24356964481437335), J.$mul$ns(t1.call$2(7, 3), 0.609375)), J.$mul$ns(t1.call$2(7, 5), 0.5700448858423344)), J.$mul$ns(t1.call$2(7, 7), 0.4943528756111367));
    if (59 >= t3)
      return H.ioore(c_out, 59);
    c_out[59] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(7, -7), 0.2981060004427955), J.$mul$ns(t1.call$2(7, -5), 0.78125)), J.$mul$ns(t1.call$2(7, -3), 0.10364452469860624)), J.$mul$ns(t1.call$2(7, -1), 0.5385527481129402));
    if (60 >= t3)
      return H.ioore(c_out, 60);
    c_out[60] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(7, 1), -0.4487939567607835), J.$mul$ns(t1.call$2(7, 3), 0.5700448858423344)), J.$mul$ns(t1.call$2(7, 5), 0.671875)), J.$mul$ns(t1.call$2(7, 7), 0.14905300022139775));
    if (61 >= t3)
      return H.ioore(c_out, 61);
    c_out[61] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(7, -7), -0.05846339666834283), J.$mul$ns(t1.call$2(7, -5), 0.3983608994994363)), J.$mul$ns(t1.call$2(7, -3), 0.7927281808728639)), J.$mul$ns(t1.call$2(7, -1), 0.4576818286211503));
    if (62 >= t3)
      return H.ioore(c_out, 62);
    c_out[62] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(7, 1), -0.8562442974262661), J.$mul$ns(t1.call$2(7, 3), 0.4943528756111367)), J.$mul$ns(t1.call$2(7, 5), 0.14905300022139775)), J.$mul$ns(t1.call$2(7, 7), 0.015625));
    if (63 >= t3)
      return H.ioore(c_out, 63);
    c_out[63] = t4;
    if (t2.$lt(lmax, 8))
      return;
    t4 = J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(8, 1), -0.8356088723200586), J.$mul$ns(t1.call$2(8, 3), 0.516334738808072)), J.$mul$ns(t1.call$2(8, 5), 0.184877493221863)), J.$mul$ns(t1.call$2(8, 7), 0.03125));
    if (64 >= t3)
      return H.ioore(c_out, 64);
    c_out[64] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(8, -7), -0.109375), J.$mul$ns(t1.call$2(8, -5), 0.4621937330546575)), J.$mul$ns(t1.call$2(8, -3), 0.774502108212108)), J.$mul$ns(t1.call$2(8, -1), 0.4178044361600293));
    if (65 >= t3)
      return H.ioore(c_out, 65);
    c_out[65] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(8, 1), -0.4576818286211503), J.$mul$ns(t1.call$2(8, 3), 0.47134697278119864)), J.$mul$ns(t1.call$2(8, 5), 0.7088310138883598)), J.$mul$ns(t1.call$2(8, 7), 0.2567449488305466));
    if (66 >= t3)
      return H.ioore(c_out, 66);
    c_out[66] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(8, -7), 0.4621937330546575), J.$mul$ns(t1.call$2(8, -5), 0.703125)), J.$mul$ns(t1.call$2(8, -3), 0.2181912506838897)), J.$mul$ns(t1.call$2(8, -1), 0.4943528756111367));
    if (67 >= t3)
      return H.ioore(c_out, 67);
    c_out[67] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(8, 1), -0.27421763710600383), J.$mul$ns(t1.call$2(8, 3), 0.6051536478449089)), J.$mul$ns(t1.call$2(8, 5), 0.33802043207474897)), J.$mul$ns(t1.call$2(8, 7), 0.6665852814906732));
    if (68 >= t3)
      return H.ioore(c_out, 68);
    c_out[68] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(8, -7), -0.774502108212108), J.$mul$ns(t1.call$2(8, -5), 0.2181912506838897)), J.$mul$ns(t1.call$2(8, -3), 0.265625)), J.$mul$ns(t1.call$2(8, -1), 0.5310201708739509));
    if (69 >= t3)
      return H.ioore(c_out, 69);
    c_out[69] = t4;
    t4 = J.$sub$n(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(8, 1), -0.1307281291459493), J.$mul$ns(t1.call$2(8, 3), 0.38081430021731066)), J.$mul$ns(t1.call$2(8, 5), 0.5908647000371574)), J.$mul$ns(t1.call$2(8, 7), 0.6991205412874092));
    if (70 >= t3)
      return H.ioore(c_out, 70);
    c_out[70] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(8, -7), 0.4178044361600293), J.$mul$ns(t1.call$2(8, -5), 0.4943528756111367)), J.$mul$ns(t1.call$2(8, -3), 0.5310201708739509)), J.$mul$ns(t1.call$2(8, -1), 0.546875));
    if (71 >= t3)
      return H.ioore(c_out, 71);
    c_out[71] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(8, 0), 0.2734375), J.$mul$ns(t1.call$2(8, 2), 0.3921843874378479)), J.$mul$ns(t1.call$2(8, 4), 0.4113264556590057)), J.$mul$ns(t1.call$2(8, 6), 0.4576818286211503)), J.$mul$ns(t1.call$2(8, 8), 0.626706654240044));
    if (72 >= t3)
      return H.ioore(c_out, 72);
    c_out[72] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(8, -8), 0.8356088723200586), J.$mul$ns(t1.call$2(8, -6), 0.4576818286211503)), J.$mul$ns(t1.call$2(8, -4), 0.27421763710600383)), J.$mul$ns(t1.call$2(8, -2), 0.1307281291459493));
    if (73 >= t3)
      return H.ioore(c_out, 73);
    c_out[73] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(8, 0), 0.3921843874378479), J.$mul$ns(t1.call$2(8, 2), 0.5)), J.$mul$ns(t1.call$2(8, 4), 0.32775276505317236)), J.$mul$ns(t1.call$2(8, 8), 0.6991205412874092));
    if (74 >= t3)
      return H.ioore(c_out, 74);
    c_out[74] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(8, -8), -0.516334738808072), J.$mul$ns(t1.call$2(8, -6), 0.47134697278119864)), J.$mul$ns(t1.call$2(8, -4), 0.6051536478449089)), J.$mul$ns(t1.call$2(8, -2), 0.38081430021731066));
    if (75 >= t3)
      return H.ioore(c_out, 75);
    c_out[75] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(8, 0), 0.4113264556590057), J.$mul$ns(t1.call$2(8, 2), 0.32775276505317236)), J.$mul$ns(t1.call$2(8, 4), 0.28125)), J.$mul$ns(t1.call$2(8, 6), 0.7302075903467452)), J.$mul$ns(t1.call$2(8, 8), 0.3332926407453366));
    if (76 >= t3)
      return H.ioore(c_out, 76);
    c_out[76] = t4;
    t4 = J.$add$ns(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(8, -8), 0.184877493221863), J.$mul$ns(t1.call$2(8, -6), 0.7088310138883598)), J.$mul$ns(t1.call$2(8, -4), 0.33802043207474897)), J.$mul$ns(t1.call$2(8, -2), 0.5908647000371574));
    if (77 >= t3)
      return H.ioore(c_out, 77);
    c_out[77] = t4;
    t4 = J.$sub$n(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(8, 0), 0.4576818286211503), J.$mul$ns(t1.call$2(8, 4), 0.7302075903467452)), J.$mul$ns(t1.call$2(8, 6), 0.5)), J.$mul$ns(t1.call$2(8, 8), 0.0855816496101822));
    if (78 >= t3)
      return H.ioore(c_out, 78);
    c_out[78] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(8, -8), -0.03125), J.$mul$ns(t1.call$2(8, -6), 0.2567449488305466)), J.$mul$ns(t1.call$2(8, -4), 0.6665852814906732)), J.$mul$ns(t1.call$2(8, -2), 0.6991205412874092));
    if (79 >= t3)
      return H.ioore(c_out, 79);
    c_out[79] = t4;
    t4 = J.$add$ns(J.$sub$n(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(8, 0), 0.626706654240044), J.$mul$ns(t1.call$2(8, 2), 0.6991205412874092)), J.$mul$ns(t1.call$2(8, 4), 0.3332926407453366)), J.$mul$ns(t1.call$2(8, 6), 0.0855816496101822)), J.$mul$ns(t1.call$2(8, 8), 0.0078125));
    if (80 >= t3)
      return H.ioore(c_out, 80);
    c_out[80] = t4;
    if (t2.$lt(lmax, 9))
      return;
    t2 = J.$add$ns(J.$sub$n(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(9, 0), 0.6090493921755238), J.$mul$ns(t1.call$2(9, 2), 0.6968469725305549)), J.$mul$ns(t1.call$2(9, 4), 0.3615761395439417)), J.$mul$ns(t1.call$2(9, 6), 0.11158481919598204)), J.$mul$ns(t1.call$2(9, 8), 0.016572815184059706));
    if (81 >= t3)
      return H.ioore(c_out, 81);
    c_out[81] = t2;
    t2 = J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(9, -8), -0.0625), J.$mul$ns(t1.call$2(9, -6), 0.3156095293238149)), J.$mul$ns(t1.call$2(9, -4), 0.6817945071647321)), J.$mul$ns(t1.call$2(9, -2), 0.656993626300895));
    if (82 >= t3)
      return H.ioore(c_out, 82);
    c_out[82] = t2;
    t2 = J.$sub$n(J.$add$ns(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(9, 0), 0.44314852502786806), J.$mul$ns(t1.call$2(9, 2), 0.05633673867912483)), J.$mul$ns(t1.call$2(9, 4), 0.6723290616859425)), J.$mul$ns(t1.call$2(9, 6), 0.5683291712335379)), J.$mul$ns(t1.call$2(9, 8), 0.1594400908746762));
    if (83 >= t3)
      return H.ioore(c_out, 83);
    c_out[83] = t2;
    t2 = J.$add$ns(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(9, -8), 0.3156095293238149), J.$mul$ns(t1.call$2(9, -6), 0.71875)), J.$mul$ns(t1.call$2(9, -4), 0.20252314682524564)), J.$mul$ns(t1.call$2(9, -2), 0.5854685623498499));
    if (84 >= t3)
      return H.ioore(c_out, 84);
    c_out[84] = t2;
    t2 = J.$add$ns(J.$sub$n(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(9, 0), 0.39636409043643195), J.$mul$ns(t1.call$2(9, 2), 0.25194555463432966)), J.$mul$ns(t1.call$2(9, 4), 0.3921843874378479)), J.$mul$ns(t1.call$2(9, 6), 0.6051536478449089)), J.$mul$ns(t1.call$2(9, 8), 0.509312687906457));
    if (85 >= t3)
      return H.ioore(c_out, 85);
    c_out[85] = t2;
    t2 = J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(9, -8), -0.6817945071647321), J.$mul$ns(t1.call$2(9, -6), 0.20252314682524564)), J.$mul$ns(t1.call$2(9, -4), 0.5625)), J.$mul$ns(t1.call$2(9, -2), 0.4215855488510013));
    if (86 >= t3)
      return H.ioore(c_out, 86);
    c_out[86] = t2;
    t2 = J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(9, 0), 0.3754879637718099), J.$mul$ns(t1.call$2(9, 2), 0.42961647140211)), J.$mul$ns(t1.call$2(9, 4), 0.13799626353637262)), J.$mul$ns(t1.call$2(9, 6), 0.2981060004427955)), J.$mul$ns(t1.call$2(9, 8), 0.7526807559068452));
    if (87 >= t3)
      return H.ioore(c_out, 87);
    c_out[87] = t2;
    t2 = J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(9, -8), 0.656993626300895), J.$mul$ns(t1.call$2(9, -6), 0.5854685623498499)), J.$mul$ns(t1.call$2(9, -4), 0.4215855488510013)), J.$mul$ns(t1.call$2(9, -2), 0.21875));
    if (88 >= t3)
      return H.ioore(c_out, 88);
    c_out[88] = t2;
    t2 = J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(9, 0), 0.36685490255855924), J.$mul$ns(t1.call$2(9, 2), 0.5130142237306876)), J.$mul$ns(t1.call$2(9, 4), 0.4943528756111367)), J.$mul$ns(t1.call$2(9, 6), 0.4576818286211503)), J.$mul$ns(t1.call$2(9, 8), 0.38519665736315783));
    if (89 >= t3)
      return H.ioore(c_out, 89);
    c_out[89] = t2;
    t2 = J.$sub$n(J.$sub$n(J.$sub$n(J.$sub$n(J.$mul$ns(t1.call$2(9, -9), -0.6090493921755238), J.$mul$ns(t1.call$2(9, -7), 0.44314852502786806)), J.$mul$ns(t1.call$2(9, -5), 0.39636409043643195)), J.$mul$ns(t1.call$2(9, -3), 0.3754879637718099)), J.$mul$ns(t1.call$2(9, -1), 0.36685490255855924));
    if (90 >= t3)
      return H.ioore(c_out, 90);
    c_out[90] = t2;
    t2 = J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(9, 1), 0.0546875), J.$mul$ns(t1.call$2(9, 3), 0.16792332234534904)), J.$mul$ns(t1.call$2(9, 5), 0.2954323500185787)), J.$mul$ns(t1.call$2(9, 7), 0.4624247721758373)), J.$mul$ns(t1.call$2(9, 9), 0.8171255055356398));
    if (91 >= t3)
      return H.ioore(c_out, 91);
    c_out[91] = t2;
    t2 = J.$sub$n(J.$sub$n(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(9, -9), 0.6968469725305549), J.$mul$ns(t1.call$2(9, -7), 0.05633673867912483)), J.$mul$ns(t1.call$2(9, -5), 0.25194555463432966)), J.$mul$ns(t1.call$2(9, -3), 0.42961647140211)), J.$mul$ns(t1.call$2(9, -1), 0.5130142237306876));
    if (92 >= t3)
      return H.ioore(c_out, 92);
    c_out[92] = t2;
    t2 = J.$sub$n(J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(9, 1), 0.16792332234534904), J.$mul$ns(t1.call$2(9, 3), 0.453125)), J.$mul$ns(t1.call$2(9, 5), 0.577279787559724)), J.$mul$ns(t1.call$2(9, 7), 0.387251054106054)), J.$mul$ns(t1.call$2(9, 9), 0.5322256665703469));
    if (93 >= t3)
      return H.ioore(c_out, 93);
    c_out[93] = t2;
    t2 = J.$sub$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(9, -9), -0.3615761395439417), J.$mul$ns(t1.call$2(9, -7), 0.6723290616859425)), J.$mul$ns(t1.call$2(9, -5), 0.3921843874378479)), J.$mul$ns(t1.call$2(9, -3), 0.13799626353637262)), J.$mul$ns(t1.call$2(9, -1), 0.4943528756111367));
    if (94 >= t3)
      return H.ioore(c_out, 94);
    c_out[94] = t2;
    t2 = J.$add$ns(J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(t1.call$2(9, 1), 0.2954323500185787), J.$mul$ns(t1.call$2(9, 3), 0.577279787559724)), J.$mul$ns(t1.call$2(9, 5), 0.140625)), J.$mul$ns(t1.call$2(9, 7), 0.7162405240429014)), J.$mul$ns(t1.call$2(9, 9), 0.21608307321780204));
    if (95 >= t3)
      return H.ioore(c_out, 95);
    c_out[95] = t2;
    t2 = J.$sub$n(J.$add$ns(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(9, -9), 0.11158481919598204), J.$mul$ns(t1.call$2(9, -7), 0.5683291712335379)), J.$mul$ns(t1.call$2(9, -5), 0.6051536478449089)), J.$mul$ns(t1.call$2(9, -3), 0.2981060004427955)), J.$mul$ns(t1.call$2(9, -1), 0.4576818286211503));
    if (96 >= t3)
      return H.ioore(c_out, 96);
    c_out[96] = t2;
    t2 = J.$sub$n(J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(9, 1), 0.4624247721758373), J.$mul$ns(t1.call$2(9, 3), 0.387251054106054)), J.$mul$ns(t1.call$2(9, 5), 0.7162405240429014)), J.$mul$ns(t1.call$2(9, 7), 0.34765625)), J.$mul$ns(t1.call$2(9, 9), 0.048317644050206957));
    if (97 >= t3)
      return H.ioore(c_out, 97);
    c_out[97] = t2;
    t2 = J.$sub$n(J.$add$ns(J.$sub$n(J.$add$ns(J.$mul$ns(t1.call$2(9, -9), -0.016572815184059706), J.$mul$ns(t1.call$2(9, -7), 0.1594400908746762)), J.$mul$ns(t1.call$2(9, -5), 0.509312687906457)), J.$mul$ns(t1.call$2(9, -3), 0.7526807559068452)), J.$mul$ns(t1.call$2(9, -1), 0.38519665736315783));
    if (98 >= t3)
      return H.ioore(c_out, 98);
    c_out[98] = t2;
    t1 = J.$add$ns(J.$sub$n(J.$add$ns(J.$sub$n(J.$mul$ns(t1.call$2(9, 1), 0.8171255055356398), J.$mul$ns(t1.call$2(9, 3), 0.5322256665703469)), J.$mul$ns(t1.call$2(9, 5), 0.21608307321780204)), J.$mul$ns(t1.call$2(9, 7), 0.048317644050206957)), J.$mul$ns(t1.call$2(9, 9), 0.00390625));
    if (99 >= t3)
      return H.ioore(c_out, 99);
    c_out[99] = t1;
  },
  SphericalHarmonics_ComputeDiffuseTransfer: function(p, n, rayEpsilon, scene, rng, nSamples, lmax, c_transfer) {
    var scramble, t1, t2, Ylm, u, t3, t4, t5, t6, i, t7, w, t8, hit, len, j;
    scramble = [rng.randomUInt$0(), rng.randomUInt$0()];
    t1 = J.getInterceptor$ns(lmax);
    t2 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
    if (typeof t2 !== "number")
      return H.iae(t2);
    Ylm = H.setRuntimeTypeInfo(Array(t2), [J.JSDouble]);
    u = [0, 0];
    for (t2 = J.getInterceptor$x(n), t3 = scene.aggregate, t4 = c_transfer.length, t5 = Ylm.length, t6 = 0.07957747154594767 * nSamples, i = 0; i < nSamples; ++i) {
      u[0] = G.VanDerCorput(i, scramble[0]);
      t7 = G.Sobol2(i, scramble[1]);
      u[1] = t7;
      w = G.UniformSampleSphere(u[0], t7);
      if (J.$gt$n(J.$add$ns(J.$add$ns(J.$mul$ns(w.x, t2.get$x(n)), J.$mul$ns(w.y, t2.get$y(n))), J.$mul$ns(w.z, t2.get$z(n))), 0)) {
        t7 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
        t8 = new G.Vector(w.x, w.y, w.z);
        hit = t3.intersectP$1(new G.Ray(t7, t8, rayEpsilon, 1 / 0, 0, 0));
        t8 = $.get$Stats_shadowRays();
        t8.count = J.$add$ns(t8.count, 1);
        $.Stats_shadowRays = t8;
        t8 = !hit;
        t7 = t8;
      } else
        t7 = false;
      if (t7) {
        G.SphericalHarmonics_Evaluate(w, lmax, Ylm, 0);
        len = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
        if (typeof len !== "number")
          return H.iae(len);
        j = 0;
        for (; j < len; ++j) {
          if (j >= t4)
            return H.ioore(c_transfer, j);
          t7 = c_transfer[j];
          if (j >= t5)
            return H.ioore(Ylm, j);
          c_transfer[j] = J.$add$ns(t7, G.Spectrum_Spectrum(J.$mul$ns(Ylm[j], J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(w.x, t2.get$x(n)), J.$mul$ns(w.y, t2.get$y(n))), J.$mul$ns(w.z, t2.get$z(n)))))).$div(0, t6));
        }
      }
    }
  },
  SphericalHarmonics_ComputeTransferMatrix: function(p, rayEpsilon, scene, rng, nSamples, lmax, $T) {
    var t1, len, t2, i, t3, scramble, Ylm, u, t4, t5, t6, w, t7, hit, nj, j, nk, k, t8;
    t1 = J.getInterceptor$ns(lmax);
    len = J.$mul$ns(J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1)), J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1)));
    if (typeof len !== "number")
      return H.iae(len);
    t2 = $T.length;
    i = 0;
    for (; i < len; ++i) {
      t3 = G.Spectrum_Spectrum(0);
      if (i >= t2)
        return H.ioore($T, i);
      $T[i] = t3;
    }
    scramble = [rng.randomUInt$0(), rng.randomUInt$0()];
    t3 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
    if (typeof t3 !== "number")
      return H.iae(t3);
    Ylm = H.setRuntimeTypeInfo(Array(t3), [J.JSDouble]);
    u = [0, 0];
    for (t3 = scene.aggregate, t4 = Ylm.length, t5 = 0.07957747154594767 * nSamples, i = 0; i < nSamples; ++i) {
      u[0] = G.VanDerCorput(i, scramble[0]);
      t6 = G.Sobol2(i, scramble[1]);
      u[1] = t6;
      w = G.UniformSampleSphere(u[0], t6);
      t6 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
      t7 = new G.Vector(w.x, w.y, w.z);
      hit = t3.intersectP$1(new G.Ray(t6, t7, rayEpsilon, 1 / 0, 0, 0));
      t7 = $.get$Stats_shadowRays();
      t7.count = J.$add$ns(t7.count, 1);
      $.Stats_shadowRays = t7;
      if (!hit) {
        G.SphericalHarmonics_Evaluate(w, lmax, Ylm, 0);
        nj = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
        if (typeof nj !== "number")
          return H.iae(nj);
        j = 0;
        for (; j < nj; ++j) {
          nk = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
          if (typeof nk !== "number")
            return H.iae(nk);
          k = 0;
          for (; k < nk; ++k) {
            t6 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
            if (typeof t6 !== "number")
              return H.iae(t6);
            t6 = j * t6 + k;
            if (t6 >>> 0 !== t6 || t6 >= t2)
              return H.ioore($T, t6);
            t7 = $T[t6];
            if (j >= t4)
              return H.ioore(Ylm, j);
            t8 = Ylm[j];
            if (k >= t4)
              return H.ioore(Ylm, k);
            $T[t6] = J.$add$ns(t7, G.Spectrum_Spectrum(J.$div$n(J.$mul$ns(t8, Ylm[k]), t5)));
          }
        }
      }
    }
  },
  SphericalHarmonics_ComputeBSDFMatrix: function(Kd, Ks, roughness, rng, nSamples, lmax, $B) {
    var t1, i, t2, bsdf, t3, t4, Ylm, w, scramble, u, osamp, wo, isamp, wi, f, t5, j, t6, t7;
    t1 = J.getInterceptor$ns(lmax);
    i = 0;
    while (true) {
      t2 = J.$mul$ns(J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1)), J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1)));
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (!(i < t2))
        break;
      t2 = G.Spectrum_Spectrum(0);
      if (i >= $B.length)
        return H.ioore($B, i);
      $B[i] = t2;
      ++i;
    }
    bsdf = G.BSDF$(G.DifferentialGeometry$().set$8(new G.Point(0, 0, 0), new G.Vector(1, 0, 0), new G.Vector(0, 1, 0), new G.Normal(0, 0, 0), new G.Normal(0, 0, 0), 0, 0, null), new G.Normal(0, 0, 1), 1);
    t2 = G.Lambertian$(G.Spectrum_Spectrum$from(Kd, 0));
    t3 = bsdf.bxdfs;
    t4 = bsdf.nBxDFs++;
    if (t4 >= 8)
      return H.ioore(t3, t4);
    t3[t4] = t2;
    if (typeof roughness !== "number")
      return H.iae(roughness);
    t2 = G.Blinn$(1 / roughness);
    t4 = bsdf.nBxDFs++;
    if (t4 >= 8)
      return H.ioore(t3, t4);
    t3[t4] = new G.Microfacet(Ks, t2, new G.FresnelDielectric(1.5, 1), 9);
    t2 = J.$mul$ns(J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1)), nSamples);
    if (typeof t2 !== "number" || Math.floor(t2) !== t2)
      H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
    Ylm = new Float32Array(t2);
    w = H.setRuntimeTypeInfo(Array(nSamples), [G.Vector]);
    scramble = [rng.randomUInt$0(), rng.randomUInt$0()];
    u = [0, 0];
    for (t2 = w.length, i = 0; i < nSamples; ++i) {
      u[0] = G.VanDerCorput(i, scramble[0]);
      t3 = G.Sobol2(i, scramble[1]);
      u[1] = t3;
      t3 = G.UniformSampleSphere(u[0], t3);
      if (i >= t2)
        return H.ioore(w, i);
      w[i] = t3;
      G.SphericalHarmonics_Evaluate(t3, lmax, Ylm, J.$mul$ns(J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1)), i));
    }
    for (t3 = Ylm.length, t4 = 0.006332573977646112 * nSamples * nSamples, osamp = 0; osamp < nSamples; ++osamp) {
      if (osamp >= t2)
        return H.ioore(w, osamp);
      wo = w[osamp];
      for (isamp = 0; isamp < nSamples; ++isamp) {
        if (isamp >= t2)
          return H.ioore(w, isamp);
        wi = w[isamp];
        f = bsdf.f$2(wo, wi);
        if (!f.isBlack$0()) {
          f = f.$mul(0, J.abs$0$n(J.get$z$x(wi)) / t4);
          i = 0;
          while (true) {
            t5 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
            if (typeof t5 !== "number")
              return H.iae(t5);
            if (!(i < t5))
              break;
            j = 0;
            while (true) {
              t5 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
              if (typeof t5 !== "number")
                return H.iae(t5);
              if (!(j < t5))
                break;
              t5 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
              if (typeof t5 !== "number")
                return H.iae(t5);
              t5 = i * t5 + j;
              if (t5 >>> 0 !== t5 || t5 >= $B.length)
                return H.ioore($B, t5);
              t5 = $B[t5];
              t6 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
              if (typeof t6 !== "number")
                return H.iae(t6);
              t6 = isamp * t6 + j;
              if (t6 >>> 0 !== t6 || t6 >= t3)
                return H.ioore(Ylm, t6);
              t6 = Ylm[t6];
              t7 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
              if (typeof t7 !== "number")
                return H.iae(t7);
              t7 = osamp * t7 + i;
              if (t7 >>> 0 !== t7 || t7 >= t3)
                return H.ioore(Ylm, t7);
              J.add$1$ax(t5, f.$mul(0, t6 * Ylm[t7]));
              ++j;
            }
            ++i;
          }
        }
      }
    }
  },
  SphericalHarmonics_MatrixVectorMultiply: function($M, v, vout, lmax) {
    var t1, len, t2, i, t3, j, t4, t5;
    t1 = J.getInterceptor$ns(lmax);
    len = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
    if (typeof len !== "number")
      return H.iae(len);
    t2 = vout.length;
    i = 0;
    for (; i < len; ++i) {
      t3 = G.Spectrum_Spectrum(0);
      if (i >= t2)
        return H.ioore(vout, i);
      vout[i] = t3;
      j = 0;
      while (true) {
        t3 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(j < t3))
          break;
        t3 = vout[i];
        if (j >= v.length)
          return H.ioore(v, j);
        t4 = v[j];
        t5 = J.$add$ns(J.$mul$ns(J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1)), i), j);
        if (t5 >>> 0 !== t5 || t5 >= $M.length)
          return H.ioore($M, t5);
        vout[i] = J.$add$ns(t3, J.$mul$ns(t4, $M[t5]));
        ++j;
      }
    }
  },
  SphericalHarmonics__legendrep: function(x, lmax, out, outIndex) {
    var t1, t2, l, t3, t4, t5, t6, xroot, xpow, neg, dfact, m, t7, t8, t9;
    t1 = new G.SphericalHarmonics__legendrep_P(out, outIndex);
    t2 = out.length;
    if (0 >= t2)
      return H.ioore(out, 0);
    out[0] = 1;
    if (2 >= t2)
      return H.ioore(out, 2);
    out[2] = x;
    if (typeof lmax !== "number")
      return H.iae(lmax);
    t2 = J.getInterceptor$ns(outIndex);
    l = 2;
    for (; l <= lmax; ++l) {
      t3 = t2.$add(outIndex, l * l + l);
      if (typeof x !== "number")
        return H.iae(x);
      t4 = l - 1;
      t5 = t1.call$2(t4, 0);
      if (typeof t5 !== "number")
        return H.iae(t5);
      t6 = t1.call$2(l - 2, 0);
      if (typeof t6 !== "number")
        return H.iae(t6);
      if (t3 >>> 0 !== t3 || t3 >= out.length)
        return H.ioore(out, t3);
      out[t3] = ((2 * l - 1) * x * t5 - t4 * t6) / l;
    }
    t3 = J.getInterceptor$ns(x);
    t4 = t3.$mul(x, x);
    if (typeof t4 !== "number")
      return H.iae(t4);
    t4 = P.max(0, 1 - t4);
    xroot = Math.sqrt(t4);
    for (xpow = xroot, neg = -1, dfact = 1, l = 1; l <= lmax; ++l) {
      t4 = t2.$add(outIndex, l * l + l + l);
      if (t4 >>> 0 !== t4 || t4 >= out.length)
        return H.ioore(out, t4);
      out[t4] = neg * dfact * xpow;
      neg *= -1;
      dfact *= 2 * l + 1;
      xpow *= xroot;
    }
    for (l = 2; l <= lmax; ++l) {
      t4 = l - 1;
      t5 = t2.$add(outIndex, l * l + l + t4);
      t4 = J.$mul$ns(t3.$mul(x, 2 * l - 1), t1.call$2(t4, t4));
      if (t5 >>> 0 !== t5 || t5 >= out.length)
        return H.ioore(out, t5);
      out[t5] = t4;
    }
    for (l = 3; l <= lmax; ++l)
      for (t3 = l - 2, t4 = l * l + l, t5 = l - 1, t6 = 2 * t5 + 1, m = 1; m <= t3; ++m) {
        t7 = t2.$add(outIndex, t4 + m);
        if (typeof x !== "number")
          return H.iae(x);
        t8 = t1.call$2(t5, m);
        if (typeof t8 !== "number")
          return H.iae(t8);
        t9 = t1.call$2(t3, m);
        if (typeof t9 !== "number")
          return H.iae(t9);
        if (t7 >>> 0 !== t7 || t7 >= out.length)
          return H.ioore(out, t7);
        out[t7] = (t6 * x * t8 - (t5 + m) * t9) / (l - m);
      }
  },
  SphericalHarmonics__divfact: function(a, b) {
    var fb, x, t1, v;
    if (b === 0)
      return 1;
    fb = Math.abs(b);
    for (x = a - fb + 1, t1 = a + fb, v = 1; x <= t1; ++x)
      v *= x;
    return 1 / v;
  },
  SphericalHarmonics__sinCosIndexed: function(s, c, n, sout, cout) {
    var t1, t2, si, ci, i, si0;
    if (typeof n !== "number")
      return H.iae(n);
    t1 = sout.length;
    t2 = cout.length;
    si = 0;
    ci = 1;
    i = 0;
    for (; i < n; ++i, si = si0) {
      if (i >= t1)
        return H.ioore(sout, i);
      sout[i] = si;
      if (i >= t2)
        return H.ioore(cout, i);
      cout[i] = ci;
      if (typeof c !== "number")
        return H.iae(c);
      if (typeof s !== "number")
        return H.iae(s);
      si0 = si * c + ci * s;
      ci = ci * c - si * s;
    }
  },
  Stats_getString: function() {
    var t1, s;
    for (t1 = $.get$Stats_trackers(), t1 = new H.ListIterator(t1, t1.length, 0, null), s = ""; t1.moveNext$0();)
      s += H.S(t1._current) + "\n";
    return s;
  },
  Lanczos: function(x, tau) {
    var t1, t2;
    x = Math.abs(x);
    if (x < 0.00001)
      return 1;
    if (x > 1)
      return 0;
    x *= 3.141592653589793;
    t1 = x * tau;
    t2 = Math.sin(t1);
    return t2 / t1 * (Math.sin(x) / x);
  },
  Noise: function(x, y, z) {
    var ix, iy, iz, dx, dy, dz, w000, t1, t2, w100, t3, t4, w010, w110, t5, t6, w001, w101, w011, w111, wx, wy, wz;
    ix = J.floor$0$n(x);
    iy = J.floor$0$n(y);
    iz = J.floor$0$n(z);
    dx = x - ix;
    dy = y - iy;
    dz = z - iz;
    ix &= 255;
    iy &= 255;
    iz &= 255;
    w000 = G._Grad(ix, iy, iz, dx, dy, dz);
    t1 = ix + 1;
    t2 = dx - 1;
    w100 = G._Grad(t1, iy, iz, t2, dy, dz);
    t3 = iy + 1;
    t4 = dy - 1;
    w010 = G._Grad(ix, t3, iz, dx, t4, dz);
    w110 = G._Grad(t1, t3, iz, t2, t4, dz);
    t5 = iz + 1;
    t6 = dz - 1;
    w001 = G._Grad(ix, iy, t5, dx, dy, t6);
    w101 = G._Grad(t1, iy, t5, t2, dy, t6);
    w011 = G._Grad(ix, t3, t5, dx, t4, t6);
    w111 = G._Grad(t1, t3, t5, t2, t4, t6);
    wx = G._NoiseWeight(dx);
    wy = G._NoiseWeight(dy);
    wz = G._NoiseWeight(dz);
    t6 = 1 - wx;
    t4 = 1 - wy;
    return (1 - wz) * (t4 * (t6 * w000 + wx * w100) + wy * (t6 * w010 + wx * w110)) + wz * (t4 * (t6 * w001 + wx * w101) + wy * (t6 * w011 + wx * w111));
  },
  FBm: function($P, dpdx, dpdy, omega, maxOctaves) {
    var s2, t1, t2, foctaves, octaves, sum, lambda, o, i;
    s2 = P.max(dpdx.lengthSquared$0(), dpdy.lengthSquared$0());
    t1 = Math.log(s2);
    t2 = $.get$_invLog2();
    if (typeof t2 !== "number")
      return H.iae(t2);
    foctaves = P.min(J.toDouble$0$n(maxOctaves), P.max(0, -1 - 0.5 * (t1 * t2)));
    octaves = C.JSNumber_methods.floor$0(foctaves);
    for (sum = 0, lambda = 1, o = 1, i = 0; i < octaves; ++i) {
      t1 = $P.$mul(0, lambda);
      sum += o * G.Noise(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1));
      lambda *= 1.99;
      if (typeof omega !== "number")
        return H.iae(omega);
      o *= omega;
    }
    t1 = G.SmoothStep(0.3, 0.7, foctaves - octaves);
    t2 = $P.$mul(0, lambda);
    return sum + o * t1 * G.Noise(t2.get$x(t2), t2.get$y(t2), t2.get$z(t2));
  },
  Turbulence: function($P, dpdx, dpdy, omega, maxOctaves) {
    var s2, t1, t2, t3, foctaves, octaves, sum, lambda, o, i;
    s2 = P.max(dpdx.lengthSquared$0(), dpdy.lengthSquared$0());
    t1 = J.toDouble$0$n(maxOctaves);
    t2 = Math.log(s2);
    t3 = $.get$_invLog2();
    if (typeof t3 !== "number")
      return H.iae(t3);
    foctaves = P.min(t1, P.max(0, -1 - 0.5 * (t2 * t3)));
    octaves = C.JSNumber_methods.floor$0(foctaves);
    for (sum = 0, lambda = 1, o = 1, i = 0; i < octaves; ++i) {
      t1 = $P.$mul(0, lambda);
      sum += o * Math.abs(G.Noise(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1)));
      lambda *= 1.99;
      if (typeof omega !== "number")
        return H.iae(omega);
      o *= omega;
    }
    t1 = G.SmoothStep(0.3, 0.7, foctaves - octaves);
    t2 = $P.$mul(0, lambda);
    return sum + o * t1 * Math.abs(G.Noise(t2.get$x(t2), t2.get$y(t2), t2.get$z(t2))) + (maxOctaves - foctaves) * 0.2;
  },
  _Grad: function(x, y, z, dx, dy, dz) {
    var t1, h, u, v;
    if (x >= 512)
      return H.ioore(C.List_2jN, x);
    t1 = J.$add$ns(C.List_2jN[x], y);
    if (t1 >>> 0 !== t1 || t1 >= 512)
      return H.ioore(C.List_2jN, t1);
    t1 = J.$add$ns(C.List_2jN[t1], z);
    if (t1 >>> 0 !== t1 || t1 >= 512)
      return H.ioore(C.List_2jN, t1);
    h = J.$and$n(C.List_2jN[t1], 15);
    u = h < 8 || h === 12 || h === 13 ? dx : dy;
    v = h < 4 || h === 12 || h === 13 ? dy : dz;
    t1 = (h & 1) !== 0 ? -u : u;
    return t1 + ((h & 2) !== 0 ? -v : v);
  },
  _NoiseWeight: function(t) {
    var t3, t4;
    t3 = t * t * t;
    t4 = t3 * t;
    return 6 * t4 * t - 15 * t4 + 10 * t3;
  },
  PhaseHG: function(w, wp, g) {
    var costheta, t1, t2;
    costheta = G.Vector_Dot(w, wp);
    t1 = J.getInterceptor$ns(g);
    t2 = t1.$mul(g, g);
    if (typeof t2 !== "number")
      return H.iae(t2);
    t1 = t1.$mul(g, g);
    if (typeof t1 !== "number")
      return H.iae(t1);
    if (typeof g !== "number")
      return H.iae(g);
    if (typeof costheta !== "number")
      return H.iae(costheta);
    return 0.07957747154594767 * (1 - t2) / Math.pow(1 + t1 - 2 * g * costheta, 1.5);
  },
  GetVolumeScatteringProperties: function($name, sigma_a, sigma_prime_s) {
    if (C.Map_2j0.containsKey$1($name) !== true)
      return false;
    sigma_a.setRGB$3(J.$index$asx(J.$index$asx(C.Map_2j0.$index(0, $name), 1), 0), J.$index$asx(J.$index$asx(C.Map_2j0.$index(0, $name), 1), 1), J.$index$asx(J.$index$asx(C.Map_2j0.$index(0, $name), 2), 2));
    sigma_prime_s.setRGB$3(J.$index$asx(J.$index$asx(C.Map_2j0.$index(0, $name), 0), 0), J.$index$asx(J.$index$asx(C.Map_2j0.$index(0, $name), 0), 1), J.$index$asx(J.$index$asx(C.Map_2j0.$index(0, $name), 0), 2));
    return true;
  },
  AnimatedTransform: {
    "^": "Object;startTime,endTime,startTransform,endTransform,actuallyAnimated,T,R,S",
    interpolate$2: function(time, t) {
      var t1, t2, t3, dt, trans, rotate, scale, t4, i, t5, t6;
      if (!this.actuallyAnimated || J.$le$n(time, this.startTime)) {
        t1 = this.startTransform;
        t.m = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t1.m.m)));
        t.mInv = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t1.mInv.m)));
        return;
      }
      t1 = this.endTime;
      t2 = J.getInterceptor$n(time);
      if (t2.$ge(time, t1)) {
        t1 = this.endTransform;
        t.m = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t1.m.m)));
        t.mInv = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t1.mInv.m)));
        return;
      }
      t3 = this.startTime;
      t2 = t2.$sub(time, t3);
      t3 = J.$sub$n(t1, t3);
      if (typeof t2 !== "number")
        return t2.$div();
      if (typeof t3 !== "number")
        return H.iae(t3);
      dt = t2 / t3;
      t3 = 1 - dt;
      trans = J.$add$ns(J.$mul$ns(this.T[0], t3), J.$mul$ns(this.T[1], dt));
      t2 = this.R;
      rotate = G.Quaternion_Slerp(dt, t2[0], t2[1]);
      scale = G.Matrix4x4$();
      for (t1 = scale.m, t2 = this.S, t4 = t1.length, i = 0; i < 16; ++i) {
        t5 = J.$index$asx(t2[0].get$m(), i);
        t6 = J.$index$asx(t2[1].get$m(), i);
        if (i >= t4)
          return H.ioore(t1, i);
        t1[i] = t3 * t5 + dt * t6;
      }
      t1 = G.Transform_Translate(trans);
      t2 = rotate.toTransform$0();
      t1 = G.Transform$(G.Matrix4x4_Mul(t1.m, t2.m), G.Matrix4x4_Mul(t2.mInv, t1.mInv));
      t2 = G.Transform$(scale, null);
      t1 = G.Transform$(G.Matrix4x4_Mul(t1.m, t2.m), G.Matrix4x4_Mul(t2.mInv, t1.mInv));
      t.m = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t1.m.m)));
      t.mInv = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t1.mInv.m)));
    },
    transformRay$2: function(r, tr) {
      var t;
      if (tr == null)
        tr = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      if (!this.actuallyAnimated || J.$le$n(r.get$time(), this.startTime))
        this.startTransform.transformRay$2(r, tr);
      else if (J.$ge$n(r.get$time(), this.endTime))
        this.endTransform.transformRay$2(r, tr);
      else {
        t = G.Transform$(null, null);
        this.interpolate$2(r.get$time(), t);
        t.transformRay$2(r, tr);
      }
      tr.time = r.get$time();
      return tr;
    },
    transformRay$1: function(r) {
      return this.transformRay$2(r, null);
    },
    transformRayDifferential$2: function(r, tr) {
      var t;
      if (!this.actuallyAnimated || J.$le$n(r.time, this.startTime))
        this.startTransform.transformRayDifferential$2(r, tr);
      else if (J.$ge$n(r.time, this.endTime))
        this.endTransform.transformRayDifferential$2(r, tr);
      else {
        t = G.Transform$(null, null);
        this.interpolate$2(r.time, t);
        t.transformRayDifferential$2(r, tr);
      }
      tr.time = r.time;
    },
    motionBounds$2: function(b, useInverse) {
      var t1, ret, t, t2, i, t3, t4, t5, t6, t7;
      if (!this.actuallyAnimated) {
        t1 = this.startTransform;
        return G.Transform$(t1.mInv, t1.m).transformBBox$1(b);
      }
      ret = G.BBox$(null, null);
      t = G.Transform$(null, null);
      for (t1 = this.startTime, t2 = this.endTime, i = 0; i < 128; ++i) {
        t3 = i / 127;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (typeof t2 !== "number")
          return H.iae(t2);
        this.interpolate$2((1 - t3) * t1 + t3 * t2, t);
        if (useInverse)
          t = G.Transform$(t.mInv, t.m);
        t3 = t.transformBBox$1(b);
        t4 = ret.pMin;
        t5 = t4.x;
        t6 = t4.y;
        t4 = t4.z;
        t7 = ret.pMax;
        ret = new G.BBox(new G.Point(t5, t6, t4), new G.Point(t7.x, t7.y, t7.z)).union$1(t3);
      }
      return ret;
    },
    AnimatedTransform$from$1: function(other) {
      var t1, t2;
      this.T[0] = G.Vector$from(other.T[0]);
      this.T[1] = G.Vector$from(other.T[1]);
      t1 = this.R;
      t2 = other.R;
      t1[0] = G.Quaternion$from(t2[0]);
      t1[1] = G.Quaternion$from(t2[1]);
      t2 = this.S;
      t1 = other.S;
      t2[0] = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t1[0].get$m())));
      t2[1] = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t1[1].get$m())));
    },
    AnimatedTransform$4: function(transform1, startTime, transform2, endTime) {
      var t1, t2;
      t1 = this.R;
      t2 = this.S;
      G.AnimatedTransform_Decompose(this.startTransform.m, this.T[0], t1[0], t2[0]);
      G.AnimatedTransform_Decompose(this.endTransform.m, this.T[1], t1[1], t2[1]);
    },
    static: {AnimatedTransform$: function(transform1, startTime, transform2, endTime) {
        var t1, t2;
        t1 = G.Matrix4x4$();
        t2 = G.Matrix4x4$();
        t2 = new G.AnimatedTransform(startTime, endTime, G.Transform$from(transform1), G.Transform$from(transform2), !transform1.$eq(0, transform2), [new G.Vector(0, 0, 0), new G.Vector(0, 0, 0)], [new G.Quaternion(new G.Vector(0, 0, 0), 1), new G.Quaternion(new G.Vector(0, 0, 0), 1)], [t1, t2]);
        t2.AnimatedTransform$4(transform1, startTime, transform2, endTime);
        return t2;
      }, AnimatedTransform$from: function(other) {
        var t1, t2;
        t1 = G.Matrix4x4$();
        t2 = G.Matrix4x4$();
        t2 = new G.AnimatedTransform(other.startTime, other.endTime, G.Transform$from(other.startTransform), G.Transform$from(other.endTransform), other.actuallyAnimated, [new G.Vector(0, 0, 0), new G.Vector(0, 0, 0)], [new G.Quaternion(new G.Vector(0, 0, 0), 1), new G.Quaternion(new G.Vector(0, 0, 0), 1)], [t1, t2]);
        t2.AnimatedTransform$from$1(other);
        return t2;
      }, AnimatedTransform_Decompose: function(m, $T, Rquat, $S) {
        var t1, t2, t3, i, t4, $R, count, Rnext, t5, t6, t7, t8, t9, norm, j;
        t1 = m.m;
        t2 = t1.length;
        if (3 >= t2)
          return H.ioore(t1, 3);
        t3 = J.getInterceptor$x($T);
        t3.set$x($T, t1[3]);
        if (7 >= t2)
          return H.ioore(t1, 7);
        t3.set$y($T, t1[7]);
        if (11 >= t2)
          return H.ioore(t1, 11);
        t3.set$z($T, t1[11]);
        t1 = new Float32Array(H._ensureNativeList(t1));
        for (t2 = t1.length, i = 0; i < 3; ++i) {
          t3 = i * 3 + 3;
          t4 = 12 + i;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 0;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 0;
        }
        if (15 >= t2)
          return H.ioore(t1, 15);
        t1[15] = 1;
        $R = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t1)));
        count = 0;
        do {
          Rnext = G.Matrix4x4$();
          for (t2 = Rnext.m, t3 = $R.m, t4 = t3.length, t5 = new G.Matrix4x4(new Float32Array(H._ensureNativeList(G.Matrix4x4_Transpose($R).m))).invert$0().m, t6 = t5.length, t7 = t2.length, i = 0; i < 16; ++i) {
            if (i >= t4)
              return H.ioore(t3, i);
            t8 = t3[i];
            if (i >= t6)
              return H.ioore(t5, i);
            t9 = t5[i];
            if (i >= t7)
              return H.ioore(t2, i);
            t2[i] = 0.5 * (t8 + t9);
          }
          for (norm = 0, i = 0, j = 0; i < 3; ++i, j += 4) {
            if (j >= t4)
              return H.ioore(t3, j);
            t5 = t3[j];
            if (j >= t7)
              return H.ioore(t2, j);
            t5 = Math.abs(t5 - t2[j]);
            t6 = j + 1;
            if (t6 >= t4)
              return H.ioore(t3, t6);
            t8 = t3[t6];
            if (t6 >= t7)
              return H.ioore(t2, t6);
            t6 = Math.abs(t8 - t2[t6]);
            t8 = j + 2;
            if (t8 >= t4)
              return H.ioore(t3, t8);
            t9 = t3[t8];
            if (t8 >= t7)
              return H.ioore(t2, t8);
            norm = P.max(norm, t5 + t6 + Math.abs(t9 - t2[t8]));
          }
          ++count;
          if (count < 100 && norm > 0.0001) {
            $R = Rnext;
            continue;
          } else
            break;
        } while (true);
        t3 = new G.Quaternion(new G.Vector(0, 0, 0), 1);
        t3.Quaternion$fromMatrix$1(Rnext);
        Rquat.copy$1(t3);
        $S.copy$1(G.Matrix4x4_Mul(new G.Matrix4x4(new Float32Array(H._ensureNativeList(t2))).invert$0(), new G.Matrix4x4(t1)));
      }}
  },
  BBox: {
    "^": "Object;pMin<,pMax",
    copy$1: function(other) {
      this.pMin.copy$1(other.get$pMin());
      this.pMax.copy$1(other.pMax);
    },
    boundingSphere$1: function(c) {
      c.copy$1(this.pMin.$mul(0, 0.5).$add(0, this.pMax.$mul(0, 0.5)));
      return this.inside$1(c) ? this.pMax.$sub(0, c).length$0(0) : 0;
    },
    $index: function(_, index) {
      return J.$eq(index, 0) ? this.pMin : this.pMax;
    },
    intersectP$3: function(ray, hitt0, hitt1) {
      var t00, t1, i, t2, invRayDir, t3, tNear, tFar, t0;
      t00 = ray.get$minDistance();
      t1 = ray.maxDistance;
      for (i = 0; i < 3; ++i) {
        t2 = J.$index$asx(ray.direction, i);
        if (typeof t2 !== "number")
          return H.iae(t2);
        invRayDir = 1 / t2;
        t2 = this.pMin;
        t3 = i === 0;
        if (t3)
          t2 = t2.x;
        else
          t2 = i === 1 ? t2.y : t2.z;
        tNear = J.$mul$ns(J.$sub$n(t2, J.$index$asx(ray.origin, i)), invRayDir);
        t2 = this.pMax;
        if (t3)
          t2 = t2.x;
        else
          t2 = i === 1 ? t2.y : t2.z;
        tFar = J.$mul$ns(J.$sub$n(t2, J.$index$asx(ray.origin, i)), invRayDir);
        if (J.$gt$n(tNear, tFar)) {
          t0 = tFar;
          tFar = tNear;
          tNear = t0;
        }
        if (J.$gt$n(tNear, t00))
          t00 = tNear;
        if (J.$lt$n(tFar, t1))
          t1 = tFar;
        if (J.$gt$n(t00, t1))
          return false;
      }
      if (hitt0 != null)
        hitt0[0] = t00;
      if (hitt1 != null)
        hitt1[0] = t1;
      return true;
    },
    intersectP$1: function(ray) {
      return this.intersectP$3(ray, null, null);
    },
    intersectP$2: function(ray, hitt0) {
      return this.intersectP$3(ray, hitt0, null);
    },
    inside$1: function(pt) {
      return J.$ge$n(pt.get$x(pt), this.pMin.x) && J.$le$n(pt.get$x(pt), this.pMax.x) && J.$ge$n(pt.get$y(pt), this.pMin.y) && J.$le$n(pt.get$y(pt), this.pMax.y) && J.$ge$n(pt.get$z(pt), this.pMin.z) && J.$le$n(pt.get$z(pt), this.pMax.z);
    },
    unionPoint$1: function(p) {
      var t1, t2;
      t1 = this.pMin;
      t2 = J.getInterceptor$x(p);
      t1.x = P.min(t1.x, t2.get$x(p));
      t1 = this.pMin;
      t1.y = P.min(t1.y, t2.get$y(p));
      t1 = this.pMin;
      t1.z = P.min(t1.z, t2.get$z(p));
      t1 = this.pMax;
      t1.x = P.max(t1.x, t2.get$x(p));
      t1 = this.pMax;
      t1.y = P.max(t1.y, t2.get$y(p));
      t1 = this.pMax;
      t1.z = P.max(t1.z, t2.get$z(p));
      return this;
    },
    union$1: function(b2) {
      var t1 = this.pMin;
      t1.x = P.min(t1.x, b2.get$pMin().x);
      t1 = this.pMin;
      t1.y = P.min(t1.y, b2.pMin.y);
      t1 = this.pMin;
      t1.z = P.min(t1.z, b2.pMin.z);
      t1 = this.pMax;
      t1.x = P.max(t1.x, b2.pMax.x);
      t1 = this.pMax;
      t1.y = P.max(t1.y, b2.pMax.y);
      t1 = this.pMax;
      t1.z = P.max(t1.z, b2.pMax.z);
      return this;
    },
    expand$1: function(_, delta) {
      var t1 = this.pMin;
      t1.x = J.$sub$n(t1.x, delta);
      t1 = this.pMin;
      t1.y = J.$sub$n(t1.y, delta);
      t1 = this.pMin;
      t1.z = J.$sub$n(t1.z, delta);
      t1 = this.pMax;
      t1.x = J.$add$ns(t1.x, delta);
      t1 = this.pMax;
      t1.y = J.$add$ns(t1.y, delta);
      t1 = this.pMax;
      t1.z = J.$add$ns(t1.z, delta);
    },
    surfaceArea$0: function() {
      var d, t1;
      d = this.pMax.$sub(0, this.pMin);
      t1 = J.$add$ns(J.$add$ns(J.$mul$ns(d.x, d.y), J.$mul$ns(d.x, d.z)), J.$mul$ns(d.y, d.z));
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 2 * t1;
    },
    maximumExtent$0: function() {
      var diag = this.pMax.$sub(0, this.pMin);
      if (J.$gt$n(diag.x, diag.y) && J.$gt$n(diag.x, diag.z))
        return 0;
      else if (J.$gt$n(diag.y, diag.z))
        return 1;
      else
        return 2;
    },
    BBox$2: function(p1, p2) {
      var t1, t2;
      t1 = p1 == null;
      if (t1 && p2 == null) {
        this.pMin = new G.Point(1 / 0, 1 / 0, 1 / 0);
        this.pMax = new G.Point(-1 / 0, -1 / 0, -1 / 0);
      } else {
        t1 = !t1 && p2 != null;
        t2 = J.getInterceptor$x(p1);
        if (t1) {
          t1 = J.getInterceptor$x(p2);
          this.pMin = new G.Point(P.min(t2.get$x(p1), t1.get$x(p2)), P.min(t2.get$y(p1), t1.get$y(p2)), P.min(t2.get$z(p1), t1.get$z(p2)));
          this.pMax = new G.Point(P.max(t2.get$x(p1), t1.get$x(p2)), P.max(t2.get$y(p1), t1.get$y(p2)), P.max(t2.get$z(p1), t1.get$z(p2)));
        } else {
          this.pMin = new G.Point(t2.get$x(p1), t2.get$y(p1), t2.get$z(p1));
          this.pMax = new G.Point(t2.get$x(p1), t2.get$y(p1), t2.get$z(p1));
        }
      }
    },
    static: {BBox$: function(p1, p2) {
        var t1 = new G.BBox(null, null);
        t1.BBox$2(p1, p2);
        return t1;
      }, BBox$from: function(other) {
        var t1, t2, t3, t4;
        t1 = other.get$pMin();
        t2 = t1.x;
        t3 = t1.y;
        t1 = t1.z;
        t4 = other.pMax;
        return new G.BBox(new G.Point(t2, t3, t1), new G.Point(t4.x, t4.y, t4.z));
      }}
  },
  Camera: {
    "^": "Object;shutterOpen<,shutterClose<,film<",
    generateRayDifferential$2: function(sample, rd) {
      var wt, t1, sshift, rx, wtx, t2, ry, wty;
      wt = this.generateRay$2(sample, rd);
      t1 = sample.get$imageX();
      sshift = new G.CameraSample(t1, sample.imageY, sample.lensU, sample.lensV, sample.time);
      sshift.imageX = J.$add$ns(t1, 1);
      rx = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      wtx = this.generateRay$2(sshift, rx);
      t1 = rx.origin;
      t2 = J.getInterceptor$x(t1);
      rd.set$rxOrigin(new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1)));
      rd.rxDirection = G.Vector$from(rx.direction);
      sshift.imageX = J.$sub$n(sshift.imageX, 1);
      sshift.imageY = J.$add$ns(sshift.imageY, 1);
      ry = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      wty = this.generateRay$2(sshift, ry);
      t1 = ry.origin;
      t2 = J.getInterceptor$x(t1);
      rd.ryOrigin = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
      rd.ryDirection = G.Vector$from(ry.direction);
      if (wtx === 0 || wty === 0)
        return 0;
      rd.hasDifferentials = true;
      return wt;
    }
  },
  CameraSample: {
    "^": "Object;imageX@,imageY@,lensU?,lensV?,time@"
  },
  nth_element_closure: {
    "^": "Closure:87;pred_0",
    call$2: function(a, b) {
      return this.pred_0.call$2(a, b) === true ? -1 : 1;
    }
  },
  DifferentialGeometry: {
    "^": "Object;p>,nn<,u<,v<,shape,dpdu,dpdv,dndu,dndv,dpdx,dpdy,dudx,dvdx,dudy,dvdy",
    p$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.p.call$4(arg0, arg1, arg2, arg3);
    },
    set$8: function($P, DPDU, DPDV, DNDU, DNDV, uu, vv, sh) {
      var t1, t2, a, b;
      this.p.copy$1($P);
      this.dpdu.copy$1(DPDU);
      this.dpdv.copy$1(DPDV);
      this.dndu.copy$1(DNDU);
      this.dndv.copy$1(DNDV);
      t1 = this.nn;
      t2 = G.Vector_Cross(this.dpdu, this.dpdv);
      t1.copy$1(t2.$div(0, t2.length$0(0)));
      this.u = uu;
      this.v = vv;
      this.shape = sh;
      this.dudx = 0;
      this.dvdx = 0;
      this.dudy = 0;
      this.dvdy = 0;
      t1 = sh != null;
      a = t1 && sh.reverseOrientation === true ? 1 : 0;
      b = t1 && sh.transformSwapsHandedness ? 1 : 0;
      if (t1 && (a ^ b) !== 0)
        this.nn = J.$mul$ns(this.nn, -1);
      return this;
    },
    copy$1: function(other) {
      this.p.copy$1(J.get$p$x(other));
      this.nn.copy$1(other.get$nn());
      this.u = other.get$u();
      this.v = other.v;
      this.shape = other.shape;
      this.dpdu.copy$1(other.dpdu);
      this.dpdv.copy$1(other.dpdv);
      this.dndu.copy$1(other.dndu);
      this.dndv.copy$1(other.dndv);
      this.dpdx.copy$1(other.dpdx);
      this.dpdy.copy$1(other.dpdy);
      this.dudx = other.dudx;
      this.dvdx = other.dvdx;
      this.dudy = other.dudy;
      this.dvdy = other.dvdy;
    },
    computeDifferentials$1: function(ray) {
      var t1, t2, t3, t4, d, tx, px, ryv, ty, py, $A, Bx, By, axes, _du, _dv;
      if (ray.get$hasDifferentials()) {
        t1 = this.nn;
        t2 = this.p;
        t2 = t2.get$x(t2);
        t3 = this.p;
        t3 = t3.get$y(t3);
        t4 = this.p;
        d = J.$negate$n(G.Vector_Dot(t1, new G.Vector(t2, t3, t4.get$z(t4))));
        t4 = J.get$x$x(ray.rxOrigin);
        t3 = J.get$y$x(ray.rxOrigin);
        t2 = J.get$z$x(ray.rxOrigin);
        tx = J.$div$n(J.$negate$n(J.$add$ns(G.Vector_Dot(this.nn, new G.Vector(t4, t3, t2)), d)), G.Vector_Dot(this.nn, ray.rxDirection));
        if (J.get$isNaN$n(tx)) {
          this.dvdx = 0;
          this.dudx = 0;
          this.dvdy = 0;
          this.dudy = 0;
          this.dpdx = new G.Vector(0, 0, 0);
          this.dpdy = new G.Vector(0, 0, 0);
          return;
        }
        t1 = J.$add$ns(ray.rxOrigin, J.$mul$ns(ray.rxDirection, tx));
        t2 = J.getInterceptor$x(t1);
        px = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
        ryv = G.Vector$from(ray.ryOrigin);
        ty = J.$div$n(J.$negate$n(J.$add$ns(G.Vector_Dot(this.nn, ryv), d)), G.Vector_Dot(this.nn, ray.ryDirection));
        if (J.get$isNaN$n(ty)) {
          this.dvdx = 0;
          this.dudx = 0;
          this.dvdy = 0;
          this.dudy = 0;
          this.dpdx = new G.Vector(0, 0, 0);
          this.dpdy = new G.Vector(0, 0, 0);
          return;
        }
        t1 = J.$add$ns(ray.ryOrigin, J.$mul$ns(ray.ryDirection, ty));
        t2 = J.getInterceptor$x(t1);
        py = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
        this.dpdx = px.$sub(0, this.p);
        this.dpdy = py.$sub(0, this.p);
        $A = H.setRuntimeTypeInfo(Array(4), [J.JSDouble]);
        Bx = H.setRuntimeTypeInfo(Array(2), [J.JSDouble]);
        By = H.setRuntimeTypeInfo(Array(2), [J.JSDouble]);
        axes = H.setRuntimeTypeInfo(Array(2), [J.JSInt]);
        if (J.abs$0$n(J.get$x$x(this.nn)) > J.abs$0$n(J.get$y$x(this.nn)) && J.abs$0$n(J.get$x$x(this.nn)) > J.abs$0$n(J.get$z$x(this.nn))) {
          axes[0] = 1;
          axes[1] = 2;
          t1 = 1;
        } else {
          if (J.abs$0$n(J.get$y$x(this.nn)) > J.abs$0$n(J.get$z$x(this.nn))) {
            axes[0] = 0;
            axes[1] = 2;
          } else {
            axes[0] = 0;
            axes[1] = 1;
          }
          t1 = 0;
        }
        $A[0] = this.dpdu.$index(0, t1);
        $A[1] = this.dpdv.$index(0, axes[0]);
        $A[2] = this.dpdu.$index(0, axes[1]);
        $A[3] = this.dpdv.$index(0, axes[1]);
        Bx[0] = J.$sub$n(px.$index(0, axes[0]), this.p.$index(0, axes[0]));
        Bx[1] = J.$sub$n(px.$index(0, axes[1]), this.p.$index(0, axes[1]));
        By[0] = J.$sub$n(py.$index(0, axes[0]), this.p.$index(0, axes[0]));
        By[1] = J.$sub$n(py.$index(0, axes[1]), this.p.$index(0, axes[1]));
        _du = [0];
        _dv = [0];
        if (!G.SolveLinearSystem2x2($A, Bx, _du, _dv)) {
          this.dudx = 0;
          this.dvdx = 0;
        } else {
          this.dudx = _du[0];
          this.dvdx = _dv[0];
        }
        if (!G.SolveLinearSystem2x2($A, By, _du, _dv)) {
          this.dudy = 0;
          this.dvdy = 0;
        } else {
          this.dudy = _du[0];
          this.dvdy = _dv[0];
        }
      } else {
        this.dvdx = 0;
        this.dudx = 0;
        this.dvdy = 0;
        this.dudy = 0;
        this.dpdx = new G.Vector(0, 0, 0);
        this.dpdy = new G.Vector(0, 0, 0);
      }
    },
    DifferentialGeometry$from$1: function(other) {
      var t1, t2;
      t1 = other.p;
      this.p = new G.Point(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1));
      t1 = other.nn;
      t2 = J.getInterceptor$x(t1);
      this.nn = new G.Normal(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
      this.u = other.u;
      this.v = other.v;
      this.shape = other.shape;
      this.dpdu = G.Vector$from(other.dpdu);
      this.dpdv = G.Vector$from(other.dpdv);
      t1 = other.dndu;
      this.dndu = new G.Normal(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1));
      t1 = other.dndv;
      this.dndv = new G.Normal(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1));
      this.dpdx = G.Vector$from(other.dpdx);
      this.dpdy = G.Vector$from(other.dpdy);
      this.dudx = other.dudx;
      this.dvdx = other.dvdx;
      this.dudy = other.dudy;
      this.dvdy = other.dvdy;
    },
    static: {DifferentialGeometry$: function() {
        return new G.DifferentialGeometry(new G.Point(0, 0, 0), new G.Normal(0, 0, 0), 0, 0, null, new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Normal(0, 0, 0), new G.Normal(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), 0, 0, 0, 0);
      }}
  },
  Film: {
    "^": "Object;xResolution<"
  },
  Filter: {
    "^": "Object;xWidth<,yWidth<,invXWidth<,invYWidth<"
  },
  ImageSampler: {
    "^": "Object;"
  },
  Integrator: {
    "^": "Object;",
    preprocess$3: function(scene, camera, renderer) {
    },
    requestSamples$3: function(sampler, sample, scene) {
    }
  },
  Intersection: {
    "^": "Object;dg<,primitive,worldToObject<,objectToWorld<,shapeId<,primitiveId@,rayEpsilon",
    copy$1: function(other) {
      this.dg = other.get$dg();
      this.primitive = other.primitive;
      this.worldToObject = other.worldToObject;
      this.objectToWorld = other.objectToWorld;
      this.shapeId = other.shapeId;
      this.primitiveId = other.primitiveId;
      this.rayEpsilon = other.rayEpsilon;
    },
    getBSDF$1: function(ray) {
      this.dg.computeDifferentials$1(ray);
      return this.primitive.getBSDF$2(this.dg, this.objectToWorld);
    },
    Le$1: function(wo) {
      var area, t1;
      area = this.primitive.areaLight;
      if (area != null) {
        t1 = this.dg;
        t1 = area.L$3(t1.p, t1.nn, wo);
      } else
        t1 = G.Spectrum_Spectrum(0);
      return t1;
    },
    Intersection$0: function() {
      this.primitive = null;
      this.shapeId = 0;
      this.primitiveId = 0;
      this.rayEpsilon = 0;
    },
    static: {Intersection$: function() {
        var t1 = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
        t1.Intersection$0();
        return t1;
      }}
  },
  KdTree: {
    "^": "Object;nodes,nodeData,nNodes,nextFreeNode",
    _core0$_recursiveBuild$5: function(nodeNum, start, end, data, buildNodes) {
      var t1, t2, bound, i, t3, t4, t5, t6, t7, splitAxis, splitPos;
      t1 = J.getInterceptor$ns(start);
      if (J.$eq(t1.$add(start, 1), end)) {
        t1 = this.nodes;
        if (nodeNum < 0 || nodeNum >= t1.length)
          return H.ioore(t1, nodeNum);
        t1[nodeNum] = new G._KdNode(null, 3, false, 536870911);
        t1 = this.nodeData;
        if (start >>> 0 !== start || start >= buildNodes.length)
          return H.ioore(buildNodes, start);
        t2 = buildNodes[start];
        if (t2 >>> 0 !== t2 || t2 >= data.length)
          return H.ioore(data, t2);
        t2 = data[t2];
        if (nodeNum >= t1.length)
          return H.ioore(t1, nodeNum);
        t1[nodeNum] = t2;
        return;
      }
      bound = G.BBox$(null, null);
      for (t2 = buildNodes.length, i = start; J.$lt$n(i, end); ++i) {
        if (i >>> 0 !== i || i >= t2)
          return H.ioore(buildNodes, i);
        t3 = buildNodes[i];
        if (t3 >>> 0 !== t3 || t3 >= data.length)
          return H.ioore(data, t3);
        t3 = J.get$p$x(data[t3]);
        t4 = bound.pMin;
        t5 = t4.x;
        t6 = t4.y;
        t4 = t4.z;
        t7 = bound.pMax;
        bound = new G.BBox(new G.Point(t5, t6, t4), new G.Point(t7.x, t7.y, t7.z)).unionPoint$1(t3);
      }
      splitAxis = bound.maximumExtent$0();
      splitPos = J.$tdiv$n(t1.$add(start, end), 2);
      G.nth_element(buildNodes, start, splitPos, end, new G._CompareNode(data, splitAxis));
      t3 = this.nodes;
      if (splitPos >>> 0 !== splitPos || splitPos >= t2)
        return H.ioore(buildNodes, splitPos);
      t2 = buildNodes[splitPos];
      if (t2 >>> 0 !== t2 || t2 >= data.length)
        return H.ioore(data, t2);
      t2 = J.$index$asx(J.get$p$x(data[t2]), splitAxis);
      if (nodeNum < 0 || nodeNum >= t3.length)
        return H.ioore(t3, nodeNum);
      t3[nodeNum] = new G._KdNode(t2, splitAxis, false, 536870911);
      t2 = this.nodeData;
      t3 = buildNodes[splitPos];
      if (t3 >>> 0 !== t3 || t3 >= data.length)
        return H.ioore(data, t3);
      t3 = data[t3];
      if (nodeNum >= t2.length)
        return H.ioore(t2, nodeNum);
      t2[nodeNum] = t3;
      if (t1.$lt(start, splitPos)) {
        t1 = this.nodes;
        if (nodeNum >= t1.length)
          return H.ioore(t1, nodeNum);
        t1[nodeNum].set$hasLeftChild(true);
        this._core0$_recursiveBuild$5(this.nextFreeNode++, start, splitPos, data, buildNodes);
      }
      t1 = splitPos + 1;
      if (typeof end !== "number")
        return H.iae(end);
      if (t1 < end) {
        t2 = this.nodes;
        if (nodeNum >= t2.length)
          return H.ioore(t2, nodeNum);
        t2[nodeNum].set$rightChild(this.nextFreeNode++);
        t2 = this.nodes;
        if (nodeNum >= t2.length)
          return H.ioore(t2, nodeNum);
        this._core0$_recursiveBuild$5(t2[nodeNum].get$rightChild(), t1, end, data, buildNodes);
      }
    },
    _core0$_lookup$4: function(nodeNum, p, process, maxDistSquared) {
      var t1, node, axis, dist2, t2;
      t1 = this.nodes;
      if (nodeNum < 0 || nodeNum >= t1.length)
        return H.ioore(t1, nodeNum);
      node = t1[nodeNum];
      axis = node.get$splitAxis();
      if (!J.$eq(axis, 3)) {
        t1 = J.getInterceptor$asx(p);
        dist2 = J.$mul$ns(J.$sub$n(t1.$index(p, axis), node.get$splitPos()), J.$sub$n(t1.$index(p, axis), node.get$splitPos()));
        if (J.$le$n(t1.$index(p, axis), node.get$splitPos())) {
          if (node.get$hasLeftChild())
            this._core0$_lookup$4(nodeNum + 1, p, process, maxDistSquared);
          if (0 >= maxDistSquared.length)
            return H.ioore(maxDistSquared, 0);
          if (J.$lt$n(dist2, maxDistSquared[0])) {
            t1 = node.rightChild;
            t2 = this.nNodes;
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 < t2;
            t1 = t2;
          } else
            t1 = false;
          if (t1)
            this._core0$_lookup$4(node.rightChild, p, process, maxDistSquared);
        } else {
          t1 = node.get$rightChild();
          t2 = this.nNodes;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (t1 < t2)
            this._core0$_lookup$4(node.rightChild, p, process, maxDistSquared);
          if (0 >= maxDistSquared.length)
            return H.ioore(maxDistSquared, 0);
          if (J.$lt$n(dist2, maxDistSquared[0]) && node.hasLeftChild)
            this._core0$_lookup$4(nodeNum + 1, p, process, maxDistSquared);
        }
      }
      t1 = this.nodeData;
      if (nodeNum >= t1.length)
        return H.ioore(t1, nodeNum);
      dist2 = J.$sub$n(p, J.get$p$x(t1[nodeNum])).lengthSquared$0();
      if (0 >= maxDistSquared.length)
        return H.ioore(maxDistSquared, 0);
      if (J.$lt$n(dist2, maxDistSquared[0])) {
        t1 = this.nodeData;
        if (nodeNum >= t1.length)
          return H.ioore(t1, nodeNum);
        process.call$4(p, t1[nodeNum], dist2, maxDistSquared);
      }
    },
    KdTree$1: function(data) {
      var t1, buildNodes, t2, i;
      t1 = data.length;
      this.nNodes = t1;
      this.nextFreeNode = 1;
      this.nodes = H.setRuntimeTypeInfo(Array(t1), [G._KdNode]);
      t1 = this.nNodes;
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.nodeData = Array(t1);
      buildNodes = H.setRuntimeTypeInfo(Array(t1), [J.JSInt]);
      t1 = this.nNodes;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = buildNodes.length;
      i = 0;
      for (; i < t1; ++i) {
        if (i >= t2)
          return H.ioore(buildNodes, i);
        buildNodes[i] = i;
      }
      this._core0$_recursiveBuild$5(0, 0, t1, data, buildNodes);
    },
    static: {KdTree$: function(data) {
        var t1 = new G.KdTree(null, null, null, null);
        t1.KdTree$1(data);
        return t1;
      }}
  },
  _CompareNode: {
    "^": "Object:8;data>,axis?",
    call$2: function(d1, d2) {
      var t1, t2;
      t1 = this.data;
      if (d1 >>> 0 !== d1 || d1 >= t1.length)
        return H.ioore(t1, d1);
      t1 = J.$index$asx(J.get$p$x(t1[d1]), this.axis);
      t2 = this.data;
      if (d2 >>> 0 !== d2 || d2 >= t2.length)
        return H.ioore(t2, d2);
      t2 = J.$eq(t1, J.$index$asx(J.get$p$x(t2[d2]), this.axis));
      t1 = this.data;
      if (t2) {
        if (d1 >= t1.length)
          return H.ioore(t1, d1);
        t1 = J.get$hashCode$(t1[d1]);
        t2 = this.data;
        if (d2 >= t2.length)
          return H.ioore(t2, d2);
        t2 = J.$lt$n(t1, J.get$hashCode$(t2[d2]));
        t1 = t2;
      } else {
        if (d1 >= t1.length)
          return H.ioore(t1, d1);
        t1 = J.$index$asx(J.get$p$x(t1[d1]), this.axis);
        t2 = this.data;
        if (d2 >= t2.length)
          return H.ioore(t2, d2);
        t2 = J.$lt$n(t1, J.$index$asx(J.get$p$x(t2[d2]), this.axis));
        t1 = t2;
      }
      return t1;
    }
  },
  _KdNode: {
    "^": "Object;splitPos<,splitAxis<,hasLeftChild@,rightChild@"
  },
  AreaLight: {
    "^": "Light;"
  },
  Light: {
    "^": "Object;nSamples<",
    Le$1: function(r) {
      return G.Spectrum_Spectrum(0);
    },
    shProject$8: function(p, pEpsilon, lmax, scene, computeLightVisibility, time, rng, coeffs) {
      var t1, len, t2, i, t3, ns, scramble1D, scramble2D, Ylm, u, pdf, t4, t5, t6, t7, t8, lightSample, wi, vis, Li, hit, j;
      t1 = J.getInterceptor$ns(lmax);
      len = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
      if (typeof len !== "number")
        return H.iae(len);
      t2 = coeffs.length;
      i = 0;
      for (; i < len; ++i) {
        t3 = G.Spectrum_Spectrum(0);
        if (i >= t2)
          return H.ioore(coeffs, i);
        coeffs[i] = t3;
      }
      ns = G.RoundUpPow2(this.nSamples);
      scramble1D = rng.randomUInt$0();
      scramble2D = [rng.randomUInt$0(), rng.randomUInt$0()];
      t3 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
      if (typeof t3 !== "number" || Math.floor(t3) !== t3)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t3)));
      Ylm = new Float32Array(t3);
      u = [0, 0];
      pdf = [0];
      for (t3 = scene.aggregate, t4 = Ylm.length, i = 0; i < ns; ++i) {
        u[0] = G.VanDerCorput(i, scramble2D[0]);
        t5 = G.Sobol2(i, scramble2D[1]);
        u[1] = t5;
        t6 = u[0];
        t7 = G.VanDerCorput(i, scramble1D);
        t8 = Array(2);
        t8.$builtinTypeInfo = [J.JSDouble];
        lightSample = new G.LightSample(t8, 0);
        t8[0] = t6;
        t8[1] = t5;
        lightSample.uComponent = t7;
        wi = new G.Vector(0, 0, 0);
        vis = new G.VisibilityTester(null);
        Li = this.sampleLAtPoint$7(p, pEpsilon, lightSample, time, wi, pdf, vis);
        if (!Li.isBlack$0())
          if (J.$gt$n(pdf[0], 0))
            if (computeLightVisibility) {
              hit = t3.intersectP$1(vis.r);
              t5 = $.get$Stats_shadowRays();
              t5.count = J.$add$ns(t5.count, 1);
              $.Stats_shadowRays = t5;
              t5 = !hit;
            } else
              t5 = true;
          else
            t5 = false;
        else
          t5 = false;
        if (t5) {
          G.SphericalHarmonics_Evaluate(wi, lmax, Ylm, 0);
          j = 0;
          while (true) {
            t5 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
            if (typeof t5 !== "number")
              return H.iae(t5);
            if (!(j < t5))
              break;
            if (j >= t2)
              return H.ioore(coeffs, j);
            t5 = coeffs[j];
            if (j >= t4)
              return H.ioore(Ylm, j);
            coeffs[j] = J.$add$ns(t5, Li.$mul(0, Ylm[j]).$div(0, J.$mul$ns(pdf[0], ns)));
            ++j;
          }
        }
      }
    },
    Light$2: function(l2w, ns) {
      if (this.worldToLight.hasScale$0())
        $.Log.call$2(1, "Scaling detected in world to light transformation!\nThe system has numerous assumptions, implicit and explicit,\nthat this transform will have no scale factors in it.\nProceed at your own risk; your image may have errors or\nthe system may crash as a result of this.");
    }
  },
  LightSample: {
    "^": "Object;uPos<,uComponent<",
    LightSample$sample$3: function(sample, offsets, n) {
      var t1, t2, t3, t4;
      t1 = this.uPos;
      t2 = sample.get$twoD();
      t3 = offsets.get$posOffset();
      if (t3 >>> 0 !== t3 || t3 >= t2.length)
        return H.ioore(t2, t3);
      t4 = 2 * n;
      t1[0] = J.$index$asx(t2[t3], t4);
      t3 = sample.twoD;
      t2 = offsets.posOffset;
      if (t2 >>> 0 !== t2 || t2 >= t3.length)
        return H.ioore(t3, t2);
      t1[1] = J.$index$asx(t3[t2], t4 + 1);
      t4 = sample.oneD;
      t2 = offsets.componentOffset;
      if (t2 >>> 0 !== t2 || t2 >= t4.length)
        return H.ioore(t4, t2);
      this.uComponent = J.$index$asx(t4[t2], n);
    },
    static: {LightSample$sample: function(sample, offsets, n) {
        var t1 = new G.LightSample(H.setRuntimeTypeInfo(Array(2), [J.JSDouble]), 0);
        t1.LightSample$sample$3(sample, offsets, n);
        return t1;
      }}
  },
  LightSampleOffsets: {
    "^": "Object;nSamples<,componentOffset,posOffset<",
    LightSampleOffsets$2: function(nSamples, sample) {
      var t1 = this.nSamples;
      sample.n1D.push(t1);
      this.componentOffset = sample.n1D.length - 1;
      t1 = this.nSamples;
      sample.n2D.push(t1);
      this.posOffset = sample.n2D.length - 1;
    },
    static: {LightSampleOffsets$: function(nSamples, sample) {
        var t1 = new G.LightSampleOffsets(nSamples, null, null);
        t1.LightSampleOffsets$2(nSamples, sample);
        return t1;
      }}
  },
  ShapeSet: {
    "^": "Object;shapes,area,areas,areaDistribution",
    sample$3: function(ls, Ns, p) {
      var sn, t1, r, rayEps, thit, dg, anyHit, i, t2;
      if (p == null) {
        sn = this.areaDistribution.sampleDiscrete$2(ls.get$uComponent(), null);
        t1 = this.shapes;
        if (sn >>> 0 !== sn || sn >= t1.length)
          return H.ioore(t1, sn);
        return t1[sn].sample$3(ls.get$uPos()[0], ls.uPos[1], Ns);
      }
      sn = this.areaDistribution.sampleDiscrete$2(ls.get$uComponent(), null);
      t1 = this.shapes;
      if (sn >>> 0 !== sn || sn >= t1.length)
        return H.ioore(t1, sn);
      r = G.Ray$(p, J.$sub$n(t1[sn].sample2$4(p, ls.get$uPos()[0], ls.uPos[1], Ns), p), 0.001, 1 / 0, 0, 0);
      rayEps = [0];
      thit = [1];
      dg = G.DifferentialGeometry$();
      for (anyHit = false, i = 0; i < t1.length; ++i)
        anyHit = t1[i].intersect$4(r, thit, rayEps, dg) || anyHit;
      if (anyHit)
        Ns.copy$1(dg.nn);
      t1 = thit[0];
      t1 = J.$add$ns(r.origin, J.$mul$ns(r.direction, t1));
      t2 = J.getInterceptor$x(t1);
      return new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
    },
    sample$2: function(ls, Ns) {
      return this.sample$3(ls, Ns, null);
    },
    pdf$2: function(p, wi) {
      var t1, t2, pdf, i, t3;
      if (wi != null) {
        for (t1 = this.shapes, t2 = this.areas, pdf = 0, i = 0; i < t1.length; ++i) {
          if (i >= t2.length)
            return H.ioore(t2, i);
          t3 = J.$mul$ns(t2[i], t1[i].pdf2$2(p, wi));
          if (typeof t3 !== "number")
            return H.iae(t3);
          pdf += t3;
        }
        t1 = this.area;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return pdf / t1;
      }
      for (t1 = this.shapes, t2 = this.areas, pdf = 0, i = 0; i < t1.length; ++i) {
        if (i >= t2.length)
          return H.ioore(t2, i);
        t3 = J.$mul$ns(t2[i], t1[i].pdf$1(p));
        if (typeof t3 !== "number")
          return H.iae(t3);
        pdf += t3;
      }
      t1 = this.area;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return pdf / t1;
    },
    pdf$1: function(p) {
      return this.pdf$2(p, null);
    },
    area$0: function() {
      return this.area.call$0();
    },
    ShapeSet$1: function(s) {
      var todo, t1, sh, t2, i, a, t3;
      todo = [];
      todo.push(s);
      for (t1 = this.shapes; todo.length !== 0;) {
        sh = C.JSArray_methods.get$last(todo);
        if (0 >= todo.length)
          return H.ioore(todo, 0);
        todo.pop();
        if (sh.canIntersect$0())
          t1.push(sh);
        else
          sh.refine$1(todo);
      }
      t2 = t1.length;
      if (t2 > 64) {
        t2 = "Area light geometry turned into " + t2 + " shapes; may be very inefficient.";
        $.Log.call$2(1, t2);
      }
      this.area = 0;
      for (t2 = this.areas, i = 0; i < t1.length; ++i) {
        a = t1[i].area$0();
        t2.push(a);
        t3 = this.area;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof a !== "number")
          return H.iae(a);
        this.area = t3 + a;
      }
      this.areaDistribution = G.Distribution1D$(t2, t2.length);
    },
    static: {ShapeSet$: function(s) {
        var t1 = new G.ShapeSet([], null, [], null);
        t1.ShapeSet$1(s);
        return t1;
      }}
  },
  VisibilityTester: {
    "^": "Object;r"
  },
  Material: {
    "^": "Object;"
  },
  Matrix4x4: {
    "^": "Object;m<",
    $eq: function(_, m2) {
      var t1, t2, i;
      if (m2 == null)
        return false;
      for (t1 = this.m, t2 = t1.length, i = 0; i < 16; ++i) {
        if (i >= t2)
          return H.ioore(t1, i);
        if (t1[i] !== J.$index$asx(m2.get$m(), i))
          return false;
      }
      return true;
    },
    copy$1: function(other) {
      var t1, t2, t3;
      t1 = this.m;
      t2 = J.$index$asx(other.get$m(), 0);
      t3 = t1.length;
      if (0 >= t3)
        return H.ioore(t1, 0);
      t1[0] = t2;
      t2 = J.$index$asx(other.get$m(), 1);
      if (1 >= t3)
        return H.ioore(t1, 1);
      t1[1] = t2;
      t2 = J.$index$asx(other.get$m(), 2);
      if (2 >= t3)
        return H.ioore(t1, 2);
      t1[2] = t2;
      t2 = J.$index$asx(other.get$m(), 3);
      if (3 >= t3)
        return H.ioore(t1, 3);
      t1[3] = t2;
      t2 = J.$index$asx(other.get$m(), 4);
      if (4 >= t3)
        return H.ioore(t1, 4);
      t1[4] = t2;
      t2 = J.$index$asx(other.get$m(), 5);
      if (5 >= t3)
        return H.ioore(t1, 5);
      t1[5] = t2;
      t2 = J.$index$asx(other.get$m(), 6);
      if (6 >= t3)
        return H.ioore(t1, 6);
      t1[6] = t2;
      t2 = J.$index$asx(other.get$m(), 7);
      if (7 >= t3)
        return H.ioore(t1, 7);
      t1[7] = t2;
      t2 = J.$index$asx(other.get$m(), 8);
      if (8 >= t3)
        return H.ioore(t1, 8);
      t1[8] = t2;
      t2 = J.$index$asx(other.get$m(), 9);
      if (9 >= t3)
        return H.ioore(t1, 9);
      t1[9] = t2;
      t2 = J.$index$asx(other.get$m(), 10);
      if (10 >= t3)
        return H.ioore(t1, 10);
      t1[10] = t2;
      t2 = J.$index$asx(other.get$m(), 11);
      if (11 >= t3)
        return H.ioore(t1, 11);
      t1[11] = t2;
      t2 = J.$index$asx(other.get$m(), 12);
      if (12 >= t3)
        return H.ioore(t1, 12);
      t1[12] = t2;
      t2 = J.$index$asx(other.get$m(), 13);
      if (13 >= t3)
        return H.ioore(t1, 13);
      t1[13] = t2;
      t2 = J.$index$asx(other.get$m(), 14);
      if (14 >= t3)
        return H.ioore(t1, 14);
      t1[14] = t2;
      t2 = J.$index$asx(other.get$m(), 15);
      if (15 >= t3)
        return H.ioore(t1, 15);
      t1[15] = t2;
      return this;
    },
    $index: function(_, index) {
      var t1 = this.m;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this.m;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
      return value;
    },
    invert$0: function() {
      var t1, t2, n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, det, invDet, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49;
      t1 = this.m;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      n11 = t1[0];
      if (4 >= t2)
        return H.ioore(t1, 4);
      n12 = t1[4];
      if (8 >= t2)
        return H.ioore(t1, 8);
      n13 = t1[8];
      if (12 >= t2)
        return H.ioore(t1, 12);
      n14 = t1[12];
      n21 = t1[1];
      n22 = t1[5];
      n23 = t1[9];
      if (13 >= t2)
        return H.ioore(t1, 13);
      n24 = t1[13];
      n31 = t1[2];
      n32 = t1[6];
      n33 = t1[10];
      if (14 >= t2)
        return H.ioore(t1, 14);
      n34 = t1[14];
      n41 = t1[3];
      n42 = t1[7];
      n43 = t1[11];
      if (15 >= t2)
        return H.ioore(t1, 15);
      n44 = t1[15];
      t2 = n14 * n23;
      t3 = t2 * n32;
      t4 = n13 * n24;
      t5 = t4 * n32;
      t6 = n14 * n22;
      t7 = t6 * n33;
      t8 = n12 * n24;
      t9 = t8 * n33;
      t10 = n13 * n22;
      t11 = t10 * n34;
      t12 = n12 * n23;
      t13 = t12 * n34;
      t14 = t2 * n31;
      t15 = t4 * n31;
      t16 = n14 * n21;
      t17 = t16 * n33;
      t18 = n11 * n24;
      t19 = t18 * n33;
      t20 = n13 * n21;
      t21 = t20 * n34;
      t22 = n11 * n23;
      t23 = t22 * n34;
      t24 = t6 * n31;
      t25 = t8 * n31;
      t26 = t16 * n32;
      t27 = t18 * n32;
      t28 = n12 * n21;
      t29 = t28 * n34;
      t30 = n11 * n22;
      t31 = t30 * n34;
      t32 = t10 * n31;
      t33 = t12 * n31;
      t34 = t20 * n32;
      t35 = t22 * n32;
      t36 = t28 * n33;
      t37 = t30 * n33;
      det = t3 * n41 - t5 * n41 - t7 * n41 + t9 * n41 + t11 * n41 - t13 * n41 - t14 * n42 + t15 * n42 + t17 * n42 - t19 * n42 - t21 * n42 + t23 * n42 + t24 * n43 - t25 * n43 - t26 * n43 + t27 * n43 + t29 * n43 - t31 * n43 - t32 * n44 + t33 * n44 + t34 * n44 - t35 * n44 - t36 * n44 + t37 * n44;
      if (det === 0)
        return this;
      invDet = 1 / det;
      t38 = n23 * n34;
      t39 = n24 * n33;
      t40 = n24 * n32;
      t41 = n22 * n34;
      t42 = n23 * n32;
      t43 = n22 * n33;
      t1[0] = (t38 * n42 - t39 * n42 + t40 * n43 - t41 * n43 - t42 * n44 + t43 * n44) * invDet;
      t44 = n14 * n33;
      t45 = n13 * n34;
      t46 = n14 * n32;
      t47 = n12 * n34;
      t48 = n13 * n32;
      t49 = n12 * n33;
      t1[4] = (t44 * n42 - t45 * n42 - t46 * n43 + t47 * n43 + t48 * n44 - t49 * n44) * invDet;
      t1[8] = (t4 * n42 - t2 * n42 + t6 * n43 - t8 * n43 - t10 * n44 + t12 * n44) * invDet;
      t1[12] = (t3 - t5 - t7 + t9 + t11 - t13) * invDet;
      t13 = n24 * n31;
      t11 = n21 * n34;
      t9 = n23 * n31;
      t7 = n21 * n33;
      t1[1] = (t39 * n41 - t38 * n41 - t13 * n43 + t11 * n43 + t9 * n44 - t7 * n44) * invDet;
      t38 = n14 * n31;
      t39 = n11 * n34;
      t5 = n13 * n31;
      t3 = n11 * n33;
      t1[5] = (t45 * n41 - t44 * n41 + t38 * n43 - t39 * n43 - t5 * n44 + t3 * n44) * invDet;
      t1[9] = (t2 * n41 - t4 * n41 - t16 * n43 + t18 * n43 + t20 * n44 - t22 * n44) * invDet;
      t1[13] = (t15 - t14 + t17 - t19 - t21 + t23) * invDet;
      t23 = n22 * n31;
      t21 = n21 * n32;
      t1[2] = (t41 * n41 - t40 * n41 + t13 * n42 - t11 * n42 - t23 * n44 + t21 * n44) * invDet;
      t11 = n12 * n31;
      t13 = n11 * n32;
      t1[6] = (t46 * n41 - t47 * n41 - t38 * n42 + t39 * n42 + t11 * n44 - t13 * n44) * invDet;
      t1[10] = (t8 * n41 - t6 * n41 + t16 * n42 - t18 * n42 - t28 * n44 + t30 * n44) * invDet;
      t1[14] = (t24 - t25 - t26 + t27 + t29 - t31) * invDet;
      t1[3] = (t42 * n41 - t43 * n41 - t9 * n42 + t7 * n42 + t23 * n43 - t21 * n43) * invDet;
      t1[7] = (t49 * n41 - t48 * n41 + t5 * n42 - t3 * n42 - t11 * n43 + t13 * n43) * invDet;
      t1[11] = (t10 * n41 - t12 * n41 - t20 * n42 + t22 * n42 + t28 * n43 - t30 * n43) * invDet;
      t1[15] = (t33 - t32 + t34 - t35 - t36 + t37) * invDet;
      return this;
    },
    toString$0: function(_) {
      var t1, t2, t3;
      t1 = this.m;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = H.S(t1[0]) + " ";
      if (4 >= t2)
        return H.ioore(t1, 4);
      t3 = t3 + H.S(t1[4]) + " ";
      if (8 >= t2)
        return H.ioore(t1, 8);
      t3 = t3 + H.S(t1[8]) + " ";
      if (12 >= t2)
        return H.ioore(t1, 12);
      t3 = t3 + H.S(t1[12]) + " " + H.S(t1[1]) + " " + H.S(t1[5]) + " " + H.S(t1[9]) + " ";
      if (13 >= t2)
        return H.ioore(t1, 13);
      t3 = t3 + H.S(t1[13]) + " " + H.S(t1[2]) + " " + H.S(t1[6]) + " " + H.S(t1[10]) + " ";
      if (14 >= t2)
        return H.ioore(t1, 14);
      t3 = t3 + H.S(t1[14]) + " " + H.S(t1[3]) + " " + H.S(t1[7]) + " " + H.S(t1[11]) + " ";
      if (15 >= t2)
        return H.ioore(t1, 15);
      return t3 + H.S(t1[15]);
    },
    Matrix4x4$values$16: function(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
      var t1, t2;
      t1 = this.m;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t1[0] = m11;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t1[1] = m12;
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1[2] = m13;
      if (3 >= t2)
        return H.ioore(t1, 3);
      t1[3] = m14;
      if (4 >= t2)
        return H.ioore(t1, 4);
      t1[4] = m21;
      if (5 >= t2)
        return H.ioore(t1, 5);
      t1[5] = m22;
      if (6 >= t2)
        return H.ioore(t1, 6);
      t1[6] = m23;
      if (7 >= t2)
        return H.ioore(t1, 7);
      t1[7] = m24;
      if (8 >= t2)
        return H.ioore(t1, 8);
      t1[8] = m31;
      if (9 >= t2)
        return H.ioore(t1, 9);
      t1[9] = m32;
      if (10 >= t2)
        return H.ioore(t1, 10);
      t1[10] = m33;
      if (11 >= t2)
        return H.ioore(t1, 11);
      t1[11] = m34;
      if (12 >= t2)
        return H.ioore(t1, 12);
      t1[12] = m41;
      if (13 >= t2)
        return H.ioore(t1, 13);
      t1[13] = m42;
      if (14 >= t2)
        return H.ioore(t1, 14);
      t1[14] = m43;
      if (15 >= t2)
        return H.ioore(t1, 15);
      t1[15] = m44;
    },
    Matrix4x4$0: function() {
      var t1, t2;
      t1 = this.m;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t1[0] = 1;
      if (5 >= t2)
        return H.ioore(t1, 5);
      t1[5] = 1;
      if (10 >= t2)
        return H.ioore(t1, 10);
      t1[10] = 1;
      if (15 >= t2)
        return H.ioore(t1, 15);
      t1[15] = 1;
    },
    static: {"^": "Matrix4x4_IDENTITY", Matrix4x4$: function() {
        var t1 = new G.Matrix4x4(new Float32Array(16));
        t1.Matrix4x4$0();
        return t1;
      }, Matrix4x4$values: function(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var t1 = new G.Matrix4x4(new Float32Array(16));
        t1.Matrix4x4$values$16(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
        return t1;
      }, Matrix4x4_Transpose: function(m) {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17;
        t1 = m.m;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        if (4 >= t2)
          return H.ioore(t1, 4);
        t4 = t1[4];
        if (8 >= t2)
          return H.ioore(t1, 8);
        t5 = t1[8];
        if (12 >= t2)
          return H.ioore(t1, 12);
        t6 = t1[12];
        t7 = t1[1];
        t8 = t1[5];
        t9 = t1[9];
        if (13 >= t2)
          return H.ioore(t1, 13);
        t10 = t1[13];
        t11 = t1[2];
        t12 = t1[6];
        t13 = t1[10];
        if (14 >= t2)
          return H.ioore(t1, 14);
        t14 = t1[14];
        t15 = t1[3];
        t16 = t1[7];
        t17 = t1[11];
        if (15 >= t2)
          return H.ioore(t1, 15);
        return G.Matrix4x4$values(t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t1[15]);
      }, Matrix4x4_Mul: function(m1, m2) {
        var r, t1, t2, t3, t4, i, k, t5, t6, t7, j, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18;
        r = G.Matrix4x4$();
        for (t1 = r.m, t2 = m1.m, t3 = t2.length, t4 = t1.length, i = 0, k = 0; i < 4; ++i, k += 4)
          for (t5 = k + 1, t6 = k + 2, t7 = k + 3, j = 0; j < 4; ++j) {
            t8 = k + j;
            if (k >= t3)
              return H.ioore(t2, k);
            t9 = t2[k];
            t10 = m2.get$m();
            if (j >= t10.length)
              return H.ioore(t10, j);
            t10 = t10[j];
            if (t5 >= t3)
              return H.ioore(t2, t5);
            t11 = t2[t5];
            t12 = m2.m;
            t13 = 4 + j;
            t14 = t12.length;
            if (t13 >= t14)
              return H.ioore(t12, t13);
            t13 = t12[t13];
            if (t6 >= t3)
              return H.ioore(t2, t6);
            t15 = t2[t6];
            t16 = 8 + j;
            if (t16 >= t14)
              return H.ioore(t12, t16);
            t16 = t12[t16];
            if (t7 >= t3)
              return H.ioore(t2, t7);
            t17 = t2[t7];
            t18 = 12 + j;
            if (t18 >= t14)
              return H.ioore(t12, t18);
            t18 = t12[t18];
            if (t8 >= t4)
              return H.ioore(t1, t8);
            t1[t8] = t9 * t10 + t11 * t13 + t15 * t16 + t17 * t18;
          }
        return r;
      }}
  },
  MIPMap: {
    "^": "Object;doTrilinear,maxAnisotropy,wrapMode,pyramid,width>,height>,levels",
    texel$3: function(level, s, t) {
      var t1, l, t2, a, a0;
      t1 = this.pyramid;
      if (level >>> 0 !== level || level >= t1.length)
        return H.ioore(t1, level);
      l = t1[level];
      switch (this.wrapMode) {
        case 0:
          t1 = J.getInterceptor$x(l);
          t2 = t1.get$width(l);
          if (typeof t2 !== "number")
            return H.iae(t2);
          a = s - C.JSInt_methods.$tdiv(s, t2) * t2;
          if (a < 0)
            a += t2;
          t1 = t1.get$height(l);
          if (typeof t1 !== "number")
            return H.iae(t1);
          a0 = t - C.JSInt_methods.$tdiv(t, t1) * t1;
          if (a0 < 0)
            a0 += t1;
          t = a0;
          s = a;
          break;
        case 2:
          t1 = J.getInterceptor$x(l);
          s = C.JSInt_methods.clamp$2(s, 0, J.$sub$n(t1.get$width(l), 1));
          t = C.JSInt_methods.clamp$2(t, 0, J.$sub$n(t1.get$height(l), 1));
          break;
        case 1:
          if (s >= 0) {
            t1 = J.getInterceptor$x(l);
            t2 = t1.get$width(l);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(s >= t2))
              if (t >= 0) {
                t1 = t1.get$height(l);
                if (typeof t1 !== "number")
                  return H.iae(t1);
                t1 = t >= t1;
              } else
                t1 = true;
            else
              t1 = true;
          } else
            t1 = true;
          if (t1)
            return G.Spectrum_Spectrum(0);
          break;
      }
      t1 = J.getInterceptor$x(l);
      t2 = t1.get$width(l);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1.$index(l, t * t2 + s);
    },
    lookup$3: function(s, t, width) {
      var t1, t2, t3, level, iLevel, delta;
      t1 = this.levels;
      if (typeof t1 !== "number")
        return t1.$sub();
      t2 = P.max(width, 1e-8);
      t2 = Math.log(t2);
      t3 = $.get$_invLog2();
      if (typeof t3 !== "number")
        return H.iae(t3);
      level = t1 - 1 + t2 * t3;
      if (level < 0)
        return this.triangle$3(0, s, t);
      else {
        t1 = this.levels;
        if (typeof t1 !== "number")
          return t1.$sub();
        --t1;
        if (level >= t1)
          return this.texel$3(t1, 0, 0);
        else {
          iLevel = C.JSNumber_methods.toInt$0(Math.floor(level));
          delta = level - iLevel;
          return J.$add$ns(J.$mul$ns(this.triangle$3(iLevel, s, t), 1 - delta), J.$mul$ns(this.triangle$3(iLevel + 1, s, t), delta));
        }
      }
    },
    lookup$2: function(s, t) {
      return this.lookup$3(s, t, 0);
    },
    lookup2$6: function(s, t, ds0, dt0, ds1, dt1) {
      var t0, t1, majorLength, t2, t3, minorLength, scale, lod, ilod, d;
      if (this.doTrilinear === true)
        return this.lookup$3(s, t, 2 * P.max(P.max(J.abs$0$n(ds0), J.abs$0$n(dt0)), P.max(J.abs$0$n(ds1), J.abs$0$n(dt1))));
      if (J.$lt$n(J.$add$ns(J.$mul$ns(ds0, ds0), J.$mul$ns(dt0, dt0)), J.$add$ns(J.$mul$ns(ds1, ds1), J.$mul$ns(dt1, dt1)))) {
        t0 = dt1;
        dt1 = dt0;
        dt0 = t0;
        t0 = ds1;
        ds1 = ds0;
        ds0 = t0;
      }
      t1 = J.$add$ns(J.$mul$ns(ds0, ds0), J.$mul$ns(dt0, dt0));
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      majorLength = Math.sqrt(t1);
      t1 = J.getInterceptor$ns(ds1);
      t2 = J.getInterceptor$ns(dt1);
      t3 = J.$add$ns(t1.$mul(ds1, ds1), t2.$mul(dt1, dt1));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      minorLength = Math.sqrt(t3);
      t3 = this.maxAnisotropy;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = minorLength * t3;
      if (t3 < majorLength && minorLength > 0) {
        scale = majorLength / t3;
        ds1 = t1.$mul(ds1, scale);
        dt1 = t2.$mul(dt1, scale);
        minorLength *= scale;
      }
      if (minorLength === 0)
        return this.triangle$3(0, s, t);
      t1 = this.levels;
      if (typeof t1 !== "number")
        return t1.$sub();
      t2 = Math.log(minorLength);
      t3 = $.get$_invLog2();
      if (typeof t3 !== "number")
        return H.iae(t3);
      lod = P.max(0, t1 - 1 + t2 * t3);
      ilod = C.JSNumber_methods.floor$0(lod);
      d = lod - ilod;
      return J.$add$ns(J.$mul$ns(this.EWA$7(ilod, s, t, ds0, dt0, ds1, dt1), 1 - d), J.$mul$ns(this.EWA$7(ilod + 1, s, t, ds0, dt0, ds1, dt1), d));
    },
    EWA$7: function(level, s, t, ds0, dt0, ds1, dt1) {
      var t1, $A, t2, $B, $C, invF, det, uSqrt, vSqrt, t3, s0, s1, t00, sum, it, sumWts, tt, si, ss, r2, t4, weight;
      t1 = this.levels;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (level >= t1)
        return this.texel$3(t1 - 1, 0, 0);
      t1 = this.pyramid;
      if (level < 0 || level >= t1.length)
        return H.ioore(t1, level);
      s = J.$sub$n(J.$mul$ns(s, J.get$width$x(t1[level])), 0.5);
      t1 = this.pyramid;
      if (level >= t1.length)
        return H.ioore(t1, level);
      t = J.$sub$n(J.$mul$ns(t, J.get$height$x(t1[level])), 0.5);
      t1 = this.pyramid;
      if (level >= t1.length)
        return H.ioore(t1, level);
      ds0 = J.$mul$ns(ds0, J.get$width$x(t1[level]));
      t1 = this.pyramid;
      if (level >= t1.length)
        return H.ioore(t1, level);
      dt0 = J.$mul$ns(dt0, J.get$height$x(t1[level]));
      t1 = this.pyramid;
      if (level >= t1.length)
        return H.ioore(t1, level);
      ds1 = J.$mul$ns(ds1, J.get$width$x(t1[level]));
      t1 = this.pyramid;
      if (level >= t1.length)
        return H.ioore(t1, level);
      dt1 = J.$mul$ns(dt1, J.get$height$x(t1[level]));
      $A = J.$add$ns(J.$add$ns(J.$mul$ns(dt0, dt0), J.$mul$ns(dt1, dt1)), 1);
      t1 = J.getInterceptor$ns(ds0);
      t2 = J.getInterceptor$ns(ds1);
      dt1 = J.$add$ns(t1.$mul(ds0, dt0), t2.$mul(ds1, dt1));
      if (typeof dt1 !== "number")
        return H.iae(dt1);
      $B = -2 * dt1;
      $C = J.$add$ns(J.$add$ns(t1.$mul(ds0, ds0), t2.$mul(ds1, ds1)), 1);
      t2 = J.getInterceptor$ns($A);
      t1 = J.$sub$n(t2.$mul($A, $C), $B * $B * 0.25);
      if (typeof t1 !== "number")
        return H.iae(t1);
      invF = 1 / t1;
      $A = t2.$mul($A, invF);
      $B *= invF;
      $C = J.$mul$ns($C, invF);
      if (typeof $A !== "number")
        return H.iae($A);
      if (typeof $C !== "number")
        return H.iae($C);
      det = -$B * $B + 4 * $A * $C;
      uSqrt = Math.sqrt(det * $C);
      vSqrt = Math.sqrt($A * det);
      t1 = 2 * (1 / det);
      t2 = t1 * uSqrt;
      t3 = J.getInterceptor$n(s);
      s0 = J.ceil$0$n(t3.$sub(s, t2));
      s1 = J.floor$0$n(t3.$add(s, t2));
      t1 *= vSqrt;
      t2 = J.getInterceptor$n(t);
      t00 = J.ceil$0$n(t2.$sub(t, t1));
      t1 = J.floor$0$n(t2.$add(t, t1));
      t2 = this.pyramid;
      if (level >= t2.length)
        return H.ioore(t2, level);
      sum = J.$eq(t2[level].get$samplesPerPixel(), 1) ? 0 : G.Spectrum_Spectrum(0);
      for (it = t00, sumWts = 0; it <= t1; ++it) {
        if (typeof t !== "number")
          return H.iae(t);
        tt = it - t;
        for (t2 = $C * tt * tt, si = s0; si <= s1; ++si) {
          if (typeof s !== "number")
            return H.iae(s);
          ss = si - s;
          r2 = $A * ss * ss + $B * ss * tt + t2;
          if (r2 < 1) {
            t3 = $.MIPMap_weightLut;
            t4 = C.JSNumber_methods.toInt$0(P.min(r2 * 128, 127));
            t3.length;
            if (t4 < 0 || t4 >= 128)
              return H.ioore(t3, t4);
            weight = t3[t4];
            sum = J.$add$ns(sum, J.$mul$ns(this.texel$3(level, si, it), weight));
            sumWts += weight;
          }
        }
      }
      return J.$div$n(sum, sumWts);
    },
    triangle$3: function(level, s, t) {
      var t1, s0, t00, ds, dt, t2, t3, t4;
      t1 = this.levels;
      if (typeof t1 !== "number")
        return t1.$sub();
      level = C.JSInt_methods.clamp$2(level, 0, t1 - 1);
      t1 = this.pyramid;
      if (level >>> 0 !== level || level >= t1.length)
        return H.ioore(t1, level);
      s = J.$sub$n(J.$mul$ns(s, J.get$width$x(t1[level])), 0.5);
      t1 = this.pyramid;
      if (level >= t1.length)
        return H.ioore(t1, level);
      t = J.$sub$n(J.$mul$ns(t, J.get$height$x(t1[level])), 0.5);
      s0 = J.floor$0$n(s);
      t00 = J.floor$0$n(t);
      ds = s - s0;
      dt = t - t00;
      t1 = 1 - ds;
      t2 = 1 - dt;
      t3 = t00 + 1;
      t4 = s0 + 1;
      return J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(this.texel$3(level, s0, t00), t1 * t2), J.$mul$ns(this.texel$3(level, s0, t3), t1 * dt)), J.$mul$ns(this.texel$3(level, t4, t00), ds * t2)), J.$mul$ns(this.texel$3(level, t4, t3), ds * dt));
    },
    _resampleWeights$2: function(oldres, newres) {
      var wt, t1, i, t2, center, j, t3, invSumWts;
      wt = H.setRuntimeTypeInfo(Array(newres), [G._ResampleWeight]);
      for (t1 = wt.length, i = 0; i < newres; ++i) {
        t2 = new G._ResampleWeight(null, [0, 0, 0, 0]);
        if (i >= t1)
          return H.ioore(wt, i);
        wt[i] = t2;
        if (typeof oldres !== "number")
          return H.iae(oldres);
        center = (i + 0.5) * oldres / newres;
        t2.firstTexel = C.JSNumber_methods.toInt$0(Math.floor(center - 2 + 0.5));
        for (j = 0; t2 = wt[i], j < 4; ++j) {
          t3 = t2.get$firstTexel();
          if (typeof t3 !== "number")
            return t3.$add();
          t2.weight[j] = G.Lanczos((t3 + j + 0.5 - center) / 2, 2);
        }
        t2 = t2.get$weight();
        t2 = J.$add$ns(J.$add$ns(J.$add$ns(t2[0], t2[1]), wt[i].get$weight()[2]), wt[i].get$weight()[3]);
        if (typeof t2 !== "number")
          return H.iae(t2);
        invSumWts = 1 / t2;
        for (j = 0; j < 4; ++j) {
          t2 = wt[i].get$weight();
          t2[j] = J.$mul$ns(t2[j], invSumWts);
        }
      }
      return wt;
    },
    MIPMap$texture$4: function(img, doTrilinear, maxAnisotropy, wrapMode) {
      var t1, xres, yres, t2, t3, sPow2, tPow2, sWeights, resampledImage, zero, t4, t5, t, p, t6, s, t7, j, t8, origS, a, px, tWeights, workData, offset, i, sRes, tRes;
      t1 = J.getInterceptor$x(img);
      xres = t1.get$width(img);
      yres = t1.get$height(img);
      t2 = J.getInterceptor$n(xres);
      if (t2.$and(xres, t2.$sub(xres, 1)) === 0) {
        t3 = J.getInterceptor$n(yres);
        t3 = t3.$and(yres, t3.$sub(yres, 1)) !== 0;
      } else
        t3 = true;
      if (t3) {
        sPow2 = G.RoundUpPow2(xres);
        tPow2 = G.RoundUpPow2(yres);
        sWeights = this._resampleWeights$2(xres, sPow2);
        resampledImage = G.SpectrumImage$(sPow2, tPow2, img.get$samplesPerPixel());
        zero = J.$eq(img.get$samplesPerPixel(), 1) ? 0 : G.Spectrum_Spectrum(0);
        if (typeof yres !== "number")
          return H.iae(yres);
        t3 = this.wrapMode;
        t4 = t3 === 2;
        t3 = t3 === 0;
        t5 = sWeights.length;
        t = 0;
        p = 0;
        for (; t < yres; ++t)
          for (t6 = t * sPow2, s = 0; s < sPow2; ++s, ++p) {
            resampledImage.$indexSet(0, p, zero);
            for (t7 = t6 + s, j = 0; j < 4; ++j) {
              if (s >= t5)
                return H.ioore(sWeights, s);
              t8 = sWeights[s].get$firstTexel();
              if (typeof t8 !== "number")
                return t8.$add();
              origS = t8 + j;
              if (t3) {
                if (typeof xres !== "number")
                  return H.iae(xres);
                a = origS - C.JSInt_methods.$tdiv(origS, xres) * xres;
                if (a < 0)
                  a += xres;
                origS = a;
              } else if (t4)
                origS = C.JSInt_methods.clamp$2(origS, 0, t2.$sub(xres, 1));
              if (origS >= 0) {
                if (typeof xres !== "number")
                  return H.iae(xres);
                t8 = origS < xres;
              } else
                t8 = false;
              if (t8) {
                if (typeof xres !== "number")
                  return H.iae(xres);
                px = J.$mul$ns(t1.$index(img, t * xres + origS), sWeights[s].get$weight()[j]);
                resampledImage.$indexSet(0, t7, J.$add$ns(resampledImage.$index(0, t7), px));
              }
            }
          }
        tWeights = this._resampleWeights$2(yres, tPow2);
        workData = Array(tPow2);
        for (t1 = tWeights.length, t2 = yres - 1, s = 0; s < sPow2; ++s) {
          for (t = 0; t < tPow2; ++t) {
            workData[t] = J.$eq(img.get$samplesPerPixel(), 3) ? G.Spectrum_Spectrum(0) : 0;
            for (j = 0; j < 4; ++j) {
              if (t >= t1)
                return H.ioore(tWeights, t);
              t5 = tWeights[t].get$firstTexel();
              if (typeof t5 !== "number")
                return t5.$add();
              offset = t5 + j;
              if (t3) {
                a = offset - C.JSInt_methods.$tdiv(offset, yres) * yres;
                if (a < 0)
                  a += yres;
                offset = a;
              } else if (t4)
                offset = C.JSInt_methods.clamp$2(offset, 0, t2);
              if (offset >= 0 && offset < yres) {
                px = J.$mul$ns(resampledImage.$index(0, offset * sPow2 + s), tWeights[t].get$weight()[j]);
                workData[t] = J.$add$ns(workData[t], px);
              }
            }
          }
          for (t = 0; t < tPow2; ++t)
            resampledImage.$indexSet(0, t * sPow2 + s, J.clamp$2$n(workData[t], 0, 1 / 0));
        }
        img.set$1(resampledImage);
        yres = tPow2;
        xres = sPow2;
      }
      this.width = xres;
      this.height = yres;
      t1 = P.max(xres, yres);
      t1 = Math.log(t1);
      t2 = $.get$_invLog2();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = 1 + C.JSDouble_methods.toInt$0(t1 * t2);
      this.levels = t2;
      t2 = H.setRuntimeTypeInfo(Array(t2), [G.SpectrumImage]);
      this.pyramid = t2;
      t1 = G.SpectrumImage$from(img);
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2[0] = t1;
      i = 1;
      while (true) {
        t1 = this.levels;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.pyramid;
        t2 = i - 1;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        sRes = P.max(1, J.$tdiv$n(J.get$width$x(t1[t2]), 2));
        t1 = this.pyramid;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        tRes = P.max(1, J.$tdiv$n(J.get$height$x(t1[t2]), 2));
        t1 = this.pyramid;
        t3 = img.get$samplesPerPixel();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = sRes * tRes * t3;
        if (typeof t4 !== "number" || Math.floor(t4) !== t4)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t4)));
        t4 = new Float32Array(t4);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = new G.SpectrumImage(sRes, tRes, t3, t4);
        for (t = 0, p = 0; t < tRes; ++t)
          for (t1 = 2 * t, t3 = t1 + 1, s = 0; s < sRes; ++s, ++p) {
            t4 = this.pyramid;
            if (i >= t4.length)
              return H.ioore(t4, i);
            t5 = 2 * s;
            t6 = t5 + 1;
            J.$indexSet$ax(t4[i], p, J.$mul$ns(J.$add$ns(J.$add$ns(J.$add$ns(this.texel$3(t2, t5, t1), this.texel$3(t2, t6, t1)), this.texel$3(t2, t5, t3)), this.texel$3(t2, t6, t3)), 0.25));
          }
        ++i;
      }
      if ($.MIPMap_weightLut == null) {
        $.MIPMap_weightLut = new Float32Array(128);
        for (i = 0; i < 128; ++i) {
          t1 = $.MIPMap_weightLut;
          t2 = Math.exp(-2 * (i / 127));
          t1[i] = t2 - Math.exp(-2);
        }
      }
    },
    static: {"^": "MIPMap_TEXTURE_REPEAT,MIPMap_TEXTURE_BLACK,MIPMap_TEXTURE_CLAMP,MIPMap_WEIGHT_LUT_SIZE,MIPMap_weightLut", MIPMap$texture: function(img, doTrilinear, maxAnisotropy, wrapMode) {
        var t1 = new G.MIPMap(doTrilinear, maxAnisotropy, wrapMode, null, null, null, null);
        t1.MIPMap$texture$4(img, doTrilinear, maxAnisotropy, wrapMode);
        return t1;
      }}
  },
  _ResampleWeight: {
    "^": "Object;firstTexel<,weight<"
  },
  Distribution1D: {
    "^": "Object;func,cdf,funcInt<,count@",
    sampleContinuous$3: function(u, pdf, off) {
      var offset, t1, t2, t3, t4, du;
      offset = P.max(0, G.upper_bound(this.cdf, u, G.less_than$closure(), 0, J.$add$ns(this.count, 1)) - 1);
      if (off != null)
        off[0] = offset;
      t1 = this.cdf;
      if (offset >>> 0 !== offset || offset >= t1.length)
        return H.ioore(t1, offset);
      t1 = J.$sub$n(u, t1[offset]);
      t2 = this.cdf;
      t3 = offset + 1;
      t4 = t2.length;
      if (t3 >= t4)
        return H.ioore(t2, t3);
      t3 = t2[t3];
      if (offset >= t4)
        return H.ioore(t2, offset);
      du = J.$div$n(t1, t3 - t2[offset]);
      t1 = this.func;
      if (offset >= t1.length)
        return H.ioore(t1, offset);
      t1 = t1[offset];
      t2 = this.funcInt;
      if (typeof t2 !== "number")
        return H.iae(t2);
      pdf[0] = t1 / t2;
      if (typeof du !== "number")
        return H.iae(du);
      t1 = this.count;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return (offset + du) / t1;
    },
    sampleContinuous$2: function(u, pdf) {
      return this.sampleContinuous$3(u, pdf, null);
    },
    sampleDiscrete$2: function(u, pdf) {
      var offset, t1, t2, t3;
      offset = P.max(0, G.upper_bound(this.cdf, u, G.less_than$closure(), 0, J.$add$ns(this.count, 1)) - 1);
      if (pdf != null) {
        t1 = this.func;
        if (offset >>> 0 !== offset || offset >= t1.length)
          return H.ioore(t1, offset);
        t1 = t1[offset];
        t2 = this.funcInt;
        t3 = this.count;
        if (typeof t2 !== "number")
          return t2.$mul();
        if (typeof t3 !== "number")
          return H.iae(t3);
        pdf[0] = t1 / (t2 * t3);
      }
      return offset;
    },
    Distribution1D$2: function(f, count) {
      var t1, i, t2, t3, t4, t5, t6;
      t1 = this.count;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      t1 = new Float32Array(t1);
      this.func = t1;
      C.NativeFloat32List_methods.setRange$3(t1, 0, this.count, f);
      t1 = J.$add$ns(this.count, 1);
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      t1 = new Float32Array(t1);
      this.cdf = t1;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1[0] = 0;
      i = 1;
      while (true) {
        t1 = J.$add$ns(this.count, 1);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this.cdf;
        t3 = this.count;
        if (!(i < t1))
          break;
        t1 = i - 1;
        t4 = t2.length;
        if (t1 >= t4)
          return H.ioore(t2, t1);
        t5 = t2[t1];
        t6 = this.func;
        if (t1 >= t6.length)
          return H.ioore(t6, t1);
        t1 = t6[t1];
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (i >= t4)
          return H.ioore(t2, i);
        t2[i] = t5 + t1 / t3;
        ++i;
      }
      if (t3 >>> 0 !== t3 || t3 >= t2.length)
        return H.ioore(t2, t3);
      t1 = t2[t3];
      this.funcInt = t1;
      if (t1 === 0) {
        t1 = t3;
        i = 1;
        while (true) {
          t1 = J.$add$ns(t1, 1);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          t1 = this.cdf;
          t2 = this.count;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (i >= t1.length)
            return H.ioore(t1, i);
          t1[i] = i / t2;
          ++i;
          t1 = t2;
        }
      } else {
        i = 1;
        while (true) {
          t1 = J.$add$ns(this.count, 1);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          t1 = this.cdf;
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t3 = this.funcInt;
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1[i] = t2 / t3;
          ++i;
        }
      }
    },
    static: {Distribution1D$: function(f, count) {
        var t1 = new G.Distribution1D(null, null, null, count);
        t1.Distribution1D$2(f, count);
        return t1;
      }}
  },
  Distribution2D: {
    "^": "Object;pConditionalV,pMarginal",
    sampleContinuous$4: function(u0, u1, uv, pdf) {
      var pdfs, v, pdfs1, t1, t2;
      pdfs = [0];
      v = [0];
      uv[1] = this.pMarginal.sampleContinuous$3(u1, pdfs, v);
      pdfs1 = pdfs[0];
      t1 = this.pConditionalV;
      t2 = v[0];
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      uv[0] = t1[t2].sampleContinuous$2(u0, pdfs);
      pdf[0] = J.$mul$ns(pdfs[0], pdfs1);
    },
    pdf$2: function(u, v) {
      var t1, t2, iu, iv, t3, t4;
      t1 = this.pConditionalV;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = J.toInt$0$n(J.$mul$ns(u, t1[0].get$count()));
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      iu = C.JSInt_methods.clamp$2(t2, 0, J.$sub$n(t1[0].get$count(), 1));
      iv = C.JSInt_methods.clamp$2(J.toInt$0$n(J.$mul$ns(v, this.pMarginal.count)), 0, J.$sub$n(this.pMarginal.count, 1));
      if (iv >>> 0 !== iv || iv >= t1.length)
        return H.ioore(t1, iv);
      t1 = t1[iv];
      t2 = t1.get$funcInt();
      t3 = this.pMarginal;
      t4 = t3.funcInt;
      if (typeof t2 !== "number")
        return t2.$mul();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t4 = t2 * t4;
      if (t4 === 0)
        return 0;
      t1 = t1.func;
      if (iu >>> 0 !== iu || iu >= t1.length)
        return H.ioore(t1, iu);
      t1 = t1[iu];
      t3 = t3.func;
      if (iv >= t3.length)
        return H.ioore(t3, iv);
      return t1 * t3[iv] / t4;
    },
    Distribution2D$3: function(data, nu, nv) {
      var t1, t2, v, t3, marginalFunc, t4;
      if (typeof nv !== "number")
        return H.iae(nv);
      t1 = data.length;
      t2 = this.pConditionalV;
      v = 0;
      for (; v < nv; ++v) {
        if (typeof nu !== "number")
          return H.iae(nu);
        t3 = v * nu;
        t2.push(G.Distribution1D$(new Float32Array(data.subarray(t3, C.NativeFloat32List_methods._checkSublistArguments$3(data, t3, t3 + nu, t1))), nu));
      }
      if (typeof nv !== "number" || Math.floor(nv) !== nv)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(nv)));
      marginalFunc = new Float32Array(nv);
      for (t1 = t2.length, t3 = marginalFunc.length, v = 0; v < nv; ++v) {
        if (v >= t1)
          return H.ioore(t2, v);
        t4 = t2[v].get$funcInt();
        if (v >= t3)
          return H.ioore(marginalFunc, v);
        marginalFunc[v] = t4;
      }
      this.pMarginal = G.Distribution1D$(marginalFunc, nv);
    },
    static: {Distribution2D$: function(data, nu, nv) {
        var t1 = new G.Distribution2D([], null);
        t1.Distribution2D$3(data, nu, nv);
        return t1;
      }}
  },
  PermutedHalton: {
    "^": "Object;dims,b,permute",
    sample$2: function(n, out) {
      var t1, pi, i, t2;
      t1 = this.dims;
      if (typeof t1 !== "number")
        return H.iae(t1);
      pi = 0;
      i = 0;
      for (; i < t1; ++i) {
        t2 = this.b;
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2 = P.min(G.PermutedRadicalInverse(n, t2[i], this.permute, pi), 0.9999999403953552);
        if (i >= 6)
          return H.ioore(out, i);
        out[i] = t2;
        t2 = this.b;
        if (i >= t2.length)
          return H.ioore(t2, i);
        pi += t2[i];
      }
    },
    PermutedHalton$2: function(dims, rng) {
      var t1, t2, sumBases, i, t3, pi;
      t1 = this.dims;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      t2 = new Uint32Array(t1);
      this.b = t2;
      if (typeof t1 !== "number")
        return H.iae(t1);
      sumBases = 0;
      i = 0;
      for (; i < t1; ++i) {
        if (i >= 1000)
          return H.ioore(C.List_bge, i);
        t3 = C.List_bge[i];
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t3;
        sumBases += t2[i];
      }
      this.permute = new Uint32Array(sumBases);
      for (pi = 0, i = 0; i < t1; ++i) {
        t2 = this.permute;
        t3 = this.b;
        if (i >= t3.length)
          return H.ioore(t3, i);
        G.GeneratePermutation(t2, pi, t3[i], rng);
        t3 = this.b;
        if (i >= t3.length)
          return H.ioore(t3, i);
        pi += t3[i];
      }
    },
    static: {PermutedHalton$: function(dims, rng) {
        var t1 = new G.PermutedHalton(dims, null, null);
        t1.PermutedHalton$2(dims, rng);
        return t1;
      }}
  },
  Normal: {
    "^": "Vector;x,y,z",
    normalize$0: function() {
      var t1 = this.lengthSquared$0();
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      this.invScale$1(Math.sqrt(t1));
      return this;
    },
    $mul: function(_, s) {
      return new G.Normal(J.$mul$ns(this.x, s), J.$mul$ns(this.y, s), J.$mul$ns(this.z, s));
    },
    $div: function(_, s) {
      return new G.Normal(J.$div$n(this.x, s), J.$div$n(this.y, s), J.$div$n(this.z, s));
    },
    $add: function(_, p) {
      var t1 = J.getInterceptor$x(p);
      return new G.Normal(J.$add$ns(this.x, t1.get$x(p)), J.$add$ns(this.y, t1.get$y(p)), J.$add$ns(this.z, t1.get$z(p)));
    },
    $sub: function(_, p) {
      var t1 = J.getInterceptor$x(p);
      return new G.Normal(J.$sub$n(this.x, t1.get$x(p)), J.$sub$n(this.y, t1.get$y(p)), J.$sub$n(this.z, t1.get$z(p)));
    },
    $negate: function(_) {
      return new G.Normal(J.$negate$n(this.x), J.$negate$n(this.y), J.$negate$n(this.z));
    },
    $isNormal: true,
    static: {Normal_FaceForward: function(n, n2) {
        var t1, t2;
        t1 = J.getInterceptor$x(n);
        t2 = J.getInterceptor$x(n2);
        return J.$lt$n(J.$add$ns(J.$add$ns(J.$mul$ns(t1.get$x(n), t2.get$x(n2)), J.$mul$ns(t1.get$y(n), t2.get$y(n2))), J.$mul$ns(t1.get$z(n), t2.get$z(n2))), 0) ? new G.Normal(J.$negate$n(t1.get$x(n)), J.$negate$n(t1.get$y(n)), J.$negate$n(t1.get$z(n))) : n;
      }}
  },
  Octree: {
    "^": "Object;maxDepth,bound,root",
    lookup$2: function(p, process) {
      var t1 = this.bound;
      if (!t1.inside$1(p))
        return;
      this._core0$_lookup$4(this.root, t1, p, process);
    },
    _core0$_add$6: function(node, nodeBound, dataItem, dataBound, diag2, depth) {
      var t1, t2, t3, t4, t5, t6, pMid, x, y, z, t7, t8, over, child, childBound;
      if (depth !== this.maxDepth) {
        t1 = nodeBound.pMin;
        t1 = J.$lt$n(nodeBound.pMax.$sub(0, t1).lengthSquared$0(), diag2);
      } else
        t1 = true;
      if (t1) {
        J.add$1$ax(J.get$data$x(node), dataItem);
        return;
      }
      t1 = nodeBound.pMin;
      t2 = J.$mul$ns(t1.x, 0.5);
      t3 = J.$mul$ns(t1.y, 0.5);
      t1 = J.$mul$ns(t1.z, 0.5);
      t4 = nodeBound.pMax;
      t5 = J.$mul$ns(t4.x, 0.5);
      t6 = J.$mul$ns(t4.y, 0.5);
      t4 = J.$mul$ns(t4.z, 0.5);
      t5 = J.$add$ns(t2, t5);
      t6 = J.$add$ns(t3, t6);
      t4 = J.$add$ns(t1, t4);
      pMid = new G.Point(t5, t6, t4);
      x = [J.$le$n(dataBound.pMin.x, t5), J.$gt$n(dataBound.pMax.x, t5)];
      y = [J.$le$n(dataBound.pMin.y, t6), J.$gt$n(dataBound.pMax.y, t6)];
      z = [J.$le$n(dataBound.pMin.z, t4), J.$gt$n(dataBound.pMax.z, t4)];
      t1 = x[0] === true;
      t2 = t1 && y[0] === true && z[0] === true;
      t3 = t1 && y[0] === true && z[1] === true;
      t4 = t1 && y[1] === true && z[0] === true;
      t1 = t1 && y[1] === true && z[1] === true;
      t5 = x[1] === true;
      t6 = t5 && y[0] === true && z[0] === true;
      t7 = t5 && y[0] === true && z[1] === true;
      t8 = t5 && y[1] === true && z[0] === true;
      over = [t2, t3, t4, t1, t6, t7, t8, t5 && y[1] === true && z[1] === true];
      for (t1 = depth + 1, t2 = J.getInterceptor$x(node), child = 0; child < 8; ++child) {
        if (over[child] !== true)
          continue;
        if (J.$index$asx(t2.get$children(node), child) == null) {
          t3 = t2.get$children(node);
          t4 = Array(8);
          t4.$builtinTypeInfo = [G._OctreeNode];
          J.$indexSet$ax(t3, child, new G._OctreeNode(t4, []));
        }
        childBound = G.Octree_octreeChildBound(child, nodeBound, pMid);
        this._core0$_add$6(J.$index$asx(t2.get$children(node), child), childBound, dataItem, dataBound, diag2, t1);
      }
    },
    _core0$_add$5: function(node, nodeBound, dataItem, dataBound, diag2) {
      return this._core0$_add$6(node, nodeBound, dataItem, dataBound, diag2, 0);
    },
    _core0$_lookup$4: function(node, nodeBound, p, process) {
      var t1, i, t2, pMid, t3, t4, child, childBound;
      t1 = J.getInterceptor$x(node);
      i = 0;
      while (true) {
        t2 = J.get$length$asx(t1.get$data(node));
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        if (process.call$1(J.$index$asx(t1.get$data(node), i)) !== true)
          return false;
        ++i;
      }
      pMid = nodeBound.pMin.$mul(0, 0.5).$add(0, nodeBound.pMax.$mul(0, 0.5));
      t2 = J.$gt$n(p.get$x(p), pMid.x) ? 4 : 0;
      t3 = J.$gt$n(p.get$y(p), pMid.y) ? 2 : 0;
      t4 = J.$gt$n(p.get$z(p), pMid.z) ? 1 : 0;
      child = t2 + t3 + t4;
      if (J.$index$asx(t1.get$children(node), child) == null)
        return true;
      childBound = G.Octree_octreeChildBound(child, nodeBound, pMid);
      return this._core0$_lookup$4(J.$index$asx(t1.get$children(node), child), childBound, p, process);
    },
    static: {Octree_octreeChildBound: function(child, nodeBound, pMid) {
        var childBound, t1, t2, t3;
        childBound = G.BBox$(null, null);
        t1 = childBound.pMin;
        t2 = (child & 4) !== 0;
        t1.x = t2 ? pMid.x : nodeBound.pMin.x;
        t3 = childBound.pMax;
        t3.x = t2 ? nodeBound.pMax.x : pMid.x;
        t2 = (child & 2) !== 0;
        t1.y = t2 ? pMid.y : nodeBound.pMin.y;
        t3.y = t2 ? nodeBound.pMax.y : pMid.y;
        t2 = (child & 1) !== 0;
        t1.z = t2 ? pMid.z : nodeBound.pMin.z;
        t3.z = t2 ? nodeBound.pMax.z : pMid.z;
        return childBound;
      }}
  },
  _OctreeNode: {
    "^": "Object;children>,data>",
    static: {_OctreeNode$: function() {
        return new G._OctreeNode(H.setRuntimeTypeInfo(Array(8), [G._OctreeNode]), []);
      }}
  },
  OutputImage: {
    "^": "Object;width>,height>,xOffset,yOffset,rgb<",
    static: {OutputImage$: function(xOffset, yOffset, width, height, rgb) {
        var t1;
        if (rgb != null)
          t1 = rgb;
        else {
          t1 = J.$mul$ns(J.$mul$ns(width, height), 3);
          if (typeof t1 !== "number" || Math.floor(t1) !== t1)
            H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
          t1 = new Float32Array(t1);
        }
        return new G.OutputImage(width, height, xOffset, yOffset, t1);
      }}
  },
  ParamSet: {
    "^": "Object;bools<,ints,floats,points,vectors,normals,spectra,strings,textures",
    addInt$2: function($name, data) {
      $name = J.toLowerCase$0$s($name);
      this.eraseInt$1($name);
      this.ints.push(new G.ParamSetItem($name, data, false));
    },
    addPoint$2: function($name, data) {
      var t1, t2, numPts, pts, i, j, t3, t4, t5;
      $name = J.toLowerCase$0$s($name);
      this.erasePoint$1($name);
      t1 = J.getInterceptor$asx(data);
      t2 = t1.$index(data, 0);
      if (typeof t2 === "number") {
        numPts = J.$tdiv$n(t1.get$length(data), 3);
        if (typeof numPts !== "number")
          return H.iae(numPts);
        t2 = Array(numPts);
        t2.fixed$length = init;
        pts = H.setRuntimeTypeInfo(t2, [G.Point]);
        for (t2 = pts.length, i = 0, j = 0; i < numPts; ++i, j += 3) {
          t3 = t1.$index(data, j);
          t4 = t1.$index(data, j + 1);
          t5 = t1.$index(data, j + 2);
          if (i >= t2)
            return H.ioore(pts, i);
          pts[i] = new G.Point(t3, t4, t5);
        }
        this.points.push(new G.ParamSetItem($name, pts, false));
      } else if (!!J.getInterceptor(t1.$index(data, 0)).$isPoint)
        this.points.push(new G.ParamSetItem($name, data, false));
    },
    addVector$2: function($name, data) {
      var t1, t2, numVecs, vecs, i, j, t3, t4, t5;
      $name = J.toLowerCase$0$s($name);
      this.eraseVector$1($name);
      t1 = J.getInterceptor$asx(data);
      t2 = t1.$index(data, 0);
      if (typeof t2 === "number") {
        numVecs = J.$tdiv$n(t1.get$length(data), 3);
        if (typeof numVecs !== "number")
          return H.iae(numVecs);
        t2 = Array(numVecs);
        t2.fixed$length = init;
        vecs = H.setRuntimeTypeInfo(t2, [G.Vector]);
        for (t2 = vecs.length, i = 0, j = 0; i < numVecs; ++i, j += 3) {
          t3 = t1.$index(data, j);
          t4 = t1.$index(data, j + 1);
          t5 = t1.$index(data, j + 2);
          if (i >= t2)
            return H.ioore(vecs, i);
          vecs[i] = new G.Vector(t3, t4, t5);
        }
        this.vectors.push(new G.ParamSetItem($name, vecs, false));
      } else if (!!J.getInterceptor(t1.$index(data, 0)).$isVector)
        this.vectors.push(new G.ParamSetItem($name, data, false));
    },
    addNormal$2: function($name, data) {
      var t1, t2, numNorms, norms, i, j, t3, t4, t5;
      $name = J.toLowerCase$0$s($name);
      this.eraseNormal$1($name);
      t1 = J.getInterceptor$asx(data);
      if (!!J.getInterceptor(t1.$index(data, 0)).$isNormal)
        this.normals.push(new G.ParamSetItem($name, data, false));
      else {
        t2 = t1.$index(data, 0);
        if (typeof t2 === "number") {
          numNorms = J.$tdiv$n(t1.get$length(data), 3);
          if (typeof numNorms !== "number")
            return H.iae(numNorms);
          t2 = Array(numNorms);
          t2.fixed$length = init;
          norms = H.setRuntimeTypeInfo(t2, [G.Normal]);
          for (t2 = norms.length, i = 0, j = 0; i < numNorms; ++i, j += 3) {
            t3 = t1.$index(data, j);
            t4 = t1.$index(data, j + 1);
            t5 = t1.$index(data, j + 2);
            if (i >= t2)
              return H.ioore(norms, i);
            norms[i] = new G.Normal(t3, t4, t5);
          }
          this.normals.push(new G.ParamSetItem($name, norms, false));
        }
      }
    },
    addRGBSpectrum$2: function($name, data) {
      var t1, nItems, t2, s, i, di, t3;
      $name = J.toLowerCase$0$s($name);
      this.eraseSpectrum$1($name);
      t1 = J.getInterceptor$asx(data);
      nItems = J.$tdiv$n(t1.get$length(data), 3);
      if (typeof nItems !== "number")
        return H.iae(nItems);
      t2 = Array(nItems);
      t2.fixed$length = init;
      s = H.setRuntimeTypeInfo(t2, [G.Spectrum]);
      for (t2 = s.length, i = 0, di = 0; i < nItems; ++i, di += 3) {
        t3 = G.Spectrum_Spectrum$rgb(t1.$index(data, di), t1.$index(data, di + 1), t1.$index(data, di + 2));
        if (i >= t2)
          return H.ioore(s, i);
        s[i] = t3;
      }
      this.spectra.push(new G.ParamSetItem($name, s, false));
    },
    addXYZSpectrum$2: function($name, data) {
      var t1, nItems, t2, s, i, di, t3, t4, t5, t6, t7;
      $name = J.toLowerCase$0$s($name);
      this.eraseSpectrum$1($name);
      t1 = J.getInterceptor$asx(data);
      nItems = J.$tdiv$n(t1.get$length(data), 3);
      if (typeof nItems !== "number")
        return H.iae(nItems);
      t2 = Array(nItems);
      t2.fixed$length = init;
      s = H.setRuntimeTypeInfo(t2, [G.Spectrum]);
      for (t2 = s.length, i = 0, di = 0; i < nItems; ++i, di += 3) {
        t3 = t1.$index(data, di);
        t4 = t1.$index(data, di + 1);
        t5 = t1.$index(data, di + 2);
        t6 = $.Spectrum_type;
        if (t6 === 0)
          t3 = G.RGBColor$xyz(t3, t4, t5);
        else if (t6 === 2) {
          t6 = new G.SampledSpectrum(new Float32Array(4));
          t3 = G.RGBColor$xyz(t3, t4, t5).c;
          t4 = t3.length;
          if (0 >= t4)
            return H.ioore(t3, 0);
          t5 = t3[0];
          if (1 >= t4)
            return H.ioore(t3, 1);
          t7 = t3[1];
          if (2 >= t4)
            return H.ioore(t3, 2);
          t6.setRGB$3(t5, t7, t3[2]);
          t3 = t6;
        } else if (t6 === 1) {
          t6 = new Float32Array(3);
          t7 = new G.XYZColor(t6);
          if (0 >= 3)
            return H.ioore(t6, 0);
          t6[0] = t3;
          if (1 >= 3)
            return H.ioore(t6, 1);
          t6[1] = t4;
          if (2 >= 3)
            return H.ioore(t6, 2);
          t6[2] = t5;
          t3 = t7;
        } else
          t3 = null;
        if (i >= t2)
          return H.ioore(s, i);
        s[i] = t3;
      }
      this.spectra.push(new G.ParamSetItem($name, s, false));
    },
    addBlackbodySpectrum$2: function($name, data) {
      var t1, nItems, t2, s, bb, i, di, bs, t3;
      $name = J.toLowerCase$0$s($name);
      this.eraseSpectrum$1($name);
      t1 = J.getInterceptor$asx(data);
      nItems = J.$tdiv$n(t1.get$length(data), 2);
      if (typeof nItems !== "number")
        return H.iae(nItems);
      t2 = Array(nItems);
      t2.fixed$length = init;
      s = H.setRuntimeTypeInfo(t2, [G.Spectrum]);
      bb = new Float32Array(471);
      for (t2 = s.length, i = 0, di = 0; i < nItems; ++i, di += 2) {
        G.Spectrum_Blackbody(C.List_U49, t1.$index(data, di), bb);
        bs = new G.SampledSpectrum(new Float32Array(4));
        bs.setSampled$3(C.List_U49, bb, 0);
        t3 = G.Spectrum_Spectrum$from(bs, 0).$mul(0, t1.$index(data, di + 1));
        if (i >= t2)
          return H.ioore(s, i);
        s[i] = t3;
      }
      this.spectra.push(new G.ParamSetItem($name, s, false));
    },
    addSpectrumFiles$3: function($name, filenames, futures) {
      var t1, t2, s, subFutures, box_0, t3, t4, t5, path, bytes, values, numSamples, wls, v, i, j, j0, sc, box_00, c;
      t1 = J.getInterceptor$asx(filenames);
      t2 = t1.get$length(filenames);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = Array(t2);
      t2.fixed$length = init;
      s = H.setRuntimeTypeInfo(t2, [G.Spectrum]);
      subFutures = [];
      box_0 = {};
      box_0.fi_0 = 0;
      t2 = futures == null;
      t3 = s.length;
      while (true) {
        t4 = box_0.fi_0;
        t5 = t1.get$length(filenames);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(t4 < t5))
          break;
        c$0: {
          path = t1.$index(filenames, box_0.fi_0);
          if ($.ResourceManager_global.resources.containsKey$1(path)) {
            bytes = $.ResourceManager_global.getResource$1(path);
            t4 = H.checkSubtype(bytes, "$isList", [J.JSInt], "$asList");
            if (!t4)
              break c$0;
            values = this._readFloatFile$2(bytes, path);
            numSamples = C.JSInt_methods._tdivFast$1(values.length, 2);
            wls = new Float32Array(numSamples);
            v = new Float32Array(numSamples);
            for (t4 = values.length, i = 0, j = 0; i < numSamples; ++i) {
              j0 = j + 1;
              if (j >= t4)
                return H.ioore(values, j);
              wls[i] = values[j];
              j = j0 + 1;
              if (j0 >= t4)
                return H.ioore(values, j0);
              v[i] = values[j0];
            }
            t4 = box_0.fi_0;
            t5 = G.Spectrum_Spectrum(0);
            t5.setSampled$3(wls, v, 0);
            if (t4 >= t3)
              return H.ioore(s, t4);
            s[t4] = t5;
          } else if (t2) {
            t4 = "UNABLE TO LOAD SPECTRUM FILE " + H.S(path);
            $.Log.call$2(4, t4);
          } else {
            t4 = "LOADING SPECTRUM FILE " + H.S(path);
            $.Log.call$2(4, t4);
            t4 = new P._Future(0, $.Zone__current, null, null, null, null, null, null);
            t4.$builtinTypeInfo = [null];
            sc = new P._AsyncCompleter(t4);
            sc.$builtinTypeInfo = [null];
            $.ResourceManager_global.requestFile$2(path, null).then$1(new G.ParamSet_addSpectrumFiles_closure(box_0, this, s, path, sc));
            subFutures.push(t4);
          }
        }
        box_00 = {};
        t4 = box_0.fi_0;
        box_00.fi_0 = t4;
        box_00.fi_0 = t4 + 1;
        box_0 = box_00;
      }
      if (t2)
        this.spectra.push(new G.ParamSetItem($name, s, false));
      else if (subFutures.length === 0)
        this.spectra.push(new G.ParamSetItem($name, s, false));
      else {
        c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        futures.push(c.future);
        P.Future_wait(subFutures, false).then$1(new G.ParamSet_addSpectrumFiles_closure0(this, $name, s, c));
      }
    },
    addSampledSpectrum$2: function($name, data) {
      var t1, nItems, t2, wl, v, t3, i, j, j0, t4;
      this.eraseSpectrum$1($name);
      t1 = J.getInterceptor$asx(data);
      nItems = J.$tdiv$n(t1.get$length(data), 2);
      t2 = typeof nItems !== "number" || Math.floor(nItems) !== nItems;
      if (t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(nItems)));
      wl = new Float32Array(nItems);
      if (t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(nItems)));
      v = new Float32Array(nItems);
      if (typeof nItems !== "number")
        return H.iae(nItems);
      t2 = wl.length;
      t3 = v.length;
      i = 0;
      j = 0;
      for (; i < nItems; ++i) {
        j0 = j + 1;
        t4 = t1.$index(data, j);
        if (i >= t2)
          return H.ioore(wl, i);
        wl[i] = t4;
        j = j0 + 1;
        t4 = t1.$index(data, j0);
        if (i >= t3)
          return H.ioore(v, i);
        v[i] = t4;
      }
      t1 = G.Spectrum_Spectrum(0);
      t1.setSampled$3(wl, v, 0);
      this.spectra.push(new G.ParamSetItem($name, [t1], false));
    },
    eraseInt$1: function(n) {
      var t1, i;
      for (t1 = this.ints, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), n)) {
          C.JSArray_methods.removeAt$1(t1, i);
          return true;
        }
      return false;
    },
    eraseBool$1: function(n) {
      var t1, i;
      for (t1 = this.bools, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), n)) {
          C.JSArray_methods.removeAt$1(t1, i);
          return true;
        }
      return false;
    },
    eraseFloat$1: function(n) {
      var t1, i;
      for (t1 = this.floats, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), n)) {
          C.JSArray_methods.removeAt$1(t1, i);
          return true;
        }
      return false;
    },
    erasePoint$1: function(n) {
      var t1, i;
      for (t1 = this.points, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), n)) {
          C.JSArray_methods.removeAt$1(t1, i);
          return true;
        }
      return false;
    },
    eraseVector$1: function(n) {
      var t1, i;
      for (t1 = this.vectors, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), n)) {
          C.JSArray_methods.removeAt$1(t1, i);
          return true;
        }
      return false;
    },
    eraseNormal$1: function(n) {
      var t1, i;
      for (t1 = this.normals, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), n)) {
          C.JSArray_methods.removeAt$1(t1, i);
          return true;
        }
      return false;
    },
    eraseSpectrum$1: function(n) {
      var t1, i;
      for (t1 = this.spectra, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), n)) {
          C.JSArray_methods.removeAt$1(t1, i);
          return true;
        }
      return false;
    },
    eraseString$1: function(n) {
      var t1, i;
      for (t1 = this.strings, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), n)) {
          C.JSArray_methods.removeAt$1(t1, i);
          return true;
        }
      return false;
    },
    eraseTexture$1: function(n) {
      var t1, i;
      for (t1 = this.textures, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), n)) {
          C.JSArray_methods.removeAt$1(t1, i);
          return true;
        }
      return false;
    },
    findOneFloat$2: function($name, d) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.floats, i = 0; i < t1.length; ++i) {
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = J.$eq(J.get$length$asx(J.get$data$x(t1[i])), 1);
        } else
          t2 = false;
        if (t2) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return J.$index$asx(t2.data, 0);
        }
      }
      return d;
    },
    findOneInt$2: function($name, d) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.ints, i = 0; i < t1.length; ++i) {
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = J.$eq(J.get$length$asx(J.get$data$x(t1[i])), 1);
        } else
          t2 = false;
        if (t2) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return J.$index$asx(t2.data, 0);
        }
      }
      return d;
    },
    findOneBool$2: function($name, d) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.bools, i = 0; i < t1.length; ++i) {
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = J.$eq(J.get$length$asx(J.get$data$x(t1[i])), 1);
        } else
          t2 = false;
        if (t2) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return J.$index$asx(t2.data, 0);
        }
      }
      return d;
    },
    findOnePoint$2: function($name, d) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.points, i = 0; i < t1.length; ++i) {
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = J.$eq(J.get$length$asx(J.get$data$x(t1[i])), 1);
        } else
          t2 = false;
        if (t2) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return J.$index$asx(t2.data, 0);
        }
      }
      return d;
    },
    findOneVector$2: function($name, d) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.vectors, i = 0; i < t1.length; ++i) {
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = J.$eq(J.get$length$asx(J.get$data$x(t1[i])), 1);
        } else
          t2 = false;
        if (t2) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return J.$index$asx(t2.data, 0);
        }
      }
      return d;
    },
    findOneSpectrum$2: function($name, d) {
      var t1, i, t2, t3;
      $name = $name.toLowerCase();
      for (t1 = this.spectra, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          t3 = t1.length;
          if (i >= t3)
            return H.ioore(t1, i);
          if (t2.data == null)
            return d;
          if (i >= t3)
            return H.ioore(t1, i);
          if (J.$eq(J.get$length$asx(t2.data), 1)) {
            if (i >= t1.length)
              return H.ioore(t1, i);
            t2 = t1[i];
            t2.set$lookedUp(true);
            if (i >= t1.length)
              return H.ioore(t1, i);
            return J.$index$asx(t2.data, 0);
          }
        }
      return d;
    },
    findOneString$2: function($name, d) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.strings, i = 0; i < t1.length; ++i) {
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = J.$eq(J.get$length$asx(J.get$data$x(t1[i])), 1);
        } else
          t2 = false;
        if (t2) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return J.$index$asx(t2.data, 0);
        }
      }
      return d;
    },
    findOneFilename$2: function($name, d) {
      var filename = this.findOneString$2($name.toLowerCase(), "");
      if (J.$eq(filename, ""))
        return d;
      return filename;
    },
    findTexture$1: function($name) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.textures, i = 0; i < t1.length; ++i) {
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = J.$eq(J.get$length$asx(J.get$data$x(t1[i])), 1);
        } else
          t2 = false;
        if (t2) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return J.$index$asx(t2.data, 0);
        }
      }
      return "";
    },
    findFloat$1: function($name) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.floats, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return t2.data;
        }
      return;
    },
    findInt$1: function($name) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.ints, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return t2.data;
        }
      return;
    },
    findPoint$1: function($name) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.points, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return t2.data;
        }
      return;
    },
    findVector$1: function($name) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.vectors, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return t2.data;
        }
      return;
    },
    findNormal$1: function($name) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.normals, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return t2.data;
        }
      return;
    },
    findString$1: function($name) {
      var t1, i, t2;
      $name = $name.toLowerCase();
      for (t1 = this.strings, i = 0; i < t1.length; ++i)
        if (J.$eq(J.get$name$x(t1[i]), $name)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i];
          t2.set$lookedUp(true);
          if (i >= t1.length)
            return H.ioore(t1, i);
          return t2.data;
        }
      return;
    },
    reportUnused$0: function() {
      this._reportUnused$1(this.bools);
      this._reportUnused$1(this.ints);
      this._reportUnused$1(this.floats);
      this._reportUnused$1(this.points);
      this._reportUnused$1(this.vectors);
      this._reportUnused$1(this.normals);
      this._reportUnused$1(this.spectra);
      this._reportUnused$1(this.strings);
      this._reportUnused$1(this.textures);
    },
    _reportUnused$1: function(list) {
      var i, t1;
      for (i = 0; i < list.length; ++i) {
        t1 = list[i];
        if (!t1.get$lookedUp()) {
          t1 = "Parameter " + H.S(t1.name) + " not used";
          $.Log.call$2(1, t1);
        }
      }
    },
    toString$0: function(_) {
      var t1, out, p, t2, i, t3;
      for (t1 = this.bools, t1 = new H.ListIterator(t1, t1.length, 0, null), out = ""; t1.moveNext$0();) {
        p = t1._current;
        t2 = J.getInterceptor$x(p);
        out += "\"bool " + H.S(t2.get$name(p)) + "\" [";
        i = 0;
        while (true) {
          t3 = J.get$length$asx(t2.get$data(p));
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          if (i !== 0)
            out += " ";
          out += J.$index$asx(t2.get$data(p), i) === true ? 1 : 0;
          ++i;
        }
        out += "] ";
      }
      for (t1 = this.ints, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
        out += this._paramToString$2("integer", t1._current);
      for (t1 = this.floats, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
        out += this._paramToString$2("float", t1._current);
      for (t1 = this.points, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
        out += this._paramToString$2("point", t1._current);
      for (t1 = this.vectors, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
        out += this._paramToString$2("vector", t1._current);
      for (t1 = this.normals, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
        out += this._paramToString$2("normals", t1._current);
      for (t1 = this.spectra, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
        out += this._paramToString$2("color", t1._current);
      for (t1 = this.strings, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();) {
        p = t1._current;
        t2 = J.getInterceptor$x(p);
        out += "\"string " + H.S(t2.get$name(p)) + "\" [";
        i = 0;
        while (true) {
          t3 = J.get$length$asx(t2.get$data(p));
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          if (i !== 0)
            out += " ";
          out += "\"" + H.S(J.$index$asx(t2.get$data(p), i)) + "\"";
          ++i;
        }
        out += "] ";
      }
      for (t1 = this.textures, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();) {
        p = t1._current;
        t2 = J.getInterceptor$x(p);
        out += "\"texture " + H.S(t2.get$name(p)) + "\" [";
        i = 0;
        while (true) {
          t3 = J.get$length$asx(t2.get$data(p));
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          if (i !== 0)
            out += " ";
          out += "\"" + H.S(J.$index$asx(t2.get$data(p), i)) + "\"";
          ++i;
        }
        out += "] ";
      }
      return out;
    },
    _paramToString$2: function(type, item) {
      var t1, out, i, t2;
      t1 = J.getInterceptor$x(item);
      out = "\"" + type + " " + H.S(t1.get$name(item)) + "\" [";
      i = 0;
      while (true) {
        t2 = J.get$length$asx(t1.get$data(item));
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        if (i !== 0)
          out += " ";
        out += H.S(J.$index$asx(t1.get$data(item), i));
        ++i;
      }
      return out + "] ";
    },
    _readFloatFile$2: function(bytes, path) {
      var text, len, ZERO, t1, t2, values, ci, inNumber, curNumber, lineNumber, ci0, c, t3;
      text = H.Primitives_stringFromCharCodes(typeof bytes !== "object" || bytes === null || bytes.constructor !== Array ? P.List_List$from(bytes, true, null) : bytes);
      len = text.length;
      ZERO = "0".charCodeAt(0);
      t1 = new G.ParamSet__readFloatFile__isdigit(ZERO, "9".charCodeAt(0));
      t2 = new G.ParamSet__readFloatFile__isspace();
      values = [];
      for (ci = 0, inNumber = false, curNumber = "", lineNumber = 0; ci < len;) {
        ci0 = ci + 1;
        if (ci < 0)
          return H.ioore(text, ci);
        c = text[ci];
        if (c === "\n")
          ++lineNumber;
        if (inNumber) {
          if (t1.call$1(c) === true || c === "." || c === "e" || c === "-" || c === "+") {
            curNumber += c;
            inNumber = true;
          } else {
            values.push(H.Primitives_parseDouble(curNumber, null));
            inNumber = false;
            curNumber = "";
          }
          ci = ci0;
        } else if (t1.call$1(c) === true || c === "." || c === "-" || c === "+") {
          curNumber += c;
          ci = ci0;
          inNumber = true;
        } else {
          if (c === "#") {
            ci = ci0;
            while (true) {
              ci0 = ci + 1;
              if (ci < 0 || ci >= len)
                return H.ioore(text, ci);
              if (!(text[ci] !== "\n" && ci0 < len))
                break;
              ci = ci0;
            }
            ++lineNumber;
            ci = ci0;
          } else {
            if (t2.call$1(c) !== true) {
              t3 = "Unexpected text found at line " + lineNumber + " of float file " + H.S(path) + ": " + c;
              $.Log.call$2(1, t3);
            }
            ci = ci0;
          }
          inNumber = false;
        }
      }
      return values;
    },
    static: {ParamSet$from: function(other) {
        return new G.ParamSet(P.List_List$from(other.get$bools(), true, null), P.List_List$from(other.ints, true, null), P.List_List$from(other.floats, true, null), P.List_List$from(other.points, true, null), P.List_List$from(other.vectors, true, null), P.List_List$from(other.normals, true, null), P.List_List$from(other.spectra, true, null), P.List_List$from(other.strings, true, null), P.List_List$from(other.textures, true, null));
      }}
  },
  ParamSet_addSpectrumFiles_closure: {
    "^": "Closure:88;box_0,this_1,s_2,path_3,sc_4",
    call$1: function(bytes) {
      var t1, t2, values, numSamples, wls, v, i, j, j0, t3;
      t1 = this.path_3;
      t2 = "FINISHED SPECTRUM FILE " + H.S(t1);
      $.Log.call$2(4, t2);
      values = this.this_1._readFloatFile$2(bytes, t1);
      numSamples = C.JSInt_methods._tdivFast$1(values.length, 2);
      wls = new Float32Array(numSamples);
      v = new Float32Array(numSamples);
      for (t1 = values.length, i = 0, j = 0; i < numSamples; ++i) {
        j0 = j + 1;
        if (j >= t1)
          return H.ioore(values, j);
        wls[i] = values[j];
        j = j0 + 1;
        if (j0 >= t1)
          return H.ioore(values, j0);
        v[i] = values[j0];
      }
      t1 = this.s_2;
      t2 = this.box_0.fi_0;
      t3 = G.Spectrum_Spectrum(0);
      t3.setSampled$3(wls, v, 0);
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = t3;
      t1 = this.sc_4.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  ParamSet_addSpectrumFiles_closure0: {
    "^": "Closure:88;this_5,name_6,s_7,c_8",
    call$1: function(e) {
      var t1;
      this.this_5.spectra.push(new G.ParamSetItem(this.name_6, this.s_7, false));
      t1 = this.c_8.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  ParamSet__readFloatFile__isdigit: {
    "^": "Closure:94;ZERO_0,NINE_1",
    call$1: function(c) {
      var cu = C.JSString_methods.codeUnitAt$1(c, 0);
      return cu >= this.ZERO_0 && cu <= this.NINE_1;
    }
  },
  ParamSet__readFloatFile__isspace: {
    "^": "Closure:94;",
    call$1: function(c) {
      return c === " " || c === "\t" || c === "\n" || c === "\r";
    }
  },
  ParamSetItem: {
    "^": "Object;name>,data>,lookedUp@"
  },
  Point: {
    "^": "Vector;x,y,z",
    $mul: function(_, s) {
      return new G.Point(J.$mul$ns(this.x, s), J.$mul$ns(this.y, s), J.$mul$ns(this.z, s));
    },
    $div: function(_, s) {
      return new G.Point(J.$div$n(this.x, s), J.$div$n(this.y, s), J.$div$n(this.z, s));
    },
    $add: function(_, p) {
      var t1 = J.getInterceptor$x(p);
      return new G.Point(J.$add$ns(this.x, t1.get$x(p)), J.$add$ns(this.y, t1.get$y(p)), J.$add$ns(this.z, t1.get$z(p)));
    },
    $sub: function(_, p) {
      var t1 = J.getInterceptor$x(p);
      return new G.Point(J.$sub$n(this.x, t1.get$x(p)), J.$sub$n(this.y, t1.get$y(p)), J.$sub$n(this.z, t1.get$z(p)));
    },
    $isPoint: true
  },
  Aggregate: {
    "^": "Primitive;",
    getBSDF$2: function(dg, xform) {
      $.Log.call$2(3, "Aggregate.getBSDF() methodcalled; should have gone to GeometricPrimitive");
      return;
    }
  },
  GeometricPrimitive: {
    "^": "Primitive;shape,material@,areaLight@,primitiveId",
    canIntersect$0: function() {
      return this.shape.canIntersect$0();
    },
    refine$1: function(refined) {
      var r, i, t1, t2, t3, t4;
      r = [];
      this.shape.refine$1(r);
      for (i = 0; i < r.length; ++i) {
        t1 = r[i];
        t2 = this.material;
        t3 = this.areaLight;
        t4 = $.Primitive__nextprimitiveId;
        $.Primitive__nextprimitiveId = t4 + 1;
        refined.push(new G.GeometricPrimitive(t1, t2, t3, t4));
      }
    },
    worldBound$0: function() {
      return this.shape.worldBound$0();
    },
    intersect$2: function(r, isect) {
      var thit, rayEpsilon;
      thit = [0];
      rayEpsilon = [0];
      if (!this.shape.intersect$4(r, thit, rayEpsilon, isect.get$dg()))
        return false;
      isect.primitive = this;
      isect.worldToObject = G.Transform$from(this.shape.get$worldToObject());
      isect.objectToWorld = G.Transform$from(this.shape.get$objectToWorld());
      isect.shapeId = this.shape.get$shapeId();
      isect.primitiveId = this.primitiveId;
      isect.rayEpsilon = rayEpsilon[0];
      r.set$maxDistance(thit[0]);
      return true;
    },
    intersectP$1: function(r) {
      return this.shape.intersectP$1(r);
    },
    getBSDF$2: function(dg, objectToWorld) {
      var dgs = G.DifferentialGeometry$();
      this.shape.getShadingGeometry$3(objectToWorld, dg, dgs);
      return this.material.getBSDF$2(dg, dgs);
    }
  },
  Primitive: {
    "^": "Object;",
    canIntersect$0: function() {
      return true;
    },
    refine$1: function(refined) {
      $.Log.call$2(3, "Unimplemented Primitive.refine() method called!");
    },
    fullyRefine$1: function(refined) {
      var todo, t1, prim;
      todo = [];
      todo.push(this);
      for (t1 = J.getInterceptor$ax(refined); todo.length !== 0;) {
        prim = C.JSArray_methods.get$last(todo);
        if (0 >= todo.length)
          return H.ioore(todo, 0);
        todo.pop();
        if (prim.canIntersect$0())
          t1.add$1(refined, prim);
        else
          prim.refine$1(todo);
      }
    }
  },
  TransformedPrimitive: {
    "^": "Primitive;primitive,worldToPrimitive,primitiveId",
    intersect$2: function(r, isect) {
      var w2p, ray, t1, t2, PrimitiveToWorld;
      w2p = G.Transform$(null, null);
      this.worldToPrimitive.interpolate$2(r.get$time(), w2p);
      ray = w2p.transformRay$1(r);
      if (!this.primitive.intersect$2(ray, isect))
        return false;
      r.set$maxDistance(ray.maxDistance);
      isect.set$primitiveId(this.primitiveId);
      t1 = w2p.m.m;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      if (t1[0] === 1) {
        if (1 >= t2)
          return H.ioore(t1, 1);
        if (t1[1] === 0) {
          if (2 >= t2)
            return H.ioore(t1, 2);
          if (t1[2] === 0) {
            if (3 >= t2)
              return H.ioore(t1, 3);
            if (t1[3] === 0) {
              if (4 >= t2)
                return H.ioore(t1, 4);
              if (t1[4] === 0) {
                if (5 >= t2)
                  return H.ioore(t1, 5);
                if (t1[5] === 1) {
                  if (6 >= t2)
                    return H.ioore(t1, 6);
                  if (t1[6] === 0) {
                    if (8 >= t2)
                      return H.ioore(t1, 8);
                    if (t1[8] === 0) {
                      if (9 >= t2)
                        return H.ioore(t1, 9);
                      if (t1[9] === 0) {
                        if (10 >= t2)
                          return H.ioore(t1, 10);
                        if (t1[10] === 1) {
                          if (11 >= t2)
                            return H.ioore(t1, 11);
                          if (t1[11] === 0) {
                            if (12 >= t2)
                              return H.ioore(t1, 12);
                            if (t1[12] === 0) {
                              if (13 >= t2)
                                return H.ioore(t1, 13);
                              if (t1[13] === 0) {
                                if (14 >= t2)
                                  return H.ioore(t1, 14);
                                if (t1[14] === 0) {
                                  if (15 >= t2)
                                    return H.ioore(t1, 15);
                                  t1 = t1[15] === 1;
                                } else
                                  t1 = false;
                              } else
                                t1 = false;
                            } else
                              t1 = false;
                          } else
                            t1 = false;
                        } else
                          t1 = false;
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                } else
                  t1 = false;
              } else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      if (!t1) {
        t1 = isect.worldToObject.$mul(0, w2p);
        isect.worldToObject = t1;
        isect.objectToWorld = G.Transform$(t1.mInv, t1.m);
        PrimitiveToWorld = G.Transform$(w2p.mInv, w2p.m);
        t1 = isect.dg;
        t1.p = PrimitiveToWorld.transformPoint$1(t1.p);
        t1 = isect.dg;
        t2 = PrimitiveToWorld.transformNormal$1(t1.nn);
        t1.nn = t2.$div(0, t2.length$0(0));
        t2 = isect.dg;
        t2.dpdu = PrimitiveToWorld.transformVector$1(t2.dpdu);
        t2 = isect.dg;
        t2.dpdv = PrimitiveToWorld.transformVector$1(t2.dpdv);
        t2 = isect.dg;
        t2.dndu = PrimitiveToWorld.transformVector$1(t2.dndu);
        t2 = isect.dg;
        t2.dndv = PrimitiveToWorld.transformVector$1(t2.dndv);
      }
      return true;
    },
    intersectP$1: function(r) {
      return this.primitive.intersectP$1(this.worldToPrimitive.transformRay$1(r));
    },
    getBSDF$2: function(dg, ObjectToWorld) {
      return;
    },
    worldBound$0: function() {
      return this.worldToPrimitive.motionBounds$2(this.primitive.worldBound$0(), true);
    }
  },
  ProjectiveCamera: {
    "^": "Camera;",
    ProjectiveCamera$8: function(cam2world, cameraToScreen, screenWindow, sopen, sclose, lensRadius, focalDistance, film) {
      var t1, t2, t3, t4;
      t1 = G.Transform_Scale(J.toDouble$0$n(film.xResolution), J.toDouble$0$n(film.yResolution), 1);
      t2 = J.getInterceptor$asx(screenWindow);
      t3 = J.$sub$n(t2.$index(screenWindow, 1), t2.$index(screenWindow, 0));
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = J.$sub$n(t2.$index(screenWindow, 2), t2.$index(screenWindow, 3));
      if (typeof t4 !== "number")
        return H.iae(t4);
      t2 = t1.$mul(0, G.Transform_Scale(1 / t3, 1 / t4, 1)).$mul(0, G.Transform_Translate(new G.Vector(-J.toDouble$0$n(t2.$index(screenWindow, 0)), -J.toDouble$0$n(t2.$index(screenWindow, 3)), 0)));
      this.screenToRaster = t2;
      this.rasterToScreen = G.Transform$(t2.mInv, t2.m);
      t2 = this.cameraToScreen;
      this.rasterToCamera = G.Transform$(t2.mInv, t2.m).$mul(0, this.rasterToScreen);
    }
  },
  Quaternion: {
    "^": "Object;v<,w<",
    copy$1: function(other) {
      this.v = G.Vector$from(other.get$v());
      this.w = other.get$w();
      return this;
    },
    add$1: function(_, q) {
      this.v.add$1(0, q.get$v());
      this.w = this.w + q.get$w();
      return this;
    },
    $add: function(_, q) {
      return G.Quaternion$from(this).add$1(0, q);
    },
    $sub: function(_, q) {
      var t1, t2, t3, t4;
      t1 = G.Quaternion$from(this);
      t2 = t1.v;
      t3 = q.get$v();
      t4 = J.getInterceptor$x(t3);
      t2.x = J.$sub$n(t2.x, t4.get$x(t3));
      t2.y = J.$sub$n(t2.y, t4.get$y(t3));
      t2.z = J.$sub$n(t2.z, t4.get$z(t3));
      t1.w = t1.w - q.get$w();
      return t1;
    },
    scale$1: function(_, f) {
      var t1;
      this.v.scale$1(0, f);
      t1 = this.w;
      if (typeof f !== "number")
        return H.iae(f);
      this.w = t1 * f;
      return this;
    },
    $mul: function(_, f) {
      var t1, t2;
      t1 = G.Quaternion$from(this);
      t1.v.scale$1(0, f);
      t2 = t1.w;
      if (typeof f !== "number")
        return H.iae(f);
      t1.w = t2 * f;
      return t1;
    },
    $div: function(_, f) {
      var t1, t2;
      t1 = G.Quaternion$from(this);
      t1.v.invScale$1(f);
      t2 = t1.w;
      if (typeof f !== "number")
        return H.iae(f);
      t1.w = t2 / f;
      return t1;
    },
    toTransform$0: function() {
      var t1, xx, yy, zz, xy, xz, yz, wx, wy, wz, m, t2, t3, t4, t5, t6;
      t1 = this.v.x;
      xx = J.$mul$ns(t1, t1);
      t1 = this.v.y;
      yy = J.$mul$ns(t1, t1);
      t1 = this.v.z;
      zz = J.$mul$ns(t1, t1);
      t1 = this.v;
      xy = J.$mul$ns(t1.x, t1.y);
      t1 = this.v;
      xz = J.$mul$ns(t1.x, t1.z);
      t1 = this.v;
      yz = J.$mul$ns(t1.y, t1.z);
      wx = J.$mul$ns(this.v.x, this.w);
      wy = J.$mul$ns(this.v.y, this.w);
      wz = J.$mul$ns(this.v.z, this.w);
      m = G.Matrix4x4$();
      t1 = m.m;
      t2 = J.$add$ns(yy, zz);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = t1.length;
      if (0 >= t3)
        return H.ioore(t1, 0);
      t1[0] = 1 - 2 * t2;
      t2 = J.getInterceptor$ns(xy);
      t4 = t2.$add(xy, wz);
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (1 >= t3)
        return H.ioore(t1, 1);
      t1[1] = 2 * t4;
      t4 = J.getInterceptor$n(xz);
      t5 = t4.$sub(xz, wy);
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (2 >= t3)
        return H.ioore(t1, 2);
      t1[2] = 2 * t5;
      t2 = t2.$sub(xy, wz);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (4 >= t3)
        return H.ioore(t1, 4);
      t1[4] = 2 * t2;
      t2 = J.getInterceptor$ns(xx);
      t5 = t2.$add(xx, zz);
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (5 >= t3)
        return H.ioore(t1, 5);
      t1[5] = 1 - 2 * t5;
      t5 = J.getInterceptor$ns(yz);
      t6 = t5.$add(yz, wx);
      if (typeof t6 !== "number")
        return H.iae(t6);
      if (6 >= t3)
        return H.ioore(t1, 6);
      t1[6] = 2 * t6;
      t4 = t4.$add(xz, wy);
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (8 >= t3)
        return H.ioore(t1, 8);
      t1[8] = 2 * t4;
      t5 = t5.$sub(yz, wx);
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (9 >= t3)
        return H.ioore(t1, 9);
      t1[9] = 2 * t5;
      t2 = t2.$add(xx, yy);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (10 >= t3)
        return H.ioore(t1, 10);
      t1[10] = 1 - 2 * t2;
      return G.Transform$(G.Matrix4x4_Transpose(m), m);
    },
    Quaternion$fromMatrix$1: function(m) {
      var t1, t2, t3, t4, t5, trace, s, q, i, j, k, t6, t7;
      t1 = m.m;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (5 >= t2)
        return H.ioore(t1, 5);
      t4 = t1[5];
      if (10 >= t2)
        return H.ioore(t1, 10);
      t5 = t1[10];
      trace = t3 + t4 + t5;
      if (trace > 0) {
        s = Math.sqrt(trace + 1);
        this.w = s / 2;
        s = 0.5 / s;
        t2 = this.v;
        t2.x = (t1[9] - t1[6]) * s;
        t2.y = (t1[2] - t1[8]) * s;
        t2.z = (t1[4] - t1[1]) * s;
      } else {
        q = [0, 0, 0];
        i = t4 > t3 ? 1 : 0;
        t3 = i * 4 + i;
        if (t3 >= t2)
          return H.ioore(t1, t3);
        if (t5 > t1[t3])
          i = 2;
        j = C.List_1_2_0[i];
        if (j >>> 0 !== j || j >= 3)
          return H.ioore(C.List_1_2_0, j);
        k = C.List_1_2_0[j];
        t3 = i * 4;
        t4 = t3 + i;
        if (t4 >= t2)
          return H.ioore(t1, t4);
        t4 = t1[t4];
        t5 = j * 4 + j;
        if (t5 >= t2)
          return H.ioore(t1, t5);
        t5 = t1[t5];
        t6 = J.getInterceptor$ns(k);
        t7 = J.$add$ns(t6.$mul(k, 4), k);
        if (t7 >>> 0 !== t7 || t7 >= t2)
          return H.ioore(t1, t7);
        t7 = t1[t7];
        s = Math.sqrt(t4 - (t5 + t7) + 1);
        q[i] = s * 0.5;
        if (s !== 0)
          s = 0.5 / s;
        t4 = J.$add$ns(t6.$mul(k, 4), j);
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        t4 = t1[t4];
        if (typeof k !== "number")
          return H.iae(k);
        t5 = j * 4 + k;
        if (t5 >>> 0 !== t5 || t5 >= t2)
          return H.ioore(t1, t5);
        this.w = (t4 - t1[t5]) * s;
        t5 = j * 4 + i;
        if (t5 >= t2)
          return H.ioore(t1, t5);
        t5 = t1[t5];
        t4 = t3 + j;
        if (t4 >= t2)
          return H.ioore(t1, t4);
        q[j] = (t5 + t1[t4]) * s;
        t4 = k * 4 + i;
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        t4 = t1[t4];
        t3 += k;
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(t1, t3);
        t3 = t1[t3];
        if (k >>> 0 !== k || k >= 3)
          return H.ioore(q, k);
        q[k] = (t4 + t3) * s;
        t3 = this.v;
        t3.x = q[0];
        t3.y = q[1];
        t3.z = q[2];
      }
    },
    static: {Quaternion$from: function(q) {
        return new G.Quaternion(G.Vector$from(q.get$v()), q.get$w());
      }, Quaternion_Slerp: function(t, q1, q2) {
        var cosTheta, t1, t2, thetap, t3, qperp;
        cosTheta = G.Quaternion_Dot(q1, q2);
        t1 = J.getInterceptor$n(cosTheta);
        if (t1.$gt(cosTheta, 0.9995)) {
          t1 = J.$add$ns(J.$mul$ns(q1, 1 - t), J.$mul$ns(q2, t));
          t2 = G.Quaternion_Dot(t1, t1);
          if (typeof t2 !== "number")
            H.throwExpression(P.ArgumentError$(t2));
          return J.$div$n(t1, Math.sqrt(t2));
        } else {
          t1 = t1.clamp$2(cosTheta, -1, 1);
          thetap = Math.acos(t1) * t;
          t1 = J.getInterceptor$ns(q1);
          t2 = J.$sub$n(q2, t1.$mul(q1, cosTheta));
          t3 = G.Quaternion_Dot(t2, t2);
          if (typeof t3 !== "number")
            H.throwExpression(P.ArgumentError$(t3));
          qperp = J.$div$n(t2, Math.sqrt(t3));
          t1 = t1.$mul(q1, Math.cos(thetap));
          return J.$add$ns(t1, J.$mul$ns(qperp, Math.sin(thetap)));
        }
      }, Quaternion_Dot: function(q1, q2) {
        return J.$add$ns(G.Vector_Dot(q1.get$v(), q2.get$v()), q1.get$w() * q2.get$w());
      }}
  },
  Ray: {
    "^": "Object;origin*,direction<,minDistance<,maxDistance?,time@,depth",
    set$5: function(o, d, minDist, maxDist, time) {
      this.origin = new G.Point(o.get$x(o), o.get$y(o), o.get$z(o));
      this.direction = G.Vector$from(d);
      this.minDistance = minDist;
      this.maxDistance = maxDist;
      this.time = time;
    },
    pointAt$1: function(t) {
      var t1, t2;
      t1 = J.$add$ns(this.origin, J.$mul$ns(this.direction, t));
      t2 = J.getInterceptor$x(t1);
      return new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
    },
    static: {Ray$: function(o, d, minDistance, maxDistance, time, depth) {
        var t1, t2;
        if (o == null)
          t1 = new G.Point(0, 0, 0);
        else {
          t1 = J.getInterceptor$x(o);
          t1 = new G.Point(t1.get$x(o), t1.get$y(o), t1.get$z(o));
        }
        t2 = d == null ? new G.Vector(0, 0, 0) : G.Vector$from(d);
        return new G.Ray(t1, t2, minDistance, maxDistance, time, depth);
      }}
  },
  RayDifferential: {
    "^": "Ray;hasDifferentials<,rxOrigin?,ryOrigin,rxDirection,ryDirection,origin,direction,minDistance,maxDistance,time,depth",
    copy$1: function(b) {
      this.origin.copy$1(J.get$origin$x(b));
      this.direction.copy$1(b.get$direction());
      this.hasDifferentials = b.get$hasDifferentials();
      this.rxOrigin.copy$1(b.rxOrigin);
      this.ryOrigin.copy$1(b.ryOrigin);
      this.rxDirection.copy$1(b.rxDirection);
      this.ryDirection.copy$1(b.ryDirection);
    },
    scaleDifferentials$1: function(s) {
      var t1, t2;
      t1 = this.origin;
      t1 = J.$add$ns(t1, J.$mul$ns(J.$sub$n(this.rxOrigin, t1), s));
      t2 = J.getInterceptor$x(t1);
      this.rxOrigin = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
      t1 = this.origin;
      t1 = J.$add$ns(t1, J.$mul$ns(J.$sub$n(this.ryOrigin, t1), s));
      t2 = J.getInterceptor$x(t1);
      this.ryOrigin = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
      t1 = this.direction;
      this.rxDirection = J.$add$ns(t1, J.$mul$ns(J.$sub$n(this.rxDirection, t1), s));
      t1 = this.direction;
      this.ryDirection = J.$add$ns(t1, J.$mul$ns(J.$sub$n(this.ryDirection, t1), s));
    },
    static: {RayDifferential$fromRay: function(ray) {
        var t1, t2, t3, t4, t5, t6, t7, t8;
        t1 = J.get$origin$x(ray);
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        t2 = G.Vector$from(ray.get$direction());
        t5 = ray.minDistance;
        t6 = ray.maxDistance;
        t7 = ray.time;
        t8 = ray.depth;
        t1 = new G.Point(t3, t4, t1);
        t2 = G.Vector$from(t2);
        return new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t1, t2, t5, t6, t7, t8);
      }}
  },
  Anisotropic: {
    "^": "MicrofacetDistribution;ex,ey",
    d$1: function(wh) {
      var t1, costhetah, d, t2, t3, t4, t5, t6, t7, t8;
      t1 = J.getInterceptor$x(wh);
      costhetah = J.abs$0$n(t1.get$z(wh));
      d = 1 - costhetah * costhetah;
      if (d === 0)
        return 0;
      t2 = this.ex;
      t3 = t1.get$x(wh);
      if (typeof t2 !== "number")
        return t2.$mul();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = t1.get$x(wh);
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = this.ey;
      t6 = t1.get$y(wh);
      if (typeof t5 !== "number")
        return t5.$mul();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t1 = t1.get$y(wh);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t7 = this.ex;
      if (typeof t7 !== "number")
        return t7.$add();
      t8 = this.ey;
      if (typeof t8 !== "number")
        return t8.$add();
      t7 = Math.sqrt((t7 + 2) * (t8 + 2));
      return t7 * 0.15915494309189535 * Math.pow(costhetah, (t2 * t3 * t4 + t5 * t6 * t1) / d);
    },
    pdf$2: function(wo, wi) {
      var t1, t2, wh, costhetah, ds, t3, t4, t5, t6, t7, t8, anisotropic_pdf;
      t1 = J.$add$ns(wo, wi);
      t2 = J.getInterceptor$asx(t1);
      wh = t2.$div(t1, t2.length$0(t1));
      t1 = J.getInterceptor$x(wh);
      costhetah = J.abs$0$n(t1.get$z(wh));
      ds = 1 - costhetah * costhetah;
      if (ds > 0 && J.$gt$n(G.Vector_Dot(wo, wh), 0)) {
        t2 = this.ex;
        t3 = t1.get$x(wh);
        if (typeof t2 !== "number")
          return t2.$mul();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = t1.get$x(wh);
        if (typeof t4 !== "number")
          return H.iae(t4);
        t5 = this.ey;
        t6 = t1.get$y(wh);
        if (typeof t5 !== "number")
          return t5.$mul();
        if (typeof t6 !== "number")
          return H.iae(t6);
        t1 = t1.get$y(wh);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t7 = this.ex;
        if (typeof t7 !== "number")
          return t7.$add();
        t8 = this.ey;
        if (typeof t8 !== "number")
          return t8.$add();
        t7 = Math.sqrt((t7 + 1) * (t8 + 1));
        t1 = Math.pow(costhetah, (t2 * t3 * t4 + t5 * t6 * t1) / ds);
        t2 = G.Vector_Dot(wo, wh);
        if (typeof t2 !== "number")
          return H.iae(t2);
        anisotropic_pdf = t7 * 0.15915494309189535 * t1 / (4 * t2);
      } else
        anisotropic_pdf = 0;
      return anisotropic_pdf;
    },
    sampleFirstQuadrant$3: function(u1, u2, phi_costheta) {
      var t1, t2, cosphi, sinphi;
      t1 = this.ex;
      t2 = this.ey;
      if (t1 == null ? t2 == null : t1 === t2) {
        t1 = 3.141592653589793 * u1 * 0.5;
        phi_costheta[0] = t1;
      } else {
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return t2.$add();
        t1 = Math.sqrt((t1 + 1) / (t2 + 1));
        t2 = Math.tan(3.141592653589793 * u1 * 0.5);
        t1 = Math.atan(t1 * t2);
        phi_costheta[0] = t1;
      }
      cosphi = Math.cos(t1);
      t1 = phi_costheta[0];
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      sinphi = Math.sin(t1);
      t1 = this.ex;
      if (typeof t1 !== "number")
        return t1.$mul();
      t2 = this.ey;
      if (typeof t2 !== "number")
        return t2.$mul();
      if (typeof u2 !== "number")
        H.throwExpression(P.ArgumentError$(u2));
      phi_costheta[1] = Math.pow(u2, 1 / (t1 * cosphi * cosphi + t2 * sinphi * sinphi + 1));
    },
    Anisotropic$2: function(ex, ey) {
      var t1 = this.ex;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 10000 || isNaN(t1))
        this.ex = 10000;
      t1 = this.ey;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 10000 || isNaN(t1))
        this.ey = 10000;
    }
  },
  Blinn: {
    "^": "MicrofacetDistribution;exponent",
    pdf$2: function(wi, wo) {
      var t1, wh, costheta, t2, t3, blinn_pdf;
      t1 = wo.$add(0, wi);
      wh = t1.$div(0, t1.length$0(0));
      costheta = J.abs$0$n(wh.z);
      t1 = this.exponent;
      if (typeof t1 !== "number")
        return t1.$add();
      t2 = Math.pow(costheta, t1);
      t3 = G.Vector_Dot(wo, wh);
      if (typeof t3 !== "number")
        return H.iae(t3);
      blinn_pdf = (t1 + 1) * t2 / (25.132741228718345 * t3);
      return J.$le$n(G.Vector_Dot(wo, wh), 0) ? 0 : blinn_pdf;
    },
    Blinn$1: function(exponent) {
      var t1 = this.exponent;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 10000 || isNaN(t1))
        this.exponent = 10000;
    },
    static: {Blinn$: function(exponent) {
        var t1 = new G.Blinn(exponent);
        t1.Blinn$1(exponent);
        return t1;
      }}
  },
  BRDFToBTDF: {
    "^": "BxDF;brdf,type",
    f$2: [function(wo, wi) {
      var t1 = J.getInterceptor$x(wi);
      return this.brdf.f$2(wo, new G.Vector(t1.get$x(wi), t1.get$y(wi), J.$negate$n(t1.get$z(wi))));
    }, "call$2", "get$f", 4, 0, 95],
    sample_f$5: function(wo, wi, u1, u2, pdf) {
      var f, t1, t2, t3;
      f = this.brdf.sample_f$5(wo, wi, u1, u2, pdf);
      t1 = wi.x;
      t2 = wi.y;
      t3 = J.$negate$n(wi.z);
      wi.x = t1;
      wi.y = t2;
      wi.z = t3;
      return f;
    },
    rho$3: function(w, nSamples, samples) {
      var t1 = J.getInterceptor$x(w);
      return this.brdf.rho$3(new G.Vector(t1.get$x(w), t1.get$y(w), J.$negate$n(t1.get$z(w))), nSamples, samples);
    },
    rho2$3: function(nSamples, samples1, samples2) {
      return this.brdf.rho2$3(nSamples, samples1, samples2);
    },
    pdf$2: function(wo, wi) {
      return this.brdf.pdf$2(wo, new G.Vector(wi.x, wi.y, J.$negate$n(wi.z)));
    },
    static: {BRDFToBTDF$: function(b) {
        var t1 = b.type;
        if (typeof t1 !== "number")
          return t1.$xor();
        return new G.BRDFToBTDF(b, (t1 ^ 3) >>> 0);
      }}
  },
  BSDF: {
    "^": "Object;dgShading,eta,nn<,ng,sn,tn,nBxDFs,bxdfs",
    sample_f$6: function(woW, wiW, bsdfSample, pdf, flags, sampledType) {
      var matchingComps, t1, which, count, i, bxdf, count0, t2, wo, wi, f, t3;
      matchingComps = this.numComponents$1(flags);
      if (matchingComps === 0) {
        J.$indexSet$ax(pdf, 0, 0);
        if (sampledType != null)
          sampledType[0] = 0;
        t1 = new G.RGBColor(new Float32Array(3));
        t1.Spectrum$samples$2(3, 0);
        return t1;
      }
      which = P.min(J.floor$0$n(J.$mul$ns(bsdfSample.get$uComponent(), matchingComps)), matchingComps - 1);
      for (t1 = this.bxdfs, count = which, i = 0; bxdf = null, i < this.nBxDFs; ++i) {
        if (i >= 8)
          return H.ioore(t1, i);
        if (t1[i].matchesFlags$1(flags)) {
          count0 = count - 1;
          t2 = count === 0;
          count = count0;
        } else
          t2 = false;
        if (t2) {
          bxdf = t1[i];
          break;
        }
      }
      wo = this.worldToLocal$1(woW);
      wi = new G.Vector(0, 0, 0);
      t2 = J.getInterceptor$ax(pdf);
      t2.$indexSet(pdf, 0, 0);
      f = bxdf.sample_f$5(wo, wi, bsdfSample.get$uDir()[0], bsdfSample.uDir[1], pdf);
      if (J.$eq(t2.$index(pdf, 0), 0)) {
        if (sampledType != null)
          sampledType[0] = 0;
        return G.Spectrum_Spectrum(0);
      }
      if (sampledType != null)
        sampledType[0] = bxdf.get$type(bxdf);
      wiW.copy$1(this.localToWorld$1(wi));
      t3 = bxdf.get$type(bxdf);
      if (typeof t3 !== "number")
        return t3.$and();
      if ((t3 & 16) === 0 && matchingComps > 1)
        for (i = 0; i < this.nBxDFs; ++i) {
          if (i >= 8)
            return H.ioore(t1, i);
          if (!J.$eq(t1[i], bxdf) && t1[i].matchesFlags$1(flags))
            t2.$indexSet(pdf, 0, J.$add$ns(t2.$index(pdf, 0), t1[i].pdf$2(wo, wi)));
        }
      if (matchingComps > 1)
        t2.$indexSet(pdf, 0, J.$div$n(t2.$index(pdf, 0), matchingComps));
      t2 = bxdf.type;
      if (typeof t2 !== "number")
        return t2.$and();
      if ((t2 & 16) === 0) {
        f = G.Spectrum_Spectrum(0);
        t2 = J.getInterceptor$n(flags);
        flags = J.$gt$n(J.$mul$ns(G.Vector_Dot(wiW, this.ng), G.Vector_Dot(woW, this.ng)), 0) ? t2.$and(flags, 4294967293) : t2.$and(flags, 4294967294);
        for (i = 0; i < this.nBxDFs; ++i) {
          if (i >= 8)
            return H.ioore(t1, i);
          if (t1[i].matchesFlags$1(flags))
            f = f.$add(0, t1[i].f$2(wo, wi));
        }
      }
      return f;
    },
    sample_f$5: function(woW, wiW, bsdfSample, pdf, flags) {
      return this.sample_f$6(woW, wiW, bsdfSample, pdf, flags, null);
    },
    sample_f$4: function(woW, wiW, bsdfSample, pdf) {
      return this.sample_f$6(woW, wiW, bsdfSample, pdf, 31, null);
    },
    pdf$3: function(woW, wiW, flags) {
      var wo, wi, t1, pdf, matchingComps, i;
      if (this.nBxDFs === 0)
        return 0;
      wo = this.worldToLocal$1(woW);
      wi = this.worldToLocal$1(wiW);
      for (t1 = this.bxdfs, pdf = 0, matchingComps = 0, i = 0; i < this.nBxDFs; ++i) {
        if (i >= 8)
          return H.ioore(t1, i);
        if (t1[i].matchesFlags$1(flags)) {
          ++matchingComps;
          pdf += t1[i].pdf$2(wo, wi);
        }
      }
      return matchingComps > 0 ? pdf / matchingComps : 0;
    },
    pdf$2: function(woW, wiW) {
      return this.pdf$3(woW, wiW, 31);
    },
    add$1: function(_, bxdf) {
      var t1, t2;
      t1 = this.bxdfs;
      t2 = this.nBxDFs++;
      if (t2 >= 8)
        return H.ioore(t1, t2);
      t1[t2] = bxdf;
    },
    numComponents$1: function(flags) {
      var t1, num, i;
      if (flags == null)
        return this.nBxDFs;
      for (t1 = this.bxdfs, num = 0, i = 0; i < this.nBxDFs; ++i) {
        if (i >= 8)
          return H.ioore(t1, i);
        if (t1[i].matchesFlags$1(flags))
          ++num;
      }
      return num;
    },
    numComponents$0: function() {
      return this.numComponents$1(null);
    },
    worldToLocal$1: function(v) {
      return new G.Vector(G.Vector_Dot(v, this.sn), G.Vector_Dot(v, this.tn), G.Vector_Dot(v, this.nn));
    },
    localToWorld$1: function(v) {
      return new G.Vector(J.$add$ns(J.$add$ns(J.$mul$ns(J.get$x$x(this.sn), v.x), J.$mul$ns(this.tn.x, v.y)), J.$mul$ns(J.get$x$x(this.nn), v.z)), J.$add$ns(J.$add$ns(J.$mul$ns(J.get$y$x(this.sn), v.x), J.$mul$ns(this.tn.y, v.y)), J.$mul$ns(J.get$y$x(this.nn), v.z)), J.$add$ns(J.$add$ns(J.$mul$ns(J.get$z$x(this.sn), v.x), J.$mul$ns(this.tn.z, v.y)), J.$mul$ns(J.get$z$x(this.nn), v.z)));
    },
    f$3: [function(woW, wiW, flags) {
      var wi, wo, t1, f, i;
      wi = this.worldToLocal$1(wiW);
      wo = this.worldToLocal$1(woW);
      t1 = J.getInterceptor$n(flags);
      flags = J.$gt$n(J.$mul$ns(G.Vector_Dot(wiW, this.ng), G.Vector_Dot(woW, this.ng)), 0) ? t1.$and(flags, 4294967293) : t1.$and(flags, 4294967294);
      f = G.Spectrum_Spectrum(0);
      for (t1 = this.bxdfs, i = 0; i < this.nBxDFs; ++i) {
        if (i >= 8)
          return H.ioore(t1, i);
        if (t1[i].matchesFlags$1(flags))
          f = f.$add(0, t1[i].f$2(wo, wi));
      }
      return f;
    }, function(woW, wiW) {
      return this.f$3(woW, wiW, 31);
    }, "f$2", "call$3", "call$2", "get$f", 4, 2, 96, 97],
    rho$3: function(rng, flags, sqrtSamples) {
      var nSamples, t1, t2, s1, s2, ret, i;
      if (typeof sqrtSamples !== "number")
        return sqrtSamples.$mul();
      nSamples = sqrtSamples * sqrtSamples;
      t1 = 2 * nSamples;
      t2 = Array(t1);
      t2.fixed$length = init;
      s1 = H.setRuntimeTypeInfo(t2, [J.JSDouble]);
      G.StratifiedSample2D(s1, sqrtSamples, sqrtSamples, rng, true);
      t1 = Array(t1);
      t1.fixed$length = init;
      s2 = H.setRuntimeTypeInfo(t1, [J.JSDouble]);
      G.StratifiedSample2D(s2, sqrtSamples, sqrtSamples, rng, true);
      ret = G.Spectrum_Spectrum(0);
      for (t1 = this.bxdfs, i = 0; i < this.nBxDFs; ++i) {
        if (i >= 8)
          return H.ioore(t1, i);
        if (t1[i].matchesFlags$1(flags))
          ret = ret.$add(0, t1[i].rho2$3(nSamples, s1, s2));
      }
      return ret;
    },
    rho$2: function(rng, flags) {
      return this.rho$3(rng, flags, 6);
    },
    rho2$4: function(wo, rng, flags, sqrtSamples) {
      var nSamples, t1, s1, ret, i;
      nSamples = sqrtSamples * sqrtSamples;
      t1 = Array(2 * nSamples);
      t1.fixed$length = init;
      s1 = H.setRuntimeTypeInfo(t1, [J.JSDouble]);
      G.StratifiedSample2D(s1, sqrtSamples, sqrtSamples, rng, true);
      ret = G.Spectrum_Spectrum(0);
      for (t1 = this.bxdfs, i = 0; i < this.nBxDFs; ++i) {
        if (i >= 8)
          return H.ioore(t1, i);
        if (t1[i].matchesFlags$1(flags))
          ret = ret.$add(0, t1[i].rho$3(wo, nSamples, s1));
      }
      return ret;
    },
    rho2$3: function(wo, rng, flags) {
      return this.rho2$4(wo, rng, flags, 6);
    },
    rho2$2: function(wo, rng) {
      return this.rho2$4(wo, rng, 31, 6);
    },
    BSDF$3: function(dgShading, ngeom, eta) {
      var t1;
      this.ng = ngeom;
      t1 = this.dgShading;
      this.nn = t1.nn;
      t1 = t1.dpdu;
      t1 = t1.$div(t1, t1.length$0(0));
      this.sn = t1;
      this.tn = G.Vector_Cross(this.nn, t1);
      this.nBxDFs = 0;
    },
    static: {"^": "BSDF_MAX_BxDFS", BSDF$: function(dgShading, ngeom, eta) {
        var t1 = new G.BSDF(dgShading, eta, null, null, null, null, null, H.setRuntimeTypeInfo(Array(8), [G.BxDF]));
        t1.BSDF$3(dgShading, ngeom, eta);
        return t1;
      }}
  },
  BSDFSample: {
    "^": "Object;uDir<,uComponent<",
    BSDFSample$sample$3: function(sample, offsets, n) {
      var t1, t2, t3, t4;
      t1 = this.uDir;
      t2 = sample.get$twoD();
      t3 = offsets.get$dirOffset();
      if (t3 < 0 || t3 >= t2.length)
        return H.ioore(t2, t3);
      t4 = 2 * n;
      t1[0] = J.$index$asx(t2[t3], t4);
      t3 = sample.twoD;
      t2 = offsets.dirOffset;
      if (t2 < 0 || t2 >= t3.length)
        return H.ioore(t3, t2);
      t1[1] = J.$index$asx(t3[t2], t4 + 1);
      t4 = sample.oneD;
      t2 = offsets.componentOffset;
      if (t2 < 0 || t2 >= t4.length)
        return H.ioore(t4, t2);
      this.uComponent = J.$index$asx(t4[t2], n);
    },
    BSDFSample$random$1: function(rng) {
      var t1 = this.uDir;
      t1[0] = rng.randomFloat$0();
      t1[1] = rng.randomFloat$0();
      this.uComponent = rng.randomFloat$0();
    },
    static: {BSDFSample$random: function(rng) {
        var t1 = new G.BSDFSample(H.setRuntimeTypeInfo(Array(2), [J.JSDouble]), 0);
        t1.BSDFSample$random$1(rng);
        return t1;
      }, BSDFSample$sample: function(sample, offsets, n) {
        var t1 = new G.BSDFSample(H.setRuntimeTypeInfo(Array(2), [J.JSDouble]), 0);
        t1.BSDFSample$sample$3(sample, offsets, n);
        return t1;
      }}
  },
  BSDFSampleOffsets: {
    "^": "Object;nSamples<,componentOffset,dirOffset<",
    BSDFSampleOffsets$2: function(nSamples, sample) {
      var t1 = this.nSamples;
      sample.n1D.push(t1);
      this.componentOffset = sample.n1D.length - 1;
      t1 = this.nSamples;
      sample.n2D.push(t1);
      this.dirOffset = sample.n2D.length - 1;
    },
    static: {BSDFSampleOffsets$: function(nSamples, sample) {
        var t1 = new G.BSDFSampleOffsets(nSamples, null, null);
        t1.BSDFSampleOffsets$2(nSamples, sample);
        return t1;
      }}
  },
  BxDF: {
    "^": "Object;type>",
    matchesFlags$1: function(flags) {
      var t1 = this.type;
      if (typeof t1 !== "number")
        return t1.$and();
      if (typeof flags !== "number")
        return H.iae(flags);
      return (t1 & flags) >>> 0 === t1;
    },
    sample_f$5: function(wo, out_wi, u1, u2, out_pdf) {
      var t1 = G.CosineSampleHemisphere(u1, u2);
      out_wi.x = t1.x;
      out_wi.y = t1.y;
      out_wi.z = t1.z;
      if (J.$lt$n(J.get$z$x(wo), 0))
        out_wi.z = J.$mul$ns(out_wi.z, -1);
      J.$indexSet$ax(out_pdf, 0, this.pdf$2(wo, out_wi));
      return this.f$2(wo, out_wi);
    },
    rho$3: function(w, nSamples, samples) {
      var r, t1, i, wi, pdf, t2, t3, f;
      r = G.Spectrum_Spectrum(0);
      for (t1 = samples.length, i = 0; i < nSamples; ++i) {
        wi = new G.Vector(0, 0, 0);
        pdf = [0];
        t2 = 2 * i;
        if (t2 >= t1)
          return H.ioore(samples, t2);
        t3 = samples[t2];
        ++t2;
        if (t2 >= t1)
          return H.ioore(samples, t2);
        f = this.sample_f$5(w, wi, t3, samples[t2], pdf);
        if (0 >= pdf.length)
          return H.ioore(pdf, 0);
        if (J.$gt$n(pdf[0], 0)) {
          t2 = J.abs$0$n(wi.z);
          if (0 >= pdf.length)
            return H.ioore(pdf, 0);
          t3 = pdf[0];
          if (typeof t3 !== "number")
            return H.iae(t3);
          r = r.$add(0, J.$mul$ns(f, t2 / t3));
        }
      }
      return r.$div(0, nSamples);
    },
    rho2$3: function(nSamples, samples1, samples2) {
      var r, t1, t2, i, wi, t3, z, t4, t5, t6, r0, phi, wo, pdf_i, f;
      r = G.Spectrum_Spectrum(0);
      for (t1 = samples2.length, t2 = samples1.length, i = 0; i < nSamples; ++i) {
        wi = new G.Vector(0, 0, 0);
        t3 = 2 * i;
        if (t3 >= t2)
          return H.ioore(samples1, t3);
        z = samples1[t3];
        t4 = t3 + 1;
        if (t4 >= t2)
          return H.ioore(samples1, t4);
        t5 = samples1[t4];
        t6 = J.$mul$ns(z, z);
        if (typeof t6 !== "number")
          return H.iae(t6);
        t6 = P.max(0, 1 - t6);
        r0 = Math.sqrt(t6);
        if (typeof t5 !== "number")
          return H.iae(t5);
        phi = 6.283185307179586 * t5;
        t5 = Math.cos(phi);
        wo = new G.Vector(r0 * t5, r0 * Math.sin(phi), z);
        pdf_i = [0];
        if (t3 >= t1)
          return H.ioore(samples2, t3);
        t3 = samples2[t3];
        if (t4 >= t1)
          return H.ioore(samples2, t4);
        f = this.sample_f$5(wo, wi, t3, samples2[t4], pdf_i);
        if (0 >= pdf_i.length)
          return H.ioore(pdf_i, 0);
        if (J.$gt$n(pdf_i[0], 0)) {
          t3 = J.abs$0$n(wi.z);
          t4 = J.abs$0$n(wo.z);
          if (0 >= pdf_i.length)
            return H.ioore(pdf_i, 0);
          t5 = pdf_i[0];
          if (typeof t5 !== "number")
            return H.iae(t5);
          r = r.$add(0, J.$mul$ns(f, t3 * t4 / (0.15915494309189535 * t5)));
        }
      }
      return r.$div(0, 3.141592653589793 * nSamples);
    },
    pdf$2: function(wo, wi) {
      return J.$gt$n(J.$mul$ns(J.get$z$x(wo), wi.z), 0) ? J.abs$0$n(wi.z) * 0.3183098861837907 : 0;
    }
  },
  Fresnel: {
    "^": "Object;"
  },
  FresnelBlend: {
    "^": "BxDF;Rd,Rs,distribution,type",
    f$2: [function(wo, wi) {
      var t1, t2, t3, t4, t5, t6, diffuse, wh, a, b;
      t1 = this.Rs;
      t2 = this.Rd.$mul(0, 0.387507687528093).$mul(0, G.Spectrum_Spectrum(1).$sub(0, t1));
      t3 = J.getInterceptor$x(wi);
      t4 = J.abs$0$n(t3.get$z(wi));
      t4 = Math.pow(1 - 0.5 * t4, 5);
      t5 = J.getInterceptor$x(wo);
      t6 = J.abs$0$n(t5.get$z(wo));
      diffuse = t2.$mul(0, (1 - t4) * (1 - Math.pow(1 - 0.5 * t6, 5)));
      wh = t3.$add(wi, wo);
      if (J.$eq(wh.get$x(wh), 0) && J.$eq(wh.get$y(wh), 0) && J.$eq(wh.get$z(wh), 0))
        return G.Spectrum_Spectrum(0);
      wh = wh.$div(wh, wh.length$0(0));
      a = G.Spectrum_Spectrum(this.distribution.d$1(wh));
      t2 = G.Vector_Dot(wi, wh);
      t4 = G.Spectrum_Spectrum(1).$sub(0, t1);
      if (typeof t2 !== "number")
        return H.iae(t2);
      b = t1.$add(0, t4.$mul(0, Math.pow(1 - t2, 5)));
      t1 = G.Vector_AbsDot(wi, wh);
      t5 = P.max(J.abs$0$n(t3.get$z(wi)), J.abs$0$n(t5.get$z(wo)));
      return diffuse.$add(0, a.$div(0, b).$mul(0, 4 * t1 * t5));
    }, "call$2", "get$f", 4, 0, 95],
    sample_f$5: function(wi, wo, u1, u2, outPdf) {
      var t1, phi_cosTheta, t2, phi, cosTheta, sintheta, t3, wh, t4, t5, t6, t7, t8, costhetah, ds, anisotropic_pdf;
      t1 = J.getInterceptor$n(u1);
      if (t1.$lt(u1, 0.5)) {
        if (typeof u1 !== "number")
          return H.iae(u1);
        wi.copy$1(G.CosineSampleHemisphere(2 * u1, u2));
        if (J.$lt$n(wo.z, 0)) {
          t1 = J.getInterceptor$x(wi);
          t1.set$z(wi, J.$mul$ns(t1.get$z(wi), -1));
        }
      } else {
        t1 = t1.$sub(u1, 0.5);
        if (typeof t1 !== "number")
          return H.iae(t1);
        u1 = 2 * t1;
        t1 = this.distribution;
        phi_cosTheta = [0, 0];
        if (u1 < 0.25)
          t1.sampleFirstQuadrant$3(4 * u1, u2, phi_cosTheta);
        else if (u1 < 0.5) {
          t1.sampleFirstQuadrant$3(4 * (0.5 - u1), u2, phi_cosTheta);
          t2 = phi_cosTheta[0];
          if (typeof t2 !== "number")
            return H.iae(t2);
          phi_cosTheta[0] = 3.141592653589793 - t2;
        } else if (u1 < 0.75) {
          t1.sampleFirstQuadrant$3(4 * (u1 - 0.5), u2, phi_cosTheta);
          phi_cosTheta[0] = J.$add$ns(phi_cosTheta[0], 3.141592653589793);
        } else {
          t1.sampleFirstQuadrant$3(4 * (1 - u1), u2, phi_cosTheta);
          t2 = phi_cosTheta[0];
          if (typeof t2 !== "number")
            return H.iae(t2);
          phi_cosTheta[0] = 6.283185307179586 - t2;
        }
        phi = phi_cosTheta[0];
        cosTheta = phi_cosTheta[1];
        t2 = J.$mul$ns(cosTheta, cosTheta);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = P.max(0, 1 - t2);
        sintheta = Math.sqrt(t2);
        t2 = typeof phi !== "number";
        if (t2)
          H.throwExpression(P.ArgumentError$(phi));
        t3 = sintheta * Math.cos(phi);
        if (t2)
          H.throwExpression(P.ArgumentError$(phi));
        t2 = sintheta * Math.sin(phi);
        wh = new G.Vector(t3, t2, cosTheta);
        if (!J.$gt$n(J.$mul$ns(wo.z, cosTheta), 0))
          wh = new G.Vector(-t3, -t2, J.$negate$n(cosTheta));
        t2 = J.$negate$n(wo.x);
        t3 = J.$negate$n(wo.y);
        t4 = J.$negate$n(wo.z);
        t5 = J.$mul$ns(wh.x, 2);
        t6 = J.$mul$ns(wh.y, 2);
        t7 = J.$mul$ns(wh.z, 2);
        t8 = J.$add$ns(J.$add$ns(J.$mul$ns(wo.x, wh.x), J.$mul$ns(wo.y, wh.y)), J.$mul$ns(wo.z, wh.z));
        t5 = J.$mul$ns(t5, t8);
        t6 = J.$mul$ns(t6, t8);
        t8 = J.$mul$ns(t7, t8);
        wi.copy$1(new G.Vector(J.$add$ns(t2, t5), J.$add$ns(t3, t6), J.$add$ns(t4, t8)));
        costhetah = J.abs$0$n(wh.z);
        ds = 1 - costhetah * costhetah;
        if (ds > 0 && J.$gt$n(J.$add$ns(J.$add$ns(J.$mul$ns(wo.x, wh.x), J.$mul$ns(wo.y, wh.y)), J.$mul$ns(wo.z, wh.z)), 0)) {
          t2 = t1.ex;
          t3 = wh.x;
          if (typeof t2 !== "number")
            return t2.$mul();
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1 = t1.ey;
          t4 = wh.y;
          if (typeof t1 !== "number")
            return t1.$mul();
          if (typeof t4 !== "number")
            return H.iae(t4);
          t5 = Math.sqrt((t2 + 1) * (t1 + 1));
          t1 = Math.pow(costhetah, (t2 * t3 * t3 + t1 * t4 * t4) / ds);
          t2 = J.$add$ns(J.$add$ns(J.$mul$ns(wo.x, wh.x), J.$mul$ns(wo.y, wh.y)), J.$mul$ns(wo.z, wh.z));
          if (typeof t2 !== "number")
            return H.iae(t2);
          anisotropic_pdf = t5 * 0.15915494309189535 * t1 / (4 * t2);
        } else
          anisotropic_pdf = 0;
        J.$indexSet$ax(outPdf, 0, anisotropic_pdf);
        if (!J.$gt$n(J.$mul$ns(wo.z, J.get$z$x(wi)), 0))
          return G.Spectrum_Spectrum(0);
      }
      J.$indexSet$ax(outPdf, 0, this.pdf$2(wo, wi));
      return this.f$2(wo, wi);
    },
    pdf$2: function(wi, wo) {
      var t1 = J.getInterceptor$x(wi);
      if (!J.$gt$n(J.$mul$ns(J.get$z$x(wo), t1.get$z(wi)), 0))
        return 0;
      return 0.5 * (J.abs$0$n(t1.get$z(wi)) * 0.3183098861837907 + this.distribution.pdf$2(wo, wi));
    }
  },
  FresnelConductor: {
    "^": "Fresnel;eta,k",
    evaluate$1: function(cosi) {
      var t1, cosSqr, t2, t3, tmp, t4, t5, Rparl2, tmp_f;
      cosi = J.abs$0$n(cosi);
      t1 = cosi * cosi;
      cosSqr = G.Spectrum_Spectrum(t1);
      t2 = this.eta;
      t3 = this.k;
      tmp = t2.$mul(0, t2).$add(0, t3.$mul(0, t3)).$mul(0, t1);
      t1 = 2 * cosi;
      t4 = tmp.$sub(0, t2.$mul(t2, t1));
      t5 = $.get$FresnelConductor_ONE();
      Rparl2 = t4.$add(0, t5).$div(0, tmp.$add(0, t2.$mul(t2, t1)).$add(0, t5));
      tmp_f = t2.$mul(t2, t2).$add(0, t3.$mul(t3, t3));
      return Rparl2.$add(0, tmp_f.$sub(0, t2.$mul(t2, t1)).$add(0, cosSqr).$div(0, tmp_f.$add(0, t2.$mul(t2, t1)).$add(0, cosSqr))).$div(0, 2);
    },
    static: {"^": "FresnelConductor_ONE", FresnelConductor$: function(e, kk) {
        return new G.FresnelConductor(G.Spectrum_Spectrum$from(e, 0), G.Spectrum_Spectrum$from(kk, 0));
      }}
  },
  FresnelDielectric: {
    "^": "Fresnel;eta_i,eta_t",
    evaluate$1: function(cosi) {
      var ei, et, t0, t1, t2, t3, sint, cost, Rparl, Rperp;
      cosi = J.clamp$2$n(cosi, -1, 1);
      if (typeof cosi !== "number")
        return cosi.$gt();
      ei = this.eta_i;
      et = this.eta_t;
      if (!(cosi > 0)) {
        t0 = et;
        et = ei;
        ei = t0;
      }
      t1 = J.getInterceptor$n(ei);
      t2 = t1.$div(ei, et);
      t3 = P.max(0, 1 - cosi * cosi);
      sint = J.$mul$ns(t2, Math.sqrt(t3));
      t2 = J.getInterceptor$n(sint);
      if (t2.$ge(sint, 1))
        return G.Spectrum_Spectrum(1);
      t2 = t2.$mul(sint, sint);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = P.max(0, 1 - t2);
      cost = Math.sqrt(t2);
      cosi = Math.abs(cosi);
      t2 = J.getInterceptor$ns(et);
      Rparl = J.$div$n(J.$sub$n(t2.$mul(et, cosi), t1.$mul(ei, cost)), J.$add$ns(t2.$mul(et, cosi), t1.$mul(ei, cost)));
      Rperp = J.$div$n(J.$sub$n(t1.$mul(ei, cosi), t2.$mul(et, cost)), J.$add$ns(t1.$mul(ei, cosi), t2.$mul(et, cost)));
      return G.Spectrum_Spectrum(J.$div$n(J.$add$ns(J.$mul$ns(Rparl, Rparl), J.$mul$ns(Rperp, Rperp)), 2));
    }
  },
  FresnelNoOp: {
    "^": "Fresnel;",
    evaluate$1: function($double) {
      return G.Spectrum_Spectrum(1);
    }
  },
  IrregIsotropicBRDFSample: {
    "^": "Object;p>,v<",
    p$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.p.call$4(arg0, arg1, arg2, arg3);
    }
  },
  IrregularIsotropicBRDF: {
    "^": "BxDF;isoBRDFData,type",
    f$2: [function(wo, wi) {
      var m, t1, lastMaxDist2, t2;
      m = G.BRDFRemap(wo, wi);
      for (t1 = this.isoBRDFData, lastMaxDist2 = 0.001; true;) {
        t2 = {};
        t2.v_0 = G.Spectrum_Spectrum(0);
        t2.sumWeights_1 = 0;
        t2.nFound_2 = 0;
        t1._core0$_lookup$4(0, m, new G.IrregularIsotropicBRDF_f_proc(t2), [lastMaxDist2]);
        if (t2.nFound_2 > 2 || lastMaxDist2 > 1.5)
          return t2.v_0.clamp$0(0).$div(0, t2.sumWeights_1);
        lastMaxDist2 *= 2;
      }
    }, "call$2", "get$f", 4, 0, 95]
  },
  IrregularIsotropicBRDF_f_proc: {
    "^": "Closure:98;box_0",
    call$4: function(p, sample, d2, maxDist2) {
      var weight, t1;
      if (typeof d2 !== "number")
        return H.iae(d2);
      weight = Math.exp(-100 * d2);
      t1 = this.box_0;
      t1.v_0 = t1.v_0.$add(0, J.$mul$ns(sample.get$v(), weight));
      t1.sumWeights_1 += weight;
      ++t1.nFound_2;
    }
  },
  Lambertian: {
    "^": "BxDF;R,type",
    f$2: [function(wo, wi) {
      return this.R.$mul(0, 0.3183098861837907);
    }, "call$2", "get$f", 4, 0, 95],
    rho$3: function(Vector, $int, samples) {
      return this.R;
    },
    rho2$3: function($int, samples1, samples2) {
      return this.R;
    },
    static: {Lambertian$: function(reflectance) {
        return new G.Lambertian(G.Spectrum_Spectrum$from(reflectance, 0), 5);
      }}
  },
  Microfacet: {
    "^": "BxDF;R,distribution,fresnel,type",
    f$2: [function(wo, wi) {
      var t1, cosThetaO, t2, cosThetaI, wh, $F, t3, costhetah, t4, NdotWh, NdotWo, NdotWi, WOdotWh;
      t1 = J.getInterceptor$x(wo);
      cosThetaO = J.abs$0$n(t1.get$z(wo));
      t2 = J.getInterceptor$x(wi);
      cosThetaI = J.abs$0$n(t2.get$z(wi));
      if (cosThetaI === 0 || cosThetaO === 0)
        return G.Spectrum_Spectrum(0);
      wh = t2.$add(wi, wo);
      if (J.$eq(wh.get$x(wh), 0) && J.$eq(wh.get$y(wh), 0) && J.$eq(wh.get$z(wh), 0))
        return G.Spectrum_Spectrum(0);
      wh = wh.$div(wh, wh.length$0(0));
      $F = this.fresnel.evaluate$1(G.Vector_Dot(wi, wh));
      t3 = this.distribution;
      costhetah = J.abs$0$n(wh.z);
      t3 = t3.exponent;
      if (typeof t3 !== "number")
        return t3.$add();
      t4 = Math.pow(costhetah, t3);
      NdotWh = J.abs$0$n(wh.z);
      NdotWo = J.abs$0$n(t1.get$z(wo));
      NdotWi = J.abs$0$n(t2.get$z(wi));
      WOdotWh = G.Vector_AbsDot(wo, wh);
      t2 = 2 * NdotWh;
      return J.$div$n(J.$mul$ns(J.$mul$ns(this.R, (t3 + 2) * 0.15915494309189535 * t4 * P.min(1, P.min(t2 * NdotWo / WOdotWh, t2 * NdotWi / WOdotWh))), $F), 4 * cosThetaI * cosThetaO);
    }, "call$2", "get$f", 4, 0, 95],
    sample_f$5: function(wo, wi, u1, u2, pdf) {
      var t1, t2, costheta, sintheta, phi, t3, wh, t4, t5, t6, t7, blinn_pdf;
      t1 = this.distribution;
      t2 = t1.exponent;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof u1 !== "number")
        H.throwExpression(P.ArgumentError$(u1));
      costheta = Math.pow(u1, 1 / (t2 + 1));
      t2 = P.max(0, 1 - costheta * costheta);
      sintheta = Math.sqrt(t2);
      phi = J.$mul$ns(J.$mul$ns(u2, 2), 3.141592653589793);
      t2 = typeof phi !== "number";
      if (t2)
        H.throwExpression(P.ArgumentError$(phi));
      t3 = sintheta * Math.cos(phi);
      if (t2)
        H.throwExpression(P.ArgumentError$(phi));
      t2 = sintheta * Math.sin(phi);
      wh = new G.Vector(t3, t2, costheta);
      t4 = J.getInterceptor$x(wo);
      if (!J.$gt$n(J.$mul$ns(t4.get$z(wo), costheta), 0))
        wh = new G.Vector(-t3, -t2, -costheta);
      t2 = t4.$negate(wo);
      t3 = J.$mul$ns(wh.x, 2);
      t5 = J.$mul$ns(wh.y, 2);
      t6 = J.$mul$ns(wh.z, 2);
      t7 = J.$add$ns(J.$add$ns(J.$mul$ns(t4.get$x(wo), wh.x), J.$mul$ns(t4.get$y(wo), wh.y)), J.$mul$ns(t4.get$z(wo), wh.z));
      t7 = t2.$add(0, new G.Vector(J.$mul$ns(t3, t7), J.$mul$ns(t5, t7), J.$mul$ns(t6, t7)));
      wi.x = t7.get$x(t7);
      wi.y = t7.get$y(t7);
      wi.z = t7.get$z(t7);
      t1 = t1.exponent;
      if (typeof t1 !== "number")
        return t1.$add();
      t2 = Math.pow(costheta, t1);
      t3 = J.$add$ns(J.$add$ns(J.$mul$ns(t4.get$x(wo), wh.x), J.$mul$ns(t4.get$y(wo), wh.y)), J.$mul$ns(t4.get$z(wo), wh.z));
      if (typeof t3 !== "number")
        return H.iae(t3);
      blinn_pdf = (t1 + 1) * t2 / (25.132741228718345 * t3);
      J.$indexSet$ax(pdf, 0, J.$le$n(J.$add$ns(J.$add$ns(J.$mul$ns(t4.get$x(wo), wh.x), J.$mul$ns(t4.get$y(wo), wh.y)), J.$mul$ns(t4.get$z(wo), wh.z)), 0) ? 0 : blinn_pdf);
      if (!J.$gt$n(J.$mul$ns(t4.get$z(wo), wi.z), 0))
        return G.Spectrum_Spectrum(0);
      return this.f$2(wo, wi);
    },
    pdf$2: function(wo, wi) {
      if (!J.$gt$n(J.$mul$ns(J.get$z$x(wo), wi.z), 0))
        return 0;
      return this.distribution.pdf$2(wo, wi);
    }
  },
  MicrofacetDistribution: {
    "^": "Object;"
  },
  OrenNayar: {
    "^": "BxDF;R,A,B,type",
    f$2: [function(wo, wi) {
      var t1, sinthetai, sinthetao, sinphii, cosphii, sinphio, maxcos, t2, tanbeta, sinalpha;
      t1 = G.Vector_SinTheta2(wi);
      sinthetai = Math.sqrt(t1);
      t1 = G.Vector_SinTheta2(wo);
      sinthetao = Math.sqrt(t1);
      if (sinthetai > 0.0001 && sinthetao > 0.0001) {
        sinphii = G.Vector_SinPhi(wi);
        cosphii = G.Vector_CosPhi(wi);
        sinphio = G.Vector_SinPhi(wo);
        maxcos = P.max(0, J.$add$ns(J.$mul$ns(cosphii, G.Vector_CosPhi(wo)), J.$mul$ns(sinphii, sinphio)));
      } else
        maxcos = 0;
      t1 = J.getInterceptor$x(wi);
      t2 = J.getInterceptor$x(wo);
      if (J.abs$0$n(t1.get$z(wi)) > J.abs$0$n(t2.get$z(wo))) {
        tanbeta = sinthetai / J.abs$0$n(t1.get$z(wi));
        sinalpha = sinthetao;
      } else {
        tanbeta = sinthetao / J.abs$0$n(t2.get$z(wo));
        sinalpha = sinthetai;
      }
      return this.R.$mul(0, 0.3183098861837907 * (this.A + this.B * maxcos * sinalpha * tanbeta));
    }, "call$2", "get$f", 4, 0, 95],
    OrenNayar$2: function(reflectance, sig) {
      var sigma, sigma2;
      if (typeof sig !== "number")
        return H.iae(sig);
      sigma = 0.017453292519943295 * sig;
      sigma2 = sigma * sigma;
      this.A = 1 - sigma2 / (2 * (sigma2 + 0.33));
      this.B = 0.45 * sigma2 / (sigma2 + 0.09);
    }
  },
  RegularHalfangleBRDF: {
    "^": "BxDF;brdf,nThetaH,nThetaD,nPhiD,type",
    f$2: [function(WO, WI) {
      var wo, wi, wh, t1, whTheta, whCosPhi, whSinPhi, whCosTheta, whSinTheta, t2, t3, t4, wdTheta, wdPhi, whThetaIndex, wdThetaIndex, wdPhiIndex, t5;
      wo = G.Vector$from(WO);
      wi = G.Vector$from(WI);
      wh = wo.$add(0, wi);
      if (J.$lt$n(wh.z, 0)) {
        wo.$negate(0);
        wi = wi.$negate(0);
        wh = wh.$negate(0);
      }
      if (J.$eq(wh.x, 0) && J.$eq(wh.y, 0) && J.$eq(wh.z, 0))
        return G.Spectrum_Spectrum(0);
      wh = wh.$div(0, wh.length$0(0));
      t1 = J.clamp$2$n(wh.z, -1, 1);
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      whTheta = Math.acos(t1);
      whCosPhi = G.Vector_CosPhi(wh);
      whSinPhi = G.Vector_SinPhi(wh);
      whCosTheta = wh.z;
      t1 = G.Vector_SinTheta2(wh);
      whSinTheta = Math.sqrt(t1);
      t1 = J.$mul$ns(whCosPhi, whCosTheta);
      t2 = J.getInterceptor$ns(whSinPhi);
      t3 = t2.$mul(whSinPhi, whCosTheta);
      t2 = t2.$negate(whSinPhi);
      t3 = G.Vector_Dot(wi, new G.Vector(t1, t3, -whSinTheta));
      t2 = G.Vector_Dot(wi, new G.Vector(t2, whCosPhi, 0));
      t1 = G.Vector_Dot(wi, wh);
      t4 = J.clamp$2$n(t1, -1, 1);
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      wdTheta = Math.acos(t4);
      wdPhi = G.Vector_SphericalPhi(new G.Vector(t3, t2, t1));
      if (wdPhi > 3.141592653589793)
        wdPhi -= 3.141592653589793;
      t1 = new G.RegularHalfangleBRDF_f_REMAP();
      t2 = P.max(0, whTheta / 1.5707963267948966);
      whThetaIndex = t1.call$3(Math.sqrt(t2), 1, this.nThetaH);
      wdThetaIndex = t1.call$3(wdTheta, 1.5707963267948966, this.nThetaD);
      wdPhiIndex = t1.call$3(wdPhi, 3.141592653589793, this.nPhiD);
      t1 = this.nPhiD;
      t2 = J.$add$ns(wdThetaIndex, J.$mul$ns(whThetaIndex, this.nThetaD));
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.brdf;
      t2 = 3 * J.$add$ns(wdPhiIndex, t1 * t2);
      t1 = t3.length;
      if (t2 >>> 0 !== t2 || t2 >= t1)
        return H.ioore(t3, t2);
      t4 = t3[t2];
      t5 = t2 + 1;
      if (t5 >= t1)
        return H.ioore(t3, t5);
      t5 = t3[t5];
      t2 += 2;
      if (t2 >= t1)
        return H.ioore(t3, t2);
      return G.Spectrum_Spectrum$rgb(t4, t5, t3[t2]);
    }, "call$2", "get$f", 4, 0, 95]
  },
  RegularHalfangleBRDF_f_REMAP: {
    "^": "Closure:99;",
    call$3: function($V, MAX, COUNT) {
      var t1 = C.JSNumber_methods.toInt$0($V / MAX);
      if (typeof COUNT !== "number")
        return H.iae(COUNT);
      return C.JSInt_methods.clamp$2(t1 * COUNT, 0, COUNT - 1);
    }
  },
  ScaledBxDF: {
    "^": "BxDF;bxdf,s,type",
    rho$3: function(w, nSamples, samples) {
      return this.s.$mul(0, this.bxdf.rho$3(w, nSamples, samples));
    },
    rho2$3: function(nSamples, samples1, samples2) {
      return this.s.$mul(0, this.bxdf.rho2$3(nSamples, samples1, samples2));
    },
    f$2: [function(wo, wi) {
      return this.s.$mul(0, this.bxdf.f$2(wo, wi));
    }, "call$2", "get$f", 4, 0, 95],
    sample_f$5: function(wo, wi, u1, u2, pdf) {
      return this.s.$mul(0, this.bxdf.sample_f$5(wo, wi, u1, u2, pdf));
    }
  },
  SpecularReflection: {
    "^": "BxDF;R,fresnel,type",
    f$2: [function(wo, wi) {
      return G.Spectrum_Spectrum(0);
    }, "call$2", "get$f", 4, 0, 95],
    sample_f$5: function(wo, wi, u1, u2, pdf) {
      var t1 = J.getInterceptor$x(wo);
      wi.x = J.$negate$n(t1.get$x(wo));
      wi.y = J.$negate$n(t1.get$y(wo));
      wi.z = t1.get$z(wo);
      J.$indexSet$ax(pdf, 0, 1);
      return this.fresnel.evaluate$1(t1.get$z(wo)).$mul(0, this.R).$div(0, J.abs$0$n(wi.z));
    },
    pdf$2: function(wo, wi) {
      return 0;
    },
    static: {SpecularReflection$: function(r, f) {
        return new G.SpecularReflection(G.Spectrum_Spectrum$from(r, 0), f, 17);
      }}
  },
  SpecularTransmission: {
    "^": "BxDF;T,etai,etat,fresnel,type",
    f$2: [function(wo, wi) {
      return G.Spectrum_Spectrum(0);
    }, "call$2", "get$f", 4, 0, 95],
    sample_f$5: function(wo, wi, u1, u2, pdf) {
      var t1, entering, ei, et, t0, t2, sini2, eta, sint2, t3, cost, $F;
      t1 = J.getInterceptor$x(wo);
      entering = J.$gt$n(t1.get$z(wo), 0);
      ei = this.etai;
      et = this.etat;
      if (!entering) {
        t0 = et;
        et = ei;
        ei = t0;
      }
      t2 = J.$mul$ns(t1.get$z(wo), t1.get$z(wo));
      if (typeof t2 !== "number")
        return H.iae(t2);
      sini2 = P.max(0, 1 - t2);
      eta = J.$div$n(ei, et);
      t2 = J.getInterceptor$ns(eta);
      sint2 = J.$mul$ns(t2.$mul(eta, eta), sini2);
      if (J.$ge$n(sint2, 1))
        return G.Spectrum_Spectrum(0);
      if (typeof sint2 !== "number")
        return H.iae(sint2);
      t3 = P.max(0, 1 - sint2);
      cost = Math.sqrt(t3);
      if (entering)
        cost = -cost;
      wi.x = t2.$mul(eta, J.$negate$n(t1.get$x(wo)));
      wi.y = t2.$mul(eta, J.$negate$n(t1.get$y(wo)));
      wi.z = cost;
      J.$indexSet$ax(pdf, 0, 1);
      $F = this.fresnel.evaluate$1(t1.get$z(wo));
      return G.Spectrum_Spectrum(1).$sub(0, $F).$mul(0, this.T).$div(0, J.abs$0$n(wi.z));
    },
    pdf$2: function(wo, wi) {
      return 0;
    },
    SpecularTransmission$3: function(t, ei, et) {
      this.T = t;
      this.etai = ei;
      this.etat = et;
    },
    static: {SpecularTransmission$: function(t, ei, et) {
        var t1 = new G.SpecularTransmission(null, null, null, new G.FresnelDielectric(ei, et), 18);
        t1.SpecularTransmission$3(t, ei, et);
        return t1;
      }}
  },
  Renderer: {
    "^": "Object;"
  },
  ResourceManager: {
    "^": "Object;",
    requestFile$2: function(path, future) {
      var t1, t2, c;
      if (future != null)
        this.futures.push(future);
      t1 = this.resources;
      if (t1.containsKey$1(path)) {
        if (!!J.getInterceptor(t1.$index(0, path)).$isFuture)
          return t1.$index(0, path);
        t2 = [J.JSArray, J.JSInt];
        c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t2)), [t2]);
        t1 = t1.$index(0, path);
        t2 = c.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
        return t2;
      }
      t2 = [J.JSArray, J.JSInt];
      c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t2)), [t2]);
      t2 = c.future;
      t1.$indexSet(0, path, t2);
      this.loadFile$1(path).then$1(new G.ResourceManager_requestFile_closure(this, path, c));
      return t2;
    },
    requestFile$1: function(path) {
      return this.requestFile$2(path, null);
    },
    requestImage$2: function(path, future) {
      var t1, t2, c;
      this.futures.push(future);
      t1 = this.resources;
      if (t1.containsKey$1(path)) {
        if (!!J.getInterceptor(t1.$index(0, path)).$isFuture)
          return t1.$index(0, path);
        t2 = [J.JSArray, J.JSInt];
        c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t2)), [t2]);
        t1 = t1.$index(0, path);
        t2 = c.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
        return t2;
      }
      t2 = "LOADING " + H.S(path);
      $.Log.call$2(4, t2);
      t2 = G.SpectrumImage;
      c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t2)), [t2]);
      t2 = c.future;
      t1.$indexSet(0, path, t2);
      this.loadFile$1(path).then$1(new G.ResourceManager_requestImage_closure(this, path, c));
      return t2;
    },
    waitUntilReady$0: function() {
      var c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      P.Future_wait(this.futures, false).then$1(new G.ResourceManager_waitUntilReady_closure(this, c));
      return c.future;
    },
    getResource$1: function(path) {
      var t1 = this.resources;
      if (!t1.containsKey$1(path))
        return;
      return t1.$index(0, path);
    }
  },
  ResourceManager_requestFile_closure: {
    "^": "Closure:88;this_0,path_1,c_2",
    call$1: function(bytes) {
      var t1;
      if (bytes == null) {
        t1 = this.c_2.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(null);
        return;
      }
      this.this_0.resources.$indexSet(0, this.path_1, bytes);
      t1 = this.c_2.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(bytes);
    }
  },
  ResourceManager_requestImage_closure: {
    "^": "Closure:88;this_0,path_1,c_2",
    call$1: function(bytes) {
      var t1, decoder, info, hdr, t2, t3, res, ri, y, x, r, g, b, ri0;
      if (bytes == null) {
        t1 = "UNABLE TO LOAD " + H.S(this.path_1);
        $.Log.call$2(0, t1);
        t1 = this.c_2.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(null);
        return;
      }
      decoder = U.findDecoderForData(bytes);
      if (decoder == null) {
        t1 = this.c_2.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(null);
        return;
      }
      info = decoder.startDecode$1(bytes);
      if (info == null) {
        t1 = "UNABLE TO DECODE " + H.S(this.path_1);
        $.Log.call$2(0, t1);
        t1 = this.c_2.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(null);
        return;
      }
      if (!!info.$isExrImage) {
        t1 = info.parts;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        hdr = t1[0].get$framebuffer();
        t1 = hdr.slices;
        if (t1.get$isEmpty(t1))
          t2 = 0;
        else {
          t2 = t1.get$values(t1);
          t2 = J.get$width$x(t2._f$1(J.get$first$ax(t2._iterable)));
        }
        if (t1.get$isEmpty(t1))
          t3 = 0;
        else {
          t3 = t1.get$values(t1);
          t3 = J.get$height$x(t3._f$1(J.get$first$ax(t3._iterable)));
        }
        res = G.SpectrumImage$(t2, t3, 3);
        ri = 0;
        y = 0;
        while (true) {
          if (t1.get$isEmpty(t1))
            t2 = 0;
          else {
            t2 = t1.get$values(t1);
            t2 = J.get$height$x(t2._f$1(J.get$first$ax(t2._iterable)));
          }
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(y < t2))
            break;
          x = 0;
          while (true) {
            if (t1.get$isEmpty(t1))
              t2 = 0;
            else {
              t2 = t1.get$values(t1);
              t2 = J.get$width$x(t2._f$1(J.get$first$ax(t2._iterable)));
            }
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(x < t2))
              break;
            t2 = hdr.red;
            r = t2 != null ? t2.getFloat$2(x, y) : 0;
            t2 = hdr.green;
            g = t2 != null ? t2.getFloat$2(x, y) : 0;
            t2 = hdr.blue;
            b = t2 != null ? t2.getFloat$2(x, y) : 0;
            t2 = res.data;
            ri0 = ri + 1;
            t3 = t2.length;
            if (ri < 0 || ri >= t3)
              return H.ioore(t2, ri);
            t2[ri] = r;
            ri = ri0 + 1;
            if (ri0 < 0 || ri0 >= t3)
              return H.ioore(t2, ri0);
            t2[ri0] = g;
            ri0 = ri + 1;
            if (ri < 0 || ri >= t3)
              return H.ioore(t2, ri);
            t2[ri] = b;
            ++x;
            ri = ri0;
          }
          ++y;
        }
        t1 = this.path_1;
        t2 = "HDR IMAGE LOADED " + H.S(t1);
        $.Log.call$2(4, t2);
        this.this_0.resources.$indexSet(0, t1, res);
        t1 = this.c_2.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(res);
        return;
      }
      res = G.SpectrumImage$fromImage(decoder.decodeFrame$1(0));
      t1 = this.path_1;
      t2 = "IMAGE LOADED " + H.S(t1);
      $.Log.call$2(4, t2);
      this.this_0.resources.$indexSet(0, t1, res);
      t1 = this.c_2.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(res);
    }
  },
  ResourceManager_waitUntilReady_closure: {
    "^": "Closure:88;this_0,c_1",
    call$1: function(r) {
      var t1;
      C.JSArray_methods.set$length(this.this_0.futures, 0);
      t1 = this.c_1.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  RGBColor: {
    "^": "Spectrum;c",
    setSampled$3: function(lambda, v, offset) {
      var x, y, z, yint, i, t1, val, t2;
      if (!G.Spectrum_SpectrumSamplesSorted(lambda))
        G.Spectrum_SortSpectrumSamples(lambda, v, offset);
      for (x = 0, y = 0, z = 0, yint = 0, i = 0; i < 471; ++i) {
        t1 = C.List_s9c[i];
        if (typeof t1 !== "number")
          return H.iae(t1);
        yint += t1;
        val = G.Spectrum_InterpolateSpectrumSamples(lambda, v, C.List_U49[i], offset);
        t1 = J.getInterceptor$ns(val);
        t2 = t1.$mul(val, C.List_wsa[i]);
        if (typeof t2 !== "number")
          return H.iae(t2);
        x += t2;
        t2 = t1.$mul(val, C.List_s9c[i]);
        if (typeof t2 !== "number")
          return H.iae(t2);
        y += t2;
        t1 = t1.$mul(val, C.List_SCE[i]);
        if (typeof t1 !== "number")
          return H.iae(t1);
        z += t1;
      }
      G.Spectrum_XYZToRGB(x / yint, y / yint, z / yint, this.c);
      return this;
    },
    setSampled$2: function(lambda, v) {
      return this.setSampled$3(lambda, v, 0);
    },
    toXYZ$0: function() {
      return G.XYZColor$from(this);
    },
    toRGB$0: function() {
      return this;
    },
    set$1: function(v) {
      var t1, t2;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t1[0] = v;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t1[1] = v;
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1[2] = v;
    },
    setRGB$4: function(r, g, b, type) {
      var t1, t2;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t1[0] = r;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t1[1] = g;
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1[2] = b;
      return this;
    },
    setRGB$3: function(r, g, b) {
      return this.setRGB$4(r, g, b, 0);
    },
    $add: function(_, s) {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t4 = J.$index$asx(s.get$c(), 0);
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (1 >= t2)
        return H.ioore(t1, 1);
      t5 = t1[1];
      t6 = J.$index$asx(s.get$c(), 1);
      if (typeof t6 !== "number")
        return H.iae(t6);
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = J.$index$asx(s.get$c(), 2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return G.RGBColor$rgb(t3 + t4, t5 + t6, t1 + t2);
    },
    $sub: function(_, s) {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t4 = J.$index$asx(s.get$c(), 0);
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (1 >= t2)
        return H.ioore(t1, 1);
      t5 = t1[1];
      t6 = J.$index$asx(s.get$c(), 1);
      if (typeof t6 !== "number")
        return H.iae(t6);
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = J.$index$asx(s.get$c(), 2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return G.RGBColor$rgb(t3 - t4, t5 - t6, t1 - t2);
    },
    $mul: function(_, s) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      if (typeof s === "number") {
        t1 = this.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t4 = t1[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        return G.RGBColor$rgb(t3 * s, t4 * s, t1[2] * s);
      }
      if (!!J.getInterceptor(s).$isRGBColor) {
        t1 = this.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        t4 = s.c;
        t5 = t4.length;
        if (0 >= t5)
          return H.ioore(t4, 0);
        t6 = t4[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t7 = t1[1];
        if (1 >= t5)
          return H.ioore(t4, 1);
        t8 = t4[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        t1 = t1[2];
        if (2 >= t5)
          return H.ioore(t4, 2);
        return G.RGBColor$rgb(t3 * t6, t7 * t8, t1 * t4[2]);
      }
      $.Log.call$2(3, "RGBSpectrum or double expected.");
      t1 = new G.RGBColor(new Float32Array(3));
      t1.Spectrum$samples$2(3, 0);
      return t1;
    },
    $div: function(_, s) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      if (typeof s === "number") {
        t1 = this.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t4 = t1[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        return G.RGBColor$rgb(t3 / s, t4 / s, t1[2] / s);
      }
      if (!!J.getInterceptor(s).$isRGBColor) {
        t1 = this.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        t4 = s.c;
        t5 = t4.length;
        if (0 >= t5)
          return H.ioore(t4, 0);
        t6 = t4[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t7 = t1[1];
        if (1 >= t5)
          return H.ioore(t4, 1);
        t8 = t4[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        t1 = t1[2];
        if (2 >= t5)
          return H.ioore(t4, 2);
        return G.RGBColor$rgb(t3 / t6, t7 / t8, t1 / t4[2]);
      }
      $.Log.call$2(3, "RGBSpectrum or double expected.");
      t1 = new G.RGBColor(new Float32Array(3));
      t1.Spectrum$samples$2(3, 0);
      return t1;
    },
    $negate: function(_) {
      var t1, t2, t3, t4;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      t4 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      return G.RGBColor$rgb(-t3, -t4, -t1[2]);
    },
    get$y: function(_) {
      var t1, t2, t3, t4;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      t4 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      return 0.212671 * t3 + 0.71516 * t4 + 0.072169 * t1[2];
    },
    isBlack$0: function() {
      var t1, t2;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      if (t1[0] === 0) {
        if (1 >= t2)
          return H.ioore(t1, 1);
        if (t1[1] === 0) {
          if (2 >= t2)
            return H.ioore(t1, 2);
          t1 = t1[2] !== 0;
        } else
          t1 = true;
      } else
        t1 = true;
      if (t1)
        return false;
      return true;
    },
    sqrt$0: function() {
      var t1, t2, t3, t4;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t3 = Math.sqrt(t3);
      if (1 >= t2)
        return H.ioore(t1, 1);
      t4 = t1[1];
      t4 = Math.sqrt(t4);
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      return G.RGBColor$rgb(t3, t4, Math.sqrt(t1));
    },
    exp$0: function() {
      var t1, t2, t3, t4;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t3 = Math.exp(t3);
      if (1 >= t2)
        return H.ioore(t1, 1);
      t4 = t1[1];
      t4 = Math.exp(t4);
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      return G.RGBColor$rgb(t3, t4, Math.exp(t1));
    },
    clamp$2: function(_, low, high) {
      var t1, t2, t3, t4;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = C.JSNumber_methods.clamp$2(t1[0], low, high);
      if (1 >= t2)
        return H.ioore(t1, 1);
      t4 = C.JSNumber_methods.clamp$2(t1[1], low, high);
      if (2 >= t2)
        return H.ioore(t1, 2);
      return G.RGBColor$rgb(t3, t4, C.JSNumber_methods.clamp$2(t1[2], low, high));
    },
    clamp$0: function($receiver) {
      return this.clamp$2($receiver, 0, 1 / 0);
    },
    toString$0: function(_) {
      var t1, t2, t3;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = H.S(t1[0]) + " ";
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t3 + H.S(t1[1]) + " ";
      if (2 >= t2)
        return H.ioore(t1, 2);
      return t3 + H.S(t1[2]);
    },
    RGBColor$xyz$3: function(x, y, z) {
      G.Spectrum_XYZToRGB(x, y, z, this.c);
    },
    RGBColor$rgb$3: function(r, g, b) {
      var t1, t2;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t1[0] = r;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t1[1] = g;
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1[2] = b;
    },
    RGBColor$from$1: function(s) {
      var t1, t2, t3, t4, t5;
      t1 = J.getInterceptor(s);
      if (!!t1.$isRGBColor) {
        t1 = this.c;
        t2 = s.c;
        t3 = t2.length;
        if (0 >= t3)
          return H.ioore(t2, 0);
        t4 = t2[0];
        t5 = t1.length;
        if (0 >= t5)
          return H.ioore(t1, 0);
        t1[0] = t4;
        if (1 >= t3)
          return H.ioore(t2, 1);
        t4 = t2[1];
        if (1 >= t5)
          return H.ioore(t1, 1);
        t1[1] = t4;
        if (2 >= t3)
          return H.ioore(t2, 2);
        t2 = t2[2];
        if (2 >= t5)
          return H.ioore(t1, 2);
        t1[2] = t2;
      } else if (!!t1.$isXYZColor) {
        t1 = s.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t4 = t1[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        G.Spectrum_XYZToRGB(t3, t4, t1[2], this.c);
      } else if (!!t1.$isSampledSpectrum) {
        t1 = this.c;
        t2 = s.toRGB$0().c;
        t3 = t2.length;
        if (0 >= t3)
          return H.ioore(t2, 0);
        t4 = t2[0];
        t5 = t1.length;
        if (0 >= t5)
          return H.ioore(t1, 0);
        t1[0] = t4;
        if (1 >= t3)
          return H.ioore(t2, 1);
        t4 = t2[1];
        if (1 >= t5)
          return H.ioore(t1, 1);
        t1[1] = t4;
        if (2 >= t3)
          return H.ioore(t2, 2);
        t2 = t2[2];
        if (2 >= t5)
          return H.ioore(t1, 2);
        t1[2] = t2;
      }
    },
    $isRGBColor: true,
    static: {RGBColor$rgb: function(r, g, b) {
        var t1 = new G.RGBColor(new Float32Array(3));
        t1.Spectrum$samples$2(3, 0);
        t1.RGBColor$rgb$3(r, g, b);
        return t1;
      }, RGBColor$xyz: function(x, y, z) {
        var t1 = new G.RGBColor(new Float32Array(3));
        t1.Spectrum$samples$2(3, 0);
        t1.RGBColor$xyz$3(x, y, z);
        return t1;
      }, RGBColor$from: function(s) {
        var t1 = new G.RGBColor(new Float32Array(3));
        t1.Spectrum$samples$2(3, 0);
        t1.RGBColor$from$1(s);
        return t1;
      }}
  },
  RNG: {
    "^": "Object;random,mt,mti",
    seed$1: function(_, seed) {
      var t1, t2, t3;
      t1 = this.mt;
      t1[0] = J.$and$n(seed, 4294967295);
      for (this.mti = 1, t2 = 1; t2 < 624; ++t2, this.mti = t2) {
        t3 = t1[t2 - 1];
        t1[t2] = 1812433253 * ((t3 ^ t3 >>> 30) >>> 0) + t2;
        t1[t2] = (t1[t2] & 4294967295) >>> 0;
      }
    },
    randomFloat$0: function() {
      return (this.randomUInt$0() & 16777215) / 16777216;
    },
    randomUInt$0: function() {
      var t1, kk, kk0, y, t2, t3;
      t1 = this.mti;
      if (t1 >= 624) {
        if (t1 === 625)
          this.seed$1(0, 5489);
        for (t1 = this.mt, kk = 0; kk < 227; kk = kk0) {
          kk0 = kk + 1;
          y = t1[kk] & 2147483648 | t1[kk0] & 2147483647;
          t2 = t1[kk + 397];
          t3 = C.List_0_2567483615[y & 1];
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1[kk] = (t2 ^ y >>> 1 ^ t3) >>> 0;
        }
        for (; kk < 623; kk = kk0) {
          kk0 = kk + 1;
          y = t1[kk] & 2147483648 | t1[kk0] & 2147483647;
          t2 = t1[kk + -227];
          t3 = C.List_0_2567483615[y & 1];
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1[kk] = (t2 ^ y >>> 1 ^ t3) >>> 0;
        }
        y = t1[623] & 2147483648 | t1[0] & 2147483647;
        t2 = t1[396];
        t3 = C.List_0_2567483615[y & 1];
        if (typeof t3 !== "number")
          return H.iae(t3);
        t1[623] = (t2 ^ y >>> 1 ^ t3) >>> 0;
        this.mti = 0;
        t1 = 0;
      }
      t2 = this.mt;
      this.mti = t1 + 1;
      if (t1 >= 624)
        return H.ioore(t2, t1);
      y = t2[t1];
      y ^= y >>> 11;
      y ^= y << 7 & 2636928640;
      y ^= y << 15 & 4022730752;
      return (y ^ y >>> 18) >>> 0;
    },
    static: {"^": "RNG_N"}
  },
  Sample: {
    "^": "CameraSample;n1D<,n2D<,oneD<,twoD<,imageX,imageY,lensU,lensV,time",
    duplicate$1: function(count) {
      var ret, t1, i, t2;
      if (typeof count !== "number")
        return H.iae(count);
      ret = H.setRuntimeTypeInfo(Array(count), [G.Sample]);
      for (t1 = ret.length, i = 0; i < count; ++i) {
        t2 = new G.Sample([], [], [], [], 0, 0, 0, 0, 0);
        t2.n1D = P.List_List$from(this.n1D, true, J.JSInt);
        t2.n2D = P.List_List$from(this.n2D, true, J.JSInt);
        t2._allocateSampleMemory$0();
        if (i >= t1)
          return H.ioore(ret, i);
        ret[i] = t2;
      }
      return ret;
    },
    _allocateSampleMemory$0: function() {
      var i, t1, t2;
      this.oneD = H.setRuntimeTypeInfo(Array(this.n1D.length), [P.Float32List]);
      this.twoD = H.setRuntimeTypeInfo(Array(this.n2D.length), [P.Float32List]);
      for (i = 0; t1 = this.n1D, i < t1.length; ++i) {
        t2 = this.oneD;
        t1 = t1[i];
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        t1 = new Float32Array(t1);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
      }
      for (i = 0; t1 = this.n2D, i < t1.length; ++i) {
        t2 = this.twoD;
        t1 = t1[i];
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = 2 * t1;
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        t1 = new Float32Array(t1);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
      }
    },
    Sample$4: function(sampler, surf, vol, scene) {
      if (surf != null)
        surf.requestSamples$3(sampler, this, scene);
      if (vol != null)
        vol.requestSamples$3(sampler, this, scene);
      this._allocateSampleMemory$0();
    },
    static: {Sample$: function(sampler, surf, vol, scene) {
        var t1 = new G.Sample([], [], [], [], 0, 0, 0, 0, 0);
        t1.Sample$4(sampler, surf, vol, scene);
        return t1;
      }}
  },
  SampledSpectrum: {
    "^": "Spectrum;c",
    setSampled$3: function(lambda, v, offset) {
      var t1, t2, i, t3, i0, t4;
      if (!G.Spectrum_SpectrumSamplesSorted(lambda))
        G.Spectrum_SortSpectrumSamples(lambda, v, offset);
      for (t1 = this.c, t2 = t1.length, i = 0; i < 4; i = i0) {
        t3 = i / 4;
        i0 = i + 1;
        t4 = i0 / 4;
        t4 = G.Spectrum_AverageSpectrumSamples(lambda, v, (1 - t3) * 400 + t3 * 700, (1 - t4) * 400 + t4 * 700, offset);
        if (i >= t2)
          return H.ioore(t1, i);
        t1[i] = t4;
      }
      return this;
    },
    setSampled$2: function(lambda, v) {
      return this.setSampled$3(lambda, v, 0);
    },
    $add: function(_, s) {
      var t1, r, t2, t3, i, t4, t5;
      t1 = new Float32Array(4);
      r = new G.SampledSpectrum(t1);
      r.Spectrum$samples$2(4, 0);
      for (t2 = this.c, t3 = t2.length, i = 0; i < 4; ++i) {
        if (i >= t3)
          return H.ioore(t2, i);
        t4 = t2[i];
        t5 = J.$index$asx(s.get$c(), i);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (i >= 4)
          return H.ioore(t1, i);
        t1[i] = t4 + t5;
      }
      return r;
    },
    $sub: function(_, s) {
      var t1, r, t2, t3, i, t4, t5;
      t1 = new Float32Array(4);
      r = new G.SampledSpectrum(t1);
      r.Spectrum$samples$2(4, 0);
      for (t2 = this.c, t3 = t2.length, i = 0; i < 4; ++i) {
        if (i >= t3)
          return H.ioore(t2, i);
        t4 = t2[i];
        t5 = J.$index$asx(s.get$c(), i);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (i >= 4)
          return H.ioore(t1, i);
        t1[i] = t4 - t5;
      }
      return r;
    },
    $mul: function(_, s) {
      var t1, r, t2, t3, i, t4, t5, t6, t7;
      if (typeof s === "number") {
        t1 = new Float32Array(4);
        r = new G.SampledSpectrum(t1);
        r.Spectrum$samples$2(4, 0);
        for (t2 = this.c, t3 = t2.length, i = 0; i < 4; ++i) {
          if (i >= t3)
            return H.ioore(t2, i);
          t4 = t2[i];
          if (i >= 4)
            return H.ioore(t1, i);
          t1[i] = t4 * s;
        }
        return r;
      }
      if (!!J.getInterceptor(s).$isSampledSpectrum) {
        t1 = new Float32Array(4);
        r = new G.SampledSpectrum(t1);
        r.Spectrum$samples$2(4, 0);
        for (t2 = this.c, t3 = t2.length, t4 = s.c, t5 = t4.length, i = 0; i < 4; ++i) {
          if (i >= t3)
            return H.ioore(t2, i);
          t6 = t2[i];
          if (i >= t5)
            return H.ioore(t4, i);
          t7 = t4[i];
          if (i >= 4)
            return H.ioore(t1, i);
          t1[i] = t6 * t7;
        }
        return r;
      }
      $.Log.call$2(3, "SampledSpectrum or num expected.");
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      return t1;
    },
    $div: function(_, s) {
      var t1, r, t2, t3, i, t4, t5, t6, t7;
      if (typeof s === "number") {
        t1 = new Float32Array(4);
        r = new G.SampledSpectrum(t1);
        r.Spectrum$samples$2(4, 0);
        for (t2 = this.c, t3 = t2.length, i = 0; i < 4; ++i) {
          if (i >= t3)
            return H.ioore(t2, i);
          t4 = t2[i];
          if (i >= 4)
            return H.ioore(t1, i);
          t1[i] = t4 / s;
        }
        return r;
      }
      if (!!J.getInterceptor(s).$isSampledSpectrum) {
        t1 = new Float32Array(4);
        r = new G.SampledSpectrum(t1);
        r.Spectrum$samples$2(4, 0);
        for (t2 = this.c, t3 = t2.length, t4 = s.c, t5 = t4.length, i = 0; i < 4; ++i) {
          if (i >= t3)
            return H.ioore(t2, i);
          t6 = t2[i];
          if (i >= t5)
            return H.ioore(t4, i);
          t7 = t4[i];
          if (i >= 4)
            return H.ioore(t1, i);
          t1[i] = t6 / t7;
        }
        return r;
      }
      $.Log.call$2(3, "SampledSpectrum or double expected.");
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      return t1;
    },
    setRGB$4: function(r, g, b, type) {
      var res, t1, t2, t3, t4, t5;
      res = new G.SampledSpectrum(new Float32Array(4));
      res.Spectrum$samples$2(4, 0);
      if (type === 0) {
        t1 = J.getInterceptor$n(r);
        if (t1.$le(r, g) && t1.$le(r, b)) {
          res = res.$add(0, $.get$_Spectrum_G().rgbRefl2SpectWhite.$mul(0, r));
          t1 = J.getInterceptor$n(g);
          t2 = J.getInterceptor$n(b);
          res = t1.$le(g, b) ? res.$add(0, $.get$_Spectrum_G().rgbRefl2SpectCyan.$mul(0, t1.$sub(g, r))).$add(0, $.get$_Spectrum_G().rgbRefl2SpectBlue.$mul(0, t2.$sub(b, g))) : res.$add(0, $.get$_Spectrum_G().rgbRefl2SpectCyan.$mul(0, t2.$sub(b, r))).$add(0, $.get$_Spectrum_G().rgbRefl2SpectGreen.$mul(0, t1.$sub(g, b)));
        } else {
          t2 = J.getInterceptor$n(g);
          if (t2.$le(g, r) && t2.$le(g, b)) {
            res = res.$add(0, $.get$_Spectrum_G().rgbRefl2SpectWhite.$mul(0, g));
            t2 = J.getInterceptor$n(b);
            res = t1.$le(r, b) ? res.$add(0, $.get$_Spectrum_G().rgbRefl2SpectMagenta.$mul(0, t1.$sub(r, g))).$add(0, $.get$_Spectrum_G().rgbRefl2SpectBlue.$mul(0, t2.$sub(b, r))) : res.$add(0, $.get$_Spectrum_G().rgbRefl2SpectMagenta.$mul(0, t2.$sub(b, g))).$add(0, $.get$_Spectrum_G().rgbRefl2SpectRed.$mul(0, t1.$sub(r, b)));
          } else {
            res = res.$add(0, $.get$_Spectrum_G().rgbRefl2SpectWhite.$mul(0, b));
            res = t1.$le(r, g) ? res.$add(0, $.get$_Spectrum_G().rgbRefl2SpectYellow.$mul(0, t1.$sub(r, b))).$add(0, $.get$_Spectrum_G().rgbRefl2SpectGreen.$mul(0, t2.$sub(g, r))) : res.$add(0, $.get$_Spectrum_G().rgbRefl2SpectYellow.$mul(0, t2.$sub(g, b))).$add(0, $.get$_Spectrum_G().rgbRefl2SpectRed.$mul(0, t1.$sub(r, g)));
          }
        }
        res = res.$mul(0, 0.94);
      } else {
        t1 = J.getInterceptor$n(r);
        if (t1.$le(r, g) && t1.$le(r, b)) {
          res = res.$add(0, $.get$_Spectrum_G().rgbIllum2SpectWhite.$mul(0, r));
          t1 = J.getInterceptor$n(g);
          t2 = J.getInterceptor$n(b);
          res = t1.$le(g, b) ? res.$add(0, $.get$_Spectrum_G().rgbIllum2SpectCyan.$mul(0, t1.$sub(g, r))).$add(0, $.get$_Spectrum_G().rgbIllum2SpectBlue.$mul(0, t2.$sub(b, g))) : res.$add(0, $.get$_Spectrum_G().rgbIllum2SpectCyan.$mul(0, t2.$sub(b, r))).$add(0, $.get$_Spectrum_G().rgbIllum2SpectGreen.$mul(0, t1.$sub(g, b)));
        } else {
          t2 = J.getInterceptor$n(g);
          if (t2.$le(g, r) && t2.$le(g, b)) {
            res = res.$add(0, $.get$_Spectrum_G().rgbIllum2SpectWhite.$mul(0, g));
            t2 = J.getInterceptor$n(b);
            res = t1.$le(r, b) ? res.$add(0, $.get$_Spectrum_G().rgbIllum2SpectMagenta.$mul(0, t1.$sub(r, g))).$add(0, $.get$_Spectrum_G().rgbIllum2SpectBlue.$mul(0, t2.$sub(b, r))) : res.$add(0, $.get$_Spectrum_G().rgbIllum2SpectMagenta.$mul(0, t2.$sub(b, g))).$add(0, $.get$_Spectrum_G().rgbIllum2SpectRed.$mul(0, t1.$sub(r, b)));
          } else {
            res = res.$add(0, $.get$_Spectrum_G().rgbIllum2SpectWhite.$mul(0, b));
            res = t1.$le(r, g) ? res.$add(0, $.get$_Spectrum_G().rgbIllum2SpectYellow.$mul(0, t1.$sub(r, b))).$add(0, $.get$_Spectrum_G().rgbIllum2SpectGreen.$mul(0, t2.$sub(g, r))) : res.$add(0, $.get$_Spectrum_G().rgbIllum2SpectYellow.$mul(0, t2.$sub(g, b))).$add(0, $.get$_Spectrum_G().rgbIllum2SpectRed.$mul(0, t1.$sub(r, g)));
          }
        }
        res = res.$mul(0, 0.86445);
      }
      t1 = this.c;
      t2 = res.c;
      t3 = t2.length;
      if (0 >= t3)
        return H.ioore(t2, 0);
      t4 = C.JSNumber_methods.clamp$2(t2[0], 0, 1 / 0);
      t5 = t1.length;
      if (0 >= t5)
        return H.ioore(t1, 0);
      t1[0] = t4;
      if (1 >= t3)
        return H.ioore(t2, 1);
      t4 = C.JSNumber_methods.clamp$2(t2[1], 0, 1 / 0);
      if (1 >= t5)
        return H.ioore(t1, 1);
      t1[1] = t4;
      if (2 >= t3)
        return H.ioore(t2, 2);
      t2 = C.JSNumber_methods.clamp$2(t2[2], 0, 1 / 0);
      if (2 >= t5)
        return H.ioore(t1, 2);
      t1[2] = t2;
      return this;
    },
    setRGB$3: function(r, g, b) {
      return this.setRGB$4(r, g, b, 0);
    },
    toXYZ$0: function() {
      var t1, xyz, t2, t3, i, t4, t5, t6;
      t1 = new Float32Array(3);
      xyz = new G.XYZColor(t1);
      xyz.Spectrum$samples$2(3, 0);
      if (0 >= 3)
        return H.ioore(t1, 0);
      t1[0] = 0;
      if (1 >= 3)
        return H.ioore(t1, 1);
      t1[1] = 0;
      if (2 >= 3)
        return H.ioore(t1, 2);
      t1[2] = 0;
      for (t2 = this.c, t3 = t2.length, i = 0; t4 = t1[0], i < 4; ++i) {
        t5 = $.get$_Spectrum_G();
        t6 = t5.X.c;
        if (i >= t6.length)
          return H.ioore(t6, i);
        t6 = t6[i];
        if (i >= t3)
          return H.ioore(t2, i);
        t1[0] = t4 + t6 * t2[i];
        t6 = t1[1];
        t4 = t5.Y.c;
        if (i >= t4.length)
          return H.ioore(t4, i);
        t1[1] = t6 + t4[i] * t2[i];
        t4 = t1[2];
        t5 = t5.Z.c;
        if (i >= t5.length)
          return H.ioore(t5, i);
        t1[2] = t4 + t5[i] * t2[i];
      }
      t1[0] = t4 * 0.7018732857622337;
      t1[1] = t1[1] * 0.7018732857622337;
      t1[2] = t1[2] * 0.7018732857622337;
      return xyz;
    },
    get$y: function(_) {
      var t1, t2, yy, i, t3;
      for (t1 = this.c, t2 = t1.length, yy = 0, i = 0; i < 4; ++i) {
        t3 = $.get$_Spectrum_G().Y.c;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3 = t3[i];
        if (i >= t2)
          return H.ioore(t1, i);
        yy += t3 * t1[i];
      }
      return yy * 300 / 427.42758;
    },
    toRGB$0: function() {
      return G.RGBColor$from(this.toXYZ$0());
    },
    clamp$2: function(_, low, high) {
      var t1, r, t2, t3, i, t4;
      t1 = new Float32Array(4);
      r = new G.SampledSpectrum(t1);
      r.Spectrum$samples$2(4, 0);
      for (t2 = this.c, t3 = t2.length, i = 0; i < 4; ++i) {
        if (i >= t3)
          return H.ioore(t2, i);
        t4 = C.JSNumber_methods.clamp$2(t2[i], low, high);
        if (i >= 4)
          return H.ioore(t1, i);
        t1[i] = t4;
      }
      return r;
    },
    clamp$0: function($receiver) {
      return this.clamp$2($receiver, 0, 1 / 0);
    },
    SampledSpectrum$from$2: function(s, type) {
      var t1, t2, t3, t4, i, t5;
      t1 = J.getInterceptor(s);
      if (!!t1.$isSampledSpectrum)
        for (t1 = this.c, t2 = s.c, t3 = t2.length, t4 = t1.length, i = 0; i < 4; ++i) {
          if (i >= t3)
            return H.ioore(t2, i);
          t5 = t2[i];
          if (i >= t4)
            return H.ioore(t1, i);
          t1[i] = t5;
        }
      else if (!!t1.$isRGBColor) {
        t1 = s.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t4 = t1[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        this.setRGB$4(t3, t4, t1[2], type);
      } else if (!!t1.$isXYZColor) {
        t1 = G.RGBColor$from(s).c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t4 = t1[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        this.setRGB$4(t3, t4, t1[2], type);
      }
    },
    $isSampledSpectrum: true,
    static: {"^": "SampledSpectrum_NUM_SAMPLES", SampledSpectrum$from: function(s, type) {
        var t1 = new G.SampledSpectrum(new Float32Array(4));
        t1.Spectrum$samples$2(4, 0);
        t1.SampledSpectrum$from$2(s, type);
        return t1;
      }}
  },
  _Spectrum: {
    "^": "Object;X,Y,Z,rgbRefl2SpectWhite,rgbRefl2SpectCyan,rgbRefl2SpectMagenta,rgbRefl2SpectYellow,rgbRefl2SpectRed,rgbRefl2SpectGreen,rgbRefl2SpectBlue,rgbIllum2SpectWhite,rgbIllum2SpectCyan,rgbIllum2SpectMagenta,rgbIllum2SpectYellow,rgbIllum2SpectRed,rgbIllum2SpectGreen,rgbIllum2SpectBlue",
    _Spectrum$0: function() {
      var t1, i, wl0, i0, wl1, t2;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.X = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.Y = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.Z = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbRefl2SpectWhite = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbRefl2SpectCyan = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbRefl2SpectMagenta = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbRefl2SpectYellow = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbRefl2SpectRed = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbRefl2SpectGreen = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbRefl2SpectBlue = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbIllum2SpectWhite = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbIllum2SpectCyan = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbIllum2SpectMagenta = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbIllum2SpectYellow = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbIllum2SpectRed = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbIllum2SpectGreen = t1;
      t1 = new G.SampledSpectrum(new Float32Array(4));
      t1.Spectrum$samples$2(4, 0);
      this.rgbIllum2SpectBlue = t1;
      for (i = 0; i < 4; i = i0) {
        t1 = i / 4;
        wl0 = (1 - t1) * 400 + t1 * 700;
        i0 = i + 1;
        t1 = i0 / 4;
        wl1 = (1 - t1) * 400 + t1 * 700;
        t1 = this.X.c;
        t2 = G.Spectrum_AverageSpectrumSamples(C.List_U49, C.List_wsa, wl0, wl1, 0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
        t2 = this.Y.c;
        t1 = G.Spectrum_AverageSpectrumSamples(C.List_U49, C.List_s9c, wl0, wl1, 0);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
        t1 = this.Z.c;
        t2 = G.Spectrum_AverageSpectrumSamples(C.List_U49, C.List_SCE, wl0, wl1, 0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
      }
      for (i = 0; i < 4; i = i0) {
        t1 = i / 4;
        wl0 = (1 - t1) * 400 + t1 * 700;
        i0 = i + 1;
        t1 = i0 / 4;
        wl1 = (1 - t1) * 400 + t1 * 700;
        t1 = this.rgbRefl2SpectWhite.c;
        t2 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_iDZ, wl0, wl1, 0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
        t2 = this.rgbRefl2SpectCyan.c;
        t1 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_DFB, wl0, wl1, 0);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
        t1 = this.rgbRefl2SpectMagenta.c;
        t2 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_Qu6, wl0, wl1, 0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
        t2 = this.rgbRefl2SpectYellow.c;
        t1 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_Qaw, wl0, wl1, 0);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
        t1 = this.rgbRefl2SpectRed.c;
        t2 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_Sby, wl0, wl1, 0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
        t2 = this.rgbRefl2SpectGreen.c;
        t1 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_cQL, wl0, wl1, 0);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
        t1 = this.rgbRefl2SpectBlue.c;
        t2 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_Ls5, wl0, wl1, 0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
        t2 = this.rgbIllum2SpectWhite.c;
        t1 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_ssa, wl0, wl1, 0);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
        t1 = this.rgbIllum2SpectCyan.c;
        t2 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_QmM, wl0, wl1, 0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
        t2 = this.rgbIllum2SpectMagenta.c;
        t1 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_ild, wl0, wl1, 0);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
        t1 = this.rgbIllum2SpectYellow.c;
        t2 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_LkP, wl0, wl1, 0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
        t2 = this.rgbIllum2SpectRed.c;
        t1 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_wQn, wl0, wl1, 0);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
        t1 = this.rgbIllum2SpectGreen.c;
        t2 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_ec6, wl0, wl1, 0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
        t2 = this.rgbIllum2SpectBlue.c;
        t1 = G.Spectrum_AverageSpectrumSamples(C.List_KEl, C.List_aXZ, wl0, wl1, 0);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t1;
      }
    },
    static: {"^": "_Spectrum_G", _Spectrum$: function() {
        var t1 = new G._Spectrum(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t1._Spectrum$0();
        return t1;
      }}
  },
  Sampler: {
    "^": "Object;samplesPerPixel<,shutterOpen<,shutterClose<",
    get$width: function(_) {
      return J.$sub$n(this.xPixelEnd, this.xPixelStart);
    },
    get$height: function(_) {
      return J.$sub$n(this.yPixelEnd, this.yPixelStart);
    },
    reportResults$5: function(samples, rays, Ls, isects, count) {
      return true;
    }
  },
  Scene: {
    "^": "Object;aggregate,lights,volumeRegion,worldBound",
    worldBound$0: function() {
      return this.worldBound.call$0();
    },
    intersect$2: function(ray, isect) {
      var hit, t1;
      hit = this.aggregate.intersect$2(ray, isect);
      t1 = $.get$Stats_nonShadowRays();
      t1.count = J.$add$ns(t1.count, 1);
      $.Stats_nonShadowRays = t1;
      return hit;
    },
    intersectP$1: function(ray) {
      var hit, t1;
      hit = this.aggregate.intersectP$1(ray);
      t1 = $.get$Stats_shadowRays();
      t1.count = J.$add$ns(t1.count, 1);
      $.Stats_shadowRays = t1;
      return hit;
    },
    Scene$3: function(aggregate, lights, volumeRegion) {
      var t1, t2;
      t1 = this.aggregate.worldBound$0();
      this.worldBound = t1;
      t2 = this.volumeRegion;
      if (t2 != null) {
        t2 = t2.worldBound$0();
        this.worldBound = G.BBox$from(t1).union$1(t2);
      }
    }
  },
  Shape: {
    "^": "Object;objectToWorld<,worldToObject<,reverseOrientation@,shapeId<",
    worldBound$0: function() {
      return this.objectToWorld.transformBBox$1(this.objectBound$0());
    },
    canIntersect$0: function() {
      return true;
    },
    refine$1: function(refined) {
      $.Log.call$2(3, "Unimplemented Shape.refine() method called");
    },
    intersect$4: function(ray, tHit, rayEpsilon, dg) {
      $.Log.call$2(3, "Unimplemented Shape.intersect() method called");
      return false;
    },
    intersectP$1: function(ray) {
      $.Log.call$2(3, "Unimplemented Shape.intersectP() method called");
      return false;
    },
    getShadingGeometry$3: function(obj2world, dg, dgShading) {
      dgShading.copy$1(dg);
    },
    area$0: function() {
      $.Log.call$2(3, "Unimplemented Shape.area() method called");
      return 0;
    },
    sample$3: function(u1, u2, Ns) {
      $.Log.call$2(3, "Unimplemented Shape::sample() method called");
      return new G.Point(0, 0, 0);
    },
    pdf$1: function(Pshape) {
      var t1 = this.area$0();
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 1 / t1;
    },
    sample2$4: function($P, u1, u2, Ns) {
      return this.sample$3(u1, u2, Ns);
    },
    pdf2$2: function(p, wi) {
      var dgLight, ray, thit, t1, t2, t3, pdf;
      dgLight = G.DifferentialGeometry$();
      ray = G.Ray$(p, wi, 0.001, 1 / 0, 0, 0);
      ray.depth = -1;
      thit = [0];
      if (!this.intersect$4(ray, thit, [0], dgLight))
        return 0;
      t1 = thit[0];
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t1));
      t2 = J.getInterceptor$x(t1);
      t1 = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1)).$sub(0, p).lengthSquared$0();
      t2 = G.Vector_AbsDot(dgLight.nn, wi.$negate(0));
      t3 = this.area$0();
      if (typeof t3 !== "number")
        return H.iae(t3);
      pdf = J.$div$n(t1, t2 * t3);
      return J.get$isInfinite$n(pdf) ? 0 : pdf;
    }
  },
  Spectrum: {
    "^": "Object;c<",
    $index: function(_, index) {
      var t1 = this.c;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this.c;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
      return value;
    },
    set$1: function(v) {
      var t1, n, i;
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i)
        t1[i] = v;
    },
    copy$1: function(other) {
      var t1, n, i;
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i)
        t1[i] = J.$index$asx(other.get$c(), i);
    },
    hasNaNs$0: function() {
      var t1, nSamples, i;
      for (t1 = this.c, nSamples = t1.length, i = 0; i < nSamples; ++i)
        if (isNaN(t1[i]))
          return true;
      return false;
    },
    isBlack$0: function() {
      var t1, n, i;
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i)
        if (t1[i] !== 0)
          return false;
      return true;
    },
    isValue$1: function(v) {
      var t1, n, i;
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i)
        if (t1[i] !== v)
          return false;
      return true;
    },
    $add: function(_, s) {
      var r, t1, n, i, t2, t3, t4;
      r = G.Spectrum_Spectrum(0);
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i) {
        t2 = r.c;
        t3 = t1[i];
        t4 = J.$index$asx(s.get$c(), i);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t3 + t4;
      }
      return r;
    },
    $sub: function(_, s) {
      var r, t1, n, i, t2, t3, t4;
      r = G.Spectrum_Spectrum(0);
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i) {
        t2 = r.c;
        t3 = t1[i];
        t4 = J.$index$asx(s.get$c(), i);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t3 - t4;
      }
      return r;
    },
    $mul: function(_, s) {
      var r, t1, n, i, t2, t3, t4, t5, t6;
      r = G.Spectrum_Spectrum(0);
      if (typeof s === "number")
        for (t1 = this.c, n = t1.length, i = 0; i < n; ++i) {
          t2 = r.c;
          t3 = t1[i];
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2[i] = t3 * s;
        }
      else if (!!J.getInterceptor(s).$isSpectrum)
        for (t1 = this.c, n = t1.length, t2 = s.c, t3 = t2.length, i = 0; i < n; ++i) {
          t4 = r.c;
          t5 = t1[i];
          if (i >= t3)
            return H.ioore(t2, i);
          t6 = t2[i];
          if (i >= t4.length)
            return H.ioore(t4, i);
          t4[i] = t5 * t6;
        }
      else
        $.Log.call$2(3, "Spectrum or double expected.");
      return r;
    },
    $div: function(_, s) {
      var r, t1, n, i, t2, t3, t4, t5, t6;
      r = G.Spectrum_Spectrum(0);
      if (typeof s === "number")
        for (t1 = this.c, n = t1.length, i = 0; i < n; ++i) {
          t2 = r.c;
          t3 = t1[i];
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2[i] = t3 / s;
        }
      else if (!!J.getInterceptor(s).$isSpectrum)
        for (t1 = this.c, n = t1.length, t2 = s.c, t3 = t2.length, i = 0; i < n; ++i) {
          t4 = r.c;
          t5 = t1[i];
          if (i >= t3)
            return H.ioore(t2, i);
          t6 = t2[i];
          if (i >= t4.length)
            return H.ioore(t4, i);
          t4[i] = t5 / t6;
        }
      else
        $.Log.call$2(3, "Spectrum or double expected.");
      return r;
    },
    $negate: function(_) {
      var r, t1, n, i, t2, t3;
      r = G.Spectrum_Spectrum(0);
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i) {
        t2 = r.c;
        t3 = t1[i];
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = -t3;
      }
      return r;
    },
    scale$1: function(_, v) {
      var t1, n, i;
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i)
        t1[i] = t1[i] * v;
    },
    add$1: function(_, s) {
      var t1, n, i, t2, t3;
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i) {
        t2 = t1[i];
        t3 = J.$index$asx(s.get$c(), i);
        if (typeof t3 !== "number")
          return H.iae(t3);
        t1[i] = t2 + t3;
      }
    },
    sqrt$0: function() {
      var s, t1, n, i, t2, t3;
      s = G.Spectrum_Spectrum(0);
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i) {
        t2 = s.c;
        t3 = t1[i];
        t3 = Math.sqrt(t3);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t3;
      }
      return s;
    },
    exp$0: function() {
      var s, t1, n, i, t2, t3;
      s = G.Spectrum_Spectrum(0);
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i) {
        t2 = s.c;
        t3 = t1[i];
        t3 = Math.exp(t3);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t3;
      }
      return s;
    },
    clamp$2: function(_, low, high) {
      var s, t1, n, i, t2, t3;
      s = G.Spectrum_Spectrum(0);
      for (t1 = this.c, n = t1.length, i = 0; i < n; ++i) {
        t2 = s.c;
        t3 = C.JSNumber_methods.clamp$2(t1[i], low, high);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t3;
      }
      return s;
    },
    clamp$0: function($receiver) {
      return this.clamp$2($receiver, 0, 1 / 0);
    },
    Spectrum$samples$2: function(nSamples, v) {
      if (!J.$eq(v, 0))
        C.NativeFloat32List_methods.fillRange$3(this.c, 0, nSamples, v);
    },
    $isSpectrum: true,
    static: {"^": "Spectrum_type<"}
  },
  Spectrum_SortSpectrumSamples_closure: {
    "^": "Closure:87;",
    call$2: function(a, b) {
      return J.$lt$n(J.$index$asx(a, 0), J.$index$asx(b, 0));
    }
  },
  Spectrum_AverageSpectrumSamples_INTERP: {
    "^": "Closure:87;lambda_0,vals_1,offset_2",
    call$2: function(w, i) {
      var t1, t2, t3, t4, t5;
      t1 = this.lambda_0;
      t2 = t1.length;
      if (i >= t2)
        return H.ioore(t1, i);
      t3 = t1[i];
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = i + 1;
      if (t4 >= t2)
        return H.ioore(t1, t4);
      t4 = J.$sub$n(t1[t4], t3);
      if (typeof t4 !== "number")
        return H.iae(t4);
      t4 = (w - t3) / t4;
      t3 = this.vals_1;
      t1 = this.offset_2 + i;
      t2 = t3.length;
      if (t1 < 0 || t1 >= t2)
        return H.ioore(t3, t1);
      t5 = t3[t1];
      ++t1;
      if (t1 >= t2)
        return H.ioore(t3, t1);
      t1 = t3[t1];
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return (1 - t4) * t5 + t4 * t1;
    }
  },
  Spectrum_AverageSpectrumSamples_SEG_AVG: {
    "^": "Closure:100;INTERP_3",
    call$3: function(wl0, wl1, i) {
      var t1 = this.INTERP_3;
      return 0.5 * J.$add$ns(t1.call$2(wl0, i), t1.call$2(wl1, i));
    }
  },
  SpectrumImage: {
    "^": "Object;width>,height>,samplesPerPixel<,data>",
    convert$1: function(format) {
      var out, t1, len, t2, i, j, i0, r, g, b, j0, y, t3;
      if (format === this.samplesPerPixel)
        return this;
      if (format === 1) {
        out = G.SpectrumImage$(this.width, this.height, 1);
        t1 = this.data;
        len = t1.length;
        for (t2 = out.data, i = 0, j = 0; i < len; j = j0, i = i0) {
          i0 = i + 1;
          r = t1[i];
          i = i0 + 1;
          if (i0 >= len)
            return H.ioore(t1, i0);
          g = t1[i0];
          i0 = i + 1;
          if (i >= len)
            return H.ioore(t1, i);
          b = t1[i];
          j0 = j + 1;
          if (j >= t2.length)
            return H.ioore(t2, j);
          t2[j] = 0.212671 * r + 0.71516 * g + 0.072169 * b;
        }
        return out;
      }
      out = G.SpectrumImage$(this.width, this.height, 3);
      t1 = this.data;
      len = t1.length;
      for (t2 = out.data, i = 0, j = 0; i < len; j = j0, i = i0) {
        i0 = i + 1;
        y = t1[i];
        j0 = j + 1;
        t3 = t2.length;
        if (j >= t3)
          return H.ioore(t2, j);
        t2[j] = y;
        j = j0 + 1;
        if (j0 >= t3)
          return H.ioore(t2, j0);
        t2[j0] = y;
        j0 = j + 1;
        if (j >= t3)
          return H.ioore(t2, j);
        t2[j] = y;
      }
      return out;
    },
    set$1: function(other) {
      this.data = J.get$data$x(other);
      this.width = other.width;
      this.height = other.height;
    },
    $index: function(_, index) {
      var t1, t2, t3, t4, t5;
      if (J.$eq(this.samplesPerPixel, 1)) {
        t1 = this.data;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return t1[index];
      }
      index = J.$mul$ns(index, this.samplesPerPixel);
      t1 = $.get$SpectrumImage__output().c;
      t2 = this.data;
      t3 = t2.length;
      if (index >>> 0 !== index || index >= t3)
        return H.ioore(t2, index);
      t4 = t2[index];
      t5 = t1.length;
      if (0 >= t5)
        return H.ioore(t1, 0);
      t1[0] = t4;
      t4 = index + 1;
      if (t4 >= t3)
        return H.ioore(t2, t4);
      t4 = t2[t4];
      if (1 >= t5)
        return H.ioore(t1, 1);
      t1[1] = t4;
      t4 = index + 2;
      if (t4 >= t2.length)
        return H.ioore(t2, t4);
      t4 = t2[t4];
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1[2] = t4;
      return $.get$SpectrumImage__output();
    },
    $indexSet: function(_, index, s) {
      var t1, t2, t3;
      if (J.$eq(this.samplesPerPixel, 1)) {
        t1 = this.data;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        t1[index] = s;
        return;
      }
      index = J.$mul$ns(index, this.samplesPerPixel);
      t1 = this.data;
      t2 = J.$index$asx(s.get$c(), 0);
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = t2;
      t2 = this.data;
      t1 = index + 1;
      t3 = J.$index$asx(s.get$c(), 1);
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      t2[t1] = t3;
      t3 = this.data;
      t1 = index + 2;
      t2 = J.$index$asx(s.get$c(), 2);
      if (t1 >= t3.length)
        return H.ioore(t3, t1);
      t3[t1] = t2;
    },
    SpectrumImage$fromImage$1: function(img) {
      var b, t1, t2, t3, t4, y, p, d, x, d0, t5, t6;
      b = img.getBytes$0();
      t1 = this.height;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.width;
      t3 = this.data;
      t4 = b.length;
      y = 0;
      p = 0;
      d = 0;
      for (; y < t1; ++y) {
        if (typeof t2 !== "number")
          return H.iae(t2);
        x = 0;
        for (; x < t2; ++x, p += 4, d = d0) {
          d0 = d + 1;
          if (p < 0 || p >= t4)
            return H.ioore(b, p);
          t5 = b[p];
          t6 = t3.length;
          if (d < 0 || d >= t6)
            return H.ioore(t3, d);
          t3[d] = t5 / 255;
          d = d0 + 1;
          t5 = p + 1;
          if (t5 >= t4)
            return H.ioore(b, t5);
          t5 = b[t5];
          if (d0 < 0 || d0 >= t6)
            return H.ioore(t3, d0);
          t3[d0] = t5 / 255;
          d0 = d + 1;
          t5 = p + 2;
          if (t5 >= t4)
            return H.ioore(b, t5);
          t5 = b[t5];
          if (d < 0 || d >= t6)
            return H.ioore(t3, d);
          t3[d] = t5 / 255;
        }
      }
    },
    static: {"^": "SpectrumImage_FLOAT,SpectrumImage_SPECTRUM,SpectrumImage__output", SpectrumImage$: function(width, height, samplesPerPixel) {
        var t1 = J.$mul$ns(J.$mul$ns(width, height), samplesPerPixel);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        return new G.SpectrumImage(width, height, samplesPerPixel, new Float32Array(t1));
      }, SpectrumImage$fromImage: function(img) {
        var t1, t2, t3;
        t1 = J.get$width$x(img);
        t2 = img.height;
        t3 = J.$mul$ns(J.$mul$ns(img.width, t2), 3);
        if (typeof t3 !== "number" || Math.floor(t3) !== t3)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t3)));
        t1 = new G.SpectrumImage(t1, t2, 3, new Float32Array(t3));
        t1.SpectrumImage$fromImage$1(img);
        return t1;
      }, SpectrumImage$from: function(other) {
        var t1 = J.getInterceptor$x(other);
        return new G.SpectrumImage(t1.get$width(other), t1.get$height(other), other.get$samplesPerPixel(), new Float32Array(H._ensureNativeList(t1.get$data(other))));
      }}
  },
  SphericalHarmonics_RotateXPlus_O: {
    "^": "Closure:87;c_in_0",
    call$2: function(l, m) {
      var t1, t2;
      t1 = this.c_in_0;
      t2 = l * l + l + m;
      if (t2 < 0 || t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    }
  },
  SphericalHarmonics__legendrep_P: {
    "^": "Closure:101;out_0,outIndex_1",
    call$2: function(l, m) {
      var index, t1;
      index = J.toInt$0$n(J.$add$ns(this.outIndex_1, l * l + l + m));
      t1 = this.out_0;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    }
  },
  StatTracker: {
    "^": "Object;name>"
  },
  StatsCounter: {
    "^": "StatTracker;count@,category,name",
    $add: function(_, n) {
      this.count = J.$add$ns(this.count, n);
      return this;
    },
    toString$0: function(_) {
      return this.category + " | " + this.name + ": " + H.S(this.count);
    }
  },
  SurfaceIntegrator: {
    "^": "Integrator;"
  },
  ConstantTexture: {
    "^": "Texture;value",
    evaluate$1: function(dg) {
      return this.value;
    }
  },
  CylindricalMapping2D: {
    "^": "TextureMapping2D;worldToTexture",
    map$7: function(_, dg, s, t, dsdx, dtdx, dsdy, dtdy) {
      var sx, tx, sy, ty, t1;
      this._cylinder$3(dg.p, s, t);
      sx = [0];
      tx = [0];
      sy = [0];
      ty = [0];
      this._cylinder$3(dg.p.$add(0, dg.dpdx.$mul(0, 0.01)), sx, tx);
      dsdx[0] = J.$div$n(J.$sub$n(sx[0], s[0]), 0.01);
      t1 = J.$div$n(J.$sub$n(tx[0], t[0]), 0.01);
      dtdx[0] = t1;
      if (J.$gt$n(t1, 0.5)) {
        t1 = dtdx[0];
        if (typeof t1 !== "number")
          return H.iae(t1);
        dtdx[0] = 1 - t1;
      } else if (J.$lt$n(dtdx[0], -0.5))
        dtdx[0] = J.$negate$n(J.$add$ns(dtdx[0], 1));
      this._cylinder$3(dg.p.$add(0, dg.dpdy.$mul(0, 0.01)), sy, ty);
      dsdy[0] = J.$div$n(J.$sub$n(sy[0], s[0]), 0.01);
      t1 = J.$div$n(J.$sub$n(ty[0], t[0]), 0.01);
      dtdy[0] = t1;
      if (J.$gt$n(t1, 0.5)) {
        t1 = dtdy[0];
        if (typeof t1 !== "number")
          return H.iae(t1);
        dtdy[0] = 1 - t1;
      } else if (J.$lt$n(dtdy[0], -0.5))
        dtdy[0] = J.$negate$n(J.$add$ns(dtdy[0], 1));
    },
    _cylinder$3: function(p, s, t) {
      var t1, vec, t2;
      t1 = this.worldToTexture.transformPoint$1(p).$sub(0, new G.Point(0, 0, 0));
      vec = t1.$div(t1, t1.length$0(0));
      t1 = vec.y;
      t2 = vec.x;
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      s[0] = (3.141592653589793 + Math.atan2(t1, t2)) / 6.283185307179586;
      t[0] = vec.z;
    }
  },
  IdentityMapping3D: {
    "^": "TextureMapping3D;worldToTexture",
    map$3: function(_, dg, dpdx, dpdy) {
      var t1 = this.worldToTexture;
      dpdx.copy$1(t1.transformVector$1(dg.dpdx));
      dpdy.copy$1(t1.transformVector$1(dg.dpdy));
      return t1.transformPoint$1(dg.p);
    }
  },
  PlanarMapping2D: {
    "^": "TextureMapping2D;vs,vt,ds,dt",
    map$7: function(_, dg, s, t, dsdx, dtdx, dsdy, dtdy) {
      var vec, t1, t2;
      vec = dg.p.$sub(0, new G.Point(0, 0, 0));
      t1 = this.vs;
      s[0] = J.$add$ns(this.ds, G.Vector_Dot(vec, t1));
      t2 = this.vt;
      t[0] = J.$add$ns(this.dt, G.Vector_Dot(vec, t2));
      dsdx[0] = G.Vector_Dot(dg.dpdx, t1);
      dtdx[0] = G.Vector_Dot(dg.dpdx, t2);
      dsdy[0] = G.Vector_Dot(dg.dpdy, t1);
      dtdy[0] = G.Vector_Dot(dg.dpdy, t2);
    }
  },
  SphericalMapping2D: {
    "^": "TextureMapping2D;worldToTexture",
    map$7: function(_, dg, s, t, dsdx, dtdx, dsdy, dtdy) {
      var sx, tx, sy, ty, t1;
      this._sphere$3(dg.p, s, t);
      sx = [0];
      tx = [0];
      sy = [0];
      ty = [0];
      this._sphere$3(dg.p.$add(0, dg.dpdx.$mul(0, 0.1)), sx, tx);
      dsdx[0] = J.$div$n(J.$sub$n(sx[0], s[0]), 0.1);
      t1 = J.$div$n(J.$sub$n(tx[0], t[0]), 0.1);
      dtdx[0] = t1;
      if (J.$gt$n(t1, 0.5)) {
        t1 = dtdx[0];
        if (typeof t1 !== "number")
          return H.iae(t1);
        dtdx[0] = 1 - t1;
      } else if (J.$lt$n(dtdx[0], -0.5))
        dtdx[0] = J.$negate$n(J.$add$ns(dtdx[0], 1));
      this._sphere$3(dg.p.$add(0, dg.dpdy.$mul(0, 0.1)), sy, ty);
      dsdy[0] = J.$div$n(J.$sub$n(sy[0], s[0]), 0.1);
      t1 = J.$div$n(J.$sub$n(ty[0], t[0]), 0.1);
      dtdy[0] = t1;
      if (J.$gt$n(t1, 0.5)) {
        t1 = dtdy[0];
        if (typeof t1 !== "number")
          return H.iae(t1);
        dtdy[0] = 1 - t1;
      } else if (J.$lt$n(dtdy[0], -0.5))
        dtdy[0] = J.$negate$n(J.$add$ns(dtdy[0], 1));
    },
    _sphere$3: function(p, s, t) {
      var t1, vec, theta, phi;
      t1 = this.worldToTexture.transformPoint$1(p).$sub(0, new G.Point(0, 0, 0));
      vec = t1.$div(t1, t1.length$0(0));
      t1 = J.clamp$2$n(vec.z, -1, 1);
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      theta = Math.acos(t1);
      phi = G.Vector_SphericalPhi(vec);
      s[0] = theta * 0.3183098861837907;
      t[0] = phi * 0.15915494309189535;
    }
  },
  Texture: {
    "^": "Object;"
  },
  TextureMapping2D: {
    "^": "Object;"
  },
  TextureMapping3D: {
    "^": "Object;"
  },
  UVMapping2D: {
    "^": "TextureMapping2D;su,sv,du,dv",
    map$7: function(_, dg, s, t, dsdx, dtdx, dsdy, dtdy) {
      var t1, t2, t3, t4;
      t1 = this.su;
      t2 = J.getInterceptor$ns(t1);
      s[0] = J.$add$ns(t2.$mul(t1, dg.u), this.du);
      t3 = this.sv;
      t4 = J.getInterceptor$ns(t3);
      t[0] = J.$add$ns(t4.$mul(t3, dg.v), this.dv);
      dsdx[0] = t2.$mul(t1, dg.dudx);
      dtdx[0] = t4.$mul(t3, dg.dvdx);
      dsdy[0] = t2.$mul(t1, dg.dudy);
      dtdy[0] = t4.$mul(t3, dg.dvdy);
    }
  },
  TextureParams: {
    "^": "Object;floatTextures,spectrumTextures<,geomParams,materialParams@",
    getSpectrumTexture$2: function(n, def) {
      var t1, $name, t2;
      t1 = this.geomParams;
      $name = t1.findTexture$1(n);
      if (J.get$isEmpty$asx($name) === true)
        $name = this.materialParams.findTexture$1(n);
      if (J.get$isNotEmpty$asx($name)) {
        t2 = this.spectrumTextures;
        if (t2.containsKey$1($name))
          return t2.$index(0, $name);
        else {
          t2 = "Couldn't find spectrum texture named '" + H.S($name) + "' for parameter '" + n + "'";
          $.Log.call$2(1, t2);
        }
      }
      return new G.ConstantTexture(t1.findOneSpectrum$2(n, this.materialParams.findOneSpectrum$2(n, def)));
    },
    getFloatTexture$2: function(n, def) {
      var t1, $name, t2;
      t1 = this.geomParams;
      $name = t1.findTexture$1(n);
      if (J.$eq($name, ""))
        $name = this.materialParams.findTexture$1(n);
      if (!J.$eq($name, "")) {
        t2 = this.floatTextures;
        if (t2.containsKey$1($name))
          return t2.$index(0, $name);
        else {
          t2 = "Couldn't find float texture named '" + H.S($name) + "' for parameter '" + n + "'";
          $.Log.call$2(1, t2);
        }
      }
      return new G.ConstantTexture(t1.findOneFloat$2(n, this.materialParams.findOneFloat$2(n, def)));
    },
    getFloatTextureOrNull$1: function(n) {
      var $name, t1;
      $name = this.geomParams.findTexture$1(n);
      if (J.$eq($name, ""))
        $name = this.materialParams.findTexture$1(n);
      if (J.$eq($name, ""))
        return;
      t1 = this.floatTextures;
      if (t1.containsKey$1($name))
        return t1.$index(0, $name);
      else {
        t1 = "Couldn't find float texture named '" + H.S($name) + "' for parameter '" + n + "'";
        $.Log.call$2(1, t1);
        return;
      }
    },
    findFloat$2: function(n, d) {
      return this.geomParams.findOneFloat$2(n, this.materialParams.findOneFloat$2(n, d));
    },
    findString$2: function(n, d) {
      return this.geomParams.findOneString$2(n, this.materialParams.findOneString$2(n, d));
    },
    findString$1: function(n) {
      return this.findString$2(n, "");
    },
    findInt$2: function(n, d) {
      return this.geomParams.findOneInt$2(n, this.materialParams.findOneInt$2(n, d));
    },
    reportUnused$0: function() {
      this.geomParams.reportUnused$0();
      this.materialParams.reportUnused$0();
    }
  },
  Transform: {
    "^": "Object;m<,mInv<",
    copy$1: function(t) {
      this.m = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t.get$m().get$m())));
      this.mInv = new G.Matrix4x4(new Float32Array(H._ensureNativeList(t.get$mInv().m)));
      return this;
    },
    $eq: function(_, t) {
      if (t == null)
        return false;
      return J.$eq(t.get$m(), this.m) && t.get$mInv().$eq(0, this.mInv);
    },
    $lt: function(_, t2) {
      var t1, t3, i, t4, t5;
      for (t1 = this.m.m, t3 = t1.length, i = 0; i < 16; ++i) {
        if (i >= t3)
          return H.ioore(t1, i);
        t4 = t1[i];
        t5 = t2.get$m().get$m();
        if (i >= t5.length)
          return H.ioore(t5, i);
        t5 = t5[i];
        if (t4 < t5)
          return true;
        if (t4 > t5)
          return false;
      }
      return false;
    },
    $mul: function(_, t2) {
      return G.Transform$(G.Matrix4x4_Mul(this.m, t2.get$m()), G.Matrix4x4_Mul(t2.get$mInv(), this.mInv));
    },
    hasScale$0: function() {
      var la2, lb2, lc2, t1;
      la2 = this.transformVector$1(new G.Vector(1, 0, 0)).lengthSquared$0();
      lb2 = this.transformVector$1(new G.Vector(0, 1, 0)).lengthSquared$0();
      lc2 = this.transformVector$1(new G.Vector(0, 0, 1)).lengthSquared$0();
      t1 = J.getInterceptor$n(la2);
      if (!(t1.$lt(la2, 0.999) || t1.$gt(la2, 1.001))) {
        t1 = J.getInterceptor$n(lb2);
        if (!(t1.$lt(lb2, 0.999) || t1.$gt(lb2, 1.001))) {
          t1 = J.getInterceptor$n(lc2);
          t1 = t1.$lt(lc2, 0.999) || t1.$gt(lc2, 1.001);
        } else
          t1 = true;
      } else
        t1 = true;
      return t1;
    },
    transformPoint$2: function(p, out) {
      var t1, x, y, z, t2, t3, t4, t5, t6, w;
      if (out == null)
        out = new G.Point(0, 0, 0);
      t1 = J.getInterceptor$x(p);
      x = t1.get$x(p);
      y = t1.get$y(p);
      z = t1.get$z(p);
      t1 = this.m.m;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (typeof x !== "number")
        return H.iae(x);
      if (1 >= t2)
        return H.ioore(t1, 1);
      t4 = t1[1];
      if (typeof y !== "number")
        return H.iae(y);
      if (2 >= t2)
        return H.ioore(t1, 2);
      t5 = t1[2];
      if (typeof z !== "number")
        return H.iae(z);
      if (3 >= t2)
        return H.ioore(t1, 3);
      t2 = J.getInterceptor$x(out);
      t2.set$x(out, t3 * x + t4 * y + t5 * z + t1[3]);
      t1 = this.m.m;
      t5 = t1.length;
      if (4 >= t5)
        return H.ioore(t1, 4);
      t4 = t1[4];
      if (5 >= t5)
        return H.ioore(t1, 5);
      t3 = t1[5];
      if (6 >= t5)
        return H.ioore(t1, 6);
      t6 = t1[6];
      if (7 >= t5)
        return H.ioore(t1, 7);
      t2.set$y(out, t4 * x + t3 * y + t6 * z + t1[7]);
      t1 = this.m.m;
      t6 = t1.length;
      if (8 >= t6)
        return H.ioore(t1, 8);
      t3 = t1[8];
      if (9 >= t6)
        return H.ioore(t1, 9);
      t4 = t1[9];
      if (10 >= t6)
        return H.ioore(t1, 10);
      t5 = t1[10];
      if (11 >= t6)
        return H.ioore(t1, 11);
      t2.set$z(out, t3 * x + t4 * y + t5 * z + t1[11]);
      t1 = this.m.m;
      t5 = t1.length;
      if (12 >= t5)
        return H.ioore(t1, 12);
      t4 = t1[12];
      if (13 >= t5)
        return H.ioore(t1, 13);
      t3 = t1[13];
      if (14 >= t5)
        return H.ioore(t1, 14);
      t2 = t1[14];
      if (15 >= t5)
        return H.ioore(t1, 15);
      w = t4 * x + t3 * y + t2 * z + t1[15];
      if (w !== 1)
        out.invScale$1(w);
      return out;
    },
    transformPoint$1: function(p) {
      return this.transformPoint$2(p, null);
    },
    transformVector$2: function(p, out) {
      var t1, x, y, z, t2, t3, t4, t5;
      if (out == null)
        out = new G.Vector(0, 0, 0);
      t1 = J.getInterceptor$x(p);
      x = t1.get$x(p);
      y = t1.get$y(p);
      z = t1.get$z(p);
      t1 = this.m.m;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (typeof x !== "number")
        return H.iae(x);
      if (1 >= t2)
        return H.ioore(t1, 1);
      t4 = t1[1];
      if (typeof y !== "number")
        return H.iae(y);
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      if (typeof z !== "number")
        return H.iae(z);
      t2 = J.getInterceptor$x(out);
      t2.set$x(out, t3 * x + t4 * y + t1 * z);
      t1 = this.m.m;
      t4 = t1.length;
      if (4 >= t4)
        return H.ioore(t1, 4);
      t3 = t1[4];
      if (5 >= t4)
        return H.ioore(t1, 5);
      t5 = t1[5];
      if (6 >= t4)
        return H.ioore(t1, 6);
      t2.set$y(out, t3 * x + t5 * y + t1[6] * z);
      t1 = this.m.m;
      t5 = t1.length;
      if (8 >= t5)
        return H.ioore(t1, 8);
      t3 = t1[8];
      if (9 >= t5)
        return H.ioore(t1, 9);
      t4 = t1[9];
      if (10 >= t5)
        return H.ioore(t1, 10);
      t2.set$z(out, t3 * x + t4 * y + t1[10] * z);
      return out;
    },
    transformVector$1: function(p) {
      return this.transformVector$2(p, null);
    },
    transformNormal$2: function(p, out) {
      var t1, x, y, z, t2, t3, t4, t5;
      out = new G.Normal(0, 0, 0);
      t1 = J.getInterceptor$x(p);
      x = t1.get$x(p);
      y = t1.get$y(p);
      z = t1.get$z(p);
      t1 = this.mInv.m;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (typeof x !== "number")
        return H.iae(x);
      if (4 >= t2)
        return H.ioore(t1, 4);
      t4 = t1[4];
      if (typeof y !== "number")
        return H.iae(y);
      if (8 >= t2)
        return H.ioore(t1, 8);
      t5 = t1[8];
      if (typeof z !== "number")
        return H.iae(z);
      out.x = t3 * x + t4 * y + t5 * z;
      t5 = t1[1];
      t4 = t1[5];
      if (9 >= t2)
        return H.ioore(t1, 9);
      out.y = t5 * x + t4 * y + t1[9] * z;
      t4 = t1[2];
      t5 = t1[6];
      if (10 >= t2)
        return H.ioore(t1, 10);
      out.z = t4 * x + t5 * y + t1[10] * z;
      return out;
    },
    transformNormal$1: function(p) {
      return this.transformNormal$2(p, null);
    },
    transformBBox$2: function(b, out) {
      var t1, t2;
      out = G.BBox$(null, null);
      t1 = this.transformPoint$1(b.get$pMin());
      out.pMin.copy$1(t1);
      out.pMax.copy$1(t1);
      t1 = b.pMax.x;
      t2 = b.pMin;
      out.unionPoint$1(this.transformPoint$1(new G.Point(t1, t2.y, t2.z)));
      t2 = b.pMin;
      out.unionPoint$1(this.transformPoint$1(new G.Point(t2.x, b.pMax.y, t2.z)));
      t2 = b.pMin;
      out.unionPoint$1(this.transformPoint$1(new G.Point(t2.x, t2.y, b.pMax.z)));
      t2 = b.pMin.x;
      t1 = b.pMax;
      out.unionPoint$1(this.transformPoint$1(new G.Point(t2, t1.y, t1.z)));
      t1 = b.pMax;
      out.unionPoint$1(this.transformPoint$1(new G.Point(t1.x, t1.y, b.pMin.z)));
      t1 = b.pMax;
      out.unionPoint$1(this.transformPoint$1(new G.Point(t1.x, b.pMin.y, t1.z)));
      out.unionPoint$1(this.transformPoint$1(b.pMax));
      return out;
    },
    transformBBox$1: function(b) {
      return this.transformBBox$2(b, null);
    },
    transformRay$2: function(r, tr) {
      if (tr == null)
        tr = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.transformPoint$2(J.get$origin$x(r), tr.origin);
      this.transformVector$2(r.get$direction(), tr.direction);
      if (tr !== r) {
        tr.minDistance = r.minDistance;
        tr.maxDistance = r.maxDistance;
        tr.time = r.time;
        tr.depth = r.depth;
      }
      return tr;
    },
    transformRay$1: function(r) {
      return this.transformRay$2(r, null);
    },
    transformRayDifferential$2: function(r, rt) {
      this.transformRay$2(r, rt);
      rt.hasDifferentials = r.hasDifferentials;
      this.transformPoint$2(r.rxOrigin, rt.rxOrigin);
      this.transformPoint$2(r.ryOrigin, rt.ryOrigin);
      this.transformVector$2(r.rxDirection, rt.rxDirection);
      this.transformVector$2(r.ryDirection, rt.ryDirection);
      return rt;
    },
    static: {Transform$: function(m, inv) {
        var t1, t2;
        t1 = m == null;
        t2 = t1 ? G.Matrix4x4$() : new G.Matrix4x4(new Float32Array(H._ensureNativeList(m.m)));
        if (inv == null)
          t1 = t1 ? G.Matrix4x4$() : new G.Matrix4x4(new Float32Array(H._ensureNativeList(m.m))).invert$0();
        else
          t1 = new G.Matrix4x4(new Float32Array(H._ensureNativeList(inv.m)));
        return new G.Transform(t2, t1);
      }, Transform$from: function(t) {
        return new G.Transform(new G.Matrix4x4(new Float32Array(H._ensureNativeList(t.get$m().get$m()))), new G.Matrix4x4(new Float32Array(H._ensureNativeList(t.get$mInv().m))));
      }, Transform_Translate: function(delta) {
        var t1 = J.getInterceptor$x(delta);
        return G.Transform$(G.Matrix4x4$values(1, 0, 0, t1.get$x(delta), 0, 1, 0, t1.get$y(delta), 0, 0, 1, t1.get$z(delta), 0, 0, 0, 1), G.Matrix4x4$values(1, 0, 0, J.$negate$n(t1.get$x(delta)), 0, 1, 0, J.$negate$n(t1.get$y(delta)), 0, 0, 1, J.$negate$n(t1.get$z(delta)), 0, 0, 0, 1));
      }, Transform_Scale: function(x, y, z) {
        var m = G.Matrix4x4$values(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        if (typeof x !== "number")
          return H.iae(x);
        if (typeof y !== "number")
          return H.iae(y);
        if (typeof z !== "number")
          return H.iae(z);
        return G.Transform$(m, G.Matrix4x4$values(1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1));
      }, Transform_Perspective: function(fov, znear, zfar) {
        var t1, persp, invTanAng;
        t1 = zfar - znear;
        persp = G.Matrix4x4$values(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, zfar / t1, -zfar * znear / t1, 0, 0, 1, 0);
        if (typeof fov !== "number")
          return H.iae(fov);
        invTanAng = 1 / Math.tan(0.017453292519943295 * fov / 2);
        return G.Transform_Scale(invTanAng, invTanAng, 1).$mul(0, G.Transform$(persp, null));
      }}
  },
  Vector: {
    "^": "Object;x*,y*,z*",
    copy$1: function(other) {
      var t1 = J.getInterceptor$x(other);
      this.x = t1.get$x(other);
      this.y = t1.get$y(other);
      this.z = t1.get$z(other);
    },
    $add: function(_, v) {
      var t1 = J.getInterceptor$x(v);
      return new G.Vector(J.$add$ns(this.x, t1.get$x(v)), J.$add$ns(this.y, t1.get$y(v)), J.$add$ns(this.z, t1.get$z(v)));
    },
    add$1: function(_, v) {
      var t1 = J.getInterceptor$x(v);
      this.x = J.$add$ns(this.x, t1.get$x(v));
      this.y = J.$add$ns(this.y, t1.get$y(v));
      this.z = J.$add$ns(this.z, t1.get$z(v));
    },
    $sub: function(_, v) {
      var t1 = J.getInterceptor$x(v);
      return new G.Vector(J.$sub$n(this.x, t1.get$x(v)), J.$sub$n(this.y, t1.get$y(v)), J.$sub$n(this.z, t1.get$z(v)));
    },
    $mul: function(_, f) {
      return new G.Vector(J.$mul$ns(this.x, f), J.$mul$ns(this.y, f), J.$mul$ns(this.z, f));
    },
    scale$1: function(_, f) {
      this.x = J.$mul$ns(this.x, f);
      this.y = J.$mul$ns(this.y, f);
      this.z = J.$mul$ns(this.z, f);
    },
    $div: function(_, f) {
      return new G.Vector(J.$div$n(this.x, f), J.$div$n(this.y, f), J.$div$n(this.z, f));
    },
    invScale$1: function(f) {
      this.x = J.$div$n(this.x, f);
      this.y = J.$div$n(this.y, f);
      this.z = J.$div$n(this.z, f);
    },
    $negate: function(_) {
      return new G.Vector(J.$negate$n(this.x), J.$negate$n(this.y), J.$negate$n(this.z));
    },
    $index: function(_, i) {
      var t1 = J.getInterceptor(i);
      if (t1.$eq(i, 0))
        t1 = this.x;
      else
        t1 = t1.$eq(i, 1) ? this.y : this.z;
      return t1;
    },
    $indexSet: function(_, i, v) {
      var t1 = J.getInterceptor(i);
      if (t1.$eq(i, 0))
        this.x = v;
      else if (t1.$eq(i, 1))
        this.y = v;
      else
        this.z = v;
      return v;
    },
    lengthSquared$0: function() {
      var t1, t2;
      t1 = this.x;
      t1 = J.$mul$ns(t1, t1);
      t2 = this.y;
      t2 = J.$add$ns(t1, J.$mul$ns(t2, t2));
      t1 = this.z;
      return J.$add$ns(t2, J.$mul$ns(t1, t1));
    },
    length$0: [function(_) {
      var t1 = this.lengthSquared$0();
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return Math.sqrt(t1);
    }, "call$0", "get$length", 0, 0, 93],
    toString$0: function(_) {
      return H.S(this.x) + " " + H.S(this.y) + " " + H.S(this.z);
    },
    $isVector: true,
    static: {Vector$from: function(other) {
        var t1 = J.getInterceptor$x(other);
        return new G.Vector(t1.get$x(other), t1.get$y(other), t1.get$z(other));
      }, Vector_SinTheta2: function(v) {
        var t1 = J.getInterceptor$x(v);
        t1 = J.$mul$ns(t1.get$z(v), t1.get$z(v));
        if (typeof t1 !== "number")
          return H.iae(t1);
        return P.max(0, 1 - t1);
      }, Vector_CosPhi: function(v) {
        var t1, sintheta;
        t1 = G.Vector_SinTheta2(v);
        sintheta = Math.sqrt(t1);
        if (sintheta === 0)
          return 1;
        return J.clamp$2$n(J.$div$n(J.get$x$x(v), sintheta), -1, 1);
      }, Vector_SinPhi: function(v) {
        var t1, sintheta;
        t1 = G.Vector_SinTheta2(v);
        sintheta = Math.sqrt(t1);
        if (sintheta === 0)
          return 0;
        return J.clamp$2$n(J.$div$n(J.get$y$x(v), sintheta), -1, 1);
      }, Vector_Dot: function(v1, v2) {
        var t1, t2;
        t1 = J.getInterceptor$x(v1);
        t2 = J.getInterceptor$x(v2);
        return J.$add$ns(J.$add$ns(J.$mul$ns(t1.get$x(v1), t2.get$x(v2)), J.$mul$ns(t1.get$y(v1), t2.get$y(v2))), J.$mul$ns(t1.get$z(v1), t2.get$z(v2)));
      }, Vector_AbsDot: function(v1, v2) {
        var t1, t2;
        t1 = J.getInterceptor$x(v1);
        t2 = J.getInterceptor$x(v2);
        return J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(t1.get$x(v1), t2.get$x(v2)), J.$mul$ns(t1.get$y(v1), t2.get$y(v2))), J.$mul$ns(t1.get$z(v1), t2.get$z(v2))));
      }, Vector_Cross: function(v1, v2) {
        var t1, v1x, v1y, v1z, v2x, v2y, v2z, t2, t3;
        t1 = J.getInterceptor$x(v1);
        v1x = t1.get$x(v1);
        v1y = t1.get$y(v1);
        v1z = t1.get$z(v1);
        t1 = J.getInterceptor$x(v2);
        v2x = t1.get$x(v2);
        v2y = t1.get$y(v2);
        v2z = t1.get$z(v2);
        t1 = J.getInterceptor$ns(v1y);
        t2 = J.getInterceptor$ns(v1z);
        t3 = J.getInterceptor$ns(v1x);
        return new G.Vector(J.$sub$n(t1.$mul(v1y, v2z), t2.$mul(v1z, v2y)), J.$sub$n(t2.$mul(v1z, v2x), t3.$mul(v1x, v2z)), J.$sub$n(t3.$mul(v1x, v2y), t1.$mul(v1y, v2x)));
      }, Vector_SphericalPhi: function(v) {
        var t1, t2, p;
        t1 = J.getInterceptor$x(v);
        t2 = t1.get$y(v);
        t1 = t1.get$x(v);
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        p = Math.atan2(t2, t1);
        return p < 0 ? p + 6.283185307179586 : p;
      }, Vector_CoordinateSystem: function(v1, v2, v3) {
        var t1, t2, invLen;
        t1 = J.getInterceptor$x(v1);
        if (J.abs$0$n(t1.get$x(v1)) > J.abs$0$n(t1.get$y(v1))) {
          t2 = J.$add$ns(J.$mul$ns(t1.get$x(v1), t1.get$x(v1)), J.$mul$ns(t1.get$z(v1), t1.get$z(v1)));
          if (typeof t2 !== "number")
            H.throwExpression(P.ArgumentError$(t2));
          invLen = 1 / Math.sqrt(t2);
          t2 = J.getInterceptor$x(v2);
          t2.set$x(v2, J.$mul$ns(J.$negate$n(t1.get$z(v1)), invLen));
          t2.set$y(v2, 0);
          t2.set$z(v2, J.$mul$ns(t1.get$x(v1), invLen));
        } else {
          t2 = J.$add$ns(J.$mul$ns(t1.get$y(v1), t1.get$y(v1)), J.$mul$ns(t1.get$z(v1), t1.get$z(v1)));
          if (typeof t2 !== "number")
            H.throwExpression(P.ArgumentError$(t2));
          invLen = 1 / Math.sqrt(t2);
          t2 = J.getInterceptor$x(v2);
          t2.set$x(v2, 0);
          t2.set$y(v2, J.$mul$ns(t1.get$z(v1), invLen));
          t2.set$z(v2, J.$mul$ns(J.$negate$n(t1.get$y(v1)), invLen));
        }
        t1 = G.Vector_Cross(v1, v2);
        v3.x = t1.x;
        v3.y = t1.y;
        v3.z = t1.z;
      }}
  },
  AggregateVolume: {
    "^": "VolumeRegion;regions,_bound",
    worldBound$0: function() {
      return this._bound;
    },
    intersectP$3: function(ray, t00, t1) {
      var tr0, tr1, t2, i;
      t00[0] = 1 / 0;
      t1[0] = -1 / 0;
      tr0 = [0];
      tr1 = [0];
      for (t2 = this.regions, i = 0; i < t2.length; ++i)
        if (t2[i].intersectP$3(ray, tr0, tr1)) {
          t00[0] = P.min(t00[0], tr0[0]);
          t1[0] = P.max(t1[0], tr1[0]);
        }
      return J.$lt$n(t00[0], t1[0]);
    },
    sigma_s$3: function(p, w, time) {
      var s, t1, i;
      s = G.Spectrum_Spectrum(0);
      for (t1 = this.regions, i = 0; i < t1.length; ++i)
        s = s.$add(0, t1[i].sigma_s$3(p, w, time));
      return s;
    },
    Lve$3: function(p, w, time) {
      var $L, t1, i;
      $L = G.Spectrum_Spectrum(0);
      for (t1 = this.regions, i = 0; i < t1.length; ++i)
        $L = $L.$add(0, t1[i].Lve$3(p, w, time));
      return $L;
    },
    p$4: [function(_, p, w, wp, time) {
      var t1, ph, sumWt, i, wt, t2;
      for (t1 = this.regions, ph = 0, sumWt = 0, i = 0; i < t1.length; ++i) {
        wt = J.get$y$x(t1[i].sigma_s$3(p, w, time));
        if (typeof wt !== "number")
          return H.iae(wt);
        sumWt += wt;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = J.p$4$x(t1[i], p, w, wp, time);
        if (typeof t2 !== "number")
          return H.iae(t2);
        ph += wt * t2;
      }
      return ph / sumWt;
    }, "call$4", "get$p", 8, 0, 102],
    tau$3: function(ray, step, offset) {
      var t, t1, i;
      t = G.Spectrum_Spectrum(0);
      for (t1 = this.regions, i = 0; i < t1.length; ++i)
        t = t.$add(0, t1[i].tau$3(ray, step, offset));
      return t;
    },
    AggregateVolume$1: function(regions) {
      var t1, i, t2, t3, t4, t5, t6;
      for (t1 = this.regions, i = 0; i < t1.length; ++i) {
        t2 = this._bound;
        t3 = t1[i].worldBound$0();
        t4 = t2.pMin;
        t5 = t4.x;
        t6 = t4.y;
        t4 = t4.z;
        t2 = t2.pMax;
        this._bound = new G.BBox(new G.Point(t5, t6, t4), new G.Point(t2.x, t2.y, t2.z)).union$1(t3);
      }
    },
    static: {AggregateVolume$: function(regions) {
        var t1 = new G.AggregateVolume(regions, G.BBox$(null, null));
        t1.AggregateVolume$1(regions);
        return t1;
      }}
  },
  DensityRegion: {
    "^": "VolumeRegion;",
    sigma_s$3: function(p, v, d) {
      return this.sig_s.$mul(0, this.density$1(this.worldToVolume.transformPoint$1(p)));
    },
    Lve$3: function(p, v, d) {
      return this.le.$mul(0, this.density$1(this.worldToVolume.transformPoint$1(p)));
    },
    p$4: [function(_, p, w, wp, d) {
      return G.PhaseHG(w, wp, this.g);
    }, "call$4", "get$p", 8, 0, 102],
    tau$3: function(r, stepSize, u) {
      var t00, t1, $length, rn, tau, t2, t3, t4, t5;
      t00 = [0];
      t1 = [0];
      $length = J.length$0$asx(r.direction);
      if (J.$eq($length, 0))
        return G.Spectrum_Spectrum(0);
      rn = G.Ray$(r.origin, J.$div$n(r.direction, $length), J.$mul$ns(r.minDistance, $length), J.$mul$ns(r.maxDistance, $length), r.time, 0);
      if (!this.intersectP$3(rn, t00, t1))
        return G.Spectrum_Spectrum(0);
      tau = G.Spectrum_Spectrum(0);
      t2 = J.$add$ns(t00[0], J.$mul$ns(u, stepSize));
      t00[0] = t2;
      for (; J.$lt$n(t2, t1[0]);) {
        t2 = t00[0];
        t2 = J.$add$ns(rn.origin, J.$mul$ns(rn.direction, t2));
        t3 = J.getInterceptor$x(t2);
        t4 = t3.get$x(t2);
        t5 = t3.get$y(t2);
        t2 = t3.get$z(t2);
        J.$negate$n(rn.direction);
        tau = tau.$add(0, this.sig_a.$add(0, this.sig_s).$mul(0, this.density$1(this.worldToVolume.transformPoint$1(new G.Point(t4, t5, t2)))));
        t2 = J.$add$ns(t00[0], stepSize);
        t00[0] = t2;
      }
      return tau.$mul(0, stepSize);
    }
  },
  VolumeRegion: {
    "^": "Object;"
  },
  VolumeIntegrator: {
    "^": "Integrator;"
  },
  XYZColor: {
    "^": "Spectrum;c",
    get$x: function(_) {
      var t1 = this.c;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    set$x: function(_, v) {
      var t1 = this.c;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1[0] = v;
      return v;
    },
    get$y: function(_) {
      var t1 = this.c;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    set$y: function(_, v) {
      var t1 = this.c;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      t1[1] = v;
      return v;
    },
    get$z: function(_) {
      var t1 = this.c;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      return t1[2];
    },
    set$z: function(_, v) {
      var t1 = this.c;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1[2] = v;
      return v;
    },
    toRGB$0: function() {
      return G.RGBColor$from(this);
    },
    toXYZ$0: function() {
      return this;
    },
    setSampled$3: function(lambda, v, offset) {
      var t1, t2, t3, t4;
      t1 = new G.RGBColor(new Float32Array(3));
      t1.Spectrum$samples$2(3, 0);
      t1 = t1.setSampled$3(lambda, v, offset).c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      t4 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      G.Spectrum_RGBToXYZ(t3, t4, t1[2], this.c);
      return this;
    },
    setSampled$2: function(lambda, v) {
      return this.setSampled$3(lambda, v, 0);
    },
    setRGB$4: function(r, g, b, type) {
      G.Spectrum_RGBToXYZ(r, g, b, this.c);
      return this;
    },
    setRGB$3: function(r, g, b) {
      return this.setRGB$4(r, g, b, 0);
    },
    $add: function(_, s) {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t4 = J.$index$asx(s.get$c(), 0);
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (1 >= t2)
        return H.ioore(t1, 1);
      t5 = t1[1];
      t6 = J.$index$asx(s.get$c(), 1);
      if (typeof t6 !== "number")
        return H.iae(t6);
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = J.$index$asx(s.get$c(), 2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return G.XYZColor$xyz(t3 + t4, t5 + t6, t1 + t2);
    },
    $sub: function(_, s) {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t4 = J.$index$asx(s.get$c(), 0);
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (1 >= t2)
        return H.ioore(t1, 1);
      t5 = t1[1];
      t6 = J.$index$asx(s.get$c(), 1);
      if (typeof t6 !== "number")
        return H.iae(t6);
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = J.$index$asx(s.get$c(), 2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return G.XYZColor$xyz(t3 - t4, t5 - t6, t1 - t2);
    },
    $mul: function(_, s) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      if (typeof s === "number") {
        t1 = this.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t4 = t1[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        return G.XYZColor$xyz(t3 * s, t4 * s, t1[2] * s);
      }
      if (!!J.getInterceptor(s).$isXYZColor) {
        t1 = this.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        t4 = s.c;
        t5 = t4.length;
        if (0 >= t5)
          return H.ioore(t4, 0);
        t6 = t4[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t7 = t1[1];
        if (1 >= t5)
          return H.ioore(t4, 1);
        t8 = t4[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        t1 = t1[2];
        if (2 >= t5)
          return H.ioore(t4, 2);
        return G.XYZColor$xyz(t3 * t6, t7 * t8, t1 * t4[2]);
      }
      $.Log.call$2(3, "XYZColor or double expected.");
      t1 = new G.XYZColor(new Float32Array(3));
      t1.Spectrum$samples$2(3, 0);
      return t1;
    },
    $div: function(_, s) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      if (typeof s === "number") {
        t1 = this.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t4 = t1[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        return G.XYZColor$xyz(t3 / s, t4 / s, t1[2] / s);
      }
      if (!!J.getInterceptor(s).$isXYZColor) {
        t1 = this.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        t4 = s.c;
        t5 = t4.length;
        if (0 >= t5)
          return H.ioore(t4, 0);
        t6 = t4[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t7 = t1[1];
        if (1 >= t5)
          return H.ioore(t4, 1);
        t8 = t4[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        t1 = t1[2];
        if (2 >= t5)
          return H.ioore(t4, 2);
        return G.XYZColor$xyz(t3 / t6, t7 / t8, t1 / t4[2]);
      }
      $.Log.call$2(3, "XYZColor or double expected.");
      t1 = new G.XYZColor(new Float32Array(3));
      t1.Spectrum$samples$2(3, 0);
      return t1;
    },
    XYZColor$from$1: function(color) {
      var t1, t2, t3, t4, t5;
      t1 = J.getInterceptor(color);
      if (!!t1.$isRGBColor) {
        t1 = color.c;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t3 = t1[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        t4 = t1[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        G.Spectrum_RGBToXYZ(t3, t4, t1[2], this.c);
      } else if (!!t1.$isXYZColor) {
        t1 = this.c;
        t2 = color.c;
        t3 = t2.length;
        if (0 >= t3)
          return H.ioore(t2, 0);
        t4 = t2[0];
        t5 = t1.length;
        if (0 >= t5)
          return H.ioore(t1, 0);
        t1[0] = t4;
        if (1 >= t3)
          return H.ioore(t2, 1);
        t4 = t2[1];
        if (1 >= t5)
          return H.ioore(t1, 1);
        t1[1] = t4;
        if (2 >= t3)
          return H.ioore(t2, 2);
        t2 = t2[2];
        if (2 >= t5)
          return H.ioore(t1, 2);
        t1[2] = t2;
      } else if (!!t1.$isSampledSpectrum) {
        t1 = this.c;
        t2 = color.toXYZ$0().c;
        t3 = t2.length;
        if (0 >= t3)
          return H.ioore(t2, 0);
        t4 = t2[0];
        t5 = t1.length;
        if (0 >= t5)
          return H.ioore(t1, 0);
        t1[0] = t4;
        if (1 >= t3)
          return H.ioore(t2, 1);
        t4 = t2[1];
        if (1 >= t5)
          return H.ioore(t1, 1);
        t1[1] = t4;
        if (2 >= t3)
          return H.ioore(t2, 2);
        t2 = t2[2];
        if (2 >= t5)
          return H.ioore(t1, 2);
        t1[2] = t2;
      }
    },
    XYZColor$xyz$3: function(x, y, z) {
      var t1, t2;
      t1 = this.c;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t1[0] = x;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t1[1] = y;
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1[2] = z;
    },
    $isXYZColor: true,
    static: {XYZColor$xyz: function(x, y, z) {
        var t1 = new G.XYZColor(new Float32Array(3));
        t1.Spectrum$samples$2(3, 0);
        t1.XYZColor$xyz$3(x, y, z);
        return t1;
      }, XYZColor$from: function(color) {
        var t1 = new G.XYZColor(new Float32Array(3));
        t1.Spectrum$samples$2(3, 0);
        t1.XYZColor$from$1(color);
        return t1;
      }}
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableMixinWorkaround_forEach: function(iterable, f) {
    var t1;
    for (t1 = new H.ListIterator(iterable, iterable.length, 0, null); t1.moveNext$0();)
      f.call$1(t1._current);
  },
  IterableMixinWorkaround_removeWhereList: function(list, test) {
    var retained, $length, t1, i, element;
    retained = [];
    $length = list.length;
    for (t1 = $length, i = 0; i < $length; ++i) {
      if (i >= t1)
        return H.ioore(list, i);
      element = list[i];
      if (test.call$1(element) !== true)
        retained.push(element);
      t1 = list.length;
      if ($length !== t1)
        throw H.wrapException(P.ConcurrentModificationError$(list));
    }
    t1 = retained.length;
    if (t1 === $length)
      return;
    C.JSArray_methods.set$length(list, t1);
    for (i = 0; i < retained.length; ++i)
      C.JSArray_methods.$indexSet(list, i, retained[i]);
  },
  IterableMixinWorkaround_toStringIterable: function(iterable, leftDelimiter, rightDelimiter) {
    var result, i, t1, t2;
    for (i = 0; t1 = $.get$IterableMixinWorkaround__toStringList(), i < t1.length; ++i) {
      t1 = t1[i];
      t2 = iterable;
      if (t1 == null ? t2 == null : t1 === t2)
        return H.S(leftDelimiter) + "..." + H.S(rightDelimiter);
    }
    result = P.StringBuffer$("");
    try {
      $.get$IterableMixinWorkaround__toStringList().push(iterable);
      result.write$1(leftDelimiter);
      result.writeAll$2(iterable, ", ");
      result.write$1(rightDelimiter);
    } finally {
      t1 = $.get$IterableMixinWorkaround__toStringList();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    return result.get$_contents();
  },
  IterableMixinWorkaround_sortList: function(list, compare) {
    H.Sort__doSort(list, 0, list.length - 1, compare);
  },
  IterableMixinWorkaround__rangeCheck: function(list, start, end) {
    var t1 = J.getInterceptor$n(start);
    if (t1.$lt(start, 0) || t1.$gt(start, list.length))
      throw H.wrapException(P.RangeError$range(start, 0, list.length));
    t1 = J.getInterceptor$n(end);
    if (t1.$lt(end, start) || t1.$gt(end, list.length))
      throw H.wrapException(P.RangeError$range(end, start, list.length));
  },
  IterableMixinWorkaround_setRangeList: function(list, start, end, from, skipCount) {
    var $length, t1, otherStart, otherList;
    H.IterableMixinWorkaround__rangeCheck(list, start, end);
    $length = J.$sub$n(end, start);
    if (J.$eq($length, 0))
      return;
    if (J.$lt$n(skipCount, 0))
      throw H.wrapException(P.ArgumentError$(skipCount));
    t1 = J.getInterceptor(from);
    if (!!t1.$isList) {
      otherStart = skipCount;
      otherList = from;
    } else {
      otherList = t1.skip$1(from, skipCount).toList$1$growable(0, false);
      otherStart = 0;
    }
    if (J.$gt$n(J.$add$ns(otherStart, $length), J.get$length$asx(otherList)))
      throw H.wrapException(P.StateError$("Not enough elements"));
    H.Lists_copy(otherList, otherStart, list, start, $length);
  },
  IterableMixinWorkaround_fillRangeList: function(list, start, end, fillValue) {
    var i, t1;
    H.IterableMixinWorkaround__rangeCheck(list, start, end);
    for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
      C.JSArray_methods.$indexSet(list, i, fillValue);
  },
  Lists_copy: function(src, srcStart, dst, dstStart, count) {
    var t1, i, j, t2, t3;
    t1 = J.getInterceptor$n(srcStart);
    if (t1.$lt(srcStart, dstStart))
      for (i = J.$sub$n(t1.$add(srcStart, count), 1), j = J.$sub$n(J.$add$ns(dstStart, count), 1), t1 = J.getInterceptor$asx(src); t2 = J.getInterceptor$n(i), t2.$ge(i, srcStart); i = t2.$sub(i, 1), j = J.$sub$n(j, 1))
        C.JSArray_methods.$indexSet(dst, j, t1.$index(src, i));
    else
      for (t2 = J.getInterceptor$asx(src), j = dstStart, i = srcStart; t3 = J.getInterceptor$n(i), t3.$lt(i, t1.$add(srcStart, count)); i = t3.$add(i, 1), j = J.$add$ns(j, 1))
        C.JSArray_methods.$indexSet(dst, j, t2.$index(src, i));
  },
  Lists_lastIndexOf: function(a, element, startIndex) {
    var t1, i;
    if (typeof startIndex !== "number")
      return startIndex.$lt();
    if (startIndex < 0)
      return -1;
    t1 = a.length;
    if (startIndex >= t1)
      startIndex = t1 - 1;
    for (i = startIndex; i >= 0; --i) {
      if (i >= a.length)
        return H.ioore(a, i);
      if (J.$eq(a[i], element))
        return i;
    }
    return -1;
  },
  Sort__doSort: function(a, left, right, compare) {
    if (right - left <= 32)
      H.Sort__insertionSort(a, left, right, compare);
    else
      H.Sort__dualPivotQuicksort(a, left, right, compare);
  },
  Sort__insertionSort: function(a, left, right, compare) {
    var i, t1, el, j, j0;
    for (i = left + 1, t1 = J.getInterceptor$asx(a); i <= right; ++i) {
      el = t1.$index(a, i);
      j = i;
      while (true) {
        if (!(j > left && J.$gt$n(compare.call$2(t1.$index(a, j - 1), el), 0)))
          break;
        j0 = j - 1;
        t1.$indexSet(a, j, t1.$index(a, j0));
        j = j0;
      }
      t1.$indexSet(a, j, el);
    }
  },
  Sort__dualPivotQuicksort: function(a, left, right, compare) {
    var sixth, index1, index5, index3, index2, index4, t1, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, t2, great0, less0, pivots_are_equal;
    sixth = C.JSInt_methods._tdivFast$1(right - left + 1, 6);
    index1 = left + sixth;
    index5 = right - sixth;
    index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
    index2 = index3 - sixth;
    index4 = index3 + sixth;
    t1 = J.getInterceptor$asx(a);
    el1 = t1.$index(a, index1);
    el2 = t1.$index(a, index2);
    el3 = t1.$index(a, index3);
    el4 = t1.$index(a, index4);
    el5 = t1.$index(a, index5);
    if (J.$gt$n(compare.call$2(el1, el2), 0)) {
      t0 = el2;
      el2 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el3), 0)) {
      t0 = el3;
      el3 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el4), 0)) {
      t0 = el4;
      el4 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el3, el4), 0)) {
      t0 = el4;
      el4 = el3;
      el3 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el5), 0)) {
      t0 = el5;
      el5 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    t1.$indexSet(a, index1, el1);
    t1.$indexSet(a, index3, el3);
    t1.$indexSet(a, index5, el5);
    t1.$indexSet(a, index2, t1.$index(a, left));
    t1.$indexSet(a, index4, t1.$index(a, right));
    less = left + 1;
    great = right - 1;
    if (J.$eq(compare.call$2(el2, el4), 0)) {
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        comp = compare.call$2(ak, el2);
        t2 = J.getInterceptor(comp);
        if (t2.$eq(comp, 0))
          continue;
        if (t2.$lt(comp, 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else
          for (; true;) {
            comp = compare.call$2(t1.$index(a, great), el2);
            t2 = J.getInterceptor$n(comp);
            if (t2.$gt(comp, 0)) {
              --great;
              continue;
            } else {
              great0 = great - 1;
              if (t2.$lt(comp, 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
                break;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                break;
              }
            }
          }
      }
      pivots_are_equal = true;
    } else {
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        if (J.$lt$n(compare.call$2(ak, el2), 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else if (J.$gt$n(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$gt$n(compare.call$2(t1.$index(a, great), el4), 0)) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              great0 = great - 1;
              if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      pivots_are_equal = false;
    }
    t2 = less - 1;
    t1.$indexSet(a, left, t1.$index(a, t2));
    t1.$indexSet(a, t2, el2);
    t2 = great + 1;
    t1.$indexSet(a, right, t1.$index(a, t2));
    t1.$indexSet(a, t2, el4);
    H.Sort__doSort(a, left, less - 2, compare);
    H.Sort__doSort(a, great + 2, right, compare);
    if (pivots_are_equal)
      return;
    if (less < index1 && great > index5) {
      for (; J.$eq(compare.call$2(t1.$index(a, less), el2), 0);)
        ++less;
      for (; J.$eq(compare.call$2(t1.$index(a, great), el4), 0);)
        --great;
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        if (J.$eq(compare.call$2(ak, el2), 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else if (J.$eq(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$eq(compare.call$2(t1.$index(a, great), el4), 0)) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              great0 = great - 1;
              if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      H.Sort__doSort(a, less, great, compare);
    } else
      H.Sort__doSort(a, less, great, compare);
  },
  Symbol_getName: function(symbol) {
    return symbol.get$_name();
  },
  ListIterable: {
    "^": "IterableBase;",
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$iterator: function(_) {
      return new H.ListIterator(this, this.get$length(this), 0, null);
    },
    forEach$1: function(_, action) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        action.call$1(this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$first: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(P.StateError$("No elements"));
      return this.elementAt$1(0, 0);
    },
    skip$1: function(_, count) {
      return H.SubListIterable$(this, count, null, null);
    },
    toList$1$growable: function(_, growable) {
      var result, i, t1;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else
        result = H.setRuntimeTypeInfo(Array(this.get$length(this)), [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
      for (i = 0; i < this.get$length(this); ++i) {
        t1 = this.elementAt$1(0, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    $isEfficientLength: true
  },
  SubListIterable: {
    "^": "ListIterable;_iterable,__internal$_start,_endOrLength",
    get$_endIndex: function() {
      var $length = J.get$length$asx(this._iterable);
      return $length;
    },
    get$_startIndex: function() {
      var $length, t1;
      $length = J.get$length$asx(this._iterable);
      t1 = this.__internal$_start;
      if (J.$gt$n(t1, $length))
        return $length;
      return t1;
    },
    get$length: function(_) {
      var $length, t1;
      $length = J.get$length$asx(this._iterable);
      t1 = this.__internal$_start;
      if (J.$ge$n(t1, $length))
        return 0;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return $length - t1;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    elementAt$1: function(_, index) {
      var realIndex = J.$add$ns(this.get$_startIndex(), index);
      if (J.$lt$n(index, 0) || J.$ge$n(realIndex, this.get$_endIndex()))
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this)));
      return J.elementAt$1$ax(this._iterable, realIndex);
    },
    skip$1: function(_, count) {
      if (J.$lt$n(count, 0))
        throw H.wrapException(P.RangeError$value(count));
      return H.SubListIterable$(this._iterable, J.$add$ns(this.__internal$_start, count), this._endOrLength, null);
    },
    SubListIterable$3: function(_iterable, _start, _endOrLength, $E) {
      var t1 = this.__internal$_start;
      if (J.$lt$n(t1, 0))
        throw H.wrapException(P.RangeError$value(t1));
    },
    static: {SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
        var t1 = H.setRuntimeTypeInfo(new H.SubListIterable(_iterable, _start, _endOrLength), [$E]);
        t1.SubListIterable$3(_iterable, _start, _endOrLength, $E);
        return t1;
      }}
  },
  ListIterator: {
    "^": "Object;_iterable,_length,_index,_current",
    get$current: function() {
      return this._current;
    },
    moveNext$0: function() {
      var t1, t2, $length, t3;
      t1 = this._iterable;
      t2 = J.getInterceptor$asx(t1);
      $length = t2.get$length(t1);
      if (this._length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = this._index;
      if (t3 >= $length) {
        this._current = null;
        return false;
      }
      this._current = t2.elementAt$1(t1, t3);
      ++this._index;
      return true;
    }
  },
  MappedIterable: {
    "^": "IterableBase;_iterable,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$iterator: function(_) {
      var t1 = new H.MappedIterator(null, J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      return J.get$length$asx(this._iterable);
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this._iterable);
    },
    get$first: function(_) {
      return this._f$1(J.get$first$ax(this._iterable));
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    static: {MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
        if (!!J.getInterceptor(iterable).$isEfficientLength)
          return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(iterable, $function), [$S, $T]);
        return H.setRuntimeTypeInfo(new H.MappedIterable(iterable, $function), [$S, $T]);
      }}
  },
  EfficientLengthMappedIterable: {
    "^": "MappedIterable;_iterable,_f",
    $isEfficientLength: true
  },
  MappedIterator: {
    "^": "Iterator;_current,_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      var t1 = this._iterator;
      if (t1.moveNext$0()) {
        this._current = this._f$1(t1.get$current());
        return true;
      }
      this._current = null;
      return false;
    },
    get$current: function() {
      return this._current;
    }
  },
  WhereIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = new H.WhereIterator(J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    }
  },
  WhereIterator: {
    "^": "Iterator;_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      for (var t1 = this._iterator; t1.moveNext$0();)
        if (this._f$1(t1.get$current()) === true)
          return true;
      return false;
    },
    get$current: function() {
      return this._iterator.get$current();
    }
  },
  SkipIterable: {
    "^": "IterableBase;_iterable,_skipCount",
    skip$1: function(_, n) {
      if (typeof n !== "number" || Math.floor(n) !== n || n < 0)
        throw H.wrapException(P.RangeError$value(n));
      return H.SkipIterable_SkipIterable(this._iterable, J.$add$ns(this._skipCount, n), H.getTypeArgumentByIndex(this, 0));
    },
    get$iterator: function(_) {
      var t1 = this._iterable;
      t1 = new H.SkipIterator(t1.get$iterator(t1), this._skipCount);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    SkipIterable$_$2: function(_iterable, _skipCount, $E) {
      var t1 = this._skipCount;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1 || J.$lt$n(t1, 0))
        throw H.wrapException(P.RangeError$(t1));
    },
    static: {SkipIterable_SkipIterable: function(iterable, skipCount, $E) {
        var t1;
        if (!!iterable.$isEfficientLength) {
          t1 = H.setRuntimeTypeInfo(new H.EfficientLengthSkipIterable(iterable, skipCount), [$E]);
          t1.SkipIterable$_$2(iterable, skipCount, $E);
          return t1;
        }
        return H.SkipIterable$_(iterable, skipCount, $E);
      }, SkipIterable$_: function(_iterable, _skipCount, $E) {
        var t1 = H.setRuntimeTypeInfo(new H.SkipIterable(_iterable, _skipCount), [$E]);
        t1.SkipIterable$_$2(_iterable, _skipCount, $E);
        return t1;
      }}
  },
  EfficientLengthSkipIterable: {
    "^": "SkipIterable;_iterable,_skipCount",
    get$length: function(_) {
      var t1, $length;
      t1 = this._iterable;
      $length = J.$sub$n(t1.get$length(t1), this._skipCount);
      if (J.$ge$n($length, 0))
        return $length;
      return 0;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    $isEfficientLength: true
  },
  SkipIterator: {
    "^": "Iterator;_iterator,_skipCount",
    moveNext$0: function() {
      var t1, i, t2;
      t1 = this._iterator;
      i = 0;
      while (true) {
        t2 = this._skipCount;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        t1.moveNext$0();
        ++i;
      }
      this._skipCount = 0;
      return t1.moveNext$0();
    },
    get$current: function() {
      return this._iterator.get$current();
    }
  },
  FixedLengthListMixin: {
    "^": "Object;",
    set$length: function(receiver, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    }
  },
  UnmodifiableListMixin: {
    "^": "Object;",
    $indexSet: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of an unmodifiable list"));
    },
    add$1: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    fillRange$3: function(_, start, end, fillValue) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  UnmodifiableListBase: {
    "^": "ListBase+UnmodifiableListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  }
}],
["dart._js_names", "dart:_js_names", , H, {
  "^": "",
  extractKeys: function(victim) {
    var t1 = H.setRuntimeTypeInfo((function(victim, hasOwnProperty) {
  var result = [];
  for (var key in victim) {
    if (hasOwnProperty.call(victim, key)) result.push(key);
  }
  return result;
})(victim, Object.prototype.hasOwnProperty), [null]);
    t1.fixed$length = init;
    return t1;
  }
}],
["dart.async", "dart:async", , P, {
  "^": "",
  _registerErrorHandler: function(errorHandler, zone) {
    var t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(t1, [t1, t1])._isTest$1(errorHandler);
    if (t1) {
      zone.toString;
      return errorHandler;
    } else {
      zone.toString;
      return errorHandler;
    }
  },
  Future_wait: function(futures, eagerError) {
    var t1, t2, t3, values, completer;
    t1 = {};
    t1.completer_0 = null;
    t1.values_1 = null;
    t1.remaining_2 = 0;
    t1.error_3 = null;
    t1.stackTrace_4 = null;
    t2 = new P.Future_wait_handleError(t1, eagerError);
    for (t3 = new H.ListIterator(futures, futures.length, 0, null); t3.moveNext$0();)
      t3._current.then$2$onError(new P.Future_wait_closure(t1, eagerError, t1.remaining_2++), t2);
    t2 = t1.remaining_2;
    if (t2 === 0)
      return P._Future$immediate(C.List_empty, null);
    values = Array(t2);
    values.fixed$length = init;
    t1.values_1 = values;
    t2 = J.JSArray;
    completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t2)), [t2]);
    t1.completer_0 = completer;
    return completer.future;
  },
  _asyncRunCallbackLoop: function() {
    var entry = $._nextCallback;
    for (; entry != null;) {
      entry.callback$0();
      entry = entry.next;
      $._nextCallback = entry;
    }
    $._lastCallback = null;
  },
  _asyncRunCallback: [function() {
    var e, s, exception, t1;
    try {
      P._asyncRunCallbackLoop();
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      if (!!J.getInterceptor(e).$isError)
        P.print("microtask error " + H.S(e.get$stackTrace()));
      else
        P.print("microtask error " + H.S(e));
      P.print("microtask error stack trace: " + H.S(s));
      P._createTimer(C.Duration_0, P._asyncRunCallback$closure());
      $._nextCallback = $._nextCallback.get$next();
      throw exception;
    }

  }, "call$0", "_asyncRunCallback$closure", 0, 0, 10],
  _scheduleAsyncCallback: function(callback) {
    var t1, t2;
    t1 = $._lastCallback;
    if (t1 == null) {
      t1 = new P._AsyncCallbackEntry(callback, null);
      $._lastCallback = t1;
      $._nextCallback = t1;
      P._createTimer(C.Duration_0, P._asyncRunCallback$closure());
    } else {
      t2 = new P._AsyncCallbackEntry(callback, null);
      t1.next = t2;
      $._lastCallback = t2;
    }
  },
  scheduleMicrotask: function(callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone) {
      t1.toString;
      P._rootScheduleMicrotask(t1, null, t1, callback);
      return;
    }
    P._rootScheduleMicrotask(t1, null, t1, t1.bindCallback$2$runGuarded(callback, true));
  },
  StreamController_StreamController: function(onCancel, onListen, onPause, onResume, sync, $T) {
    return sync ? H.setRuntimeTypeInfo(new P._SyncStreamController(onListen, onPause, onResume, onCancel, null, 0, null), [$T]) : H.setRuntimeTypeInfo(new P._AsyncStreamController(onListen, onPause, onResume, onCancel, null, 0, null), [$T]);
  },
  _runGuarded: function(notificationHandler) {
    var result, e, s, exception, t1;
    if (notificationHandler == null)
      return;
    try {
      result = notificationHandler.call$0();
      if (!!J.getInterceptor(result).$isFuture)
        return result;
      return;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      t1 = $.Zone__current;
      t1.toString;
      P._rootHandleUncaughtError(t1, null, t1, e, s);
    }

  },
  _nullDataHandler: [function(value) {
  }, "call$1", "_nullDataHandler$closure", 2, 0, 11],
  _nullErrorHandler: [function(error, stackTrace) {
    var t1 = $.Zone__current;
    t1.toString;
    P._rootHandleUncaughtError(t1, null, t1, error, stackTrace);
  }, function(error) {
    return P._nullErrorHandler(error, null);
  }, null, "call$2", "call$1", "_nullErrorHandler$closure", 2, 2, 12, 13],
  _nullDoneHandler: [function() {
  }, "call$0", "_nullDoneHandler$closure", 0, 0, 10],
  _runUserCode: function(userCode, onSuccess, onError) {
    var e, s, exception, t1;
    try {
      onSuccess.call$1(userCode.call$0());
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      onError.call$2(e, s);
    }

  },
  _cancelAndError: function(subscription, future, error, stackTrace) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
    else
      future._completeError$2(error, stackTrace);
  },
  _cancelAndErrorClosure: function(subscription, future) {
    return new P._cancelAndErrorClosure_closure(subscription, future);
  },
  _cancelAndValue: function(subscription, future, value) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
    else
      future._complete$1(value);
  },
  Timer_Timer: function(duration, callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone) {
      t1.toString;
      return P._rootCreateTimer(t1, null, t1, duration, callback);
    }
    return P._rootCreateTimer(t1, null, t1, duration, t1.bindCallback$2$runGuarded(callback, true));
  },
  _createTimer: function(duration, callback) {
    var milliseconds = C.JSNumber_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Zone__enter: function(zone) {
    var previous = $.Zone__current;
    $.Zone__current = zone;
    return previous;
  },
  _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
    P._rootRun($self, null, $self, new P._rootHandleUncaughtError_closure(error, stackTrace));
  },
  _rootRun: function($self, $parent, zone, f) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$0();
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$0();
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunUnary: function($self, $parent, zone, f, arg) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$1(arg);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$1(arg);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$2(arg1, arg2);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$2(arg1, arg2);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootScheduleMicrotask: function($self, $parent, zone, f) {
    P._scheduleAsyncCallback(C.C__RootZone !== zone ? zone.bindCallback$1(f) : f);
  },
  _rootCreateTimer: function($self, $parent, zone, duration, callback) {
    return P._createTimer(duration, C.C__RootZone !== zone ? zone.bindCallback$1(callback) : callback);
  },
  _AsyncError: {
    "^": "Object;error>,stackTrace<",
    $isError: true
  },
  Future: {
    "^": "Object;",
    $isFuture: true
  },
  Future_wait_handleError: {
    "^": "Closure:87;box_0,eagerError_1",
    call$2: function(theError, theStackTrace) {
      var t1, t2, t3;
      t1 = this.box_0;
      t2 = t1.values_1;
      t1.values_1 = null;
      t3 = --t1.remaining_2;
      if (t2 != null)
        if (t3 === 0 || this.eagerError_1)
          t1.completer_0.completeError$2(theError, theStackTrace);
        else {
          t1.error_3 = theError;
          t1.stackTrace_4 = theStackTrace;
        }
      else if (t3 === 0 && !this.eagerError_1)
        t1.completer_0.completeError$2(t1.error_3, t1.stackTrace_4);
    }
  },
  Future_wait_closure: {
    "^": "Closure:103;box_0,eagerError_2,pos_3",
    call$1: function(value) {
      var t1, t2, t3, t4;
      t1 = this.box_0;
      t2 = --t1.remaining_2;
      t3 = t1.values_1;
      if (t3 != null) {
        t4 = this.pos_3;
        if (t4 < 0 || t4 >= t3.length)
          return H.ioore(t3, t4);
        t3[t4] = value;
        if (t2 === 0) {
          t1 = t1.completer_0.future;
          if (t1._state !== 0)
            H.throwExpression(P.StateError$("Future already completed"));
          t1._asyncComplete$1(t3);
        }
      } else if (t2 === 0 && !this.eagerError_2)
        t1.completer_0.completeError$2(t1.error_3, t1.stackTrace_4);
    }
  },
  _Completer: {
    "^": "Object;"
  },
  _AsyncCompleter: {
    "^": "_Completer;future",
    completeError$2: [function(error, stackTrace) {
      var t1;
      if (error == null)
        throw H.wrapException(P.ArgumentError$("Error must not be null"));
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncCompleteError$2(error, stackTrace);
    }, function(error) {
      return this.completeError$2(error, null);
    }, "completeError$1", "call$2", "call$1", "get$completeError", 2, 2, 104, 13]
  },
  _Future: {
    "^": "Object;_state,_zone<,_resultOrListeners,_nextListener<,_onValueCallback,_errorTestCallback,_onErrorCallback,_whenCompleteActionCallback",
    get$_isComplete: function() {
      return this._state >= 4;
    },
    get$_hasValue: function() {
      return this._state === 4;
    },
    get$_hasError: function() {
      return this._state === 8;
    },
    set$_isChained: function(value) {
      if (value)
        this._state = 2;
      else
        this._state = 0;
    },
    then$2$onError: function(f, onError) {
      var t1, result;
      t1 = $.Zone__current;
      t1.toString;
      result = H.setRuntimeTypeInfo(new P._Future(0, t1, null, null, f, null, P._registerErrorHandler(onError, t1), null), [null]);
      this._addListener$1(result);
      return result;
    },
    then$1: function(f) {
      return this.then$2$onError(f, null);
    },
    catchError$2$test: function(onError, test) {
      var t1, t2, result;
      t1 = $.Zone__current;
      t2 = P._registerErrorHandler(onError, t1);
      t1.toString;
      result = H.setRuntimeTypeInfo(new P._Future(0, t1, null, null, null, test, t2, null), [null]);
      this._addListener$1(result);
      return result;
    },
    catchError$1: function(onError) {
      return this.catchError$2$test(onError, null);
    },
    whenComplete$1: function(action) {
      var t1, result;
      t1 = $.Zone__current;
      t1.toString;
      result = new P._Future(0, t1, null, null, null, null, null, action);
      result.$builtinTypeInfo = this.$builtinTypeInfo;
      this._addListener$1(result);
      return result;
    },
    get$_value: function() {
      return this._resultOrListeners;
    },
    get$_error: function() {
      return this._resultOrListeners;
    },
    _setValue$1: function(value) {
      this._state = 4;
      this._resultOrListeners = value;
    },
    _setError$2: function(error, stackTrace) {
      this._state = 8;
      this._resultOrListeners = new P._AsyncError(error, stackTrace);
    },
    _addListener$1: function(listener) {
      var t1;
      if (this._state >= 4) {
        t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(t1, null, t1, new P._Future__addListener_closure(this, listener));
      } else {
        listener._nextListener = this._resultOrListeners;
        this._resultOrListeners = listener;
      }
    },
    _removeListeners$0: function() {
      var current, prev, next;
      current = this._resultOrListeners;
      this._resultOrListeners = null;
      for (prev = null; current != null; prev = current, current = next) {
        next = current.get$_nextListener();
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1: function(value) {
      var t1, listeners;
      t1 = J.getInterceptor(value);
      if (!!t1.$isFuture)
        if (!!t1.$is_Future)
          P._Future__chainCoreFuture(value, this);
        else
          P._Future__chainForeignFuture(value, this);
      else {
        listeners = this._removeListeners$0();
        this._setValue$1(value);
        P._Future__propagateToListeners(this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners = this._removeListeners$0();
      this._setValue$1(value);
      P._Future__propagateToListeners(this, listeners);
    },
    _completeError$2: [function(error, stackTrace) {
      var listeners = this._removeListeners$0();
      this._setError$2(error, stackTrace);
      P._Future__propagateToListeners(this, listeners);
    }, function(error) {
      return this._completeError$2(error, null);
    }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 12, 13],
    _asyncComplete$1: function(value) {
      var t1;
      if (value == null)
        ;
      else {
        t1 = J.getInterceptor(value);
        if (!!t1.$isFuture) {
          if (!!t1.$is_Future) {
            t1 = value._state;
            if (t1 >= 4 && t1 === 8) {
              if (this._state !== 0)
                H.throwExpression(P.StateError$("Future already completed"));
              this._state = 1;
              t1 = this._zone;
              t1.toString;
              P._rootScheduleMicrotask(t1, null, t1, new P._Future__asyncComplete_closure(this, value));
            } else
              P._Future__chainCoreFuture(value, this);
          } else
            P._Future__chainForeignFuture(value, this);
          return;
        }
      }
      if (this._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      this._state = 1;
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(t1, null, t1, new P._Future__asyncComplete_closure0(this, value));
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      var t1;
      if (this._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      this._state = 1;
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(t1, null, t1, new P._Future__asyncCompleteError_closure(this, error, stackTrace));
    },
    _async$_Future$immediate$1: function(value, $T) {
      this._asyncComplete$1(value);
    },
    $is_Future: true,
    $isFuture: true,
    static: {"^": "_Future__INCOMPLETE,_Future__PENDING_COMPLETE,_Future__CHAINED,_Future__VALUE,_Future__ERROR", _Future$: function($T) {
        return H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null, null, null, null, null, null), [$T]);
      }, _Future$immediate: function(value, $T) {
        var t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null, null, null, null, null, null), [$T]);
        t1._async$_Future$immediate$1(value, $T);
        return t1;
      }, _Future__chainForeignFuture: function(source, target) {
        target._state = 2;
        source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
      }, _Future__chainCoreFuture: function(source, target) {
        target._state = 2;
        if (source._state >= 4)
          P._Future__propagateToListeners(source, target);
        else
          source._addListener$1(target);
      }, _Future__propagateMultipleListeners: function(source, listeners) {
        var listeners0;
        do {
          listeners0 = listeners.get$_nextListener();
          listeners._nextListener = null;
          P._Future__propagateToListeners(source, listeners);
          if (listeners0 != null) {
            listeners = listeners0;
            continue;
          } else
            break;
        } while (true);
      }, _Future__propagateToListeners: function(source, listeners) {
        var t1, t2, t3, hasError, asyncError, t4, sourceValue, t5, zone, oldZone, chainSource, listeners0;
        t1 = {};
        t1.source_4 = source;
        for (t2 = source; true;) {
          t3 = {};
          if (!t2.get$_isComplete())
            return;
          hasError = t1.source_4.get$_hasError();
          if (hasError && listeners == null) {
            t2 = t1.source_4;
            asyncError = t2.get$_error();
            t2 = t2._zone;
            t3 = J.get$error$x(asyncError);
            t4 = asyncError.get$stackTrace();
            t2.toString;
            P._rootHandleUncaughtError(t2, null, t2, t3, t4);
            return;
          }
          if (listeners == null)
            return;
          if (listeners._nextListener != null) {
            P._Future__propagateMultipleListeners(t1.source_4, listeners);
            return;
          }
          t3.listenerHasValue_1 = true;
          sourceValue = t1.source_4.get$_hasValue() ? t1.source_4.get$_value() : null;
          t3.listenerValueOrError_2 = sourceValue;
          t3.isPropagationAborted_3 = false;
          t2 = !hasError;
          if (t2) {
            t4 = listeners._state === 2;
            if ((t4 ? null : listeners._onValueCallback) == null) {
              t5 = (t4 ? null : listeners._whenCompleteActionCallback) != null;
              t4 = t5;
            } else
              t4 = true;
          } else
            t4 = true;
          if (t4) {
            zone = listeners._zone;
            if (hasError) {
              t4 = t1.source_4.get$_zone();
              t4.toString;
              zone.toString;
              t4 = zone == null ? t4 != null : zone !== t4;
            } else
              t4 = false;
            if (t4) {
              t2 = t1.source_4;
              asyncError = t2.get$_error();
              t2 = t2._zone;
              t3 = J.get$error$x(asyncError);
              t4 = asyncError.get$stackTrace();
              t2.toString;
              P._rootHandleUncaughtError(t2, null, t2, t3, t4);
              return;
            }
            oldZone = $.Zone__current;
            if (oldZone == null ? zone != null : oldZone !== zone)
              $.Zone__current = zone;
            else
              oldZone = null;
            if (t2) {
              if ((listeners._state === 2 ? null : listeners._onValueCallback) != null)
                t3.listenerHasValue_1 = new P._Future__propagateToListeners_handleValueCallback(t3, listeners, sourceValue, zone).call$0();
            } else
              new P._Future__propagateToListeners_handleError(t1, t3, listeners, zone).call$0();
            if ((listeners._state === 2 ? null : listeners._whenCompleteActionCallback) != null)
              new P._Future__propagateToListeners_handleWhenCompleteCallback(t1, t3, hasError, listeners, zone).call$0();
            if (oldZone != null)
              $.Zone__current = oldZone;
            if (t3.isPropagationAborted_3)
              return;
            if (t3.listenerHasValue_1 === true) {
              t2 = t3.listenerValueOrError_2;
              t2 = (sourceValue == null ? t2 != null : sourceValue !== t2) && !!J.getInterceptor(t2).$isFuture;
            } else
              t2 = false;
            if (t2) {
              chainSource = t3.listenerValueOrError_2;
              if (!!J.getInterceptor(chainSource).$is_Future)
                if (chainSource._state >= 4) {
                  listeners._state = 2;
                  t1.source_4 = chainSource;
                  t2 = chainSource;
                  continue;
                } else
                  P._Future__chainCoreFuture(chainSource, listeners);
              else
                P._Future__chainForeignFuture(chainSource, listeners);
              return;
            }
          }
          if (t3.listenerHasValue_1 === true) {
            listeners0 = listeners._removeListeners$0();
            t2 = t3.listenerValueOrError_2;
            listeners._state = 4;
            listeners._resultOrListeners = t2;
          } else {
            listeners0 = listeners._removeListeners$0();
            asyncError = t3.listenerValueOrError_2;
            t2 = J.get$error$x(asyncError);
            t3 = asyncError.get$stackTrace();
            listeners._state = 8;
            listeners._resultOrListeners = new P._AsyncError(t2, t3);
          }
          t1.source_4 = listeners;
          t2 = listeners;
          listeners = listeners0;
        }
      }}
  },
  _Future__addListener_closure: {
    "^": "Closure:86;this_0,listener_1",
    call$0: function() {
      P._Future__propagateToListeners(this.this_0, this.listener_1);
    }
  },
  _Future__chainForeignFuture_closure: {
    "^": "Closure:88;target_0",
    call$1: function(value) {
      this.target_0._completeWithValue$1(value);
    }
  },
  _Future__chainForeignFuture_closure0: {
    "^": "Closure:105;target_1",
    call$2: function(error, stackTrace) {
      this.target_1._completeError$2(error, stackTrace);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    }
  },
  _Future__asyncComplete_closure: {
    "^": "Closure:86;this_0,coreFuture_1",
    call$0: function() {
      P._Future__chainCoreFuture(this.coreFuture_1, this.this_0);
    }
  },
  _Future__asyncComplete_closure0: {
    "^": "Closure:86;this_2,value_3",
    call$0: function() {
      this.this_2._completeWithValue$1(this.value_3);
    }
  },
  _Future__asyncCompleteError_closure: {
    "^": "Closure:86;this_0,error_1,stackTrace_2",
    call$0: function() {
      this.this_0._completeError$2(this.error_1, this.stackTrace_2);
    }
  },
  _Future__propagateToListeners_handleValueCallback: {
    "^": "Closure:106;box_1,listener_3,sourceValue_4,zone_5",
    call$0: function() {
      var e, s, t1, t2, exception;
      try {
        t1 = this.zone_5;
        t2 = this.listener_3;
        t2 = t2._state === 2 ? null : t2._onValueCallback;
        t1.toString;
        this.box_1.listenerValueOrError_2 = P._rootRunUnary(t1, null, t1, t2, this.sourceValue_4);
        return true;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.box_1.listenerValueOrError_2 = new P._AsyncError(e, s);
        return false;
      }

    }
  },
  _Future__propagateToListeners_handleError: {
    "^": "Closure:10;box_2,box_1,listener_6,zone_7",
    call$0: function() {
      var asyncError, test, matchesTest, e, s, errorCallback, e0, s0, t1, t2, t3, exception, listenerValueOrError, t4;
      asyncError = this.box_2.source_4.get$_error();
      t1 = this.listener_6;
      test = t1._state === 2 ? null : t1._errorTestCallback;
      matchesTest = true;
      if (test != null)
        try {
          t2 = this.zone_7;
          t3 = J.get$error$x(asyncError);
          t2.toString;
          matchesTest = P._rootRunUnary(t2, null, t2, test, t3);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P._AsyncError(e, s);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

      errorCallback = t1._state === 2 ? null : t1._onErrorCallback;
      if (matchesTest === true && errorCallback != null) {
        try {
          t1 = errorCallback;
          t2 = H.getDynamicRuntimeType();
          t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
          t3 = this.zone_7;
          t4 = this.box_1;
          if (t2) {
            t1 = J.get$error$x(asyncError);
            t2 = asyncError.get$stackTrace();
            t3.toString;
            t4.listenerValueOrError_2 = P._rootRunBinary(t3, null, t3, errorCallback, t1, t2);
          } else {
            t1 = J.get$error$x(asyncError);
            t3.toString;
            t4.listenerValueOrError_2 = P._rootRunUnary(t3, null, t3, errorCallback, t1);
          }
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e0 = t1;
          s0 = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e0;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P._AsyncError(e0, s0);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

        this.box_1.listenerHasValue_1 = true;
      } else {
        t1 = this.box_1;
        t1.listenerValueOrError_2 = asyncError;
        t1.listenerHasValue_1 = false;
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback: {
    "^": "Closure:10;box_2,box_1,hasError_8,listener_9,zone_10",
    call$0: function() {
      var t1, e, s, t2, t3, exception;
      t1 = {};
      t1.completeResult_0 = null;
      try {
        t2 = this.zone_10;
        t3 = this.listener_9;
        t3 = t3._state === 2 ? null : t3._whenCompleteActionCallback;
        t2.toString;
        t1.completeResult_0 = P._rootRun(t2, null, t2, t3);
      } catch (exception) {
        t2 = H.unwrapException(exception);
        e = t2;
        s = new H._StackTrace(exception, null);
        if (this.hasError_8) {
          t2 = J.get$error$x(this.box_2.source_4.get$_error());
          t3 = e;
          t3 = t2 == null ? t3 == null : t2 === t3;
          t2 = t3;
        } else
          t2 = false;
        t3 = this.box_1;
        if (t2)
          t3.listenerValueOrError_2 = this.box_2.source_4.get$_error();
        else
          t3.listenerValueOrError_2 = new P._AsyncError(e, s);
        t3.listenerHasValue_1 = false;
      }

      if (!!J.getInterceptor(t1.completeResult_0).$isFuture) {
        t2 = this.listener_9;
        t2.set$_isChained(true);
        this.box_1.isPropagationAborted_3 = true;
        t1.completeResult_0.then$2$onError(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(this.box_2, t2), new P._Future__propagateToListeners_handleWhenCompleteCallback_closure0(t1, t2));
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
    "^": "Closure:88;box_2,listener_11",
    call$1: function(ignored) {
      P._Future__propagateToListeners(this.box_2.source_4, this.listener_11);
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0: {
    "^": "Closure:105;box_0,listener_12",
    call$2: function(error, stackTrace) {
      var t1, completeResult;
      t1 = this.box_0;
      if (!J.getInterceptor(t1.completeResult_0).$is_Future) {
        completeResult = P._Future$(null);
        t1.completeResult_0 = completeResult;
        completeResult._setError$2(error, stackTrace);
      }
      P._Future__propagateToListeners(t1.completeResult_0, this.listener_12);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    }
  },
  _AsyncCallbackEntry: {
    "^": "Object;callback,next@",
    callback$0: function() {
      return this.callback.call$0();
    }
  },
  Stream: {
    "^": "Object;",
    forEach$1: function(_, action) {
      var t1, future;
      t1 = {};
      future = P._Future$(null);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, action, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
      return future;
    },
    get$length: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(J.JSInt);
      t1.count_0 = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(J.JSBool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
      return future;
    },
    skip$1: function(_, count) {
      var t1 = H.setRuntimeTypeInfo(new P._SkipStream(count, this), [null]);
      t1._SkipStream$2(this, count, null);
      return t1;
    },
    get$first: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(H.getRuntimeTypeArgument(this, "Stream", 0));
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_first_closure(t1, this, future), true, new P.Stream_first_closure0(future), future.get$_completeError());
      return future;
    }
  },
  Stream_forEach_closure: {
    "^": "Closure;box_0,this_1,action_2,future_3",
    call$1: function(element) {
      P._runUserCode(new P.Stream_forEach__closure(this.action_2, element), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this.box_0.subscription_0, this.future_3));
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_forEach__closure: {
    "^": "Closure:86;action_4,element_5",
    call$0: function() {
      return this.action_4.call$1(this.element_5);
    }
  },
  Stream_forEach__closure0: {
    "^": "Closure:88;",
    call$1: function(_) {
    }
  },
  Stream_forEach_closure0: {
    "^": "Closure:86;future_6",
    call$0: function() {
      this.future_6._complete$1(null);
    }
  },
  Stream_length_closure: {
    "^": "Closure:88;box_0",
    call$1: function(_) {
      ++this.box_0.count_0;
    }
  },
  Stream_length_closure0: {
    "^": "Closure:86;box_0,future_1",
    call$0: function() {
      this.future_1._complete$1(this.box_0.count_0);
    }
  },
  Stream_isEmpty_closure: {
    "^": "Closure:88;box_0,future_1",
    call$1: function(_) {
      P._cancelAndValue(this.box_0.subscription_0, this.future_1, false);
    }
  },
  Stream_isEmpty_closure0: {
    "^": "Closure:86;future_2",
    call$0: function() {
      this.future_2._complete$1(true);
    }
  },
  Stream_first_closure: {
    "^": "Closure;box_0,this_1,future_2",
    call$1: function(value) {
      P._cancelAndValue(this.box_0.subscription_0, this.future_2, value);
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_first_closure0: {
    "^": "Closure:86;future_3",
    call$0: function() {
      this.future_3._completeError$1(new P.StateError("No elements"));
    }
  },
  StreamSubscription: {
    "^": "Object;"
  },
  _StreamController: {
    "^": "Object;",
    get$_pendingEvents: function() {
      if ((this._state & 8) === 0)
        return this._varData;
      return this._varData.get$varData();
    },
    _ensurePendingEvents$0: function() {
      if ((this._state & 8) === 0) {
        var t1 = this._varData;
        if (t1 == null) {
          t1 = new P._StreamImplEvents(null, null, 0);
          this._varData = t1;
        }
        return t1;
      }
      t1 = this._varData.get$varData();
      return t1;
    },
    get$_subscription: function() {
      if ((this._state & 8) !== 0)
        return this._varData.get$varData();
      return this._varData;
    },
    _badEventState$0: function() {
      if ((this._state & 4) !== 0)
        return new P.StateError("Cannot add event after closing");
      return new P.StateError("Cannot add event while adding a stream");
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 == null) {
        t1 = (this._state & 2) !== 0 ? $.get$Future__nullFuture() : P._Future$(null);
        this._doneFuture = t1;
      }
      return t1;
    },
    add$1: [function(_, value) {
      var t1 = this._state;
      if (t1 >= 4)
        throw H.wrapException(this._badEventState$0());
      if ((t1 & 1) !== 0)
        this._sendData$1(value);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, new P._DelayedData(value, null));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__T", void: true, args: [T]};
      }, this.$receiver, "_StreamController");
    }],
    close$0: function(_) {
      var t1 = this._state;
      if ((t1 & 4) !== 0) {
        this._ensureDoneFuture$0();
        return this._doneFuture;
      }
      if (t1 >= 4)
        throw H.wrapException(this._badEventState$0());
      t1 |= 4;
      this._state = t1;
      if ((t1 & 1) !== 0)
        this._sendDone$0();
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
      this._ensureDoneFuture$0();
      return this._doneFuture;
    },
    _subscribe$1: function(cancelOnError) {
      var t1, t2, subscription, pendingEvents, addState;
      if ((this._state & 3) !== 0)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      subscription = H.setRuntimeTypeInfo(new P._ControllerSubscription(this, null, null, null, t1, t2, null, null), [null]);
      pendingEvents = this.get$_pendingEvents();
      t2 = this._state |= 1;
      if ((t2 & 8) !== 0) {
        addState = this._varData;
        addState.set$varData(subscription);
        addState.resume$0();
      } else
        this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new P._StreamController__subscribe_closure(this));
      return subscription;
    },
    _recordCancel$1: function(subscription) {
      var t1, future;
      if ((this._state & 8) !== 0)
        this._varData.cancel$0();
      this._varData = null;
      this._state = this._state & 4294967286 | 2;
      t1 = new P._StreamController__recordCancel_complete(this);
      future = P._runGuarded(this.get$_onCancel());
      if (future != null)
        future = future.whenComplete$1(t1);
      else
        t1.call$0();
      return future;
    }
  },
  _StreamController__subscribe_closure: {
    "^": "Closure:86;this_0",
    call$0: function() {
      P._runGuarded(this.this_0.get$_onListen());
    }
  },
  _StreamController__recordCancel_complete: {
    "^": "Closure:10;this_0",
    call$0: function() {
      var t1 = this.this_0._doneFuture;
      if (t1 != null && t1._state === 0)
        t1._asyncComplete$1(null);
    }
  },
  _SyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      this.get$_subscription()._async$_add$1(data);
    },
    _sendDone$0: function() {
      this.get$_subscription()._close$0();
    }
  },
  _AsyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      this.get$_subscription()._addPending$1(new P._DelayedData(data, null));
    },
    _sendDone$0: function() {
      this.get$_subscription()._addPending$1(C.C__DelayedDone);
    }
  },
  _AsyncStreamController: {
    "^": "_StreamController__AsyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture"
  },
  _StreamController__AsyncStreamControllerDispatch: {
    "^": "_StreamController+_AsyncStreamControllerDispatch;"
  },
  _SyncStreamController: {
    "^": "_StreamController__SyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture"
  },
  _StreamController__SyncStreamControllerDispatch: {
    "^": "_StreamController+_SyncStreamControllerDispatch;"
  },
  _ControllerStream: {
    "^": "_StreamImpl;_async$_controller",
    _createSubscription$1: function(cancelOnError) {
      return this._async$_controller._subscribe$1(cancelOnError);
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$is_ControllerStream)
        return false;
      return other._async$_controller === this._async$_controller;
    },
    $is_ControllerStream: true
  },
  _ControllerSubscription: {
    "^": "_BufferingStreamSubscription;_async$_controller,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _onCancel$0: function() {
      return this._async$_controller._recordCancel$1(this);
    },
    _onPause$0: [function() {
      var t1 = this._async$_controller;
      if ((t1._state & 8) !== 0)
        t1._varData.pause$0(0);
      P._runGuarded(t1.get$_onPause());
    }, "call$0", "get$_onPause", 0, 0, 10],
    _onResume$0: [function() {
      var t1 = this._async$_controller;
      if ((t1._state & 8) !== 0)
        t1._varData.resume$0();
      P._runGuarded(t1.get$_onResume());
    }, "call$0", "get$_onResume", 0, 0, 10]
  },
  _EventSink: {
    "^": "Object;"
  },
  _BufferingStreamSubscription: {
    "^": "Object;_onData,_onError,_onDone,_zone<,_state,_cancelFuture,_pending",
    _setPendingEvents$1: function(pendingEvents) {
      if (pendingEvents == null)
        return;
      this._pending = pendingEvents;
      if (!pendingEvents.get$isEmpty(pendingEvents)) {
        this._state = (this._state | 64) >>> 0;
        pendingEvents.schedule$1(this);
      }
    },
    onData$1: function(handleData) {
      this._zone.toString;
      this._onData = handleData;
    },
    onError$1: function(_, handleError) {
      if (handleError == null)
        handleError = P._nullErrorHandler$closure();
      this._onError = P._registerErrorHandler(handleError, this._zone);
    },
    onDone$1: function(handleDone) {
      if (handleDone == null)
        handleDone = P._nullDoneHandler$closure();
      this._zone.toString;
      this._onDone = handleDone;
    },
    pause$1: function(_, resumeSignal) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      this._state = (t1 + 128 | 4) >>> 0;
      if (t1 < 128 && this._pending != null)
        this._pending.cancelSchedule$0();
      if ((t1 & 4) === 0 && (this._state & 32) === 0)
        this._guardCallback$1(this.get$_onPause());
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      var t1, t2;
      t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        t1 -= 128;
        this._state = t1;
        if (t1 < 128) {
          if ((t1 & 64) !== 0) {
            t2 = this._pending;
            t2 = !t2.get$isEmpty(t2);
          } else
            t2 = false;
          if (t2)
            this._pending.schedule$1(this);
          else {
            t1 = (t1 & 4294967291) >>> 0;
            this._state = t1;
            if ((t1 & 32) === 0)
              this._guardCallback$1(this.get$_onResume());
          }
        }
      }
    },
    cancel$0: function() {
      var t1 = (this._state & 4294967279) >>> 0;
      this._state = t1;
      if ((t1 & 8) !== 0)
        return this._cancelFuture;
      this._cancel$0();
      return this._cancelFuture;
    },
    _cancel$0: function() {
      var t1 = (this._state | 8) >>> 0;
      this._state = t1;
      if ((t1 & 64) !== 0)
        this._pending.cancelSchedule$0();
      if ((this._state & 32) === 0)
        this._pending = null;
      this._cancelFuture = this._onCancel$0();
    },
    _async$_add$1: function(data) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendData$1(data);
      else
        this._addPending$1(new P._DelayedData(data, null));
    },
    _addError$2: function(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new P._DelayedError(error, stackTrace, null));
    },
    _close$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      this._state = t1;
      if (t1 < 32)
        this._sendDone$0();
      else
        this._addPending$1(C.C__DelayedDone);
    },
    _onPause$0: [function() {
    }, "call$0", "get$_onPause", 0, 0, 10],
    _onResume$0: [function() {
    }, "call$0", "get$_onResume", 0, 0, 10],
    _onCancel$0: function() {
    },
    _addPending$1: function($event) {
      var pending, t1;
      pending = this._pending;
      if (pending == null) {
        pending = new P._StreamImplEvents(null, null, 0);
        this._pending = pending;
      }
      pending.add$1(0, $event);
      t1 = this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        this._state = t1;
        if (t1 < 128)
          this._pending.schedule$1(this);
      }
    },
    _sendData$1: function(data) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      this._zone.runUnaryGuarded$2(this._onData, data);
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var t1, t2;
      t1 = this._state;
      t2 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        this._state = (t1 | 16) >>> 0;
        this._cancel$0();
        t1 = this._cancelFuture;
        if (!!J.getInterceptor(t1).$isFuture)
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t1, t2;
      t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
      this._cancel$0();
      this._state = (this._state | 16) >>> 0;
      t2 = this._cancelFuture;
      if (!!J.getInterceptor(t2).$isFuture)
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      callback.call$0();
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, t2, isInputPaused;
      t1 = this._state;
      if ((t1 & 64) !== 0) {
        t2 = this._pending;
        t2 = t2.get$isEmpty(t2);
      } else
        t2 = false;
      if (t2) {
        t1 = (t1 & 4294967231) >>> 0;
        this._state = t1;
        if ((t1 & 4) !== 0)
          if (t1 < 128) {
            t2 = this._pending;
            t2 = t2 == null || t2.get$isEmpty(t2);
          } else
            t2 = false;
        else
          t2 = false;
        if (t2) {
          t1 = (t1 & 4294967291) >>> 0;
          this._state = t1;
        }
      }
      for (; true; wasInputPaused = isInputPaused) {
        if ((t1 & 8) !== 0) {
          this._pending = null;
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          this._onPause$0();
        else
          this._onResume$0();
        t1 = (this._state & 4294967263) >>> 0;
        this._state = t1;
      }
      if ((t1 & 64) !== 0 && t1 < 128)
        this._pending.schedule$1(this);
    },
    static: {"^": "_BufferingStreamSubscription__STATE_CANCEL_ON_ERROR,_BufferingStreamSubscription__STATE_CLOSED,_BufferingStreamSubscription__STATE_INPUT_PAUSED,_BufferingStreamSubscription__STATE_CANCELED,_BufferingStreamSubscription__STATE_WAIT_FOR_CANCEL,_BufferingStreamSubscription__STATE_IN_CALLBACK,_BufferingStreamSubscription__STATE_HAS_PENDING,_BufferingStreamSubscription__STATE_PAUSE_COUNT,_BufferingStreamSubscription__STATE_PAUSE_COUNT_SHIFT"}
  },
  _BufferingStreamSubscription__sendError_sendError: {
    "^": "Closure:10;this_0,error_1,stackTrace_2",
    call$0: function() {
      var t1, t2, t3, t4, t5;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      t2 = t1._zone;
      t3 = $.Zone__current;
      t2.toString;
      t3.toString;
      if (t3 == null ? t2 != null : t3 !== t2)
        P._rootHandleUncaughtError(t3, null, t3, this.error_1, this.stackTrace_2);
      else {
        t3 = t1._onError;
        t4 = H.getDynamicRuntimeType();
        t4 = H.buildFunctionType(t4, [t4, t4])._isTest$1(t3);
        t5 = this.error_1;
        if (t4)
          t2.runBinaryGuarded$3(t3, t5, this.stackTrace_2);
        else
          t2.runUnaryGuarded$2(t3, t5);
      }
      t1._state = (t1._state & 4294967263) >>> 0;
    }
  },
  _BufferingStreamSubscription__sendDone_sendDone: {
    "^": "Closure:10;this_0",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    }
  },
  _StreamImpl: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var subscription = this._createSubscription$1(true === cancelOnError);
      subscription.onData$1(onData);
      subscription.onError$1(0, onError);
      subscription.onDone$1(onDone);
      return subscription;
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _createSubscription$1: function(cancelOnError) {
      var t1, t2;
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      return new P._BufferingStreamSubscription(null, null, null, t1, t2, null, null);
    }
  },
  _DelayedEvent: {
    "^": "Object;next@"
  },
  _DelayedData: {
    "^": "_DelayedEvent;value,next",
    perform$1: function(dispatch) {
      dispatch._sendData$1(this.value);
    }
  },
  _DelayedError: {
    "^": "_DelayedEvent;error>,stackTrace<,next",
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  },
  _DelayedDone: {
    "^": "Object;",
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function() {
      return;
    },
    set$next: function(_) {
      throw H.wrapException(P.StateError$("No events after a done."));
    }
  },
  _PendingEvents: {
    "^": "Object;",
    schedule$1: function(dispatch) {
      var t1 = this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
      this._state = 1;
    },
    cancelSchedule$0: function() {
      if (this._state === 1)
        this._state = 3;
    }
  },
  _PendingEvents_schedule_closure: {
    "^": "Closure:86;this_0,dispatch_1",
    call$0: function() {
      var t1, oldState;
      t1 = this.this_0;
      oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this.dispatch_1);
    }
  },
  _StreamImplEvents: {
    "^": "_PendingEvents;firstPendingEvent,lastPendingEvent,_state",
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: function(_, $event) {
      var t1 = this.lastPendingEvent;
      if (t1 == null) {
        this.lastPendingEvent = $event;
        this.firstPendingEvent = $event;
      } else {
        t1.set$next($event);
        this.lastPendingEvent = $event;
      }
    },
    handleNext$1: function(dispatch) {
      var $event, t1;
      $event = this.firstPendingEvent;
      t1 = $event.get$next();
      this.firstPendingEvent = t1;
      if (t1 == null)
        this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    }
  },
  _cancelAndError_closure: {
    "^": "Closure:86;future_0,error_1,stackTrace_2",
    call$0: function() {
      return this.future_0._completeError$2(this.error_1, this.stackTrace_2);
    }
  },
  _cancelAndErrorClosure_closure: {
    "^": "Closure:107;subscription_0,future_1",
    call$2: function(error, stackTrace) {
      return P._cancelAndError(this.subscription_0, this.future_1, error, stackTrace);
    }
  },
  _cancelAndValue_closure: {
    "^": "Closure:86;future_0,value_1",
    call$0: function() {
      return this.future_0._complete$1(this.value_1);
    }
  },
  _ForwardingStream: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2, t3, t4, result;
      cancelOnError = true === cancelOnError;
      t1 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 0);
      t2 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 1);
      t3 = $.Zone__current;
      t4 = cancelOnError ? 1 : 0;
      result = H.setRuntimeTypeInfo(new P._ForwardingStreamSubscription(this, null, null, null, null, t3, t4, null, null), [t1, t2]);
      result._ForwardingStreamSubscription$2(this, cancelOnError, t1, t2);
      result.onData$1(onData);
      result.onError$1(0, onError);
      result.onDone$1(onDone);
      return result;
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _handleData$2: function(data, sink) {
      sink._async$_add$1(data);
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  },
  _ForwardingStreamSubscription: {
    "^": "_BufferingStreamSubscription;_stream,_subscription,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _async$_add$1: function(data) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._async$_add$1.call(this, data);
    },
    _addError$2: function(error, stackTrace) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._addError$2.call(this, error, stackTrace);
    },
    _onPause$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.pause$0(0);
    }, "call$0", "get$_onPause", 0, 0, 10],
    _onResume$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.resume$0();
    }, "call$0", "get$_onResume", 0, 0, 10],
    _onCancel$0: function() {
      var t1 = this._subscription;
      if (t1 != null) {
        this._subscription = null;
        t1.cancel$0();
      }
      return;
    },
    _handleData$1: [function(data) {
      this._stream._handleData$2(data, this);
    }, "call$1", "get$_handleData", 2, 0, function() {
      return H.computeSignature(function(S, T) {
        return {func: "void__S", void: true, args: [S]};
      }, this.$receiver, "_ForwardingStreamSubscription");
    }],
    _handleError$2: [function(error, stackTrace) {
      this._addError$2(error, stackTrace);
    }, "call$2", "get$_handleError", 4, 0, 108],
    _handleDone$0: [function() {
      this._close$0();
    }, "call$0", "get$_handleDone", 0, 0, 10],
    _ForwardingStreamSubscription$2: function(_stream, cancelOnError, $S, $T) {
      var t1, t2;
      t1 = this.get$_handleData();
      t2 = this.get$_handleError();
      this._subscription = this._stream._source.listen$3$onDone$onError(t1, this.get$_handleDone(), t2);
    }
  },
  _SkipStream: {
    "^": "_ForwardingStream;_remaining,_source",
    _handleData$2: function(inputEvent, sink) {
      if (J.$gt$n(this._remaining, 0)) {
        this._remaining = J.$sub$n(this._remaining, 1);
        return;
      }
      sink._async$_add$1(inputEvent);
    },
    _SkipStream$2: function(source, count, $T) {
      if (typeof count !== "number" || Math.floor(count) !== count || count < 0)
        throw H.wrapException(P.ArgumentError$(count));
    },
    $as_ForwardingStream: function($T) {
      return [$T, $T];
    },
    $asStream: null
  },
  _BaseZone: {
    "^": "Object;",
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      try {
        t1 = this.run$1(f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return this.handleUncaughtError$2(e, s);
      }

    },
    runUnaryGuarded$2: function(f, arg) {
      var e, s, t1, exception;
      try {
        t1 = this.runUnary$2(f, arg);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return this.handleUncaughtError$2(e, s);
      }

    },
    runBinaryGuarded$3: function(f, arg1, arg2) {
      var e, s, t1, exception;
      try {
        t1 = this.runBinary$3(f, arg1, arg2);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return this.handleUncaughtError$2(e, s);
      }

    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      var registered = this.registerCallback$1(f);
      if (runGuarded)
        return new P._BaseZone_bindCallback_closure(this, registered);
      else
        return new P._BaseZone_bindCallback_closure0(this, registered);
    },
    bindCallback$1: function(f) {
      return this.bindCallback$2$runGuarded(f, true);
    },
    bindUnaryCallback$2$runGuarded: function(f, runGuarded) {
      var registered = this.registerUnaryCallback$1(f);
      if (runGuarded)
        return new P._BaseZone_bindUnaryCallback_closure(this, registered);
      else
        return new P._BaseZone_bindUnaryCallback_closure0(this, registered);
    }
  },
  _BaseZone_bindCallback_closure: {
    "^": "Closure:86;this_0,registered_1",
    call$0: function() {
      return this.this_0.runGuarded$1(this.registered_1);
    }
  },
  _BaseZone_bindCallback_closure0: {
    "^": "Closure:86;this_2,registered_3",
    call$0: function() {
      return this.this_2.run$1(this.registered_3);
    }
  },
  _BaseZone_bindUnaryCallback_closure: {
    "^": "Closure:88;this_0,registered_1",
    call$1: function(arg) {
      return this.this_0.runUnaryGuarded$2(this.registered_1, arg);
    }
  },
  _BaseZone_bindUnaryCallback_closure0: {
    "^": "Closure:88;this_2,registered_3",
    call$1: function(arg) {
      return this.this_2.runUnary$2(this.registered_3, arg);
    }
  },
  _rootHandleUncaughtError_closure: {
    "^": "Closure:86;error_0,stackTrace_1",
    call$0: function() {
      P._scheduleAsyncCallback(new P._rootHandleUncaughtError__closure(this.error_0, this.stackTrace_1));
    }
  },
  _rootHandleUncaughtError__closure: {
    "^": "Closure:86;error_2,stackTrace_3",
    call$0: function() {
      var t1, trace;
      t1 = this.error_2;
      P.print("Uncaught Error: " + H.S(t1));
      trace = this.stackTrace_3;
      if (trace == null && !!J.getInterceptor(t1).$isError)
        trace = t1.get$stackTrace();
      if (trace != null)
        P.print("Stack Trace: \n" + H.S(trace) + "\n");
      throw H.wrapException(t1);
    }
  },
  _RootZone: {
    "^": "_BaseZone;",
    $index: function(_, key) {
      return;
    },
    handleUncaughtError$2: function(error, stackTrace) {
      return P._rootHandleUncaughtError(this, null, this, error, stackTrace);
    },
    run$1: function(f) {
      return P._rootRun(this, null, this, f);
    },
    runUnary$2: function(f, arg) {
      return P._rootRunUnary(this, null, this, f, arg);
    },
    runBinary$3: function(f, arg1, arg2) {
      return P._rootRunBinary(this, null, this, f, arg1, arg2);
    },
    registerCallback$1: function(f) {
      return f;
    },
    registerUnaryCallback$1: function(f) {
      return f;
    }
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
    return H.fillLiteralMap(keyValuePairs, H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]));
  },
  LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  _HashSet__newHashTable: function() {
    var table = Object.create(null);
    table["<non-identifier-key>"] = table;
    delete table["<non-identifier-key>"];
    return table;
  },
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 8],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 14],
  HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._HashMap(0, null, null, null, null), [$K, $V]);
  },
  HashSet_HashSet$identity: function($E) {
    return H.setRuntimeTypeInfo(new P._IdentityHashSet(0, null, null, null, null), [$E]);
  },
  _iterableToString: function(iterable) {
    var parts, t1;
    if ($.get$_toStringVisiting().contains$1(0, iterable))
      return "(...)";
    $.get$_toStringVisiting().add$1(0, iterable);
    parts = [];
    try {
      P._iterablePartsToStrings(iterable, parts);
    } finally {
      $.get$_toStringVisiting().remove$1(0, iterable);
    }
    t1 = P.StringBuffer$("(");
    t1.writeAll$2(parts, ", ");
    t1.write$1(")");
    return t1._contents;
  },
  _iterablePartsToStrings: function(iterable, parts) {
    var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, t1, elision;
    it = iterable.get$iterator(iterable);
    $length = 0;
    count = 0;
    while (true) {
      if (!($length < 80 || count < 3))
        break;
      if (!it.moveNext$0())
        return;
      next = H.S(it.get$current());
      parts.push(next);
      $length += next.length + 2;
      ++count;
    }
    if (!it.moveNext$0()) {
      if (count <= 5)
        return;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      ultimateString = parts.pop();
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      penultimateString = parts.pop();
    } else {
      penultimate = it.get$current();
      ++count;
      if (!it.moveNext$0()) {
        if (count <= 4) {
          parts.push(H.S(penultimate));
          return;
        }
        ultimateString = H.S(penultimate);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        penultimateString = parts.pop();
        $length += ultimateString.length + 2;
      } else {
        ultimate = it.get$current();
        ++count;
        for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
          ultimate0 = it.get$current();
          ++count;
          if (count > 100) {
            while (true) {
              if (!($length > 75 && count > 3))
                break;
              if (0 >= parts.length)
                return H.ioore(parts, 0);
              t1 = J.$add$ns(J.get$length$asx(parts.pop()), 2);
              if (typeof t1 !== "number")
                return H.iae(t1);
              $length -= t1;
              --count;
            }
            parts.push("...");
            return;
          }
        }
        penultimateString = H.S(penultimate);
        ultimateString = H.S(ultimate);
        $length += ultimateString.length + penultimateString.length + 4;
      }
    }
    if (count > parts.length + 2) {
      $length += 5;
      elision = "...";
    } else
      elision = null;
    while (true) {
      if (!($length > 80 && parts.length > 3))
        break;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      t1 = J.$add$ns(J.get$length$asx(parts.pop()), 2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      $length -= t1;
      if (elision == null) {
        $length += 5;
        elision = "...";
      }
    }
    if (elision != null)
      parts.push(elision);
    parts.push(penultimateString);
    parts.push(ultimateString);
  },
  LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._LinkedHashSet(0, null, null, null, null, null, 0), [$E]);
  },
  Maps_mapToString: function(m) {
    var t1, result, i, t2, t3;
    t1 = {};
    for (i = 0; t2 = $.get$Maps__toStringList(), i < t2.length; ++i) {
      t2 = t2[i];
      t3 = m;
      if (t2 == null ? t3 == null : t2 === t3)
        return "{...}";
    }
    result = P.StringBuffer$("");
    try {
      $.get$Maps__toStringList().push(m);
      result.write$1("{");
      t1.first_0 = true;
      J.forEach$1$ax(m, new P.Maps_mapToString_closure(t1, result));
      result.write$1("}");
    } finally {
      t1 = $.get$Maps__toStringList();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    return result.get$_contents();
  },
  _HashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_keys",
    get$length: function(_) {
      return this._collection$_length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._HashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        return strings == null ? false : strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        return nums == null ? false : nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    $index: function(_, key) {
      var strings, t1, entry, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          t1 = null;
        else {
          entry = strings[key];
          t1 = entry === strings ? null : entry;
        }
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          t1 = null;
        else {
          entry = nums[key];
          t1 = entry === nums ? null : entry;
        }
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._HashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._HashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++this._collection$_length;
        this._keys = null;
      } else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++this._collection$_length;
          this._keys = null;
        }
      }
    },
    forEach$1: function(_, action) {
      var keys, $length, i, key;
      keys = this._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(key, this.$index(0, key));
        if (keys !== this._keys)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    _computeKeys$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._keys;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._keys = result;
      return result;
    },
    _addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._collection$_length;
        this._keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq(bucket[i], key))
          return i;
      return -1;
    },
    $isMap: true,
    static: {_HashMap__setTableEntry: function(table, key, value) {
        if (value == null)
          table[key] = table;
        else
          table[key] = value;
      }, _HashMap__newHashTable: function() {
        var table = Object.create(null);
        P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _HashMap_values_closure: {
    "^": "Closure:88;this_0",
    call$1: function(each) {
      return this.this_0.$index(0, each);
    }
  },
  HashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._map;
      return new P.HashMapKeyIterator(t1, t1._computeKeys$0(), 0, null);
    },
    forEach$1: function(_, f) {
      var t1, keys, $length, i;
      t1 = this._map;
      keys = t1._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        f.call$1(keys[i]);
        if (keys !== t1._keys)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
      }
    },
    $isEfficientLength: true
  },
  HashMapKeyIterator: {
    "^": "Object;_map,_keys,_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var keys, offset, t1;
      keys = this._keys;
      offset = this._offset;
      t1 = this._map;
      if (keys !== t1._keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = keys[offset];
        this._offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$length: function(_) {
      return this._collection$_length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._LinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    addAll$1: function(_, other) {
      other.forEach$1(0, new P._LinkedHashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, cell, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return;
        cell = strings[key];
        return cell == null ? null : cell.get$_collection$_value();
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return;
        cell = nums[key];
        return cell == null ? null : cell.get$_collection$_value();
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].get$_collection$_value();
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._LinkedHashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._LinkedHashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$2(key, value)];
      else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].set$_collection$_value(value);
        else
          bucket.push(this._newLinkedCell$2(key, value));
      }
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index, cell;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      this._unlinkCell$1(cell);
      return cell.get$_collection$_value();
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$2(cell.get$_key(), cell._collection$_value);
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.set$_collection$_value(value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = table[key];
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      delete table[key];
      return cell.get$_collection$_value();
    },
    _newLinkedCell$2: function(key, value) {
      var cell, last;
      cell = new P.LinkedHashMapCell(key, value, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_key(), key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    $isMap: true,
    static: {_LinkedHashMap__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _LinkedHashMap_values_closure: {
    "^": "Closure:88;this_0",
    call$1: function(each) {
      return this.this_0.$index(0, each);
    }
  },
  _LinkedHashMap_addAll_closure: {
    "^": "Closure;this_0",
    call$2: function(key, value) {
      this.this_0.$indexSet(0, key, value);
    },
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "dynamic__K_V", args: [K, V]};
      }, this.this_0, "_LinkedHashMap");
    }
  },
  LinkedHashMapCell: {
    "^": "Object;_key<,_collection$_value@,_next@,_previous@"
  },
  LinkedHashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = new P.LinkedHashMapKeyIterator(t1, t1._modifications, null, null);
      t2._cell = t1._first;
      return t2;
    },
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell.get$_key());
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell._next;
      }
    },
    $isEfficientLength: true
  },
  LinkedHashMapKeyIterator: {
    "^": "Object;_map,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._map;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_key();
          this._cell = t1._next;
          return true;
        }
      }
    }
  },
  _HashSet: {
    "^": "_HashSetBase;",
    get$iterator: function(_) {
      return new P.HashSetIterator(this, this._computeElements$0(), 0, null);
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        return strings == null ? false : strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        return nums == null ? false : nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$asx(bucket, index);
    },
    add$1: function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    },
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [element];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(element);
      }
      ++this._collection$_length;
      this._elements = null;
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      --this._collection$_length;
      this._elements = null;
      bucket.splice(index, 1);
      return true;
    },
    _computeElements$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._elements;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; ++i0) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._elements = result;
      return result;
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = 0;
      ++this._collection$_length;
      this._elements = null;
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      if (table != null && table[element] != null) {
        delete table[element];
        --this._collection$_length;
        this._elements = null;
        return true;
      } else
        return false;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i], element))
          return i;
      return -1;
    },
    $isEfficientLength: true
  },
  _IdentityHashSet: {
    "^": "_HashSet;_collection$_length,_strings,_nums,_rest,_elements",
    _computeHashCode$1: function(key) {
      return H.objectHashCode(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = bucket[i];
        if (t1 == null ? element == null : t1 === element)
          return i;
      }
      return -1;
    }
  },
  HashSetIterator: {
    "^": "Object;_set,_elements,_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var elements, offset, t1;
      elements = this._elements;
      offset = this._offset;
      t1 = this._set;
      if (elements !== t1._elements)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= elements.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = elements[offset];
        this._offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashSet: {
    "^": "_HashSetBase;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$iterator: function(_) {
      var t1 = new P.LinkedHashSetIterator(this, this._modifications, null, null);
      t1._cell = this._first;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      else
        return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$asx(bucket, index).get$_collection$_element();
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$1(cell.get$_collection$_element());
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._next;
      }
    },
    get$first: function(_) {
      var t1 = this._first;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return t1.get$_collection$_element();
    },
    add$1: function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    },
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$1(element)];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(this._newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      this._unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = this._newLinkedCell$1(element);
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = table[element];
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _newLinkedCell$1: function(element) {
      var cell, last;
      cell = new P.LinkedHashSetCell(element, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_collection$_element(), element))
          return i;
      return -1;
    },
    $isEfficientLength: true,
    static: {_LinkedHashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  LinkedHashSetCell: {
    "^": "Object;_collection$_element<,_next@,_previous@"
  },
  LinkedHashSetIterator: {
    "^": "Object;_set,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._set;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_collection$_element();
          this._cell = t1._next;
          return true;
        }
      }
    }
  },
  _HashSetBase: {
    "^": "IterableBase;",
    toString$0: function(_) {
      return H.IterableMixinWorkaround_toStringIterable(this, "{", "}");
    },
    $isEfficientLength: true
  },
  IterableBase: {
    "^": "Object;",
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$length: function(_) {
      var it, count;
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return this.get$isEmpty(this) !== true;
    },
    skip$1: function(_, n) {
      return H.SkipIterable_SkipIterable(this, n, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    get$first: function(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(P.StateError$("No elements"));
      return it.get$current();
    },
    elementAt$1: function(_, index) {
      var t1, remaining, element, t2;
      if (typeof index !== "number" || Math.floor(index) !== index || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      for (t1 = this.get$iterator(this), remaining = index; t1.moveNext$0();) {
        element = t1.get$current();
        t2 = J.getInterceptor(remaining);
        if (t2.$eq(remaining, 0))
          return element;
        remaining = t2.$sub(remaining, 1);
      }
      throw H.wrapException(P.RangeError$value(index));
    },
    toString$0: function(_) {
      return P._iterableToString(this);
    }
  },
  ListBase: {
    "^": "Object+ListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return new H.ListIterator(receiver, this.get$length(receiver), 0, null);
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    forEach$1: function(receiver, action) {
      var $length, i;
      $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        action.call$1(this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    get$isEmpty: function(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$isNotEmpty: function(receiver) {
      return !this.get$isEmpty(receiver);
    },
    get$first: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(P.StateError$("No elements"));
      return this.$index(receiver, 0);
    },
    where$1: function(receiver, test) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(receiver, test), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    skip$1: function(receiver, count) {
      return H.SubListIterable$(receiver, count, null, null);
    },
    toList$1$growable: function(receiver, growable) {
      var result, i, t1;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(receiver));
      } else
        result = H.setRuntimeTypeInfo(Array(this.get$length(receiver)), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      for (i = 0; i < this.get$length(receiver); ++i) {
        t1 = this.$index(receiver, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: function(receiver, element) {
      var t1 = this.get$length(receiver);
      this.set$length(receiver, t1 + 1);
      this.$indexSet(receiver, t1, element);
    },
    sort$1: function(receiver, compare) {
      H.Sort__doSort(receiver, 0, this.get$length(receiver) - 1, compare);
    },
    _rangeCheck$2: function(receiver, start, end) {
      var t1 = J.getInterceptor$n(start);
      if (t1.$lt(start, 0) || t1.$gt(start, this.get$length(receiver)))
        throw H.wrapException(P.RangeError$range(start, 0, this.get$length(receiver)));
      t1 = J.getInterceptor$n(end);
      if (t1.$lt(end, start) || t1.$gt(end, this.get$length(receiver)))
        throw H.wrapException(P.RangeError$range(end, start, this.get$length(receiver)));
    },
    sublist$2: function(receiver, start, end) {
      var $length, result, t1, i, t2;
      if (end == null)
        end = this.get$length(receiver);
      this._rangeCheck$2(receiver, start, end);
      $length = J.$sub$n(end, start);
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      C.JSArray_methods.set$length(result, $length);
      if (typeof $length !== "number")
        return H.iae($length);
      t1 = J.getInterceptor$ns(start);
      i = 0;
      for (; i < $length; ++i) {
        t2 = this.$index(receiver, t1.$add(start, i));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t2;
      }
      return result;
    },
    fillRange$3: function(receiver, start, end, fill) {
      var i, t1;
      this._rangeCheck$2(receiver, start, end);
      for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
        this.$indexSet(receiver, i, fill);
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var t1, t2, $length, t3, otherStart, otherList, t4, i;
      t1 = J.getInterceptor$n(start);
      if (t1.$lt(start, 0) || t1.$gt(start, this.get$length(receiver)))
        H.throwExpression(P.RangeError$range(start, 0, this.get$length(receiver)));
      t2 = J.getInterceptor$n(end);
      if (t2.$lt(end, start) || t2.$gt(end, this.get$length(receiver)))
        H.throwExpression(P.RangeError$range(end, start, this.get$length(receiver)));
      $length = t2.$sub(end, start);
      t2 = J.getInterceptor($length);
      if (t2.$eq($length, 0))
        return;
      if (J.$lt$n(skipCount, 0))
        throw H.wrapException(P.ArgumentError$(skipCount));
      t3 = J.getInterceptor(iterable);
      if (!!t3.$isList) {
        otherStart = skipCount;
        otherList = iterable;
      } else {
        otherList = t3.skip$1(iterable, skipCount).toList$1$growable(0, false);
        otherStart = 0;
      }
      t3 = J.getInterceptor$ns(otherStart);
      t4 = J.getInterceptor$asx(otherList);
      if (J.$gt$n(t3.$add(otherStart, $length), t4.get$length(otherList)))
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (t3.$lt(otherStart, start))
        for (i = t2.$sub($length, 1); t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1))
          this.$indexSet(receiver, t1.$add(start, i), t4.$index(otherList, t3.$add(otherStart, i)));
      else {
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i)
          this.$indexSet(receiver, t1.$add(start, i), t4.$index(otherList, t3.$add(otherStart, i)));
      }
    },
    lastIndexOf$2: function(receiver, element, startIndex) {
      var i;
      startIndex = this.get$length(receiver) - 1;
      for (i = startIndex; i >= 0; --i)
        if (J.$eq(this.$index(receiver, i), element))
          return i;
      return -1;
    },
    lastIndexOf$1: function($receiver, element) {
      return this.lastIndexOf$2($receiver, element, null);
    },
    toString$0: function(receiver) {
      var result;
      if ($.get$_toStringVisiting().contains$1(0, receiver))
        return "[...]";
      result = P.StringBuffer$("");
      try {
        $.get$_toStringVisiting().add$1(0, receiver);
        result.write$1("[");
        result.writeAll$2(receiver, ", ");
        result.write$1("]");
      } finally {
        $.get$_toStringVisiting().remove$1(0, receiver);
      }
      return result.get$_contents();
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  Maps_mapToString_closure: {
    "^": "Closure:87;box_0,result_1",
    call$2: function(k, v) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1(", ");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(k);
      t1.write$1(": ");
      t1.write$1(v);
    }
  },
  ListQueue: {
    "^": "IterableBase;_collection$_table,_head,_tail,_modificationCount",
    get$iterator: function(_) {
      return new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, null);
    },
    forEach$1: function(_, action) {
      var modificationCount, i, t1;
      modificationCount = this._modificationCount;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._collection$_table.length - 1) >>> 0) {
        t1 = this._collection$_table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        action.call$1(t1[i]);
        if (modificationCount !== this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return (this._tail - this._head & this._collection$_table.length - 1) >>> 0;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$first: function(_) {
      var t1, t2;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(P.StateError$("No elements"));
      t2 = this._collection$_table;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      return t2[t1];
    },
    add$1: function(_, element) {
      this._add$1(element);
    },
    toString$0: function(_) {
      return H.IterableMixinWorkaround_toStringIterable(this, "{", "}");
    },
    _add$1: function(element) {
      var t1, t2, t3;
      t1 = this._collection$_table;
      t2 = this._tail;
      t3 = t1.length;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      t1[t2] = element;
      t3 = (t2 + 1 & t3 - 1) >>> 0;
      this._tail = t3;
      if (this._head === t3)
        this._grow$0();
      ++this._modificationCount;
    },
    _grow$0: function() {
      var t1, newTable, t2, split;
      t1 = Array(this._collection$_table.length * 2);
      t1.fixed$length = init;
      newTable = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      t1 = this._collection$_table;
      t2 = this._head;
      split = t1.length - t2;
      H.IterableMixinWorkaround_setRangeList(newTable, 0, split, t1, t2);
      t1 = this._head;
      t2 = this._collection$_table;
      H.IterableMixinWorkaround_setRangeList(newTable, split, split + t1, t2, 0);
      this._head = 0;
      this._tail = this._collection$_table.length;
      this._collection$_table = newTable;
    },
    ListQueue$1: function(initialCapacity, $E) {
      var t1 = Array(8);
      t1.fixed$length = init;
      this._collection$_table = H.setRuntimeTypeInfo(t1, [$E]);
    },
    $isEfficientLength: true,
    static: {"^": "ListQueue__INITIAL_CAPACITY"}
  },
  _ListQueueIterator: {
    "^": "Object;_queue,_end,_modificationCount,_collection$_position,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1, t2, t3;
      t1 = this._queue;
      if (this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = this._collection$_position;
      if (t2 === this._end) {
        this._collection$_current = null;
        return false;
      }
      t1 = t1._collection$_table;
      t3 = t1.length;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      this._collection$_current = t1[t2];
      this._collection$_position = (t2 + 1 & t3 - 1) >>> 0;
      return true;
    }
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  _symbolToString: function(symbol) {
    return H.Symbol_getName(symbol);
  },
  Comparable_compare: [function(a, b) {
    return J.compareTo$1$ns(a, b);
  }, "call$2", "Comparable_compare$closure", 4, 0, 15],
  Error_safeToString: function(object) {
    var buffer, t1, i, t2, codeUnit;
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string") {
      buffer = new P.StringBuffer("");
      buffer._contents = "\"";
      for (t1 = object.length, i = 0, t2 = "\""; i < t1; ++i) {
        codeUnit = C.JSString_methods.codeUnitAt$1(object, i);
        if (codeUnit <= 31)
          if (codeUnit === 10)
            t2 = buffer._contents += "\\n";
          else if (codeUnit === 13)
            t2 = buffer._contents += "\\r";
          else if (codeUnit === 9)
            t2 = buffer._contents += "\\t";
          else {
            t2 = buffer._contents += "\\x";
            if (codeUnit < 16)
              buffer._contents = t2 + "0";
            else {
              buffer._contents = t2 + "1";
              codeUnit -= 16;
            }
            t2 = H.Primitives_stringFromCharCode(codeUnit < 10 ? 48 + codeUnit : 87 + codeUnit);
            t2 = buffer._contents += t2;
          }
        else if (codeUnit === 92)
          t2 = buffer._contents += "\\\\";
        else if (codeUnit === 34)
          t2 = buffer._contents += "\\\"";
        else {
          t2 = H.Primitives_stringFromCharCode(codeUnit);
          t2 = buffer._contents += t2;
        }
      }
      t1 = t2 + "\"";
      buffer._contents = t1;
      return t1;
    }
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Exception_Exception: function(message) {
    return new P._ExceptionImplementation(message);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 16],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 17],
  List_List$filled: function($length, fill, $E) {
    var result, t1, i;
    result = J.JSArray_JSArray$fixed($length, $E);
    if ($length !== 0 && true)
      for (t1 = result.length, i = 0; i < t1; ++i)
        result[i] = fill;
    return result;
  },
  List_List$from: function(other, growable, $E) {
    var list, t1;
    list = H.setRuntimeTypeInfo([], [$E]);
    for (t1 = J.get$iterator$ax(other); t1.moveNext$0();)
      list.push(t1.get$current());
    if (growable)
      return list;
    list.fixed$length = init;
    return list;
  },
  print: function(object) {
    var line = H.S(object);
    H.printString(line);
  },
  String_String$fromCharCodes: function(charCodes) {
    return H.Primitives_stringFromCharCodes(typeof charCodes !== "object" || charCodes === null || charCodes.constructor !== Array ? P.List_List$from(charCodes, true, null) : charCodes);
  },
  NoSuchMethodError_toString_closure: {
    "^": "Closure:109;box_0",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (t1.i_1 > 0)
        t1.sb_0.write$1(", ");
      t1.sb_0.write$1(P._symbolToString(key));
    }
  },
  Comparable: {
    "^": "Object;"
  },
  DateTime: {
    "^": "Object;millisecondsSinceEpoch<,isUtc",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDateTime)
        return false;
      return this.millisecondsSinceEpoch === other.millisecondsSinceEpoch && this.isUtc === other.isUtc;
    },
    compareTo$1: function(_, other) {
      return C.JSNumber_methods.compareTo$1(this.millisecondsSinceEpoch, other.get$millisecondsSinceEpoch());
    },
    get$hashCode: function(_) {
      return this.millisecondsSinceEpoch;
    },
    toString$0: function(_) {
      var t1, y, m, d, h, min, sec, ms;
      t1 = this.isUtc;
      y = P.DateTime__fourDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(this).getFullYear() + 0);
      m = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(this).getMonth() + 1);
      d = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(this).getDate() + 0);
      h = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(this).getHours() + 0);
      min = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(this).getMinutes() + 0);
      sec = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(this).getSeconds() + 0);
      ms = P.DateTime__threeDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(this).getMilliseconds() + 0);
      if (t1)
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
    },
    add$1: function(_, duration) {
      return P.DateTime$fromMillisecondsSinceEpoch(this.millisecondsSinceEpoch + duration.get$inMilliseconds(), this.isUtc);
    },
    DateTime$_now$0: function() {
      H.Primitives_lazyAsJsDate(this);
    },
    DateTime$fromMillisecondsSinceEpoch$2$isUtc: function(millisecondsSinceEpoch, isUtc) {
      if (Math.abs(millisecondsSinceEpoch) > 8640000000000000)
        throw H.wrapException(P.ArgumentError$(millisecondsSinceEpoch));
    },
    $isDateTime: true,
    static: {"^": "DateTime_MONDAY,DateTime_TUESDAY,DateTime_WEDNESDAY,DateTime_THURSDAY,DateTime_FRIDAY,DateTime_SATURDAY,DateTime_SUNDAY,DateTime_DAYS_PER_WEEK,DateTime_JANUARY,DateTime_FEBRUARY,DateTime_MARCH,DateTime_APRIL,DateTime_MAY,DateTime_JUNE,DateTime_JULY,DateTime_AUGUST,DateTime_SEPTEMBER,DateTime_OCTOBER,DateTime_NOVEMBER,DateTime_DECEMBER,DateTime_MONTHS_PER_YEAR,DateTime__MAX_MILLISECONDS_SINCE_EPOCH", DateTime$fromMillisecondsSinceEpoch: function(millisecondsSinceEpoch, isUtc) {
        var t1 = new P.DateTime(millisecondsSinceEpoch, isUtc);
        t1.DateTime$fromMillisecondsSinceEpoch$2$isUtc(millisecondsSinceEpoch, isUtc);
        return t1;
      }, DateTime__fourDigits: function(n) {
        var absN, sign;
        absN = Math.abs(n);
        sign = n < 0 ? "-" : "";
        if (absN >= 1000)
          return "" + n;
        if (absN >= 100)
          return sign + "0" + H.S(absN);
        if (absN >= 10)
          return sign + "00" + H.S(absN);
        return sign + "000" + H.S(absN);
      }, DateTime__threeDigits: function(n) {
        if (n >= 100)
          return "" + n;
        if (n >= 10)
          return "0" + n;
        return "00" + n;
      }, DateTime__twoDigits: function(n) {
        if (n >= 10)
          return "" + n;
        return "0" + n;
      }}
  },
  Duration: {
    "^": "Object;_duration<",
    $add: function(_, other) {
      return P.Duration$(0, 0, this._duration + other.get$_duration(), 0, 0, 0);
    },
    $sub: function(_, other) {
      return P.Duration$(0, 0, this._duration - other.get$_duration(), 0, 0, 0);
    },
    $mul: function(_, factor) {
      if (typeof factor !== "number")
        return H.iae(factor);
      return P.Duration$(0, 0, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(this._duration * factor)), 0, 0, 0);
    },
    $tdiv: function(_, quotient) {
      if (J.$eq(quotient, 0))
        throw H.wrapException(P.IntegerDivisionByZeroException$());
      if (typeof quotient !== "number")
        return H.iae(quotient);
      return P.Duration$(0, 0, C.JSNumber_methods.$tdiv(this._duration, quotient), 0, 0, 0);
    },
    $lt: function(_, other) {
      return this._duration < other.get$_duration();
    },
    $gt: function(_, other) {
      return this._duration > other.get$_duration();
    },
    $le: function(_, other) {
      return this._duration <= other.get$_duration();
    },
    $ge: function(_, other) {
      return this._duration >= other.get$_duration();
    },
    get$inMilliseconds: function() {
      return C.JSNumber_methods._tdivFast$1(this._duration, 1000);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDuration)
        return false;
      return this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return this._duration & 0x1FFFFFFF;
    },
    compareTo$1: function(_, other) {
      return C.JSNumber_methods.compareTo$1(this._duration, other.get$_duration());
    },
    toString$0: function(_) {
      var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
      t1 = new P.Duration_toString_twoDigits();
      t2 = this._duration;
      if (t2 < 0)
        return "-" + P.Duration$(0, 0, -t2, 0, 0, 0).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSNumber_methods.remainder$1(C.JSNumber_methods._tdivFast$1(t2, 60000000), 60));
      twoDigitSeconds = t1.call$1(C.JSNumber_methods.remainder$1(C.JSNumber_methods._tdivFast$1(t2, 1000000), 60));
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(C.JSNumber_methods.remainder$1(t2, 1000000));
      return H.S(C.JSNumber_methods._tdivFast$1(t2, 3600000000)) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $isDuration: true,
    static: {"^": "Duration_MICROSECONDS_PER_MILLISECOND,Duration_MILLISECONDS_PER_SECOND,Duration_SECONDS_PER_MINUTE,Duration_MINUTES_PER_HOUR,Duration_HOURS_PER_DAY,Duration_MICROSECONDS_PER_SECOND,Duration_MICROSECONDS_PER_MINUTE,Duration_MICROSECONDS_PER_HOUR,Duration_MICROSECONDS_PER_DAY,Duration_MILLISECONDS_PER_MINUTE,Duration_MILLISECONDS_PER_HOUR,Duration_MILLISECONDS_PER_DAY,Duration_SECONDS_PER_HOUR,Duration_SECONDS_PER_DAY,Duration_MINUTES_PER_DAY,Duration_ZERO", Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
        return new P.Duration(days * 86400000000 + hours * 3600000000 + minutes * 60000000 + seconds * 1000000 + milliseconds * 1000 + microseconds);
      }}
  },
  Duration_toString_sixDigits: {
    "^": "Closure:110;",
    call$1: function(n) {
      if (n >= 100000)
        return H.S(n);
      if (n >= 10000)
        return "0" + H.S(n);
      if (n >= 1000)
        return "00" + H.S(n);
      if (n >= 100)
        return "000" + H.S(n);
      if (n >= 10)
        return "0000" + H.S(n);
      return "00000" + H.S(n);
    }
  },
  Duration_toString_twoDigits: {
    "^": "Closure:110;",
    call$1: function(n) {
      if (n >= 10)
        return H.S(n);
      return "0" + H.S(n);
    }
  },
  Error: {
    "^": "Object;",
    get$stackTrace: function() {
      return new H._StackTrace(this.$thrownJsError, null);
    },
    $isError: true
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Illegal argument(s): " + H.S(t1);
      return "Illegal argument(s)";
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;message",
    toString$0: function(_) {
      return "RangeError: " + H.S(this.message);
    },
    static: {RangeError$: function(message) {
        return new P.RangeError(message);
      }, RangeError$value: function(value) {
        return new P.RangeError("value " + H.S(value));
      }, RangeError$range: function(value, start, end) {
        return new P.RangeError("value " + H.S(value) + " not in range " + H.S(start) + ".." + H.S(end));
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
    },
    $isError: true,
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  StateError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    static: {StateError$: function(message) {
        return new P.StateError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(t1)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  OutOfMemoryError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Out of Memory";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  StackOverflowError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Stack Overflow";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    },
    static: {CyclicInitializationError$: function(variableName) {
        return new P.CyclicInitializationError(variableName);
      }}
  },
  _ExceptionImplementation: {
    "^": "Object;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 == null)
        return "Exception";
      return "Exception: " + H.S(t1);
    }
  },
  FormatException: {
    "^": "Object;message",
    toString$0: function(_) {
      return "FormatException: " + H.S(this.message);
    },
    static: {FormatException$: function(message) {
        return new P.FormatException(message);
      }}
  },
  IntegerDivisionByZeroException: {
    "^": "Object;",
    toString$0: function(_) {
      return "IntegerDivisionByZeroException";
    },
    static: {IntegerDivisionByZeroException$: function() {
        return new P.IntegerDivisionByZeroException();
      }}
  },
  Expando: {
    "^": "Object;name>",
    toString$0: function(_) {
      return "Expando:" + H.S(this.name);
    },
    $index: function(_, object) {
      var values = H.Primitives_getProperty(object, "expando$values");
      return values == null ? null : H.Primitives_getProperty(values, this._getKey$0());
    },
    $indexSet: function(_, object, value) {
      var values = H.Primitives_getProperty(object, "expando$values");
      if (values == null) {
        values = new P.Object();
        H.Primitives_setProperty(object, "expando$values", values);
      }
      H.Primitives_setProperty(values, this._getKey$0(), value);
    },
    _getKey$0: function() {
      var key, t1;
      key = H.Primitives_getProperty(this, "expando$key");
      if (key == null) {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        key = "expando$key$" + t1;
        H.Primitives_setProperty(this, "expando$key", key);
      }
      return key;
    },
    static: {"^": "Expando__KEY_PROPERTY_NAME,Expando__EXPANDO_PROPERTY_NAME,Expando__keyCount"}
  },
  Function: {
    "^": "Object;"
  },
  Iterator: {
    "^": "Object;"
  },
  Map: {
    "^": "Object;",
    $isMap: true
  },
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    }
  },
  Pattern: {
    "^": "Object;"
  },
  StackTrace: {
    "^": "Object;"
  },
  Stopwatch: {
    "^": "Object;frequency,_start,_stop",
    start$0: [function(_) {
      var t1, t2, t3;
      t1 = this._start == null;
      if (!t1 && this._stop == null)
        return;
      if (t1)
        this._start = H.Primitives_numMicroseconds();
      else {
        t1 = H.Primitives_numMicroseconds();
        t2 = this._stop;
        t3 = this._start;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        this._start = t1 - (t2 - t3);
        this._stop = null;
      }
    }, "call$0", "get$start", 0, 0, 10],
    stop$0: function(_) {
      if (!(this._start != null && this._stop == null))
        return;
      this._stop = H.Primitives_numMicroseconds();
    },
    get$elapsedTicks: function() {
      var t1, t2;
      t1 = this._start;
      if (t1 == null)
        return 0;
      t2 = this._stop;
      if (t2 == null) {
        t1 = H.Primitives_numMicroseconds();
        t2 = this._start;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 - t2;
        t1 = t2;
      } else {
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = t2 - t1;
      }
      return t1;
    }
  },
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    get$isEmpty: function(_) {
      return this._contents.length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._contents.length !== 0;
    },
    write$1: function(obj) {
      this._contents += typeof obj === "string" ? obj : H.S(obj);
    },
    writeAll$2: function(objects, separator) {
      var iterator, str;
      iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0)
        do {
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        } while (iterator.moveNext$0());
      else {
        this.write$1(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        }
      }
    },
    toString$0: function(_) {
      return this._contents;
    },
    StringBuffer$1: function($content) {
      this._contents = $content;
    },
    static: {StringBuffer$: function($content) {
        var t1 = new P.StringBuffer("");
        t1.StringBuffer$1($content);
        return t1;
      }}
  },
  Symbol: {
    "^": "Object;"
  }
}],
["dart.dom.html", "dart:html", , W, {
  "^": "",
  HttpRequest_request: function(url, method, mimeType, onProgress, requestHeaders, responseType, sendData, withCredentials) {
    var t1, completer, xhr;
    t1 = W.HttpRequest;
    completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t1)), [t1]);
    xhr = new XMLHttpRequest();
    C.HttpRequest_methods.open$3$async(xhr, method, url, true);
    xhr.overrideMimeType(mimeType);
    t1 = H.setRuntimeTypeInfo(new W._EventStream(xhr, C.EventStreamProvider_load._eventType, false), [null]);
    H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new W.HttpRequest_request_closure(completer, xhr)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    t1 = H.setRuntimeTypeInfo(new W._EventStream(xhr, C.EventStreamProvider_error._eventType, false), [null]);
    H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(completer.get$completeError()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    xhr.send();
    return completer.future;
  },
  _JenkinsSmiHash_combine: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _convertNativeToDart_XHR_Response: function(o) {
    if (!!J.getInterceptor(o).$isDocument)
      return o;
    return P.convertNativeToDart_AcceptStructuredClone(o, true);
  },
  _wrapZone: function(callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone)
      return callback;
    if (callback == null)
      return;
    return t1.bindUnaryCallback$2$runGuarded(callback, true);
  },
  HtmlElement: {
    "^": "Element;",
    "%": "HTMLAppletElement|HTMLBRElement|HTMLBaseElement|HTMLBodyElement|HTMLContentElement|HTMLDListElement|HTMLDataListElement|HTMLDetailsElement|HTMLDialogElement|HTMLDirectoryElement|HTMLDivElement|HTMLFontElement|HTMLFrameElement|HTMLFrameSetElement|HTMLHRElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLLIElement|HTMLLabelElement|HTMLLegendElement|HTMLMarqueeElement|HTMLMenuElement|HTMLMeterElement|HTMLModElement|HTMLOptGroupElement|HTMLOptionElement|HTMLParagraphElement|HTMLPreElement|HTMLProgressElement|HTMLQuoteElement|HTMLShadowElement|HTMLSpanElement|HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableElement|HTMLTableHeaderCellElement|HTMLTableRowElement|HTMLTableSectionElement|HTMLTemplateElement|HTMLTitleElement|HTMLTrackElement|HTMLUListElement|HTMLUnknownElement;HTMLElement"
  },
  AnchorElement: {
    "^": "HtmlElement;type=,origin=",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAnchorElement"
  },
  AreaElement: {
    "^": "HtmlElement;origin=",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAreaElement"
  },
  Blob: {
    "^": "Interceptor;size=,type=",
    size$0: function($receiver) {
      return $receiver.size.call$0();
    },
    "%": ";Blob"
  },
  ButtonElement: {
    "^": "HtmlElement;name=,type=",
    "%": "HTMLButtonElement"
  },
  CanvasElement: {
    "^": "HtmlElement;height=,width=",
    "%": "HTMLCanvasElement"
  },
  CharacterData: {
    "^": "Node;data=,length=",
    length$0: function($receiver) {
      return $receiver.length.call$0();
    },
    "%": "CDATASection|CharacterData|Comment|ProcessingInstruction|Text"
  },
  CompositionEvent: {
    "^": "UIEvent;data=",
    "%": "CompositionEvent"
  },
  DeviceOrientationEvent: {
    "^": "Event;alpha=",
    "%": "DeviceOrientationEvent"
  },
  Document: {
    "^": "Node;",
    $isDocument: true,
    "%": "Document|HTMLDocument|XMLDocument"
  },
  DocumentFragment: {
    "^": "Node;",
    get$children: function(receiver) {
      if (receiver._docChildren == null)
        receiver._docChildren = H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver)), [null]);
      return receiver._docChildren;
    },
    "%": "DocumentFragment|ShadowRoot"
  },
  DomError: {
    "^": "Interceptor;name=",
    "%": "DOMError|FileError"
  },
  DomException: {
    "^": "Interceptor;",
    get$name: function(receiver) {
      var errorName = receiver.name;
      if (P.Device_isWebKit() === true && errorName === "SECURITY_ERR")
        return "SecurityError";
      if (P.Device_isWebKit() === true && errorName === "SYNTAX_ERR")
        return "SyntaxError";
      return errorName;
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "DOMException"
  },
  Element: {
    "^": "Node;id=",
    get$children: function(receiver) {
      return new W._ChildrenElementList(receiver, receiver.children);
    },
    toString$0: function(receiver) {
      return receiver.localName;
    },
    $isElement: true,
    "%": ";Element"
  },
  EmbedElement: {
    "^": "HtmlElement;height=,name=,type=,width=",
    "%": "HTMLEmbedElement"
  },
  ErrorEvent: {
    "^": "Event;error=",
    "%": "ErrorEvent"
  },
  Event: {
    "^": "Interceptor;path=,type=",
    "%": "AudioProcessingEvent|AutocompleteErrorEvent|BeforeLoadEvent|BeforeUnloadEvent|CSSFontFaceLoadEvent|CloseEvent|CustomEvent|DeviceMotionEvent|HashChangeEvent|IDBVersionChangeEvent|InstallEvent|InstallPhaseEvent|MIDIConnectionEvent|MediaKeyEvent|MediaKeyMessageEvent|MediaKeyNeededEvent|MediaStreamEvent|MediaStreamTrackEvent|MutationEvent|OfflineAudioCompletionEvent|OverflowEvent|PageTransitionEvent|PopStateEvent|RTCDTMFToneChangeEvent|RTCDataChannelEvent|RTCIceCandidateEvent|SecurityPolicyViolationEvent|SpeechInputEvent|SpeechRecognitionEvent|StorageEvent|TrackEvent|TransitionEvent|WebGLContextEvent|WebKitAnimationEvent|WebKitTransitionEvent;Event"
  },
  EventTarget: {
    "^": "Interceptor;",
    addEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.addEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    removeEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.removeEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    "%": ";EventTarget"
  },
  FieldSetElement: {
    "^": "HtmlElement;name=,type=",
    "%": "HTMLFieldSetElement"
  },
  File: {
    "^": "Blob;name=",
    "%": "File"
  },
  FormElement: {
    "^": "HtmlElement;length=,name=",
    length$0: function($receiver) {
      return $receiver.length.call$0();
    },
    "%": "HTMLFormElement"
  },
  HtmlCollection: {
    "^": "Interceptor_ListMixin_ImmutableListMixin;",
    get$length: function(receiver) {
      return receiver.length;
    },
    length$0: function($receiver) {
      return this.get$length($receiver).call$0();
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "HTMLCollection|HTMLFormControlsCollection|HTMLOptionsCollection"
  },
  HttpRequest: {
    "^": "HttpRequestEventTarget;",
    get$response: function(receiver) {
      return W._convertNativeToDart_XHR_Response(receiver.response);
    },
    open$5$async$password$user: function(receiver, method, url, async, password, user) {
      return receiver.open(method, url, async, user, password);
    },
    open$3$async: function($receiver, method, url, async) {
      return $receiver.open(method, url, async);
    },
    send$1: function(receiver, data) {
      return receiver.send(data);
    },
    "%": "XMLHttpRequest"
  },
  HttpRequestEventTarget: {
    "^": "EventTarget;",
    "%": ";XMLHttpRequestEventTarget"
  },
  IFrameElement: {
    "^": "HtmlElement;height=,name=,width=",
    "%": "HTMLIFrameElement"
  },
  ImageElement: {
    "^": "HtmlElement;height=,width=",
    "%": "HTMLImageElement"
  },
  InputElement: {
    "^": "HtmlElement;height=,name=,size=,type=,width=",
    size$0: function($receiver) {
      return $receiver.size.call$0();
    },
    $isElement: true,
    "%": "HTMLInputElement"
  },
  KeygenElement: {
    "^": "HtmlElement;name=,type=",
    "%": "HTMLKeygenElement"
  },
  LinkElement: {
    "^": "HtmlElement;type=",
    "%": "HTMLLinkElement"
  },
  MapElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLMapElement"
  },
  MediaElement: {
    "^": "HtmlElement;error=",
    "%": "HTMLAudioElement;HTMLMediaElement"
  },
  MediaStream: {
    "^": "EventTarget;id=",
    "%": "MediaStream"
  },
  MessageEvent: {
    "^": "Event;origin=",
    get$data: function(receiver) {
      return P.convertNativeToDart_AcceptStructuredClone(receiver.data, true);
    },
    "%": "MessageEvent"
  },
  MetaElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLMetaElement"
  },
  MidiMessageEvent: {
    "^": "Event;data=",
    "%": "MIDIMessageEvent"
  },
  MidiOutput: {
    "^": "MidiPort;",
    send$2: function(receiver, data, timestamp) {
      return receiver.send(data, timestamp);
    },
    send$1: function($receiver, data) {
      return $receiver.send(data);
    },
    "%": "MIDIOutput"
  },
  MidiPort: {
    "^": "EventTarget;id=,name=,type=",
    "%": "MIDIInput;MIDIPort"
  },
  NavigatorUserMediaError: {
    "^": "Interceptor;name=",
    "%": "NavigatorUserMediaError"
  },
  Node: {
    "^": "EventTarget;",
    remove$0: function(receiver) {
      var t1 = receiver.parentNode;
      if (t1 != null)
        t1.removeChild(receiver);
    },
    replaceWith$1: function(receiver, otherNode) {
      var $parent, exception;
      try {
        $parent = receiver.parentNode;
        J._replaceChild$2$x($parent, otherNode, receiver);
      } catch (exception) {
        H.unwrapException(exception);
      }

      return receiver;
    },
    toString$0: function(receiver) {
      var t1 = receiver.nodeValue;
      return t1 == null ? J.Interceptor.prototype.toString$0.call(this, receiver) : t1;
    },
    _replaceChild$2: function(receiver, newChild, oldChild) {
      return receiver.replaceChild(newChild, oldChild);
    },
    "%": "DocumentType|Notation;Node"
  },
  NodeList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin0;",
    get$length: function(receiver) {
      return receiver.length;
    },
    length$0: function($receiver) {
      return this.get$length($receiver).call$0();
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "NodeList|RadioNodeList"
  },
  OListElement: {
    "^": "HtmlElement;start%,type=",
    "%": "HTMLOListElement"
  },
  ObjectElement: {
    "^": "HtmlElement;data=,height=,name=,type=,width=",
    "%": "HTMLObjectElement"
  },
  OutputElement: {
    "^": "HtmlElement;name=,type=",
    "%": "HTMLOutputElement"
  },
  ParamElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLParamElement"
  },
  ProgressEvent: {
    "^": "Event;",
    "%": "ProgressEvent|ResourceProgressEvent|XMLHttpRequestProgressEvent"
  },
  ScriptElement: {
    "^": "HtmlElement;type=",
    "%": "HTMLScriptElement"
  },
  SelectElement: {
    "^": "HtmlElement;length%,name=,size=,type=",
    length$0: function($receiver) {
      return $receiver.length.call$0();
    },
    size$0: function($receiver) {
      return $receiver.size.call$0();
    },
    "%": "HTMLSelectElement"
  },
  SourceElement: {
    "^": "HtmlElement;type=",
    "%": "HTMLSourceElement"
  },
  SpeechRecognitionError: {
    "^": "Event;error=",
    "%": "SpeechRecognitionError"
  },
  SpeechSynthesisEvent: {
    "^": "Event;name=",
    "%": "SpeechSynthesisEvent"
  },
  StyleElement: {
    "^": "HtmlElement;type=",
    "%": "HTMLStyleElement"
  },
  TextAreaElement: {
    "^": "HtmlElement;name=,type=",
    "%": "HTMLTextAreaElement"
  },
  TextEvent: {
    "^": "UIEvent;data=",
    "%": "TextEvent"
  },
  UIEvent: {
    "^": "Event;",
    "%": "DragEvent|FocusEvent|KeyboardEvent|MSPointerEvent|MouseEvent|MouseScrollEvent|MouseWheelEvent|PointerEvent|SVGZoomEvent|TouchEvent|WheelEvent;UIEvent"
  },
  VideoElement: {
    "^": "MediaElement;height=,width=",
    "%": "HTMLVideoElement"
  },
  Window: {
    "^": "EventTarget;name=",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "DOMWindow|Window"
  },
  _Attr: {
    "^": "Node;name=",
    "%": "Attr"
  },
  _ClientRect: {
    "^": "Interceptor;bottom=,height=,left=,right=,top=,width=",
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(receiver.width) + " x " + H.S(receiver.height);
    },
    $eq: function(receiver, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      t2 = receiver.left;
      t3 = t1.get$left(other);
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = receiver.top;
        t3 = t1.get$top(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = receiver.width;
          t3 = t1.get$width(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = receiver.height;
            t1 = t1.get$height(other);
            t1 = t2 == null ? t1 == null : t2 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(receiver) {
      var t1, t2, t3, t4, hash;
      t1 = J.get$hashCode$(receiver.left);
      t2 = J.get$hashCode$(receiver.top);
      t3 = J.get$hashCode$(receiver.width);
      t4 = J.get$hashCode$(receiver.height);
      t4 = W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4);
      hash = 536870911 & t4 + ((67108863 & t4) << 3 >>> 0);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    $isRectangle: true,
    $asRectangle: function() {
      return [null];
    },
    "%": "ClientRect|DOMRect"
  },
  _NamedNodeMap: {
    "^": "Interceptor_ListMixin_ImmutableListMixin1;",
    get$length: function(receiver) {
      return receiver.length;
    },
    length$0: function($receiver) {
      return this.get$length($receiver).call$0();
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true,
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "MozNamedAttrMap|NamedNodeMap"
  },
  _ChildrenElementList: {
    "^": "ListBase;_element,_childElements",
    get$isEmpty: function(_) {
      return this._element.firstElementChild == null;
    },
    get$length: function(_) {
      return this._childElements.length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    $index: function(_, index) {
      var t1 = this._childElements;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this._childElements;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      this._element.replaceChild(value, t1[index]);
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize element lists"));
    },
    add$1: function(_, value) {
      this._element.appendChild(value);
      return value;
    },
    get$iterator: function(_) {
      var t1 = this.toList$0(this);
      return new H.ListIterator(t1, t1.length, 0, null);
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort element lists"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    fillRange$3: function(_, start, end, fillValue) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    get$first: function(_) {
      var result = this._element.firstElementChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    $asListBase: function() {
      return [W.Element];
    },
    $asList: function() {
      return [W.Element];
    }
  },
  Interceptor_ListMixin: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin: {
    "^": "Interceptor_ListMixin+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  HttpRequest_request_closure0: {
    "^": "Closure:87;xhr_0",
    call$2: function(header, value) {
      this.xhr_0.setRequestHeader(header, value);
    }
  },
  HttpRequest_request_closure: {
    "^": "Closure:88;completer_1,xhr_2",
    call$1: function(e) {
      var t1, t2, t3;
      t1 = this.xhr_2;
      t2 = t1.status;
      if (typeof t2 !== "number")
        return t2.$ge();
      t2 = t2 >= 200 && t2 < 300 || t2 === 0 || t2 === 304;
      t3 = this.completer_1;
      if (t2) {
        t2 = t3.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
      } else
        t3.completeError$1(e);
    }
  },
  _ChildNodeListLazy: {
    "^": "ListBase;_this",
    get$first: function(_) {
      var result = this._this.firstChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    add$1: function(_, value) {
      this._this.appendChild(value);
    },
    $indexSet: function(_, index, value) {
      var t1, t2;
      t1 = this._this;
      t2 = t1.childNodes;
      if (index >>> 0 !== index || index >= t2.length)
        return H.ioore(t2, index);
      t1.replaceChild(value, t2[index]);
    },
    get$iterator: function(_) {
      return C.NodeList_methods.get$iterator(this._this.childNodes);
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort Node list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on Node list"));
    },
    fillRange$3: function(_, start, end, fill) {
      throw H.wrapException(P.UnsupportedError$("Cannot fillRange on Node list"));
    },
    get$length: function(_) {
      return this._this.childNodes.length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    set$length: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot set length on immutable List."));
    },
    $index: function(_, index) {
      var t1 = this._this.childNodes;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $asListBase: function() {
      return [W.Node];
    },
    $asList: function() {
      return [W.Node];
    }
  },
  Interceptor_ListMixin0: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin0: {
    "^": "Interceptor_ListMixin0+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin1: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  Interceptor_ListMixin_ImmutableListMixin1: {
    "^": "Interceptor_ListMixin1+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: true
  },
  EventStreamProvider: {
    "^": "Object;_eventType"
  },
  _EventStream: {
    "^": "Stream;_html$_target,_eventType,_useCapture",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = new W._EventStreamSubscription(0, this._html$_target, this._eventType, W._wrapZone(onData), this._useCapture);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      t1._tryResume$0();
      return t1;
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  },
  _EventStreamSubscription: {
    "^": "StreamSubscription;_pauseCount,_html$_target,_eventType,_html$_onData,_useCapture",
    cancel$0: function() {
      if (this._html$_target == null)
        return;
      this._unlisten$0();
      this._html$_target = null;
      this._html$_onData = null;
      return;
    },
    pause$1: function(_, resumeSignal) {
      if (this._html$_target == null)
        return;
      ++this._pauseCount;
      this._unlisten$0();
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      if (this._html$_target == null || this._pauseCount <= 0)
        return;
      --this._pauseCount;
      this._tryResume$0();
    },
    _tryResume$0: function() {
      var t1 = this._html$_onData;
      if (t1 != null && this._pauseCount <= 0)
        J.addEventListener$3$x(this._html$_target, this._eventType, t1, this._useCapture);
    },
    _unlisten$0: function() {
      var t1 = this._html$_onData;
      if (t1 != null)
        J.removeEventListener$3$x(this._html$_target, this._eventType, t1, this._useCapture);
    }
  },
  ImmutableListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return new W.FixedSizeListIterator(receiver, this.get$length(receiver), -1, null);
    },
    add$1: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    sort$1: function(receiver, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort immutable List."));
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on immutable List."));
    },
    fillRange$3: function(receiver, start, end, fillValue) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an immutable List."));
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true
  },
  FixedSizeListIterator: {
    "^": "Object;_array,_html$_length,_position,_html$_current",
    moveNext$0: function() {
      var nextPosition, t1;
      nextPosition = this._position + 1;
      t1 = this._html$_length;
      if (nextPosition < t1) {
        this._html$_current = J.$index$asx(this._array, nextPosition);
        this._position = nextPosition;
        return true;
      }
      this._html$_current = null;
      this._position = t1;
      return false;
    },
    get$current: function() {
      return this._html$_current;
    }
  }
}],
["dart.dom.svg", "dart:svg", , P, {
  "^": "",
  FEBlendElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEBlendElement"
  },
  FEColorMatrixElement: {
    "^": "SvgElement;type=,height=,width=,x=,y=",
    "%": "SVGFEColorMatrixElement"
  },
  FEComponentTransferElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEComponentTransferElement"
  },
  FECompositeElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFECompositeElement"
  },
  FEConvolveMatrixElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEConvolveMatrixElement"
  },
  FEDiffuseLightingElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEDiffuseLightingElement"
  },
  FEDisplacementMapElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    scale$1: function($receiver, arg0) {
      return $receiver.scale.call$1(arg0);
    },
    "%": "SVGFEDisplacementMapElement"
  },
  FEFloodElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEFloodElement"
  },
  FEGaussianBlurElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEGaussianBlurElement"
  },
  FEImageElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEImageElement"
  },
  FEMergeElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEMergeElement"
  },
  FEMorphologyElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEMorphologyElement"
  },
  FEOffsetElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEOffsetElement"
  },
  FEPointLightElement: {
    "^": "SvgElement;x=,y=,z=",
    "%": "SVGFEPointLightElement"
  },
  FESpecularLightingElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFESpecularLightingElement"
  },
  FESpotLightElement: {
    "^": "SvgElement;x=,y=,z=",
    "%": "SVGFESpotLightElement"
  },
  FETileElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFETileElement"
  },
  FETurbulenceElement: {
    "^": "SvgElement;type=,height=,width=,x=,y=",
    "%": "SVGFETurbulenceElement"
  },
  FilterElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFilterElement"
  },
  ForeignObjectElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGForeignObjectElement"
  },
  GeometryElement: {
    "^": "GraphicsElement;",
    "%": "SVGCircleElement|SVGEllipseElement|SVGLineElement|SVGPathElement|SVGPolygonElement|SVGPolylineElement;SVGGeometryElement"
  },
  GraphicsElement: {
    "^": "SvgElement;",
    "%": "SVGAElement|SVGClipPathElement|SVGDefsElement|SVGGElement|SVGSwitchElement;SVGGraphicsElement"
  },
  ImageElement0: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGImageElement"
  },
  MaskElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGMaskElement"
  },
  PatternElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGPatternElement"
  },
  RectElement: {
    "^": "GeometryElement;height=,width=,x=,y=",
    "%": "SVGRectElement"
  },
  ScriptElement0: {
    "^": "SvgElement;type=",
    "%": "SVGScriptElement"
  },
  StyleElement0: {
    "^": "SvgElement;type=",
    "%": "SVGStyleElement"
  },
  SvgElement: {
    "^": "Element;",
    get$children: function(receiver) {
      return H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver)), [W.Element]);
    },
    "%": "SVGAltGlyphDefElement|SVGAltGlyphItemElement|SVGAnimateElement|SVGAnimateMotionElement|SVGAnimateTransformElement|SVGAnimationElement|SVGComponentTransferFunctionElement|SVGCursorElement|SVGDescElement|SVGDiscardElement|SVGFEDistantLightElement|SVGFEDropShadowElement|SVGFEFuncAElement|SVGFEFuncBElement|SVGFEFuncGElement|SVGFEFuncRElement|SVGFEMergeNodeElement|SVGFontElement|SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement|SVGGlyphElement|SVGGlyphRefElement|SVGGradientElement|SVGHKernElement|SVGLinearGradientElement|SVGMPathElement|SVGMarkerElement|SVGMetadataElement|SVGMissingGlyphElement|SVGRadialGradientElement|SVGSetElement|SVGStopElement|SVGSymbolElement|SVGTitleElement|SVGVKernElement|SVGViewElement;SVGElement"
  },
  SvgSvgElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGSVGElement"
  },
  TextContentElement: {
    "^": "GraphicsElement;",
    "%": "SVGTextPathElement;SVGTextContentElement"
  },
  TextPositioningElement: {
    "^": "TextContentElement;x=,y=",
    "%": "SVGAltGlyphElement|SVGTSpanElement|SVGTextElement|SVGTextPositioningElement"
  },
  UseElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGUseElement"
  }
}],
["dart.isolate", "dart:isolate", , P, {
  "^": "",
  ReceivePort_ReceivePort: function() {
    var t1, t2, t3;
    t1 = $.RawReceivePortImpl__nextFreeId;
    $.RawReceivePortImpl__nextFreeId = t1 + 1;
    t2 = new H.RawReceivePortImpl(t1, null, false);
    t3 = init.globalState.currentContext;
    t3._addRegistration$2(t1, t2);
    t3._updateGlobalState$0();
    t3 = new H.ReceivePortImpl(t2, null);
    t3.ReceivePortImpl$fromRawReceivePort$1(t2);
    return t3;
  },
  Capability: {
    "^": "Object;",
    $isCapability: true,
    static: {Capability_Capability: function() {
        return new H.CapabilityImpl((Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296);
      }}
  },
  SendPort: {
    "^": "Object;",
    $isSendPort: true,
    $isCapability: true
  }
}],
["dart.math", "dart:math", , P, {
  "^": "",
  _JenkinsSmiHash_combine0: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _JenkinsSmiHash_finish: function(hash) {
    hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
    hash ^= hash >>> 11;
    return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
  },
  min: function(a, b) {
    if (typeof a !== "number")
      throw H.wrapException(P.ArgumentError$(a));
    if (typeof b !== "number")
      throw H.wrapException(P.ArgumentError$(b));
    if (a > b)
      return b;
    if (a < b)
      return a;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return (a + b) * a * b;
      if (a === 0 && C.JSDouble_methods.get$isNegative(b) || C.JSDouble_methods.get$isNaN(b))
        return b;
      return a;
    }
    return a;
  },
  max: function(a, b) {
    var t1;
    if (typeof a !== "number")
      throw H.wrapException(P.ArgumentError$(a));
    if (typeof b !== "number")
      throw H.wrapException(P.ArgumentError$(b));
    if (a > b)
      return a;
    if (a < b)
      return b;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return a + b;
      if (C.JSDouble_methods.get$isNaN(b))
        return b;
      return a;
    }
    if (b === 0)
      t1 = a === 0 ? 1 / a < 0 : a < 0;
    else
      t1 = false;
    if (t1)
      return b;
    return a;
  },
  _JSRandom: {
    "^": "Object;",
    nextInt$1: function(max) {
      if (max <= 0 || max > 4294967296)
        throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + max));
      return Math.random() * max >>> 0;
    }
  }
}],
["dart.typed_data", "dart:typed_data", , P, {
  "^": "",
  Uint64List_Uint64List: function($length) {
    throw H.wrapException(P.UnsupportedError$("Uint64List not supported by dart2js."));
  },
  Float32List: {
    "^": "Object;",
    $isList: true,
    $asList: function() {
      return [J.JSDouble];
    },
    $isEfficientLength: true
  },
  Uint32List: {
    "^": "Object;",
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true
  },
  Uint8List: {
    "^": "Object;",
    $isUint8List: true,
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true
  }
}],
["dart.typed_data.implementation", "dart:_native_typed_data", , H, {
  "^": "",
  _checkViewArguments: function(buffer, offsetInBytes, $length) {
    if (!J.getInterceptor(buffer).$isNativeByteBuffer)
      throw H.wrapException(P.ArgumentError$("Invalid view buffer"));
    if (typeof offsetInBytes !== "number" || Math.floor(offsetInBytes) !== offsetInBytes)
      throw H.wrapException(P.ArgumentError$("Invalid view offsetInBytes " + H.S(offsetInBytes)));
    if ($length != null && (typeof $length !== "number" || Math.floor($length) !== $length))
      throw H.wrapException(P.ArgumentError$("Invalid view length " + H.S($length)));
  },
  _ensureNativeList: function(list) {
    var t1, t2, result, i, t3;
    t1 = J.getInterceptor(list);
    if (!!t1.$isJSIndexable)
      return list;
    t2 = t1.get$length(list);
    if (typeof t2 !== "number")
      return H.iae(t2);
    result = Array(t2);
    result.fixed$length = init;
    t2 = result.length;
    i = 0;
    while (true) {
      t3 = t1.get$length(list);
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (!(i < t3))
        break;
      t3 = t1.$index(list, i);
      if (i >= t2)
        return H.ioore(result, i);
      result[i] = t3;
      ++i;
    }
    return result;
  },
  NativeFloat32List_NativeFloat32List$view: function(buffer, offsetInBytes, $length) {
    H._checkViewArguments(buffer, offsetInBytes, $length);
    return new Float32Array(buffer, offsetInBytes);
  },
  NativeUint32List_NativeUint32List$view: function(buffer, offsetInBytes, $length) {
    H._checkViewArguments(buffer, offsetInBytes, $length);
    return new Uint32Array(buffer, offsetInBytes);
  },
  NativeUint8List_NativeUint8List$view: function(buffer, offsetInBytes, $length) {
    H._checkViewArguments(buffer, offsetInBytes, $length);
    return $length == null ? new Uint8Array(buffer, offsetInBytes) : new Uint8Array(buffer, offsetInBytes, $length);
  },
  NativeByteBuffer: {
    "^": "Interceptor;",
    $isNativeByteBuffer: true,
    $isByteBuffer: true,
    "%": "ArrayBuffer"
  },
  NativeTypedData: {
    "^": "Interceptor;buffer=,offsetInBytes:byteOffset=",
    _invalidIndex$2: function(receiver, index, $length) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$ge(index, $length))
        throw H.wrapException(P.RangeError$range(index, 0, $length));
      else
        throw H.wrapException(P.ArgumentError$("Invalid list index " + H.S(index)));
    },
    _checkIndex$2: function(receiver, index, $length) {
      if (index >>> 0 !== index || index >= $length)
        this._invalidIndex$2(receiver, index, $length);
    },
    _checkSublistArguments$3: function(receiver, start, end, $length) {
      var t1 = $length + 1;
      this._checkIndex$2(receiver, start, t1);
      if (end == null)
        return $length;
      this._checkIndex$2(receiver, end, t1);
      if (J.$gt$n(start, end))
        throw H.wrapException(P.RangeError$range(start, 0, end));
      return end;
    },
    "%": "DataView;ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|NativeTypedArray_ListMixin0|NativeTypedArray_ListMixin_FixedLengthListMixin0|NativeTypedArrayOfInt"
  },
  NativeFloat32List: {
    "^": "NativeTypedArrayOfDouble;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    sublist$2: function(receiver, start, end) {
      return new Float32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [J.JSDouble];
    },
    $isEfficientLength: true,
    "%": "Float32Array"
  },
  NativeFloat64List: {
    "^": "NativeTypedArrayOfDouble;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    sublist$2: function(receiver, start, end) {
      return new Float64Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [J.JSDouble];
    },
    $isEfficientLength: true,
    "%": "Float64Array"
  },
  NativeInt16List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    sublist$2: function(receiver, start, end) {
      return new Int16Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true,
    "%": "Int16Array"
  },
  NativeInt32List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    sublist$2: function(receiver, start, end) {
      return new Int32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true,
    "%": "Int32Array"
  },
  NativeInt8List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    sublist$2: function(receiver, start, end) {
      return new Int8Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true,
    "%": "Int8Array"
  },
  NativeUint16List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    sublist$2: function(receiver, start, end) {
      return new Uint16Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true,
    "%": "Uint16Array"
  },
  NativeUint32List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    sublist$2: function(receiver, start, end) {
      return new Uint32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true,
    "%": "Uint32Array"
  },
  NativeUint8ClampedList: {
    "^": "NativeTypedArrayOfInt;",
    get$length: function(receiver) {
      return receiver.length;
    },
    length$0: function($receiver) {
      return this.get$length($receiver).call$0();
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8ClampedArray(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true,
    "%": "CanvasPixelArray|Uint8ClampedArray"
  },
  NativeUint8List: {
    "^": "NativeTypedArrayOfInt;",
    get$length: function(receiver) {
      return receiver.length;
    },
    length$0: function($receiver) {
      return this.get$length($receiver).call$0();
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isUint8List: true,
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true,
    "%": ";Uint8Array"
  },
  NativeTypedArray: {
    "^": "NativeTypedData;",
    get$length: function(receiver) {
      return receiver.length;
    },
    length$0: function($receiver) {
      return this.get$length($receiver).call$0();
    },
    _setRangeFast$4: function(receiver, start, end, source, skipCount) {
      var t1, count, sourceLength;
      t1 = receiver.length + 1;
      this._checkIndex$2(receiver, start, t1);
      this._checkIndex$2(receiver, end, t1);
      if (J.$gt$n(start, end))
        throw H.wrapException(P.RangeError$range(start, 0, end));
      count = J.$sub$n(end, start);
      if (J.$lt$n(skipCount, 0))
        throw H.wrapException(P.ArgumentError$(skipCount));
      sourceLength = source.length;
      if (typeof skipCount !== "number")
        return H.iae(skipCount);
      if (typeof count !== "number")
        return H.iae(count);
      if (sourceLength - skipCount < count)
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (skipCount !== 0 || sourceLength !== count)
        source = source.subarray(skipCount, skipCount + count);
      receiver.set(source, start);
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true
  },
  NativeTypedArrayOfDouble: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;",
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfDouble) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      P.ListMixin.prototype.setRange$4.call(this, receiver, start, end, iterable, skipCount);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isNativeTypedArrayOfDouble: true,
    $isList: true,
    $asList: function() {
      return [J.JSDouble];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [J.JSDouble];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin: {
    "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;"
  },
  NativeTypedArrayOfInt: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin0;",
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfInt) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      P.ListMixin.prototype.setRange$4.call(this, receiver, start, end, iterable, skipCount);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isNativeTypedArrayOfInt: true,
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin0: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [J.JSInt];
    },
    $isEfficientLength: true
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin0: {
    "^": "NativeTypedArray_ListMixin0+FixedLengthListMixin;"
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log == "function") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["dartray_web", "package:dartray/dartray_web.dart", , T, {
  "^": "",
  RenderManager: {
    "^": "RenderManagerInterface;pbrt,isolate,scenePath,includePaths,futures,resources",
    loadFile$2: function(path, future) {
      var t1, c;
      t1 = [J.JSArray, J.JSInt];
      c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t1)), [t1]);
      this._loadFile$1(path).then$1(new T.RenderManager_loadFile_closure(c)).catchError$1(new T.RenderManager_loadFile_closure0(c));
      return c.future;
    },
    loadFile$1: function(path) {
      return this.loadFile$2(path, null);
    },
    _loadFile$1: function(path) {
      var t1, t2, c, t3, id, c0, cmd;
      t1 = {};
      t1.path_0 = path;
      t2 = [J.JSArray, J.JSInt];
      c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t2)), [t2]);
      t2 = this.isolate;
      t3 = t1.path_0;
      if (t2 != null) {
        t1 = P.LinkedHashMap_LinkedHashMap$_literal(["cmd", "file", "path", t3], null, null);
        id = t2.rng.nextInt$1(4294967295);
        c0 = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        cmd = P.LinkedHashMap_LinkedHashMap$_literal(["cmd", "request", "id", id, "msg", t1], null, null);
        J.send$1$x(t2.sendPort, cmd);
        t2.requests.$indexSet(0, id, c0);
        c0.future.then$1(new T.RenderManager__loadFile_closure(c));
      } else {
        path = C.JSString_methods.$add(this.scenePath + "/", t3);
        t1.path_0 = path;
        W.HttpRequest_request(path, "GET", "text/plain; charset=x-user-defined", null, null, null, null, null).then$1(new T.RenderManager__loadFile_closure0(c)).catchError$1(new T.RenderManager__loadFile_closure1(t1));
      }
      return c.future;
    }
  },
  RenderManager_loadFile_closure: {
    "^": "Closure:88;c_0",
    call$1: function(bytes) {
      var t1 = this.c_0.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(bytes);
    }
  },
  RenderManager_loadFile_closure0: {
    "^": "Closure:88;c_1",
    call$1: function(e) {
      var t1 = J.toString$0(e);
      $.Log.call$2(2, t1);
      t1 = this.c_1.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  RenderManager__loadFile_closure: {
    "^": "Closure:88;c_1",
    call$1: function(bytes) {
      var t1, t2;
      if (typeof bytes === "string") {
        t1 = C.JSString_methods.get$codeUnits(bytes);
        t2 = this.c_1.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
        return;
      } else if (!!J.getInterceptor(bytes).$isByteBuffer) {
        t1 = H.NativeUint8List_NativeUint8List$view(bytes, 0, null);
        t2 = this.c_1.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
        return;
      } else {
        t1 = H.checkSubtype(bytes, "$isList", [J.JSInt], "$asList");
        if (t1) {
          t1 = this.c_1.future;
          if (t1._state !== 0)
            H.throwExpression(P.StateError$("Future already completed"));
          t1._asyncComplete$1(bytes);
          return;
        } else
          $.Log.call$2(2, "Unknown HttpRequest response type");
      }
    }
  },
  RenderManager__loadFile_closure0: {
    "^": "Closure:88;c_2",
    call$1: function(resp) {
      var t1, t2;
      t1 = J.get$response$x(resp);
      if (typeof t1 === "string") {
        t1 = J.get$codeUnits$s(W._convertNativeToDart_XHR_Response(resp.response));
        t2 = this.c_2.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
        return;
      } else if (!!J.getInterceptor(W._convertNativeToDart_XHR_Response(resp.response)).$isByteBuffer) {
        t1 = H.NativeUint8List_NativeUint8List$view(W._convertNativeToDart_XHR_Response(resp.response), 0, null);
        t2 = this.c_2.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
        return;
      } else {
        t1 = W._convertNativeToDart_XHR_Response(resp.response);
        t2 = H.checkSubtype(t1, "$isList", [J.JSInt], "$asList");
        if (t2) {
          t1 = W._convertNativeToDart_XHR_Response(resp.response);
          t2 = this.c_2.future;
          if (t2._state !== 0)
            H.throwExpression(P.StateError$("Future already completed"));
          t2._asyncComplete$1(t1);
          return;
        } else
          $.Log.call$2(2, "Unknown HttpRequest response type");
      }
    }
  },
  RenderManager__loadFile_closure1: {
    "^": "Closure:88;box_0",
    call$1: function(e) {
      var t1 = "Error Loading Resource " + H.S(this.box_0.path_0) + ": " + H.S(e);
      $.Log.call$2(2, t1);
    }
  }
}],
["film", "package:dartray/film/film.dart", , R, {
  "^": "",
  ImageFilm: {
    "^": "Film;cropWindow,image,filename,previewCallback,output,samplesProcessed,previewCount,filter,xPixelStart,yPixelStart,xPixelCount,yPixelCount,_Lxyz,_splatXYZ,_weightSum,_filterTable,_gamma,xResolution,yResolution",
    previewCallback$1: function(arg0) {
      return this.previewCallback.call$1(arg0);
    },
    addSample$2: function(sample, $L) {
      var dimageX, dimageY, t1, x0, x1, y0, y1, t2, xyz, ifx, x, t3, ify, y, t4, pixels, rgb, splatRGB, t5, t6, t7, oi, t8, t9, offset, filterWt, pi, pi3, t10, t11, weightSum, invWt, t12;
      dimageX = J.$sub$n(sample.get$imageX(), 0.5);
      dimageY = J.$sub$n(sample.imageY, 0.5);
      t1 = J.getInterceptor$n(dimageX);
      x0 = J.ceil$0$n(t1.$sub(dimageX, this.filter.get$xWidth()));
      x1 = J.floor$0$n(t1.$add(dimageX, this.filter.get$xWidth()));
      t1 = J.getInterceptor$n(dimageY);
      y0 = J.ceil$0$n(t1.$sub(dimageY, this.filter.get$yWidth()));
      y1 = J.floor$0$n(t1.$add(dimageY, this.filter.get$yWidth()));
      x0 = P.max(x0, this.xPixelStart);
      t1 = this.xPixelStart;
      t2 = this.xPixelCount;
      if (typeof t2 !== "number")
        return H.iae(t2);
      x1 = P.min(x1, t1 + t2 - 1);
      y0 = P.max(y0, this.yPixelStart);
      t2 = this.yPixelStart;
      t1 = this.yPixelCount;
      if (typeof t1 !== "number")
        return H.iae(t1);
      y1 = P.min(y1, t2 + t1 - 1);
      t1 = x1 - x0;
      if (t1 < 0 || y1 - y0 < 0)
        return;
      xyz = $L.toXYZ$0();
      ++t1;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      ifx = new Int32Array(t1);
      for (t1 = ifx.length, x = x0; x <= x1; ++x) {
        if (typeof dimageX !== "number")
          return H.iae(dimageX);
        t2 = x - x0;
        t3 = P.min(C.JSNumber_methods.toInt$0(Math.floor(Math.abs((x - dimageX) * this.filter.get$invXWidth() * 16))), 15);
        if (t2 >>> 0 !== t2 || t2 >= t1)
          return H.ioore(ifx, t2);
        ifx[t2] = t3;
      }
      t2 = y1 - y0 + 1;
      if (typeof t2 !== "number" || Math.floor(t2) !== t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
      ify = new Int32Array(t2);
      for (t2 = ify.length, y = y0; y <= y1; ++y) {
        if (typeof dimageY !== "number")
          return H.iae(dimageY);
        t3 = y - y0;
        t4 = P.min(C.JSNumber_methods.toInt$0(Math.floor(Math.abs((y - dimageY) * this.filter.get$invYWidth() * 16))), 15);
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(ify, t3);
        ify[t3] = t4;
      }
      pixels = this.image.getBytes$0();
      rgb = [0, 0, 0];
      splatRGB = [0, 0, 0];
      for (t3 = this._gamma, t4 = pixels.length, t5 = xyz.c, t6 = t5.length, y = y0; y <= y1; ++y) {
        t7 = this.xPixelCount;
        if (typeof t7 !== "number")
          return H.iae(t7);
        oi = (y0 * t7 + x0) * 4;
        for (t7 = y - y0, x = x0; x <= x1; ++x, oi += 4) {
          if (t7 >>> 0 !== t7 || t7 >= t2)
            return H.ioore(ify, t7);
          t8 = ify[t7];
          t9 = x - x0;
          if (t9 >>> 0 !== t9 || t9 >= t1)
            return H.ioore(ifx, t9);
          offset = t8 * 16 + ifx[t9];
          t9 = this._filterTable;
          if (offset < 0 || offset >= t9.length)
            return H.ioore(t9, offset);
          filterWt = t9[offset];
          t9 = this.yPixelStart;
          t8 = this.xPixelCount;
          if (typeof t8 !== "number")
            return H.iae(t8);
          pi = (y - t9) * t8 + (x - this.xPixelStart);
          pi3 = pi * 3;
          t8 = this._Lxyz;
          t9 = t8.length;
          if (pi3 >>> 0 !== pi3 || pi3 >= t9)
            return H.ioore(t8, pi3);
          t10 = t8[pi3];
          if (0 >= t6)
            return H.ioore(t5, 0);
          t8[pi3] = t10 + filterWt * t5[0];
          t10 = pi3 + 1;
          if (t10 >= t9)
            return H.ioore(t8, t10);
          t11 = t8[t10];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t8[t10] = t11 + filterWt * t5[1];
          t11 = pi3 + 2;
          if (t11 >= t9)
            return H.ioore(t8, t11);
          t9 = t8[t11];
          if (2 >= t6)
            return H.ioore(t5, 2);
          t8[t11] = t9 + filterWt * t5[2];
          t9 = this._weightSum;
          if (pi >>> 0 !== pi || pi >= t9.length)
            return H.ioore(t9, pi);
          t9[pi] = t9[pi] + filterWt;
          G.Spectrum_XYZToRGB(t8[pi3], t8[t10], t8[t11], rgb);
          t8 = this._weightSum;
          if (pi >= t8.length)
            return H.ioore(t8, pi);
          weightSum = t8[pi];
          if (weightSum !== 0) {
            invWt = 1 / weightSum;
            rgb[0] = P.max(0, J.$mul$ns(rgb[0], invWt));
            rgb[1] = P.max(0, J.$mul$ns(rgb[1], invWt));
            rgb[2] = P.max(0, J.$mul$ns(rgb[2], invWt));
          }
          t8 = this._splatXYZ;
          t9 = t8.length;
          if (pi3 >= t9)
            return H.ioore(t8, pi3);
          t12 = t8[pi3];
          if (t10 >= t9)
            return H.ioore(t8, t10);
          t10 = t8[t10];
          if (t11 >= t9)
            return H.ioore(t8, t11);
          G.Spectrum_XYZToRGB(t12, t10, t8[t11], splatRGB);
          rgb[0] = J.$add$ns(rgb[0], splatRGB[0]);
          rgb[1] = J.$add$ns(rgb[1], splatRGB[1]);
          rgb[2] = J.$add$ns(rgb[2], splatRGB[2]);
          t11 = C.JSInt_methods.clamp$2(J.floor$0$n(J.$mul$ns(rgb[0], 255)), 0, 255);
          if (t11 >>> 0 !== t11 || t11 >= 256)
            return H.ioore(t3, t11);
          t11 = t3[t11];
          if (oi >>> 0 !== oi || oi >= t4)
            return H.ioore(pixels, oi);
          pixels[oi] = t11;
          t11 = oi + 1;
          t8 = C.JSInt_methods.clamp$2(J.floor$0$n(J.$mul$ns(rgb[1], 255)), 0, 255);
          if (t8 >>> 0 !== t8 || t8 >= 256)
            return H.ioore(t3, t8);
          t8 = t3[t8];
          if (t11 >= t4)
            return H.ioore(pixels, t11);
          pixels[t11] = t8;
          t8 = oi + 2;
          t11 = C.JSInt_methods.clamp$2(J.floor$0$n(J.$mul$ns(rgb[2], 255)), 0, 255);
          if (t11 >>> 0 !== t11 || t11 >= 256)
            return H.ioore(t3, t11);
          t11 = t3[t11];
          if (t8 >= t4)
            return H.ioore(pixels, t8);
          pixels[t8] = t11;
          t11 = oi + 3;
          if (t11 >= t4)
            return H.ioore(pixels, t11);
          pixels[t11] = 255;
        }
      }
      t1 = ++this.samplesProcessed;
      if (this.previewCallback != null && C.JSInt_methods.$mod(t1, this.previewCount) === 0)
        this.previewCallback$1(this.image);
    },
    splat$2: function(sample, $L) {
      var xyz, x, y, t1, t2, t3, pi, pi3, t4, t5, t6, rgb, splatRGB, weightSum, invWt, pixels, oi;
      if ($L.hasNaNs$0()) {
        $.Log.call$2(1, "ImageFilm ignoring splatted spectrum with NaN values");
        return;
      }
      xyz = $L.toXYZ$0();
      x = J.floor$0$n(sample.imageX);
      y = J.floor$0$n(sample.imageY);
      t1 = this.xPixelStart;
      if (x >= t1) {
        t2 = this.xPixelCount;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(x - t1 >= t2)) {
          t2 = this.yPixelStart;
          if (y >= t2) {
            t3 = this.yPixelCount;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = y - t2 >= t3;
            t2 = t3;
          } else
            t2 = true;
        } else
          t2 = true;
      } else
        t2 = true;
      if (t2)
        return;
      t2 = this.yPixelStart;
      t3 = this.xPixelCount;
      if (typeof t3 !== "number")
        return H.iae(t3);
      pi = (y - t2) * t3 + (x - t1);
      pi3 = pi * 3;
      t1 = this._splatXYZ;
      t3 = t1.length;
      if (pi3 >>> 0 !== pi3 || pi3 >= t3)
        return H.ioore(t1, pi3);
      t2 = t1[pi3];
      t4 = xyz.c;
      t5 = t4.length;
      if (0 >= t5)
        return H.ioore(t4, 0);
      t1[pi3] = t2 + t4[0];
      t2 = pi3 + 1;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      t6 = t1[t2];
      if (1 >= t5)
        return H.ioore(t4, 1);
      t1[t2] = t6 + t4[1];
      t6 = pi3 + 2;
      if (t6 >= t3)
        return H.ioore(t1, t6);
      t3 = t1[t6];
      if (2 >= t5)
        return H.ioore(t4, 2);
      t1[t6] = t3 + t4[2];
      rgb = [0, 0, 0];
      splatRGB = [0, 0, 0];
      t4 = this._Lxyz;
      t3 = t4.length;
      if (pi3 >= t3)
        return H.ioore(t4, pi3);
      t1 = t4[pi3];
      if (t2 >= t3)
        return H.ioore(t4, t2);
      t5 = t4[t2];
      if (t6 >= t3)
        return H.ioore(t4, t6);
      G.Spectrum_XYZToRGB(t1, t5, t4[t6], rgb);
      t4 = this._weightSum;
      if (pi >>> 0 !== pi || pi >= t4.length)
        return H.ioore(t4, pi);
      weightSum = t4[pi];
      if (weightSum !== 0) {
        invWt = 1 / weightSum;
        rgb[0] = P.max(0, J.$mul$ns(rgb[0], invWt));
        rgb[1] = P.max(0, J.$mul$ns(rgb[1], invWt));
        rgb[2] = P.max(0, J.$mul$ns(rgb[2], invWt));
      }
      t1 = this._splatXYZ;
      t3 = t1.length;
      if (pi3 >= t3)
        return H.ioore(t1, pi3);
      t4 = t1[pi3];
      if (t2 >= t3)
        return H.ioore(t1, t2);
      t2 = t1[t2];
      if (t6 >= t3)
        return H.ioore(t1, t6);
      G.Spectrum_XYZToRGB(t4, t2, t1[t6], splatRGB);
      rgb[0] = J.$add$ns(rgb[0], splatRGB[0]);
      rgb[1] = J.$add$ns(rgb[1], splatRGB[1]);
      rgb[2] = J.$add$ns(rgb[2], splatRGB[2]);
      pixels = this.image.getBytes$0();
      oi = pi * 4;
      t6 = this._gamma;
      t1 = C.JSInt_methods.clamp$2(J.floor$0$n(J.$mul$ns(rgb[0], 255)), 0, 255);
      if (t1 >>> 0 !== t1 || t1 >= 256)
        return H.ioore(t6, t1);
      t1 = t6[t1];
      t2 = pixels.length;
      if (oi >= t2)
        return H.ioore(pixels, oi);
      pixels[oi] = t1;
      t1 = oi + 1;
      t4 = C.JSInt_methods.clamp$2(J.floor$0$n(J.$mul$ns(rgb[1], 255)), 0, 255);
      if (t4 >>> 0 !== t4 || t4 >= 256)
        return H.ioore(t6, t4);
      t4 = t6[t4];
      if (t1 >= t2)
        return H.ioore(pixels, t1);
      pixels[t1] = t4;
      t4 = oi + 2;
      t1 = C.JSInt_methods.clamp$2(J.floor$0$n(J.$mul$ns(rgb[2], 255)), 0, 255);
      if (t1 >>> 0 !== t1 || t1 >= 256)
        return H.ioore(t6, t1);
      t1 = t6[t1];
      if (t4 >= t2)
        return H.ioore(pixels, t4);
      pixels[t4] = t1;
      t1 = oi + 3;
      if (t1 >= t2)
        return H.ioore(pixels, t1);
      pixels[t1] = 255;
      t1 = ++this.samplesProcessed;
      if (this.previewCallback != null && C.JSInt_methods.$mod(t1, this.previewCount) === 0)
        this.previewCallback$1(this.image);
    },
    getSampleExtent$1: function(extent) {
      var t1, t2, t3;
      t1 = this.xPixelStart;
      t2 = this.filter.get$xWidth();
      if (typeof t2 !== "number")
        return H.iae(t2);
      extent[0] = C.JSNumber_methods.toInt$0(Math.floor(t1 + 0.5 - t2));
      t2 = this.xPixelStart;
      t1 = this.xPixelCount;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t3 = this.filter.get$xWidth();
      if (typeof t3 !== "number")
        return H.iae(t3);
      extent[1] = C.JSNumber_methods.toInt$0(Math.ceil(t2 + 0.5 + t1 + t3));
      t3 = this.yPixelStart;
      t1 = this.filter.get$yWidth();
      if (typeof t1 !== "number")
        return H.iae(t1);
      extent[2] = C.JSNumber_methods.toInt$0(Math.floor(t3 + 0.5 - t1));
      t1 = this.yPixelStart;
      t3 = this.yPixelCount;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t2 = this.filter.get$yWidth();
      if (typeof t2 !== "number")
        return H.iae(t2);
      extent[3] = C.JSNumber_methods.toInt$0(Math.ceil(t1 + 0.5 + t3 + t2));
    },
    getPixelExtent$1: function(extent) {
      var t1, t2;
      t1 = this.xPixelStart;
      extent[0] = t1;
      t2 = this.xPixelCount;
      if (typeof t2 !== "number")
        return H.iae(t2);
      extent[1] = t1 + t2;
      t2 = this.yPixelStart;
      extent[2] = t2;
      t1 = this.yPixelCount;
      if (typeof t1 !== "number")
        return H.iae(t1);
      extent[3] = t2 + t1;
    },
    updateDisplay$5: function(x0, y0, x1, y1, splatScale) {
      if (this.previewCallback != null)
        this.previewCallback$1(this.image);
    },
    updateDisplay$4: function(x0, y0, x1, y1) {
      return this.updateDisplay$5(x0, y0, x1, y1, 1);
    },
    writeImage$1: function(splatScale) {
      var c, splatRGB, t1, pi, pi3, y, t2, x, t3, t4, t5, t6, t7, weightSum, invWt;
      c = [0, 0, 0];
      splatRGB = [0, 0, 0];
      t1 = J.getInterceptor$ns(splatScale);
      pi = 0;
      pi3 = 0;
      y = 0;
      while (true) {
        t2 = this.yPixelCount;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(y < t2))
          break;
        x = 0;
        while (true) {
          t2 = this.xPixelCount;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(x < t2))
            break;
          t2 = this._Lxyz;
          t3 = t2.length;
          if (pi3 < 0 || pi3 >= t3)
            return H.ioore(t2, pi3);
          t4 = t2[pi3];
          t5 = pi3 + 1;
          if (t5 >= t3)
            return H.ioore(t2, t5);
          t6 = t2[t5];
          t7 = pi3 + 2;
          if (t7 >= t3)
            return H.ioore(t2, t7);
          G.Spectrum_XYZToRGB(t4, t6, t2[t7], c);
          t2 = this._weightSum;
          if (pi < 0 || pi >= t2.length)
            return H.ioore(t2, pi);
          weightSum = t2[pi];
          if (weightSum !== 0) {
            invWt = 1 / weightSum;
            J.$indexSet$ax(this.output.rgb, pi3, P.max(0, J.$mul$ns(c[0], invWt)));
            J.$indexSet$ax(this.output.rgb, t5, P.max(0, J.$mul$ns(c[1], invWt)));
            J.$indexSet$ax(this.output.rgb, t7, P.max(0, J.$mul$ns(c[2], invWt)));
          }
          t2 = this._splatXYZ;
          t3 = t2.length;
          if (pi3 >= t3)
            return H.ioore(t2, pi3);
          t4 = t2[pi3];
          if (t5 >= t3)
            return H.ioore(t2, t5);
          t6 = t2[t5];
          if (t7 >= t3)
            return H.ioore(t2, t7);
          G.Spectrum_XYZToRGB(t4, t6, t2[t7], splatRGB);
          t2 = this.output.rgb;
          t6 = J.getInterceptor$asx(t2);
          t6.$indexSet(t2, pi3, J.$add$ns(t6.$index(t2, pi3), t1.$mul(splatScale, splatRGB[0])));
          t2 = this.output.rgb;
          t6 = J.getInterceptor$asx(t2);
          t6.$indexSet(t2, t5, J.$add$ns(t6.$index(t2, t5), t1.$mul(splatScale, splatRGB[1])));
          t5 = this.output.rgb;
          t2 = J.getInterceptor$asx(t5);
          t2.$indexSet(t5, t7, J.$add$ns(t2.$index(t5, t7), t1.$mul(splatScale, splatRGB[2])));
          ++x;
          ++pi;
          pi3 += 3;
        }
        ++y;
      }
      return this.output;
    },
    writeImage$0: function() {
      return this.writeImage$1(1);
    },
    ImageFilm$7: function(xres, yres, filter, cropWindow, filename, image, previewCallback) {
      var t1, i, t2, t3, t4, fi, y, fy, x, fi0;
      for (t1 = this._gamma, i = 0; i < 256; ++i)
        t1[i] = C.JSInt_methods.clamp$2(C.JSNumber_methods.toInt$0(Math.floor(Math.pow(i / 255, 0.45454545454545453) * 255)), 0, 255);
      t1 = this.xResolution;
      t2 = this.cropWindow;
      t3 = J.getInterceptor$asx(t2);
      t4 = J.getInterceptor$ns(t1);
      this.xPixelStart = J.ceil$0$n(t4.$mul(t1, t3.$index(t2, 0)));
      this.xPixelCount = P.max(1, J.ceil$0$n(t4.$mul(t1, t3.$index(t2, 1))) - this.xPixelStart);
      t1 = this.yResolution;
      t4 = J.getInterceptor$ns(t1);
      this.yPixelStart = J.ceil$0$n(t4.$mul(t1, t3.$index(t2, 2)));
      t2 = P.max(1, J.ceil$0$n(t4.$mul(t1, t3.$index(t2, 3))) - this.yPixelStart);
      this.yPixelCount = t2;
      t3 = this.xPixelCount;
      if (typeof t3 !== "number")
        return t3.$mul();
      this.previewCount = t3 * 12;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = t3 * t2 * 3;
      if (typeof t2 !== "number" || Math.floor(t2) !== t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
      this._Lxyz = new Float32Array(t2);
      t1 = this.xPixelCount;
      t2 = this.yPixelCount;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = t1 * t2 * 3;
      if (typeof t2 !== "number" || Math.floor(t2) !== t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
      this._splatXYZ = new Float32Array(t2);
      t1 = this.xPixelCount;
      t2 = this.yPixelCount;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = t1 * t2;
      if (typeof t2 !== "number" || Math.floor(t2) !== t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
      this._weightSum = new Float32Array(t2);
      this._filterTable = new Float32Array(256);
      for (fi = 0, y = 0; y < 16; ++y) {
        t1 = this.filter.get$yWidth();
        if (typeof t1 !== "number")
          return H.iae(t1);
        fy = (y + 0.5) * t1 / 16;
        for (x = 0; x < 16; ++x, fi = fi0) {
          t1 = this.filter;
          t2 = t1.get$xWidth();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = this._filterTable;
          fi0 = fi + 1;
          t2 = t1.evaluate$2((x + 0.5) * t2 / 16, fy);
          if (fi < 0 || fi >= t3.length)
            return H.ioore(t3, fi);
          t3[fi] = t2;
        }
      }
      if (this.image == null)
        this.image = U.Image$(this.xPixelCount, this.yPixelCount, 4);
      this.output = G.OutputImage$(this.xPixelStart, this.yPixelStart, this.xPixelCount, this.yPixelCount, null);
    },
    static: {"^": "ImageFilm_FILTER_TABLE_SIZE", ImageFilm$: function(xres, yres, filter, cropWindow, filename, image, previewCallback) {
        var t1 = new R.ImageFilm(cropWindow, image, filename, previewCallback, null, 0, null, filter, null, null, null, null, null, null, null, null, new Uint8Array(256), xres, yres);
        t1.ImageFilm$7(xres, yres, filter, cropWindow, filename, image, previewCallback);
        return t1;
      }, ImageFilm_Create: [function(params, filter, image, previewCallback) {
        var xres, yres, filename, crop, t1;
        xres = params.findOneInt$2("xresolution", 640);
        yres = params.findOneInt$2("yresolution", 480);
        filename = params.findOneString$2("filename", "");
        crop = params.findFloat$1("cropWindow");
        if (crop == null)
          crop = [0, 1, 0, 1];
        if (image != null) {
          t1 = J.getInterceptor$x(image);
          xres = t1.get$width(image);
          yres = t1.get$height(image);
        }
        return R.ImageFilm$(xres, yres, filter, crop, filename, image, previewCallback);
      }, function(params, filter) {
        return R.ImageFilm_Create(params, filter, null, null);
      }, null, function(params, filter, image) {
        return R.ImageFilm_Create(params, filter, image, null);
      }, null, "call$4", "call$2", "call$3", "ImageFilm_Create$closure", 4, 4, 18, 13, 13]}
  }
}],
["filters", "package:dartray/filters/filters.dart", , S, {
  "^": "",
  BoxFilter: {
    "^": "Filter;xWidth,yWidth,invXWidth,invYWidth",
    evaluate$2: function(x, y) {
      return 1;
    },
    static: {BoxFilter_Create: [function(ps) {
        var xw, yw;
        xw = ps.findOneFloat$2("xwidth", 0.5);
        yw = ps.findOneFloat$2("ywidth", 0.5);
        if (typeof xw !== "number")
          return H.iae(xw);
        if (typeof yw !== "number")
          return H.iae(yw);
        return new S.BoxFilter(xw, yw, 1 / xw, 1 / yw);
      }, "call$1", "BoxFilter_Create$closure", 2, 0, 19]}
  },
  GaussianFilter: {
    "^": "Filter;alpha>,expX,expY,xWidth,yWidth,invXWidth,invYWidth",
    evaluate$2: function(x, y) {
      return this._gaussian$2(x, this.expX) * this._gaussian$2(y, this.expY);
    },
    _gaussian$2: function(d, expv) {
      var t1 = J.$mul$ns(J.$mul$ns(J.$negate$n(this.alpha), d), d);
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      return P.max(0, Math.exp(t1) - expv);
    },
    static: {GaussianFilter_Create: [function(ps) {
        var xw, yw, alpha, t1, t2;
        xw = ps.findOneFloat$2("xwidth", 2);
        yw = ps.findOneFloat$2("ywidth", 2);
        alpha = ps.findOneFloat$2("alpha", 2);
        if (typeof xw !== "number")
          return H.iae(xw);
        if (typeof yw !== "number")
          return H.iae(yw);
        t1 = J.getInterceptor$n(alpha);
        t2 = J.$mul$ns(J.$mul$ns(t1.$negate(alpha), xw), xw);
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        t2 = Math.exp(t2);
        t1 = J.$mul$ns(J.$mul$ns(t1.$negate(alpha), yw), yw);
        if (typeof t1 !== "number")
          H.throwExpression(P.ArgumentError$(t1));
        return new S.GaussianFilter(alpha, t2, Math.exp(t1), xw, yw, 1 / xw, 1 / yw);
      }, "call$1", "GaussianFilter_Create$closure", 2, 0, 20]}
  },
  LanczosSincFilter: {
    "^": "Filter;tau,xWidth,yWidth,invXWidth,invYWidth",
    evaluate$2: function(x, y) {
      return this._sinc1D$1(x * this.invXWidth) * this._sinc1D$1(y * this.invYWidth);
    },
    _sinc1D$1: function(x) {
      var t1, t2;
      x = Math.abs(x);
      if (x < 0.00001)
        return 1;
      if (x > 1)
        return 0;
      x *= 3.141592653589793;
      t1 = Math.sin(x);
      t2 = this.tau;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = x * t2;
      return t1 / x * (Math.sin(t2) / t2);
    },
    tau$3: function(arg0, arg1, arg2) {
      return this.tau.call$3(arg0, arg1, arg2);
    },
    static: {LanczosSincFilter_Create: [function(ps) {
        var xw, yw, tau;
        xw = ps.findOneFloat$2("xwidth", 4);
        yw = ps.findOneFloat$2("ywidth", 4);
        tau = ps.findOneFloat$2("tau", 3);
        if (typeof xw !== "number")
          return H.iae(xw);
        if (typeof yw !== "number")
          return H.iae(yw);
        return new S.LanczosSincFilter(tau, xw, yw, 1 / xw, 1 / yw);
      }, "call$1", "LanczosSincFilter_Create$closure", 2, 0, 21]}
  },
  MitchellFilter: {
    "^": "Filter;b,c<,xWidth,yWidth,invXWidth,invYWidth",
    evaluate$2: function(x, y) {
      return J.$mul$ns(this._mitchell1D$1(x * this.invXWidth), this._mitchell1D$1(y * this.invYWidth));
    },
    _mitchell1D$1: function(x) {
      var t1, t2, t3;
      x = Math.abs(2 * x);
      t1 = this.b;
      if (x > 1) {
        t1 = J.$negate$n(t1);
        t2 = this.c;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = J.$mul$ns(J.$mul$ns(J.$mul$ns(J.$sub$n(t1, 6 * t2), x), x), x);
        t1 = this.b;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t3 = this.c;
        if (typeof t3 !== "number")
          return H.iae(t3);
        t3 = J.$add$ns(t2, (6 * t1 + 30 * t3) * x * x);
        t1 = this.b;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this.c;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = J.$add$ns(t3, (-12 * t1 - 48 * t2) * x);
        t1 = this.b;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t3 = this.c;
        if (typeof t3 !== "number")
          return H.iae(t3);
        return J.$mul$ns(J.$add$ns(t2, 8 * t1 + 24 * t3), 0.16666666666666666);
      } else {
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this.c;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = 6 * t2;
        return ((12 - 9 * t1 - t2) * x * x * x + (-18 + 12 * t1 + t2) * x * x + (6 - 2 * t1)) * 0.16666666666666666;
      }
    },
    static: {MitchellFilter_Create: [function(ps) {
        var xw, yw, $B, $C;
        xw = ps.findOneFloat$2("xwidth", 2);
        yw = ps.findOneFloat$2("ywidth", 2);
        $B = ps.findOneFloat$2("B", 0.3333333333333333);
        $C = ps.findOneFloat$2("C", 0.3333333333333333);
        if (typeof xw !== "number")
          return H.iae(xw);
        if (typeof yw !== "number")
          return H.iae(yw);
        return new S.MitchellFilter($B, $C, xw, yw, 1 / xw, 1 / yw);
      }, "call$1", "MitchellFilter_Create$closure", 2, 0, 22]}
  },
  TriangleFilter: {
    "^": "Filter;xWidth,yWidth,invXWidth,invYWidth",
    evaluate$2: function(x, y) {
      return P.max(0, J.$sub$n(this.xWidth, Math.abs(x))) * P.max(0, J.$sub$n(this.yWidth, Math.abs(y)));
    },
    static: {TriangleFilter_Create: [function(ps) {
        var xw, yw;
        xw = ps.findOneFloat$2("xwidth", 2);
        yw = ps.findOneFloat$2("ywidth", 2);
        if (typeof xw !== "number")
          return H.iae(xw);
        if (typeof yw !== "number")
          return H.iae(yw);
        return new S.TriangleFilter(xw, yw, 1 / xw, 1 / yw);
      }, "call$1", "TriangleFilter_Create$closure", 2, 0, 23]}
  }
}],
["html_common", "dart:html_common", , P, {
  "^": "",
  convertNativeToDart_AcceptStructuredClone: function(object, mustCopy) {
    var copies = [];
    return new P.convertNativeToDart_AcceptStructuredClone_walk(mustCopy, new P.convertNativeToDart_AcceptStructuredClone_findSlot([], copies), new P.convertNativeToDart_AcceptStructuredClone_readSlot(copies), new P.convertNativeToDart_AcceptStructuredClone_writeSlot(copies)).call$1(object);
  },
  Device_isWebKit: function() {
    var t1 = $.Device__isWebKit;
    if (t1 == null) {
      t1 = $.Device__isOpera;
      if (t1 == null) {
        t1 = J.contains$2$asx(window.navigator.userAgent, "Opera", 0);
        $.Device__isOpera = t1;
      }
      t1 = t1 !== true && J.contains$2$asx(window.navigator.userAgent, "WebKit", 0);
      $.Device__isWebKit = t1;
    }
    return t1;
  },
  convertNativeToDart_AcceptStructuredClone_findSlot: {
    "^": "Closure:14;values_0,copies_1",
    call$1: function(value) {
      var t1, $length, i, t2;
      t1 = this.values_0;
      $length = t1.length;
      for (i = 0; i < $length; ++i) {
        t2 = t1[i];
        if (t2 == null ? value == null : t2 === value)
          return i;
      }
      t1.push(value);
      this.copies_1.push(null);
      return $length;
    }
  },
  convertNativeToDart_AcceptStructuredClone_readSlot: {
    "^": "Closure:111;copies_2",
    call$1: function(i) {
      var t1 = this.copies_2;
      if (i >= t1.length)
        return H.ioore(t1, i);
      return t1[i];
    }
  },
  convertNativeToDart_AcceptStructuredClone_writeSlot: {
    "^": "Closure:112;copies_3",
    call$2: function(i, x) {
      var t1 = this.copies_3;
      if (i >= t1.length)
        return H.ioore(t1, i);
      t1[i] = x;
    }
  },
  convertNativeToDart_AcceptStructuredClone_walk: {
    "^": "Closure:88;mustCopy_4,findSlot_5,readSlot_6,writeSlot_7",
    call$1: function(e) {
      var slot, copy, t1, key, $length, t2, i;
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      if (e instanceof Date)
        return P.DateTime$fromMillisecondsSinceEpoch(e.getTime(), true);
      if (e instanceof RegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (Object.getPrototypeOf(e) === Object.prototype) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null)
          return copy;
        copy = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        this.writeSlot_7.call$2(slot, copy);
        for (t1 = Object.keys(e), t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();) {
          key = t1._current;
          copy.$indexSet(0, key, this.call$1(e[key]));
        }
        return copy;
      }
      if (e instanceof Array) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null)
          return copy;
        t1 = J.getInterceptor$asx(e);
        $length = t1.get$length(e);
        copy = this.mustCopy_4 ? new Array($length) : e;
        this.writeSlot_7.call$2(slot, copy);
        if (typeof $length !== "number")
          return H.iae($length);
        t2 = J.getInterceptor$ax(copy);
        i = 0;
        for (; i < $length; ++i)
          t2.$indexSet(copy, i, this.call$1(t1.$index(e, i)));
        return copy;
      }
      return e;
    }
  },
  FilteredElementList: {
    "^": "ListBase;_node,_childNodes",
    get$_filtered: function() {
      var t1 = this._childNodes;
      return P.List_List$from(t1.where$1(t1, new P.FilteredElementList__filtered_closure()), true, W.Element);
    },
    forEach$1: function(_, f) {
      H.IterableMixinWorkaround_forEach(this.get$_filtered(), f);
    },
    $indexSet: function(_, index, value) {
      var t1 = this.get$_filtered();
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      J.replaceWith$1$x(t1[index], value);
    },
    set$length: function(_, newLength) {
      var len, t1;
      len = this.get$_filtered().length;
      t1 = J.getInterceptor$n(newLength);
      if (t1.$ge(newLength, len))
        return;
      else if (t1.$lt(newLength, 0))
        throw H.wrapException(P.ArgumentError$("Invalid list length"));
      this.removeRange$2(0, newLength, len);
    },
    add$1: function(_, value) {
      this._childNodes._this.appendChild(value);
    },
    sort$1: function(_, compare) {
      throw H.wrapException(P.UnsupportedError$("Cannot sort filtered list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on filtered list"));
    },
    fillRange$3: function(_, start, end, fillValue) {
      throw H.wrapException(P.UnsupportedError$("Cannot fillRange on filtered list"));
    },
    removeRange$2: function(_, start, end) {
      H.IterableMixinWorkaround_forEach(C.JSArray_methods.sublist$2(this.get$_filtered(), start, end), new P.FilteredElementList_removeRange_closure());
    },
    get$length: function(_) {
      return this.get$_filtered().length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    $index: function(_, index) {
      var t1 = this.get$_filtered();
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    get$iterator: function(_) {
      var t1 = this.get$_filtered();
      return new H.ListIterator(t1, t1.length, 0, null);
    }
  },
  FilteredElementList__filtered_closure: {
    "^": "Closure:88;",
    call$1: function(n) {
      return !!J.getInterceptor(n).$isElement;
    }
  },
  FilteredElementList_removeRange_closure: {
    "^": "Closure:88;",
    call$1: function(el) {
      return J.remove$0$ax(el);
    }
  }
}],
["image", "package:image/image.dart", , U, {
  "^": "",
  getColor: function(r, g, b, a) {
    var t1, t2, t3, t4;
    t1 = J.clamp$2$n(a, 0, 255);
    if (typeof t1 !== "number")
      return t1.$shl();
    t2 = J.clamp$2$n(b, 0, 255);
    if (typeof t2 !== "number")
      return t2.$shl();
    t3 = J.clamp$2$n(g, 0, 255);
    if (typeof t3 !== "number")
      return t3.$shl();
    t4 = J.clamp$2$n(r, 0, 255);
    if (typeof t4 !== "number")
      return H.iae(t4);
    return (t1 << 24 | t2 << 16 | t3 << 8 | t4) >>> 0;
  },
  ExrCompressor_ExrCompressor: function(type, hdr, maxScanLineSize, numScanLines) {
    var t1;
    switch (type) {
      case 1:
        return new U.ExrRleCompressor(null, maxScanLineSize, 0, 0, hdr);
      case 2:
        t1 = numScanLines == null ? 1 : numScanLines;
        return new U.ExrZipCompressor(new T.ZLibDecoder(), maxScanLineSize, t1, null, 0, 0, hdr);
      case 3:
        t1 = numScanLines == null ? 16 : numScanLines;
        return new U.ExrZipCompressor(new T.ZLibDecoder(), maxScanLineSize, t1, null, 0, 0, hdr);
      case 4:
        return U.ExrPizCompressor$(hdr, maxScanLineSize, numScanLines == null ? 32 : numScanLines);
      case 5:
        t1 = numScanLines == null ? 16 : numScanLines;
        return new U.ExrPxr24Compressor(new T.ZLibDecoder(), maxScanLineSize, t1, null, 0, 0, hdr);
      case 6:
        t1 = numScanLines == null ? 32 : numScanLines;
        return new U.ExrB44Compressor(maxScanLineSize, t1, false, 0, 0, hdr);
      case 7:
        t1 = numScanLines == null ? 32 : numScanLines;
        return new U.ExrB44Compressor(maxScanLineSize, t1, true, 0, 0, hdr);
      default:
        throw H.wrapException(U.ImageException$("Invalid compression type: " + H.S(type)));
    }
  },
  ExrHuffman_uncompress: function(compressed, nCompressed, raw, nRaw) {
    var start, im, iM, nBits, t1, freq, hdec, i;
    if (nCompressed === 0) {
      if (nRaw !== 0)
        throw H.wrapException(U.ImageException$("Incomplete huffman data"));
      return;
    }
    start = compressed.offset;
    im = compressed.readUint32$0();
    iM = compressed.readUint32$0();
    compressed.offset = J.$add$ns(compressed.offset, 4);
    nBits = compressed.readUint32$0();
    if (im < 65537)
      t1 = iM >= 65537;
    else
      t1 = true;
    if (t1)
      throw H.wrapException(U.ImageException$("Invalid huffman table size"));
    compressed.offset = J.$add$ns(compressed.offset, 4);
    t1 = Array(65537);
    t1.fixed$length = init;
    freq = H.setRuntimeTypeInfo(t1, [J.JSInt]);
    H.IterableMixinWorkaround_fillRangeList(freq, 0, 65537, 0);
    hdec = H.setRuntimeTypeInfo(Array(16384), [U.ExrHufDec]);
    for (i = 0; i < 16384; ++i)
      hdec[i] = new U.ExrHufDec(0, 0, null);
    U.ExrHuffman_unpackEncTable(compressed, nCompressed - 20, im, iM, freq);
    t1 = J.$sub$n(compressed.offset, start);
    if (typeof t1 !== "number")
      return H.iae(t1);
    if (nBits > 8 * (nCompressed - t1))
      throw H.wrapException(U.ImageException$("Error in header for Huffman-encoded data (invalid number of bits)."));
    U.ExrHuffman_buildDecTable(freq, im, iM, hdec);
    U.ExrHuffman_decode(freq, hdec, compressed, nBits, iM, nRaw, raw);
  },
  ExrHuffman_decode: function(hcode, hdecod, input, ni, rlc, no, out) {
    var c_lc, ie, oi, t1, t2, pl, j, l, t3, oi0, i;
    c_lc = [0, 0];
    ie = J.$add$ns(input.offset, C.JSInt_methods._tdivFast$1(ni + 7, 8));
    for (oi = 0; J.$lt$n(input.offset, ie);) {
      U.ExrHuffman_getChar(c_lc, input);
      for (; J.$ge$n(c_lc[1], 14);) {
        t1 = c_lc[0];
        t2 = J.$sub$n(c_lc[1], 14);
        if (typeof t1 !== "number")
          return t1.$shr();
        if (typeof t2 !== "number")
          return H.iae(t2);
        pl = hdecod[C.JSNumber_methods.$shr(t1, t2) & 16383];
        if (pl.get$len() !== 0) {
          c_lc[1] = J.$sub$n(c_lc[1], pl.len);
          oi = U.ExrHuffman_getCode(pl.lit, rlc, c_lc, input, out, oi, no);
        } else {
          if (pl.p == null)
            throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (invalid code)."));
          for (j = 0; j < pl.lit; ++j) {
            t1 = pl.p;
            if (j >= t1.length)
              return H.ioore(t1, j);
            t1 = t1[j];
            if (t1 >>> 0 !== t1 || t1 >= 65537)
              return H.ioore(hcode, t1);
            l = J.$and$n(hcode[t1], 63);
            while (true) {
              if (!(J.$lt$n(c_lc[1], l) && J.$lt$n(input.offset, ie)))
                break;
              U.ExrHuffman_getChar(c_lc, input);
            }
            if (J.$ge$n(c_lc[1], l)) {
              t1 = pl.p;
              if (j >= t1.length)
                return H.ioore(t1, j);
              t1 = t1[j];
              if (t1 >>> 0 !== t1 || t1 >= 65537)
                return H.ioore(hcode, t1);
              t1 = hcode[t1];
              if (typeof t1 !== "number")
                return t1.$shr();
              t1 = C.JSNumber_methods._shrOtherPositive$1(t1, 6);
              t2 = c_lc[0];
              t3 = J.$sub$n(c_lc[1], l);
              if (typeof t2 !== "number")
                return t2.$shr();
              if (typeof t3 !== "number")
                return H.iae(t3);
              if (t1 === (C.JSNumber_methods.$shr(t2, t3) & C.JSInt_methods._shlPositive$1(1, l) - 1) >>> 0) {
                c_lc[1] = J.$sub$n(c_lc[1], l);
                t1 = pl.p;
                if (j >= t1.length)
                  return H.ioore(t1, j);
                oi0 = U.ExrHuffman_getCode(t1[j], rlc, c_lc, input, out, oi, no);
                oi = oi0;
                break;
              }
            }
          }
          if (j === pl.lit)
            throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (invalid code)."));
        }
      }
    }
    i = 8 - ni & 7;
    t1 = c_lc[0];
    if (typeof t1 !== "number")
      return t1.$shr();
    c_lc[0] = C.JSNumber_methods._shrOtherPositive$1(t1, i);
    c_lc[1] = J.$sub$n(c_lc[1], i);
    for (; J.$gt$n(c_lc[1], 0);) {
      t1 = c_lc[0];
      t2 = c_lc[1];
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return t1.$shl();
      pl = hdecod[C.JSNumber_methods.$shl(t1, 14 - t2) & 16383];
      if (pl.get$len() !== 0) {
        c_lc[1] = t2 - pl.len;
        oi = U.ExrHuffman_getCode(pl.lit, rlc, c_lc, input, out, oi, no);
      } else
        throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (invalid code)."));
    }
    if (oi !== no)
      throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (decoded data are shorter than expected)."));
  },
  ExrHuffman_getCode: function(po, rlc, c_lc, input, out, oi, oe) {
    var t1, t2, cs, s, cs0, oi0;
    if (J.$eq(po, rlc)) {
      if (J.$lt$n(c_lc[1], 8))
        U.ExrHuffman_getChar(c_lc, input);
      t1 = J.$sub$n(c_lc[1], 8);
      c_lc[1] = t1;
      t2 = c_lc[0];
      if (typeof t2 !== "number")
        return t2.$shr();
      if (typeof t1 !== "number")
        return H.iae(t1);
      cs = C.JSNumber_methods.$shr(t2, t1) & 255;
      if (oi + cs > oe)
        throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (decoded data are longer than expected)."));
      t1 = oi - 1;
      t2 = out.length;
      if (t1 < 0 || t1 >= t2)
        return H.ioore(out, t1);
      s = out[t1];
      for (; cs0 = cs - 1, cs > 0; cs = cs0, oi = oi0) {
        oi0 = oi + 1;
        if (oi >= t2)
          return H.ioore(out, oi);
        out[oi] = s;
      }
    } else {
      if (oi < oe) {
        oi0 = oi + 1;
        if (oi >= out.length)
          return H.ioore(out, oi);
        out[oi] = po;
      } else
        throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (decoded data are longer than expected)."));
      oi = oi0;
    }
    return oi;
  },
  ExrHuffman_buildDecTable: function(hcode, im, iM, hdecod) {
    var t1, t2, l, pl, t3, t4, i, t5, pi;
    for (; im <= iM; ++im) {
      if (im >= 65537)
        return H.ioore(hcode, im);
      t1 = hcode[im];
      if (typeof t1 !== "number")
        return t1.$shr();
      t2 = C.JSNumber_methods._shrOtherPositive$1(t1, 6);
      l = t1 & 63;
      if (C.JSInt_methods._shrBothPositive$1(t2, l) !== 0)
        throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (invalid code table entry)."));
      if (l > 14) {
        t1 = C.JSInt_methods._shrReceiverPositive$1(t2, l - 14);
        if (t1 >= 16384)
          return H.ioore(hdecod, t1);
        pl = hdecod[t1];
        if (pl.get$len() !== 0)
          throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (invalid code table entry)."));
        t1 = ++pl.lit;
        t2 = pl.p;
        if (t2 != null) {
          t3 = Array(t1);
          t3.fixed$length = init;
          t3.$builtinTypeInfo = [J.JSInt];
          pl.p = t3;
          for (t4 = pl.lit - 1, i = 0; i < t4; ++i) {
            if (i >= t2.length)
              return H.ioore(t2, i);
            t5 = t2[i];
            if (i >= t1)
              return H.ioore(t3, i);
            t3[i] = t5;
          }
        } else
          pl.p = [0];
        t1 = pl.p;
        t2 = pl.lit - 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        t1[t2] = im;
      } else if (l !== 0) {
        t1 = 14 - l;
        pi = C.JSInt_methods.$shl(t2, t1);
        if (pi >= 16384)
          return H.ioore(hdecod, pi);
        for (i = C.JSInt_methods.$shl(1, t1); i > 0; --i, ++pi) {
          if (pi >= 16384)
            return H.ioore(hdecod, pi);
          pl = hdecod[pi];
          if (pl.get$len() !== 0 || pl.p != null)
            throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (invalid code table entry)."));
          pl.len = l;
          pl.lit = im;
        }
      }
    }
  },
  ExrHuffman_unpackEncTable: function(p, ni, im, iM, hcode) {
    var pcode, c_lc, t1, l, zerun, zerun0, im0;
    pcode = p.offset;
    c_lc = [0, 0];
    for (t1 = iM + 1; im <= iM; ++im) {
      if (J.$gt$n(J.$sub$n(p.offset, pcode), ni))
        throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (unexpected end of code table data)."));
      l = U.ExrHuffman_getBits(6, c_lc, p);
      if (im < 0 || im >= 65537)
        return H.ioore(hcode, im);
      hcode[im] = l;
      if (l === 63) {
        if (J.$gt$n(J.$sub$n(p.offset, pcode), ni))
          throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (unexpected end of code table data)."));
        zerun = U.ExrHuffman_getBits(8, c_lc, p) + 6;
        if (im + zerun > t1)
          throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (code table is longer than expected)."));
        for (; zerun0 = zerun - 1, zerun !== 0; zerun = zerun0, im = im0) {
          im0 = im + 1;
          if (im >= 65537)
            return H.ioore(hcode, im);
          hcode[im] = 0;
        }
        --im;
      } else if (l >= 59) {
        zerun = l - 59 + 2;
        if (im + zerun > t1)
          throw H.wrapException(U.ImageException$("Error in Huffman-encoded data (code table is longer than expected)."));
        for (; zerun0 = zerun - 1, zerun !== 0; zerun = zerun0, im = im0) {
          im0 = im + 1;
          if (im >= 65537)
            return H.ioore(hcode, im);
          hcode[im] = 0;
        }
        --im;
      }
    }
    U.ExrHuffman_canonicalCodeTable(hcode);
  },
  ExrHuffman_canonicalCodeTable: function(hcode) {
    var t1, n, i, c, nc, l;
    t1 = Array(59);
    t1.fixed$length = init;
    n = H.setRuntimeTypeInfo(t1, [J.JSInt]);
    H.IterableMixinWorkaround_fillRangeList(n, 0, 59, 0);
    for (i = 0; i < 65537; ++i) {
      t1 = hcode[i];
      if (t1 >>> 0 !== t1 || t1 >= 59)
        return H.ioore(n, t1);
      n[t1] = J.$add$ns(n[t1], 1);
    }
    for (c = 0, i = 58; i > 0; --i, c = nc) {
      t1 = n[i];
      if (typeof t1 !== "number")
        return H.iae(t1);
      nc = C.JSNumber_methods._shrOtherPositive$1(c + t1, 1);
      n[i] = c;
    }
    for (i = 0; i < 65537; ++i) {
      l = hcode[i];
      if (J.$gt$n(l, 0)) {
        if (l >>> 0 !== l || l >= 59)
          return H.ioore(n, l);
        t1 = n[l];
        n[l] = J.$add$ns(t1, 1);
        if (typeof t1 !== "number")
          return t1.$shl();
        hcode[i] = (l | t1 << 6) >>> 0;
      }
    }
  },
  ExrHuffman_getChar: function(c_lc, input) {
    var t1, t2, t3;
    t1 = c_lc[0];
    if (typeof t1 !== "number")
      return t1.$shl();
    t2 = input.buffer;
    t3 = input.offset;
    input.offset = J.$add$ns(t3, 1);
    t3 = J.$index$asx(t2, t3);
    if (typeof t3 !== "number")
      return H.iae(t3);
    c_lc[0] = ((t1 << 8 | t3) & -1) >>> 0;
    c_lc[1] = J.$and$n(J.$add$ns(c_lc[1], 8), -1);
  },
  ExrHuffman_getBits: function(nBits, c_lc, input) {
    var t1, t2, t3;
    for (; J.$lt$n(c_lc[1], nBits);) {
      t1 = c_lc[0];
      if (typeof t1 !== "number")
        return t1.$shl();
      t2 = input.buffer;
      t3 = input.offset;
      input.offset = J.$add$ns(t3, 1);
      t3 = J.$index$asx(t2, t3);
      if (typeof t3 !== "number")
        return H.iae(t3);
      c_lc[0] = ((t1 << 8 | t3) & -1) >>> 0;
      c_lc[1] = J.$and$n(J.$add$ns(c_lc[1], 8), -1);
    }
    t1 = J.$sub$n(c_lc[1], nBits);
    c_lc[1] = t1;
    t2 = c_lc[0];
    if (typeof t2 !== "number")
      return t2.$shr();
    if (typeof t1 !== "number")
      return H.iae(t1);
    return (C.JSNumber_methods.$shr(t2, t1) & C.JSInt_methods._shlPositive$1(1, nBits) - 1) >>> 0;
  },
  ExrWavelet_decode: function(input, si, nx, ox, ny, oy, mx) {
    var w14, t1, n, p, p0, a_b, t2, t3, t4, p2, ey, oy1, oy2, ox1, ox2, py, i00, i01, i10, i11, t5, t6, ex, px, p01, p10, p11, t7, t8;
    w14 = mx < 16384;
    t1 = J.getInterceptor$n(nx);
    n = t1.$gt(nx, ny) ? ny : nx;
    if (typeof n !== "number")
      return H.iae(n);
    p = 1;
    for (; p <= n;)
      p = p << 1 >>> 0;
    p = p >>> 1;
    p0 = p >>> 1;
    a_b = [0, 0];
    for (t2 = J.getInterceptor$n(ny), t3 = J.getInterceptor$ns(oy), t4 = J.getInterceptor$ns(si), p2 = p, p = p0; p >= 1; p2 = p, p = p0) {
      ey = t4.$add(si, t3.$mul(oy, t2.$sub(ny, p2)));
      oy1 = t3.$mul(oy, p);
      oy2 = t3.$mul(oy, p2);
      if (typeof ox !== "number")
        return ox.$mul();
      ox1 = ox * p;
      ox2 = ox * p2;
      for (py = si, i00 = null, i01 = null, i10 = null, i11 = null; t5 = J.getInterceptor$n(py), t5.$le(py, ey); py = t5.$add(py, oy2)) {
        t6 = t1.$sub(nx, p2);
        if (typeof t6 !== "number")
          return H.iae(t6);
        ex = t5.$add(py, ox * t6);
        for (px = py; t6 = J.getInterceptor$n(px), t6.$le(px, ex); px = t6.$add(px, ox2)) {
          p01 = t6.$add(px, ox1);
          p10 = t6.$add(px, oy1);
          p11 = J.$add$ns(p10, ox1);
          if (w14) {
            t7 = input.length;
            if (px >>> 0 !== px || px >= t7)
              return H.ioore(input, px);
            t8 = input[px];
            if (p10 >>> 0 !== p10 || p10 >= t7)
              return H.ioore(input, p10);
            U.ExrWavelet_wdec14(t8, input[p10], a_b);
            i00 = a_b[0];
            i10 = a_b[1];
            if (p01 >>> 0 !== p01 || p01 >= t7)
              return H.ioore(input, p01);
            t8 = input[p01];
            if (p11 >>> 0 !== p11 || p11 >= t7)
              return H.ioore(input, p11);
            U.ExrWavelet_wdec14(t8, input[p11], a_b);
            i01 = a_b[0];
            i11 = a_b[1];
            U.ExrWavelet_wdec14(i00, i01, a_b);
            input[px] = a_b[0];
            input[p01] = a_b[1];
            U.ExrWavelet_wdec14(i10, i11, a_b);
            input[p10] = a_b[0];
            input[p11] = a_b[1];
          } else {
            t7 = input.length;
            if (px >>> 0 !== px || px >= t7)
              return H.ioore(input, px);
            t8 = input[px];
            if (p10 >>> 0 !== p10 || p10 >= t7)
              return H.ioore(input, p10);
            U.ExrWavelet_wdec16(t8, input[p10], a_b);
            i00 = a_b[0];
            i10 = a_b[1];
            if (p01 >>> 0 !== p01 || p01 >= t7)
              return H.ioore(input, p01);
            t8 = input[p01];
            if (p11 >>> 0 !== p11 || p11 >= t7)
              return H.ioore(input, p11);
            U.ExrWavelet_wdec16(t8, input[p11], a_b);
            i01 = a_b[0];
            i11 = a_b[1];
            U.ExrWavelet_wdec16(i00, i01, a_b);
            input[px] = a_b[0];
            input[p01] = a_b[1];
            U.ExrWavelet_wdec16(i10, i11, a_b);
            input[p10] = a_b[0];
            input[p11] = a_b[1];
          }
        }
        if (typeof nx !== "number")
          return nx.$and();
        if ((nx & p) >>> 0 !== 0) {
          p10 = t6.$add(px, oy1);
          if (w14) {
            t6 = input.length;
            if (px >>> 0 !== px || px >= t6)
              return H.ioore(input, px);
            t7 = input[px];
            if (p10 >>> 0 !== p10 || p10 >= t6)
              return H.ioore(input, p10);
            U.ExrWavelet_wdec14(t7, input[p10], a_b);
            i00 = a_b[0];
            input[p10] = a_b[1];
          } else {
            t6 = input.length;
            if (px >>> 0 !== px || px >= t6)
              return H.ioore(input, px);
            t7 = input[px];
            if (p10 >>> 0 !== p10 || p10 >= t6)
              return H.ioore(input, p10);
            U.ExrWavelet_wdec16(t7, input[p10], a_b);
            i00 = a_b[0];
            input[p10] = a_b[1];
          }
          if (px >>> 0 !== px || px >= input.length)
            return H.ioore(input, px);
          input[px] = i00;
        }
      }
      if (t2.$and(ny, p) !== 0) {
        t6 = t1.$sub(nx, p2);
        if (typeof t6 !== "number")
          return H.iae(t6);
        ex = t5.$add(py, ox * t6);
        for (px = py; t5 = J.getInterceptor$n(px), t5.$le(px, ex); px += ox2) {
          p01 = t5.$add(px, ox1);
          t5 = input.length;
          if (px >>> 0 !== px || px >= t5)
            return H.ioore(input, px);
          t6 = input[px];
          if (p01 >>> 0 !== p01 || p01 >= t5)
            return H.ioore(input, p01);
          U.ExrWavelet_wdec14(t6, input[p01], a_b);
          i00 = a_b[0];
          input[p01] = a_b[1];
          if (px >>> 0 !== px || px >= input.length)
            return H.ioore(input, px);
          input[px] = i00;
        }
      }
      p0 = p >>> 1;
    }
  },
  ExrWavelet_wdec14: function(l, h, a_b) {
    var t1, t2, t3, ls, hs, ai;
    t1 = $.get$__uint16();
    t1[0] = l;
    t2 = $.get$__uint16ToInt16();
    t3 = t2.length;
    if (0 >= t3)
      return H.ioore(t2, 0);
    ls = t2[0];
    t1[0] = h;
    if (0 >= t3)
      return H.ioore(t2, 0);
    hs = t2[0];
    ai = ls + (hs & 1) + C.JSInt_methods._shrOtherPositive$1(hs, 1);
    a_b[0] = ai;
    a_b[1] = ai - hs;
  },
  ExrWavelet_wdec16: function(l, h, a_b) {
    var bb;
    if (typeof h !== "number")
      return h.$shr();
    bb = J.$and$n(J.$sub$n(l, C.JSNumber_methods._shrOtherPositive$1(h, 1)), 65535);
    a_b[1] = bb;
    a_b[0] = h + bb - 32768 & 65535;
  },
  findDecoderForData: function(data) {
    var bytes, png, gif, webp, tiff;
    bytes = new Uint8Array(H._ensureNativeList(data));
    U.InputBuffer$(bytes, true, null, 0);
    if (new U.JpegData(null, null, null, null, null, null, Array(4), [], [], [], [], 0, 0).validate$1(bytes))
      return new U.JpegDecoder(null, null, null);
    png = new U.PngDecoder(null, 0, 0, null, null, 0, 1, null);
    if (png.isValidFile$1(bytes))
      return png;
    gif = new U.GifDecoder(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    gif._input = U.InputBuffer$(bytes, false, null, 0);
    gif.info = new U.GifInfo(0, null, false, [], 0, 0, 4294967295);
    if (gif._getInfo$0())
      return gif;
    webp = new U.WebPDecoder(null, null, null);
    if (webp.isValidFile$1(bytes))
      return webp;
    tiff = new U.TiffDecoder(null, null, null);
    if (tiff._readHeader$1(U.InputBuffer$(bytes, false, null, 0)) != null)
      return tiff;
    if (U.PsdImage$(bytes).signature === 943870035)
      return new U.PsdDecoder(null, null);
    if (U.ExrImage_isValidFile(bytes))
      return new U.ExrDecoder(null, 1, null, null, null, null, null);
    return;
  },
  WebPFilters_horizontalUnfilter: [function(width, height, stride, row, numRows, data) {
    U.WebPFilters__doHorizontalFilter(data, width, height, stride, row, numRows, true, data);
  }, "call$6", "WebPFilters_horizontalUnfilter$closure", 12, 0, 26],
  WebPFilters_verticalUnfilter: [function(width, height, stride, row, num_rows, data) {
    U.WebPFilters__doVerticalFilter(data, width, height, stride, row, num_rows, true, data);
  }, "call$6", "WebPFilters_verticalUnfilter$closure", 12, 0, 26],
  WebPFilters_gradientUnfilter: [function(width, height, stride, row, num_rows, data) {
    U.WebPFilters__doGradientFilter(data, width, height, stride, row, num_rows, true, data);
  }, "call$6", "WebPFilters_gradientUnfilter$closure", 12, 0, 26],
  WebPFilters__predictLine: function(src, pred, dst, $length, inverse) {
    var i, t1;
    if (inverse) {
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        t1 = J.$add$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, i)), J.$index$asx(pred.buffer, J.$add$ns(pred.offset, i)));
        J.$indexSet$ax(dst.buffer, J.$add$ns(dst.offset, i), t1);
      }
    } else {
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        t1 = J.$sub$n(J.$index$asx(src.buffer, J.$add$ns(src.offset, i)), J.$index$asx(pred.buffer, J.$add$ns(pred.offset, i)));
        J.$indexSet$ax(dst.buffer, J.$add$ns(dst.offset, i), t1);
      }
    }
  },
  WebPFilters__doHorizontalFilter: function(src, width, height, stride, row, numRows, inverse, out) {
    var t1, startOffset, lastRow, s, o, preds, t2, t3;
    t1 = J.getInterceptor$ns(row);
    startOffset = t1.$mul(row, stride);
    lastRow = t1.$add(row, numRows);
    s = U.InputBuffer$(src, false, null, startOffset);
    o = U.InputBuffer$(src, false, null, startOffset);
    preds = U.InputBuffer$from(inverse ? o : s, null, 0);
    if (t1.$eq(row, 0)) {
      t1 = J.$index$asx(s.buffer, J.$add$ns(s.offset, 0));
      J.$indexSet$ax(o.buffer, J.$add$ns(o.offset, 0), t1);
      U.WebPFilters__predictLine(U.InputBuffer$from(s, null, 1), preds, U.InputBuffer$from(o, null, 1), J.$sub$n(width, 1), inverse);
      preds.offset = J.$add$ns(preds.offset, stride);
      s.offset = J.$add$ns(s.offset, stride);
      o.offset = J.$add$ns(o.offset, stride);
      row = 1;
    }
    for (t1 = J.getInterceptor$n(stride), t2 = J.getInterceptor$n(width); t3 = J.getInterceptor$n(row), t3.$lt(row, lastRow);) {
      U.WebPFilters__predictLine(s, U.InputBuffer$from(preds, null, t1.$negate(stride)), o, 1, inverse);
      U.WebPFilters__predictLine(U.InputBuffer$from(s, null, 1), preds, U.InputBuffer$from(o, null, 1), t2.$sub(width, 1), inverse);
      row = t3.$add(row, 1);
      preds.offset = J.$add$ns(preds.offset, stride);
      s.offset = J.$add$ns(s.offset, stride);
      o.offset = J.$add$ns(o.offset, stride);
    }
  },
  WebPFilters__doVerticalFilter: function(src, width, height, stride, row, numRows, inverse, out) {
    var t1, startOffset, last_row, s, o, preds;
    t1 = J.getInterceptor$ns(row);
    startOffset = t1.$mul(row, stride);
    last_row = t1.$add(row, numRows);
    s = U.InputBuffer$(src, false, null, startOffset);
    o = U.InputBuffer$(out, false, null, startOffset);
    preds = U.InputBuffer$from(inverse ? o : s, null, 0);
    if (t1.$eq(row, 0)) {
      t1 = J.$index$asx(s.buffer, J.$add$ns(s.offset, 0));
      J.$indexSet$ax(o.buffer, J.$add$ns(o.offset, 0), t1);
      U.WebPFilters__predictLine(U.InputBuffer$from(s, null, 1), preds, U.InputBuffer$from(o, null, 1), J.$sub$n(width, 1), inverse);
      s.offset = J.$add$ns(s.offset, stride);
      o.offset = J.$add$ns(o.offset, stride);
      row = 1;
    } else
      preds.offset = J.$sub$n(preds.offset, stride);
    for (; t1 = J.getInterceptor$n(row), t1.$lt(row, last_row);) {
      U.WebPFilters__predictLine(s, preds, o, width, inverse);
      row = t1.$add(row, 1);
      preds.offset = J.$add$ns(preds.offset, stride);
      s.offset = J.$add$ns(s.offset, stride);
      o.offset = J.$add$ns(o.offset, stride);
    }
  },
  WebPFilters__doGradientFilter: function(src, width, height, stride, row, numRows, inverse, out) {
    var t1, startOffset, lastRow, s, o, preds, t2, w, t3, t4, t5, g, pred;
    t1 = J.getInterceptor$ns(row);
    startOffset = t1.$mul(row, stride);
    lastRow = t1.$add(row, numRows);
    s = U.InputBuffer$(src, false, null, startOffset);
    o = U.InputBuffer$(out, false, null, startOffset);
    preds = U.InputBuffer$from(inverse ? o : s, null, 0);
    if (t1.$eq(row, 0)) {
      t1 = J.$index$asx(s.buffer, J.$add$ns(s.offset, 0));
      J.$indexSet$ax(o.buffer, J.$add$ns(o.offset, 0), t1);
      U.WebPFilters__predictLine(U.InputBuffer$from(s, null, 1), preds, U.InputBuffer$from(o, null, 1), J.$sub$n(width, 1), inverse);
      preds.offset = J.$add$ns(preds.offset, stride);
      s.offset = J.$add$ns(s.offset, stride);
      o.offset = J.$add$ns(o.offset, stride);
      row = 1;
    }
    for (t1 = J.getInterceptor$n(stride); t2 = J.getInterceptor$n(row), t2.$lt(row, lastRow);) {
      U.WebPFilters__predictLine(s, U.InputBuffer$from(preds, null, t1.$negate(stride)), o, 1, inverse);
      if (typeof width !== "number")
        return H.iae(width);
      w = 1;
      for (; w < width; ++w) {
        t3 = J.$index$asx(preds.buffer, J.$add$ns(preds.offset, w - 1));
        if (typeof stride !== "number")
          return H.iae(stride);
        t4 = w - stride;
        t5 = J.$index$asx(preds.buffer, J.$add$ns(preds.offset, t4));
        t4 = J.$index$asx(preds.buffer, J.$add$ns(preds.offset, t4 - 1));
        g = J.$sub$n(J.$add$ns(t3, t5), t4);
        if (J.$and$n(g, 4294967040) === 0)
          pred = g;
        else {
          if (typeof g !== "number")
            return g.$lt();
          pred = g < 0 ? 0 : 255;
        }
        t3 = J.$index$asx(s.buffer, J.$add$ns(s.offset, w));
        if (inverse)
          t4 = pred;
        else {
          if (typeof pred !== "number")
            return pred.$negate();
          t4 = -pred;
        }
        t4 = J.$add$ns(t3, t4);
        J.$indexSet$ax(o.buffer, J.$add$ns(o.offset, w), t4);
      }
      row = t2.$add(row, 1);
      preds.offset = J.$add$ns(preds.offset, stride);
      s.offset = J.$add$ns(s.offset, stride);
      o.offset = J.$add$ns(o.offset, stride);
    }
  },
  Half__initialize: function() {
    var t1, i, e, t2, t3;
    if ($.Half__toFloatUint32 != null)
      return;
    t1 = new Uint32Array(65536);
    $.Half__toFloatUint32 = t1;
    $.Half__toFloatFloat32 = H.NativeFloat32List_NativeFloat32List$view(t1.buffer, 0, null);
    t1 = new Uint16Array(512);
    $.Half__eLut = t1;
    for (i = 0; i < 256; ++i) {
      e = (i & 255) - 112;
      t2 = e <= 0 || e >= 30;
      t3 = (i | 256) >>> 0;
      if (t2) {
        if (i >= 512)
          return H.ioore(t1, i);
        t1[i] = 0;
        if (t3 >= 512)
          return H.ioore(t1, t3);
        t1[t3] = 0;
      } else {
        t2 = e << 10 >>> 0;
        if (i >= 512)
          return H.ioore(t1, i);
        t1[i] = t2;
        if (t3 >= 512)
          return H.ioore(t1, t3);
        t1[t3] = (t2 | 32768) >>> 0;
      }
    }
    for (i = 0; i < 65536; ++i) {
      t1 = $.Half__toFloatUint32;
      t2 = U.Half__halfToFloat(i);
      if (i >= t1.length)
        return H.ioore(t1, i);
      t1[i] = t2;
    }
  },
  Half__halfToFloat: function(y) {
    var s, e, m, t1;
    s = y >>> 15 & 1;
    e = y >>> 10 & 31;
    m = y & 1023;
    if (e === 0)
      if (m === 0)
        return s << 31 >>> 0;
      else {
        for (; (m & 1024) === 0;) {
          m = m << 1;
          --e;
        }
        ++e;
        m &= 4294966271;
      }
    else if (e === 31) {
      t1 = s << 31;
      if (m === 0)
        return (t1 | 2139095040) >>> 0;
      else
        return (t1 | 2139095040 | m << 13) >>> 0;
    }
    return (s << 31 | e + 112 << 23 | m << 13) >>> 0;
  },
  hdrToImage: function(hdr, exposure) {
    var t1, t2, t3, t4, image, pixels, m, y, di, x, r, g, b, ri, gi, bi, mi, di0, a;
    t1 = new U.hdrToImage__gamma(new U.hdrToImage__knee());
    t2 = hdr.slices;
    if (t2.get$isEmpty(t2))
      t3 = 0;
    else {
      t3 = t2.get$values(t2);
      t3 = J.get$width$x(t3._f$1(J.get$first$ax(t3._iterable)));
    }
    if (t2.get$isEmpty(t2))
      t4 = 0;
    else {
      t4 = t2.get$values(t2);
      t4 = J.get$height$x(t4._f$1(J.get$first$ax(t4._iterable)));
    }
    image = U.Image$(t3, t4, 4);
    pixels = H.NativeUint8List_NativeUint8List$view(image.data.buffer, 0, null);
    if (!(hdr.red != null || hdr.green != null || hdr.blue != null))
      throw H.wrapException(U.ImageException$("Only RGB[A] images are currently supported."));
    t3 = C.JSNumber_methods.clamp$2(exposure + 2.47393, -20, 20);
    m = Math.pow(2, t3);
    t3 = pixels.length;
    y = 0;
    di = 0;
    while (true) {
      if (t2.get$isEmpty(t2))
        t4 = 0;
      else {
        t4 = t2.get$values(t2);
        t4 = J.get$height$x(t4._f$1(J.get$first$ax(t4._iterable)));
      }
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (!(y < t4))
        break;
      x = 0;
      while (true) {
        if (t2.get$isEmpty(t2))
          t4 = 0;
        else {
          t4 = t2.get$values(t2);
          t4 = J.get$width$x(t4._f$1(J.get$first$ax(t4._iterable)));
        }
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(x < t4))
          break;
        t4 = hdr.red;
        r = t4 != null ? t4.getFloat$2(x, y) : 0;
        t4 = hdr.green;
        g = t4 != null ? t4.getFloat$2(x, y) : 0;
        t4 = hdr.blue;
        b = t4 != null ? t4.getFloat$2(x, y) : 0;
        if (r == Infinity || r == -Infinity || isNaN(r))
          r = 0;
        if (g == Infinity || g == -Infinity || isNaN(g))
          g = 0;
        if (b == Infinity || b == -Infinity || isNaN(b))
          b = 0;
        ri = t1.call$2(r, m);
        gi = t1.call$2(g, m);
        bi = t1.call$2(b, m);
        mi = P.max(ri, P.max(gi, bi));
        if (mi > 255) {
          ri = 255 * J.$div$n(ri, mi);
          gi = 255 * J.$div$n(gi, mi);
          bi = 255 * J.$div$n(bi, mi);
        }
        di0 = di + 1;
        t4 = C.JSInt_methods.clamp$2(J.toInt$0$n(ri), 0, 255);
        if (di < 0 || di >= t3)
          return H.ioore(pixels, di);
        pixels[di] = t4;
        di = di0 + 1;
        t4 = C.JSInt_methods.clamp$2(J.toInt$0$n(gi), 0, 255);
        if (di0 < 0 || di0 >= t3)
          return H.ioore(pixels, di0);
        pixels[di0] = t4;
        di0 = di + 1;
        t4 = C.JSInt_methods.clamp$2(J.toInt$0$n(bi), 0, 255);
        if (di < 0 || di >= t3)
          return H.ioore(pixels, di);
        pixels[di] = t4;
        t4 = hdr.alpha;
        if (t4 != null) {
          a = t4.getFloat$2(x, y);
          if (a == Infinity || a == -Infinity || isNaN(a))
            a = 1;
          di = di0 + 1;
          t4 = C.JSInt_methods.clamp$2(C.JSNumber_methods.toInt$0(a * 255), 0, 255);
          if (di0 < 0 || di0 >= t3)
            return H.ioore(pixels, di0);
          pixels[di0] = t4;
        } else {
          di = di0 + 1;
          if (di0 < 0 || di0 >= t3)
            return H.ioore(pixels, di0);
          pixels[di0] = 255;
        }
        ++x;
      }
      ++y;
    }
    return image;
  },
  DecodeInfo: {
    "^": "Object;width>,height>"
  },
  Decoder: {
    "^": "Object;"
  },
  ExrAttribute: {
    "^": "Object;name>,type>,size>,data>",
    size$0: function($receiver) {
      return this.size.call$0();
    }
  },
  ExrB44Compressor: {
    "^": "ExrCompressor;_maxScanLineSize,_numScanLines,_optFlatFields,decodedWidth,decodedHeight,_header",
    numScanLines$0: function() {
      return this._numScanLines;
    },
    uncompress$5: function(inPtr, x, y, width, height) {
      throw H.wrapException(U.ImageException$("B44 compression not yet supported."));
    },
    uncompress$3: function(inPtr, x, y) {
      return this.uncompress$5(inPtr, x, y, null, null);
    }
  },
  ExrChannel: {
    "^": "Object;name>,type>,size>,pLinear,xSampling<,ySampling<",
    size$0: function($receiver) {
      return this.size.call$0();
    },
    ExrChannel$1: function(input) {
      var t1, t2;
      t1 = input.readString$0();
      this.name = t1;
      if (t1.length === 0) {
        this.name = null;
        return;
      }
      this.type = input.readUint32$0();
      t1 = input.buffer;
      t2 = input.offset;
      input.offset = J.$add$ns(t2, 1);
      this.pLinear = J.$eq(J.$index$asx(t1, t2), 1);
      input.offset = J.$add$ns(input.offset, 3);
      this.xSampling = input.readUint32$0();
      this.ySampling = input.readUint32$0();
      t1 = this.type;
      switch (t1) {
        case 0:
          this.size = 4;
          break;
        case 1:
          this.size = 2;
          break;
        case 2:
          this.size = 4;
          break;
        default:
          throw H.wrapException(U.ImageException$("EXR Invalid pixel type: " + H.S(t1)));
      }
    },
    static: {"^": "ExrChannel_TYPE_UINT,ExrChannel_TYPE_HALF,ExrChannel_TYPE_FLOAT,ExrChannel_Y,ExrChannel_RY,ExrChannel_BY,ExrChannel_AR,ExrChannel_AG,ExrChannel_AB,ExrChannel_Z,ExrChannel_ZBack,ExrChannel_A,ExrChannel_R,ExrChannel_G,ExrChannel_B,ExrChannel_ID", ExrChannel$: function(input) {
        var t1 = new U.ExrChannel(null, null, null, null, null, null);
        t1.ExrChannel$1(input);
        return t1;
      }}
  },
  ExrCompressor: {
    "^": "Object;",
    uncompress$5: function(inPtr, x, y, width, height) {
      throw H.wrapException(U.ImageException$("Unsupported compression type"));
    },
    uncompress$3: function(inPtr, x, y) {
      return this.uncompress$5(inPtr, x, y, null, null);
    },
    _image$_numSamples$3: function(s, a, b) {
      var a1, t1;
      a1 = C.JSNumber_methods.$tdiv(a, s);
      t1 = J.$sub$n(J.$tdiv$n(b, s), a1);
      return J.$add$ns(t1, a1 * s < a ? 0 : 1);
    }
  },
  ExrHufDec: {
    "^": "Object;len<,lit,p>",
    p$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.p.call$4(arg0, arg1, arg2, arg3);
    }
  },
  ExrImage: {
    "^": "DecodeInfo;parts,version,flags,width,height,backgroundColor",
    _readImage$1: function(input) {
      var t1, pi, part, framebuffer, t2, ci, t3, ch, t4, t5, t6, t7, t8, t9;
      J.$and$n(this.flags, 16);
      for (t1 = this.parts, pi = 0; pi < t1.length; ++pi) {
        part = t1[pi];
        framebuffer = part.get$framebuffer();
        for (t2 = framebuffer.slices, ci = 0; t3 = part.channels, ci < t3.length; ++ci) {
          ch = t3[ci];
          t3 = J.getInterceptor$x(ch);
          if (!t2.containsKey$1(t3.get$name(ch))) {
            this.width = part.width;
            this.height = part.height;
            t4 = t3.get$name(ch);
            t5 = t3.get$name(ch);
            t6 = part.width;
            t7 = part.height;
            t3 = t3.get$type(ch);
            t8 = J.getInterceptor(t3);
            if (t8.$eq(t3, 1)) {
              t8 = J.$mul$ns(t6, t7);
              if (typeof t8 !== "number" || Math.floor(t8) !== t8)
                H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t8)));
              t8 = new Uint16Array(t8);
            } else {
              t9 = J.getInterceptor$ns(t6);
              if (t8.$eq(t3, 2)) {
                t8 = t9.$mul(t6, t7);
                if (typeof t8 !== "number" || Math.floor(t8) !== t8)
                  H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t8)));
                t8 = new Float32Array(t8);
              } else {
                t8 = t9.$mul(t6, t7);
                if (typeof t8 !== "number" || Math.floor(t8) !== t8)
                  H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t8)));
                t8 = new Uint32Array(t8);
              }
            }
            framebuffer.addSlice$2(t4, new U.HdrSlice(t5, t6, t7, t3, t8));
          }
        }
        if (part._tiled)
          this._readTiledPart$2(pi, input);
        else
          this._readScanlinePart$2(pi, input);
      }
    },
    _readTiledPart$2: function(pi, input) {
      var t1, part, multiPart, framebuffer, compressor, offsets, imgData, ly, l, t2, lx, ty, oi, t3, tx, tileX, tileY, dataSize, pos, t4, t5, t6, ty0, tx0, tileWidth, tileHeight, uncompressedData, len, numChannels, si, yi, ci, ch, slice, xx, bi, si0, di;
      t1 = this.parts;
      if (pi >= t1.length)
        return H.ioore(t1, pi);
      part = t1[pi];
      multiPart = J.$and$n(this.flags, 16) !== 0;
      framebuffer = part.get$framebuffer();
      compressor = part._compressor;
      offsets = part._offsets;
      t1 = part.channels.length;
      new Uint32Array(t1);
      imgData = U.InputBuffer$from(input, null, 0);
      t1 = framebuffer.slices;
      ly = 0;
      l = 0;
      while (true) {
        t2 = part._numYLevels;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(ly < t2))
          break;
        lx = 0;
        while (true) {
          t2 = part._numXLevels;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(lx < t2))
            break;
          t2 = l !== 0;
          ty = 0;
          oi = 0;
          while (true) {
            t3 = part._numYTiles;
            if (ly >= t3.length)
              return H.ioore(t3, ly);
            t3 = t3[ly];
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(ty < t3))
              break;
            tx = 0;
            while (true) {
              t3 = part._numXTiles;
              if (lx >= t3.length)
                return H.ioore(t3, lx);
              t3 = t3[lx];
              if (typeof t3 !== "number")
                return H.iae(t3);
              if (!(tx < t3))
                break;
              if (t2)
                break;
              if (l < 0 || l >= offsets.length)
                return H.ioore(offsets, l);
              imgData.offset = J.$index$asx(offsets[l], oi);
              if (multiPart)
                if (imgData.readUint32$0() !== pi)
                  throw H.wrapException(U.ImageException$("Invalid Image Data"));
              tileX = imgData.readUint32$0();
              tileY = imgData.readUint32$0();
              imgData.readUint32$0();
              imgData.readUint32$0();
              dataSize = imgData.readUint32$0();
              pos = J.$add$ns(imgData.offset, 0);
              t3 = imgData.buffer;
              t4 = imgData.bigEndian;
              t5 = J.$add$ns(pos, dataSize);
              imgData.offset = J.$add$ns(imgData.offset, J.$sub$n(t5, pos));
              t6 = part._tileHeight;
              if (typeof t6 !== "number")
                return H.iae(t6);
              ty0 = tileY * t6;
              t6 = part._tileWidth;
              if (typeof t6 !== "number")
                return H.iae(t6);
              tx0 = tileX * t6;
              tileWidth = compressor.decodedWidth;
              tileHeight = compressor.decodedHeight;
              if (typeof tileWidth !== "number")
                return H.iae(tileWidth);
              t6 = this.width;
              if (typeof t6 !== "number")
                return H.iae(t6);
              if (tx0 + tileWidth > t6)
                ;
              if (typeof tileHeight !== "number")
                return H.iae(tileHeight);
              t6 = this.height;
              if (typeof t6 !== "number")
                return H.iae(t6);
              if (ty0 + tileHeight > t6)
                ;
              uncompressedData = compressor.uncompress$5(new U.InputBuffer(t3, pos, t5, pos, t4), tx0, ty0, part._tileWidth, part._tileHeight);
              tileWidth = compressor.decodedWidth;
              tileHeight = compressor.decodedHeight;
              len = uncompressedData.length;
              numChannels = part.channels.length;
              if (typeof tileHeight !== "number")
                return H.iae(tileHeight);
              si = 0;
              yi = 0;
              while (true) {
                if (yi < tileHeight) {
                  t3 = this.height;
                  if (typeof t3 !== "number")
                    return H.iae(t3);
                  t3 = ty0 < t3;
                } else
                  t3 = false;
                if (!t3)
                  break;
                for (ci = 0; ci < numChannels; ++ci) {
                  t3 = part.channels;
                  if (ci >= t3.length)
                    return H.ioore(t3, ci);
                  ch = t3[ci];
                  t3 = J.getInterceptor$x(ch);
                  slice = t1.$index(0, t3.get$name(ch)).getBytes$0();
                  if (si >= len)
                    break;
                  t4 = part._tileWidth;
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  tx0 = tileX * t4;
                  if (typeof tileWidth !== "number")
                    return H.iae(tileWidth);
                  t4 = slice.length;
                  xx = 0;
                  for (; xx < tileWidth; ++xx, ++tx0) {
                    bi = 0;
                    while (true) {
                      t5 = t3.get$size(ch);
                      if (typeof t5 !== "number")
                        return H.iae(t5);
                      if (!(bi < t5))
                        break;
                      t5 = part.width;
                      if (typeof t5 !== "number")
                        return H.iae(t5);
                      if (tx0 < t5) {
                        t6 = part.height;
                        if (typeof t6 !== "number")
                          return H.iae(t6);
                        t6 = ty0 < t6;
                      } else
                        t6 = false;
                      si0 = si + 1;
                      if (t6) {
                        t6 = t3.get$size(ch);
                        if (typeof t6 !== "number")
                          return H.iae(t6);
                        di = (ty0 * t5 + tx0) * t6 + bi;
                        if (si < 0 || si >= len)
                          return H.ioore(uncompressedData, si);
                        t6 = uncompressedData[si];
                        if (di >>> 0 !== di || di >= t4)
                          return H.ioore(slice, di);
                        slice[di] = t6;
                        si = si0;
                      } else
                        si = si0;
                      ++bi;
                    }
                  }
                }
                ++yi;
                ++ty0;
              }
              ++tx;
              ++oi;
            }
            ++ty;
          }
          ++lx;
          ++l;
        }
        ++ly;
      }
    },
    _readScanlinePart$2: function(pi, input) {
      var t1, part, multiPart, framebuffer, compressor, offsets, scanLineMin, linesInBuffer, fbi, imgData, t2, t3, t4, yy, t5, t6, dataSize, pos, t7, bytes, uncompressedData, len, numChannels, yi, si, ci, ch, slice, xx, bi, si0, t8;
      t1 = this.parts;
      if (pi >= t1.length)
        return H.ioore(t1, pi);
      part = t1[pi];
      multiPart = J.$and$n(this.flags, 16) !== 0;
      framebuffer = part.get$framebuffer();
      compressor = part._compressor;
      t1 = part._offsets;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      offsets = t1[0];
      t1 = part.dataWindow;
      scanLineMin = t1[1];
      t1[3];
      linesInBuffer = part._linesInBuffer;
      J.$sub$n(J.$add$ns(scanLineMin, linesInBuffer), 1);
      t1 = part.channels.length;
      fbi = new Uint32Array(t1);
      imgData = U.InputBuffer$from(input, null, 0);
      for (t2 = J.get$iterator$ax(offsets), t3 = framebuffer.slices, t4 = compressor != null, yy = 0; t2.moveNext$0();) {
        imgData.offset = t2.get$current();
        if (multiPart)
          if (imgData.readUint32$0() !== pi)
            throw H.wrapException(U.ImageException$("Invalid Image Data"));
        t5 = imgData.readUint32$0();
        t6 = $.get$__uint32();
        t6[0] = t5;
        t5 = $.get$__uint32ToInt32();
        if (0 >= t5.length)
          return H.ioore(t5, 0);
        t5[0];
        t6[0] = imgData.readUint32$0();
        if (0 >= t5.length)
          return H.ioore(t5, 0);
        dataSize = t5[0];
        pos = J.$add$ns(imgData.offset, 0);
        t5 = imgData.buffer;
        t6 = imgData.bigEndian;
        t7 = J.$add$ns(pos, dataSize);
        bytes = new U.InputBuffer(t5, pos, t7, pos, t6);
        imgData.offset = J.$add$ns(imgData.offset, J.$sub$n(t7, pos));
        uncompressedData = t4 ? compressor.uncompress$3(bytes, 0, yy) : bytes.toUint8List$0();
        len = uncompressedData.length;
        numChannels = part.channels.length;
        if (typeof linesInBuffer !== "number")
          return H.iae(linesInBuffer);
        yi = 0;
        while (true) {
          if (yi < linesInBuffer) {
            t5 = this.height;
            if (typeof t5 !== "number")
              return H.iae(t5);
            t5 = yy < t5;
          } else
            t5 = false;
          if (!t5)
            break;
          t5 = part._offsetInLineBuffer;
          if (yy < 0 || yy >= t5.length)
            return H.ioore(t5, yy);
          si = t5[yy];
          if (si >= len)
            break;
          for (ci = 0; ci < numChannels; ++ci) {
            t5 = part.channels;
            if (ci >= t5.length)
              return H.ioore(t5, ci);
            ch = t5[ci];
            t5 = J.getInterceptor$x(ch);
            slice = t3.$index(0, t5.get$name(ch)).getBytes$0();
            if (si >= len)
              break;
            t6 = slice.length;
            xx = 0;
            while (true) {
              t7 = part.width;
              if (typeof t7 !== "number")
                return H.iae(t7);
              if (!(xx < t7))
                break;
              bi = 0;
              while (true) {
                t7 = t5.get$size(ch);
                if (typeof t7 !== "number")
                  return H.iae(t7);
                if (!(bi < t7))
                  break;
                if (ci >= t1)
                  return H.ioore(fbi, ci);
                t7 = fbi[ci];
                fbi[ci] = t7 + 1;
                si0 = si + 1;
                if (si < 0 || si >= len)
                  return H.ioore(uncompressedData, si);
                t8 = uncompressedData[si];
                if (t7 >= t6)
                  return H.ioore(slice, t7);
                slice[t7] = t8;
                ++bi;
                si = si0;
              }
              ++xx;
            }
          }
          ++yi;
          ++yy;
        }
      }
    },
    ExrImage$1: function(bytes) {
      var input, t1, t2, part;
      input = U.InputBuffer$(bytes, false, null, 0);
      if (input.readUint32$0() !== 20000630)
        throw H.wrapException(U.ImageException$("File is not an OpenEXR image file."));
      t1 = input.buffer;
      t2 = input.offset;
      input.offset = J.$add$ns(t2, 1);
      t2 = J.$index$asx(t1, t2);
      this.version = t2;
      if (!J.$eq(t2, 2))
        throw H.wrapException(U.ImageException$("Cannot read version " + H.S(this.version) + " image files."));
      t1 = input.readUint24$0();
      this.flags = t1;
      if (J.$and$n(t1, 4294967289) !== 0)
        throw H.wrapException(U.ImageException$("The file format version number's flag field contains unrecognized flags."));
      if (J.$and$n(this.flags, 16) === 0) {
        part = U.ExrPart$(J.$and$n(this.flags, 2) !== 0, input);
        if (part.width != null)
          this.parts.push(part);
      } else
        for (t1 = this.parts; true;) {
          part = U.ExrPart$(J.$and$n(this.flags, 2) !== 0, input);
          if (part.width == null)
            break;
          t1.push(part);
        }
      t1 = this.parts;
      t2 = t1.length;
      if (t2 === 0)
        throw H.wrapException(U.ImageException$("Error reading image header"));
      for (t1 = new H.ListIterator(t1, t2, 0, null); t1.moveNext$0();)
        t1._current._readOffsets$1(input);
      this._readImage$1(input);
    },
    $isExrImage: true,
    static: {"^": "ExrImage_MAGIC,ExrImage_EXR_VERSION,ExrImage_TILED_FLAG,ExrImage_LONG_NAMES_FLAG,ExrImage_NON_IMAGE_FLAG,ExrImage_MULTI_PART_FILE_FLAG,ExrImage_ALL_FLAGS", ExrImage$: function(bytes) {
        var t1 = new U.ExrImage([], null, null, 0, 0, 4294967295);
        t1.ExrImage$1(bytes);
        return t1;
      }, ExrImage_isValidFile: function(bytes) {
        var input, t1, t2;
        input = U.InputBuffer$(bytes, false, null, 0);
        if (input.readUint32$0() !== 20000630)
          return false;
        t1 = input.buffer;
        t2 = input.offset;
        input.offset = J.$add$ns(t2, 1);
        if (!J.$eq(J.$index$asx(t1, t2), 2))
          return false;
        if (J.$and$n(input.readUint24$0(), 4294967289) !== 0)
          return false;
        return true;
      }}
  },
  ExrPart: {
    "^": "Object;framebuffer<,channels,attributes,displayWindow,dataWindow,width>,height>,pixelAspectRatio,screenWindowCenterX,screenWindowCenterY,screenWindowWidth,chromaticities,_type,_lineOrder,_compressionType,_offsets,_bytesPerLine,_compressor,_linesInBuffer,_lineBufferSize,_offsetInLineBuffer,_tiled,_tileWidth,_tileHeight,_tileLevelMode,_tileRoundingMode,_numXTiles,_numYTiles,_numXLevels,_numYLevels,_bytesPerPixel,_maxBytesPerTileLine,_tileBufferSize",
    _floorLog2$1: function(x) {
      var y;
      for (y = 0; J.getInterceptor$n(x).$gt(x, 1);) {
        ++y;
        if (typeof x !== "number")
          return x.$shr();
        x = C.JSNumber_methods._shrOtherPositive$1(x, 1);
      }
      return y;
    },
    _ceilLog2$1: function(x) {
      var y, r;
      for (y = 0, r = 0; J.getInterceptor$n(x).$gt(x, 1);) {
        if (typeof x !== "number")
          return x.$and();
        if ((x & 1) !== 0)
          r = 1;
        ++y;
        x = C.JSNumber_methods._shrOtherPositive$1(x, 1);
      }
      return y + r;
    },
    _readOffsets$1: function(input) {
      var i, j, t1, numOffsets;
      if (this._tiled)
        for (i = 0; i < this._offsets.length; ++i) {
          j = 0;
          while (true) {
            t1 = this._offsets;
            if (i >= t1.length)
              return H.ioore(t1, i);
            t1 = J.get$length$asx(t1[i]);
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (!(j < t1))
              break;
            t1 = this._offsets;
            if (i >= t1.length)
              return H.ioore(t1, i);
            J.$indexSet$ax(t1[i], j, input.readUint64$0());
            ++j;
          }
        }
      else {
        t1 = this._offsets;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        numOffsets = J.get$length$asx(t1[0]);
        if (typeof numOffsets !== "number")
          return H.iae(numOffsets);
        i = 0;
        for (; i < numOffsets; ++i) {
          t1 = this._offsets;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          J.$indexSet$ax(t1[0], i, input.readUint64$0());
        }
      }
    },
    _calculateBytesPerPixel$0: function() {
      var t1, bytesPerPixel, t2;
      for (t1 = this.channels, t1 = new H.ListIterator(t1, t1.length, 0, null), bytesPerPixel = 0; t1.moveNext$0();) {
        t2 = J.get$size$x(t1._current);
        if (typeof t2 !== "number")
          return H.iae(t2);
        bytesPerPixel += t2;
      }
      return bytesPerPixel;
    },
    _calculateNumTiles$6: function(numTiles, numLevels, min, max, size, rmode) {
      var t1, t2, i, a, b, size0, t3;
      if (typeof numLevels !== "number")
        return H.iae(numLevels);
      t1 = rmode === 1;
      t2 = J.getInterceptor$n(max);
      i = 0;
      for (; i < numLevels; ++i) {
        a = J.$add$ns(t2.$sub(max, min), 1);
        b = C.JSInt_methods._shlPositive$1(1, i);
        size0 = J.$tdiv$n(a, b);
        t3 = P.max(t1 && J.$lt$n(J.$mul$ns(size0, b), a) ? J.$add$ns(size0, 1) : size0, 1);
        if (typeof size !== "number")
          return H.iae(size);
        t3 = C.JSNumber_methods.$tdiv(t3 + size - 1, size);
        if (i >= numTiles.length)
          return H.ioore(numTiles, i);
        numTiles[i] = t3;
      }
    },
    ExrPart$2: function(_tiled, input) {
      var t1, t2, $name, type, size, pos, t3, t4, t5, bytes, channel, t6, t7, mode, s, num, w, h, ly, l, lx, ch, nBytes, y, maxBytesPerLine, offset, i, numOffsets;
      t1 = this._tiled;
      this._type = t1 ? 1 : 0;
      for (t2 = this.attributes; true;) {
        $name = input.readString$0();
        if ($name.length === 0)
          break;
        type = input.readString$0();
        size = input.readUint32$0();
        pos = J.$add$ns(input.offset, 0);
        t3 = input.buffer;
        t4 = input.bigEndian;
        t5 = J.$add$ns(pos, size);
        bytes = new U.InputBuffer(t3, pos, t5, pos, t4);
        input.offset = J.$add$ns(input.offset, J.$sub$n(t5, pos));
        t2.$indexSet(0, $name, new U.ExrAttribute($name, type, size, bytes));
        switch ($name) {
          case "channels":
            for (; true;) {
              channel = U.ExrChannel$(bytes);
              if (channel.name == null)
                break;
              this.channels.push(channel);
            }
            break;
          case "chromaticities":
            t3 = new Float32Array(8);
            this.chromaticities = t3;
            t4 = bytes.readUint32$0();
            t5 = $.get$__uint32();
            t5[0] = t4;
            t4 = $.get$__uint32ToFloat32();
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t3[0] = t4[0];
            t3 = this.chromaticities;
            t5[0] = bytes.readUint32$0();
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t3[1] = t4[0];
            t3 = this.chromaticities;
            t5[0] = bytes.readUint32$0();
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t3[2] = t4[0];
            t3 = this.chromaticities;
            t5[0] = bytes.readUint32$0();
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t3[3] = t4[0];
            t3 = this.chromaticities;
            t5[0] = bytes.readUint32$0();
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t3[4] = t4[0];
            t3 = this.chromaticities;
            t5[0] = bytes.readUint32$0();
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t3[5] = t4[0];
            t3 = this.chromaticities;
            t5[0] = bytes.readUint32$0();
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t3[6] = t4[0];
            t3 = this.chromaticities;
            t5[0] = bytes.readUint32$0();
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t3[7] = t4[0];
            break;
          case "compression":
            t3 = bytes.buffer;
            t4 = bytes.offset;
            bytes.offset = J.$add$ns(t4, 1);
            t4 = J.$index$asx(t3, t4);
            this._compressionType = t4;
            if (J.$gt$n(t4, 7))
              throw H.wrapException(U.ImageException$("EXR Invalid compression type"));
            break;
          case "dataWindow":
            t3 = bytes.readUint32$0();
            t4 = $.get$__uint32();
            t4[0] = t3;
            t3 = $.get$__uint32ToInt32();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t5 = t3[0];
            t4[0] = bytes.readUint32$0();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t6 = t3[0];
            t4[0] = bytes.readUint32$0();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t7 = t3[0];
            t4[0] = bytes.readUint32$0();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t3 = [t5, t6, t7, t3[0]];
            this.dataWindow = t3;
            this.width = J.$add$ns(J.$sub$n(t3[2], t3[0]), 1);
            t3 = this.dataWindow;
            this.height = J.$add$ns(J.$sub$n(t3[3], t3[1]), 1);
            break;
          case "displayWindow":
            t3 = bytes.readUint32$0();
            t4 = $.get$__uint32();
            t4[0] = t3;
            t3 = $.get$__uint32ToInt32();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t5 = t3[0];
            t4[0] = bytes.readUint32$0();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t6 = t3[0];
            t4[0] = bytes.readUint32$0();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t7 = t3[0];
            t4[0] = bytes.readUint32$0();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            this.displayWindow = [t5, t6, t7, t3[0]];
            break;
          case "lineOrder":
            t3 = bytes.buffer;
            t4 = bytes.offset;
            bytes.offset = J.$add$ns(t4, 1);
            this._lineOrder = J.$index$asx(t3, t4);
            break;
          case "pixelAspectRatio":
            t3 = bytes.readUint32$0();
            $.get$__uint32()[0] = t3;
            t3 = $.get$__uint32ToFloat32();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            this.pixelAspectRatio = t3[0];
            break;
          case "screenWindowCenter":
            t3 = bytes.readUint32$0();
            t4 = $.get$__uint32();
            t4[0] = t3;
            t3 = $.get$__uint32ToFloat32();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            this.screenWindowCenterX = t3[0];
            t4[0] = bytes.readUint32$0();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            this.screenWindowCenterY = t3[0];
            break;
          case "screenWindowWidth":
            t3 = bytes.readUint32$0();
            $.get$__uint32()[0] = t3;
            t3 = $.get$__uint32ToFloat32();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            this.screenWindowWidth = t3[0];
            break;
          case "tiles":
            this._tileWidth = bytes.readUint32$0();
            this._tileHeight = bytes.readUint32$0();
            t3 = bytes.buffer;
            t4 = bytes.offset;
            bytes.offset = J.$add$ns(t4, 1);
            mode = J.$index$asx(t3, t4);
            this._tileLevelMode = J.getInterceptor$n(mode).$and(mode, 15);
            if (typeof mode !== "number")
              return mode.$shr();
            this._tileRoundingMode = C.JSNumber_methods._shrOtherPositive$1(mode, 4) & 15;
            break;
          case "type":
            s = bytes.readString$0();
            if (s === "deepscanline")
              this._type = 2;
            else if (s === "deeptile")
              this._type = 3;
            else
              throw H.wrapException(U.ImageException$("EXR Invalid type: " + s));
            break;
          default:
            break;
        }
      }
      if (t1) {
        t1 = this.dataWindow;
        t2 = t1[0];
        t3 = t1[2];
        t4 = t1[1];
        t1 = t1[3];
        switch (this._tileLevelMode) {
          case 0:
            num = 1;
            break;
          case 1:
            t1 = P.max(J.$add$ns(J.$sub$n(t3, t2), 1), J.$add$ns(J.$sub$n(t1, t4), 1));
            num = (this._tileRoundingMode === 0 ? this._floorLog2$1(t1) : this._ceilLog2$1(t1)) + 1;
            break;
          case 2:
            w = J.$add$ns(J.$sub$n(t3, t2), 1);
            num = (this._tileRoundingMode === 0 ? this._floorLog2$1(w) : this._ceilLog2$1(w)) + 1;
            break;
          default:
            H.throwExpression(U.ImageException$("Unknown LevelMode format."));
            num = 0;
        }
        this._numXLevels = num;
        t1 = this.dataWindow;
        t2 = t1[0];
        t3 = t1[2];
        t4 = t1[1];
        t1 = t1[3];
        switch (this._tileLevelMode) {
          case 0:
            num = 1;
            break;
          case 1:
            t1 = P.max(J.$add$ns(J.$sub$n(t3, t2), 1), J.$add$ns(J.$sub$n(t1, t4), 1));
            num = (this._tileRoundingMode === 0 ? this._floorLog2$1(t1) : this._ceilLog2$1(t1)) + 1;
            break;
          case 2:
            h = J.$add$ns(J.$sub$n(t1, t4), 1);
            num = (this._tileRoundingMode === 0 ? this._floorLog2$1(h) : this._ceilLog2$1(h)) + 1;
            break;
          default:
            H.throwExpression(U.ImageException$("Unknown LevelMode format."));
            num = 0;
        }
        this._numYLevels = num;
        if (this._tileLevelMode !== 2)
          this._numYLevels = 1;
        t1 = this._numXLevels;
        if (typeof t1 !== "number")
          return H.iae(t1);
        this._numXTiles = H.setRuntimeTypeInfo(Array(t1), [J.JSInt]);
        t1 = this._numYLevels;
        if (typeof t1 !== "number")
          return H.iae(t1);
        this._numYTiles = H.setRuntimeTypeInfo(Array(t1), [J.JSInt]);
        t1 = this._numXTiles;
        t2 = this._numXLevels;
        t3 = this.dataWindow;
        this._calculateNumTiles$6(t1, t2, t3[0], t3[2], this._tileWidth, this._tileRoundingMode);
        t3 = this._numYTiles;
        t2 = this._numYLevels;
        t1 = this.dataWindow;
        this._calculateNumTiles$6(t3, t2, t1[1], t1[3], this._tileHeight, this._tileRoundingMode);
        t1 = this._calculateBytesPerPixel$0();
        this._bytesPerPixel = t1;
        t2 = this._tileWidth;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 * t2;
        this._maxBytesPerTileLine = t2;
        t1 = this._tileHeight;
        if (typeof t1 !== "number")
          return H.iae(t1);
        this._tileBufferSize = t2 * t1;
        this._compressor = U.ExrCompressor_ExrCompressor(this._compressionType, this, t2, t1);
        t1 = this._numXLevels;
        t2 = this._numYLevels;
        if (typeof t1 !== "number")
          return t1.$mul();
        if (typeof t2 !== "number")
          return H.iae(t2);
        this._offsets = H.setRuntimeTypeInfo(Array(t1 * t2), [P.Uint32List]);
        ly = 0;
        l = 0;
        while (true) {
          t1 = this._numYLevels;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(ly < t1))
            break;
          lx = 0;
          while (true) {
            t1 = this._numXLevels;
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (!(lx < t1))
              break;
            t1 = this._offsets;
            t2 = this._numXTiles;
            if (lx >= t2.length)
              return H.ioore(t2, lx);
            t2 = t2[lx];
            t3 = this._numYTiles;
            if (ly >= t3.length)
              return H.ioore(t3, ly);
            t3 = J.$mul$ns(t2, t3[ly]);
            if (typeof t3 !== "number" || Math.floor(t3) !== t3)
              H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t3)));
            t2 = new Uint32Array(t3);
            if (l < 0 || l >= t1.length)
              return H.ioore(t1, l);
            t1[l] = t2;
            ++lx;
            ++l;
          }
          ++ly;
        }
      } else {
        t1 = J.$add$ns(this.height, 1);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        this._bytesPerLine = new Uint32Array(t1);
        for (t1 = this.channels, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();) {
          ch = t1._current;
          t2 = J.get$size$x(ch);
          t3 = this.width;
          if (typeof t2 !== "number")
            return t2.$mul();
          if (typeof t3 !== "number")
            return H.iae(t3);
          nBytes = C.JSNumber_methods.$tdiv(t2 * t3, ch.get$xSampling());
          t2 = this.height;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = this.dataWindow;
          t4 = ch.ySampling;
          t5 = this._bytesPerLine;
          y = 0;
          for (; y < t2; ++y) {
            t6 = t3[1];
            if (typeof t6 !== "number")
              return H.iae(t6);
            if (C.JSNumber_methods.$mod(y + t6, t4) === 0) {
              if (y >= t5.length)
                return H.ioore(t5, y);
              t5[y] = t5[y] + nBytes;
            }
          }
        }
        maxBytesPerLine = 0;
        y = 0;
        while (true) {
          t1 = this.height;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(y < t1))
            break;
          t1 = this._bytesPerLine;
          if (y >= t1.length)
            return H.ioore(t1, y);
          maxBytesPerLine = P.max(maxBytesPerLine, t1[y]);
          ++y;
        }
        t1 = U.ExrCompressor_ExrCompressor(this._compressionType, this, maxBytesPerLine, null);
        this._compressor = t1;
        t1 = t1.numScanLines$0();
        this._linesInBuffer = t1;
        if (typeof t1 !== "number")
          return H.iae(t1);
        this._lineBufferSize = maxBytesPerLine * t1;
        t1 = this._bytesPerLine.length;
        t2 = new Uint32Array(t1);
        this._offsetInLineBuffer = t2;
        for (t3 = this._bytesPerLine, t4 = t3.length - 1, t5 = this._linesInBuffer, offset = 0, i = 0; i <= t4; ++i) {
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (C.JSInt_methods.$mod(i, t5) === 0)
            offset = 0;
          if (i >= t1)
            return H.ioore(t2, i);
          t2[i] = offset;
          offset += t3[i];
        }
        numOffsets = J.$sub$n(J.$tdiv$n(J.$add$ns(this.height, t5), this._linesInBuffer), 1);
        if (typeof numOffsets !== "number" || Math.floor(numOffsets) !== numOffsets)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(numOffsets)));
        this._offsets = [new Uint32Array(numOffsets)];
      }
    },
    static: {"^": "ExrPart_TYPE_SCANLINE,ExrPart_TYPE_TILE,ExrPart_TYPE_DEEP_SCANLINE,ExrPart_TYPE_DEEP_TILE,ExrPart_INCREASING_Y,ExrPart_DECREASING_Y,ExrPart_RANDOM_Y,ExrPart_ONE_LEVEL,ExrPart_MIPMAP_LEVELS,ExrPart_RIPMAP_LEVELS,ExrPart_ROUND_DOWN,ExrPart_ROUND_UP", ExrPart$: function(_tiled, input) {
        var t1 = new U.ExrPart(new U.HdrImage(P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null), [], P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, 1, 0, 0, 1, null, null, 0, 0, null, null, null, null, null, null, _tiled, null, null, null, null, null, null, null, null, null, null, null);
        t1.ExrPart$2(_tiled, input);
        return t1;
      }}
  },
  ExrPizCompressor: {
    "^": "ExrCompressor;_output,_maxScanLineSize,_numScanLines,_channelData,_tmpBuffer,decodedWidth,decodedHeight,_header",
    numScanLines$0: function() {
      return this._numScanLines;
    },
    uncompress$5: function(inPtr, x, y, width, height) {
      var maxX, maxY, t1, t2, channels, numChannels, tmpBufferEnd, i, ch, cd, minNonZero, maxNonZero, bitmap, b, len, j, j0, lut, maxValue, t3, t4;
      if (width == null)
        width = this._header.width;
      if (height == null)
        height = this._header._linesInBuffer;
      if (typeof width !== "number")
        return H.iae(width);
      maxX = x + width - 1;
      if (typeof height !== "number")
        return H.iae(height);
      maxY = y + height - 1;
      t1 = this._header;
      t2 = t1.width;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (maxX > t2)
        maxX = t2 - 1;
      t2 = t1.height;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (maxY > t2)
        maxY = t2 - 1;
      this.decodedWidth = maxX - x + 1;
      this.decodedHeight = maxY - y + 1;
      channels = t1.channels;
      numChannels = channels.length;
      for (tmpBufferEnd = 0, i = 0; i < numChannels; ++i) {
        if (i >= channels.length)
          return H.ioore(channels, i);
        ch = channels[i];
        t1 = this._channelData;
        if (i >= t1.length)
          return H.ioore(t1, i);
        cd = t1[i];
        t1 = J.getInterceptor$x(cd);
        t1.set$start(cd, tmpBufferEnd);
        cd.set$end(t1.get$start(cd));
        cd.nx = this._image$_numSamples$3(ch.get$xSampling(), x, maxX);
        t1 = this._image$_numSamples$3(ch.ySampling, y, maxY);
        cd.ny = t1;
        cd.ys = ch.ySampling;
        t2 = ch.size;
        if (typeof t2 !== "number")
          return t2.$tdiv();
        cd.size = t2 / 2 | 0;
        t1 = J.$mul$ns(J.$mul$ns(cd.nx, t1), cd.size);
        if (typeof t1 !== "number")
          return H.iae(t1);
        tmpBufferEnd += t1;
      }
      minNonZero = inPtr.readUint16$0();
      maxNonZero = inPtr.readUint16$0();
      if (maxNonZero >= 8192)
        throw H.wrapException(U.ImageException$("Error in header for PIZ-compressed data (invalid bitmap size)."));
      bitmap = new Uint8Array(8192);
      if (minNonZero <= maxNonZero) {
        b = inPtr.readBytes$1(maxNonZero - minNonZero + 1);
        len = J.$sub$n(b.end, b.offset);
        if (typeof len !== "number")
          return H.iae(len);
        j = minNonZero;
        i = 0;
        for (; i < len; ++i, j = j0) {
          j0 = j + 1;
          t1 = J.$index$asx(b.buffer, J.$add$ns(b.offset, i));
          if (j >= 8192)
            return H.ioore(bitmap, j);
          bitmap[j] = t1;
        }
      }
      lut = new Uint16Array(65536);
      maxValue = this._reverseLutFromBitmap$2(bitmap, lut);
      U.ExrHuffman_uncompress(inPtr, inPtr.readUint32$0(), this._tmpBuffer, tmpBufferEnd);
      for (i = 0; i < numChannels; ++i) {
        t1 = this._channelData;
        if (i >= t1.length)
          return H.ioore(t1, i);
        cd = t1[i];
        t1 = J.getInterceptor$x(cd);
        j = 0;
        while (true) {
          t2 = t1.get$size(cd);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j < t2))
            break;
          U.ExrWavelet_decode(this._tmpBuffer, J.$add$ns(t1.get$start(cd), j), cd.get$nx(), t1.get$size(cd), cd.ny, J.$mul$ns(cd.nx, cd.size), maxValue);
          ++j;
        }
      }
      this._applyLut$3(lut, this._tmpBuffer, tmpBufferEnd);
      t1 = this._output;
      if (t1 == null) {
        t1 = this._maxScanLineSize;
        t2 = this._numScanLines;
        if (typeof t1 !== "number")
          return t1.$mul();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = U.OutputBuffer$(false, t1 * t2 + 73728);
        this._output = t2;
        t1 = t2;
      }
      t1.length = 0;
      for (; y <= maxY; ++y)
        for (i = 0; i < numChannels; ++i) {
          t1 = this._channelData;
          if (i >= t1.length)
            return H.ioore(t1, i);
          cd = t1[i];
          t1 = cd.get$ys();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (C.JSInt_methods.$mod(y, t1) !== 0)
            continue;
          for (x = J.$mul$ns(cd.nx, cd.size); t1 = J.getInterceptor$n(x), t1.$gt(x, 0); x = t1.$sub(x, 1)) {
            t2 = this._output;
            t3 = this._tmpBuffer;
            t4 = cd.end;
            if (typeof t4 !== "number")
              return t4.$add();
            cd.end = t4 + 1;
            if (t4 >>> 0 !== t4 || t4 >= t3.length)
              return H.ioore(t3, t4);
            t2.writeUint16$1(t3[t4]);
          }
        }
      t1 = this._output;
      return H.NativeUint8List_NativeUint8List$view(t1._buffer.buffer, 0, t1.length);
    },
    uncompress$3: function(inPtr, x, y) {
      return this.uncompress$5(inPtr, x, y, null, null);
    },
    _applyLut$3: function(lut, data, nData) {
      var i, t1;
      for (i = 0; i < nData; ++i) {
        if (i >= data.length)
          return H.ioore(data, i);
        t1 = data[i];
        if (t1 >= 65536)
          return H.ioore(lut, t1);
        data[i] = lut[t1];
      }
    },
    _reverseLutFromBitmap$2: function(bitmap, lut) {
      var k, i, t1, k0, k1;
      for (k = 0, i = 0; i < 65536; ++i) {
        if (i !== 0) {
          t1 = i >>> 3;
          if (t1 >= 8192)
            return H.ioore(bitmap, t1);
          t1 = (bitmap[t1] & C.JSInt_methods._shlPositive$1(1, i & 7)) !== 0;
        } else
          t1 = true;
        if (t1) {
          k0 = k + 1;
          if (k >= 65536)
            return H.ioore(lut, k);
          lut[k] = i;
          k = k0;
        }
      }
      for (k0 = k; k0 < 65536; k0 = k1) {
        k1 = k0 + 1;
        lut[k0] = 0;
      }
      return k - 1;
    },
    ExrPizCompressor$3: function(header, _maxScanLineSize, _numScanLines) {
      var t1, t2, i, tmpBufferSize;
      t1 = H.setRuntimeTypeInfo(Array(header.channels.length), [U._PizChannelData]);
      this._channelData = t1;
      for (t2 = t1.length, i = 0; i < t2; ++i)
        t1[i] = new U._PizChannelData(null, null, null, null, null, null);
      t1 = this._maxScanLineSize;
      t2 = this._numScanLines;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof t2 !== "number")
        return H.iae(t2);
      tmpBufferSize = C.JSNumber_methods._tdivFast$1(t1 * t2, 2);
      if (typeof tmpBufferSize !== "number" || Math.floor(tmpBufferSize) !== tmpBufferSize)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(tmpBufferSize)));
      this._tmpBuffer = new Uint16Array(tmpBufferSize);
    },
    static: {"^": "ExrPizCompressor_USHORT_RANGE,ExrPizCompressor_BITMAP_SIZE", ExrPizCompressor$: function(header, _maxScanLineSize, _numScanLines) {
        var t1 = new U.ExrPizCompressor(null, _maxScanLineSize, _numScanLines, null, null, 0, 0, header);
        t1.ExrPizCompressor$3(header, _maxScanLineSize, _numScanLines);
        return t1;
      }}
  },
  _PizChannelData: {
    "^": "Object;start*,end?,nx<,ny,ys<,size>",
    size$0: function($receiver) {
      return this.size.call$0();
    }
  },
  ExrPxr24Compressor: {
    "^": "ExrCompressor;_zlib,_maxScanLineSize,_numScanLines,_output,decodedWidth,decodedHeight,_header",
    numScanLines$0: function() {
      return this._numScanLines;
    },
    uncompress$5: function(inPtr, x, y, width, height) {
      var data, t1, t2, ptr, pixel, pixelBytes, maxX, maxY, numChannels, t3, yi, tmpEnd, ci, t4, ch, n, j, t5, t6, k, t7;
      data = this._zlib.decodeBuffer$2$verify(T.InputStream$(inPtr.toUint8List$0(), 1, null, 0), true);
      t1 = this._output;
      if (t1 == null) {
        t1 = this._numScanLines;
        t2 = this._maxScanLineSize;
        if (typeof t1 !== "number")
          return t1.$mul();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = U.OutputBuffer$(false, t1 * t2);
        this._output = t2;
        t1 = t2;
      }
      t1.length = 0;
      ptr = [0, 0, 0, 0];
      pixel = new Uint32Array(1);
      pixelBytes = H.NativeUint8List_NativeUint8List$view(pixel.buffer, 0, null);
      if (width == null)
        width = this._header.width;
      if (height == null)
        height = this._header._linesInBuffer;
      if (typeof width !== "number")
        return H.iae(width);
      maxX = x + width - 1;
      if (typeof height !== "number")
        return H.iae(height);
      maxY = y + height - 1;
      t1 = this._header;
      t2 = t1.width;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (maxX > t2)
        maxX = t2 - 1;
      t2 = t1.height;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (maxY > t2)
        maxY = t2 - 1;
      this.decodedWidth = maxX - x + 1;
      this.decodedHeight = maxY - y + 1;
      numChannels = t1.channels.length;
      for (t2 = pixelBytes.length, t3 = data.length, yi = y, tmpEnd = 0; yi <= maxY; ++yi)
        for (ci = 0; ci < numChannels; ++ci) {
          t4 = t1.channels;
          if (ci >= t4.length)
            return H.ioore(t4, ci);
          ch = t4[ci];
          if (C.JSInt_methods.$mod(y, ch.get$ySampling()) !== 0)
            continue;
          n = this._image$_numSamples$3(ch.xSampling, x, maxX);
          pixel[0] = 0;
          switch (ch.type) {
            case 0:
              ptr[0] = tmpEnd;
              if (typeof n !== "number")
                return H.iae(n);
              t4 = tmpEnd + n;
              ptr[1] = t4;
              t4 += n;
              ptr[2] = t4;
              tmpEnd = t4 + n;
              for (j = 0; j < n; ++j) {
                t4 = ptr[0];
                ptr[0] = J.$add$ns(t4, 1);
                if (t4 >>> 0 !== t4 || t4 >= t3)
                  return H.ioore(data, t4);
                t4 = data[t4];
                t5 = ptr[1];
                ptr[1] = J.$add$ns(t5, 1);
                if (t5 >>> 0 !== t5 || t5 >= t3)
                  return H.ioore(data, t5);
                t5 = data[t5];
                t6 = ptr[2];
                ptr[2] = J.$add$ns(t6, 1);
                if (t6 >>> 0 !== t6 || t6 >= t3)
                  return H.ioore(data, t6);
                t6 = data[t6];
                pixel[0] = pixel[0] + ((t4 << 24 | t5 << 16 | t6 << 8) >>> 0);
                for (k = 0; k < 4; ++k) {
                  t4 = this._output;
                  if (k >= t2)
                    return H.ioore(pixelBytes, k);
                  t5 = pixelBytes[k];
                  if (J.$eq(t4.length, t4._buffer.length))
                    t4._expandBuffer$0();
                  t6 = t4._buffer;
                  t7 = t4.length;
                  t4.length = J.$add$ns(t7, 1);
                  if (t7 >>> 0 !== t7 || t7 >= t6.length)
                    return H.ioore(t6, t7);
                  t6[t7] = t5 & 255;
                }
              }
              break;
            case 1:
              ptr[0] = tmpEnd;
              if (typeof n !== "number")
                return H.iae(n);
              t4 = tmpEnd + n;
              ptr[1] = t4;
              tmpEnd = t4 + n;
              for (j = 0; j < n; ++j) {
                t4 = ptr[0];
                ptr[0] = J.$add$ns(t4, 1);
                if (t4 >>> 0 !== t4 || t4 >= t3)
                  return H.ioore(data, t4);
                t4 = data[t4];
                t5 = ptr[1];
                ptr[1] = J.$add$ns(t5, 1);
                if (t5 >>> 0 !== t5 || t5 >= t3)
                  return H.ioore(data, t5);
                t5 = data[t5];
                pixel[0] = pixel[0] + ((t4 << 8 | t5) >>> 0);
                for (k = 0; k < 2; ++k) {
                  t4 = this._output;
                  if (k >= t2)
                    return H.ioore(pixelBytes, k);
                  t5 = pixelBytes[k];
                  if (J.$eq(t4.length, t4._buffer.length))
                    t4._expandBuffer$0();
                  t6 = t4._buffer;
                  t7 = t4.length;
                  t4.length = J.$add$ns(t7, 1);
                  if (t7 >>> 0 !== t7 || t7 >= t6.length)
                    return H.ioore(t6, t7);
                  t6[t7] = t5 & 255;
                }
              }
              break;
            case 2:
              ptr[0] = tmpEnd;
              if (typeof n !== "number")
                return H.iae(n);
              t4 = tmpEnd + n;
              ptr[1] = t4;
              t4 += n;
              ptr[2] = t4;
              tmpEnd = t4 + n;
              for (j = 0; j < n; ++j) {
                t4 = ptr[0];
                ptr[0] = J.$add$ns(t4, 1);
                if (t4 >>> 0 !== t4 || t4 >= t3)
                  return H.ioore(data, t4);
                t4 = data[t4];
                t5 = ptr[1];
                ptr[1] = J.$add$ns(t5, 1);
                if (t5 >>> 0 !== t5 || t5 >= t3)
                  return H.ioore(data, t5);
                t5 = data[t5];
                t6 = ptr[2];
                ptr[2] = J.$add$ns(t6, 1);
                if (t6 >>> 0 !== t6 || t6 >= t3)
                  return H.ioore(data, t6);
                t6 = data[t6];
                pixel[0] = pixel[0] + ((t4 << 24 | t5 << 16 | t6 << 8) >>> 0);
                for (k = 0; k < 4; ++k) {
                  t4 = this._output;
                  if (k >= t2)
                    return H.ioore(pixelBytes, k);
                  t5 = pixelBytes[k];
                  if (J.$eq(t4.length, t4._buffer.length))
                    t4._expandBuffer$0();
                  t6 = t4._buffer;
                  t7 = t4.length;
                  t4.length = J.$add$ns(t7, 1);
                  if (t7 >>> 0 !== t7 || t7 >= t6.length)
                    return H.ioore(t6, t7);
                  t6[t7] = t5 & 255;
                }
              }
              break;
          }
        }
      t1 = this._output;
      return H.NativeUint8List_NativeUint8List$view(t1._buffer.buffer, 0, t1.length);
    },
    uncompress$3: function(inPtr, x, y) {
      return this.uncompress$5(inPtr, x, y, null, null);
    }
  },
  ExrRleCompressor: {
    "^": "ExrCompressor;_outCache,_maxScanLineSize,decodedWidth,decodedHeight,_header",
    numScanLines$0: function() {
      return 1;
    },
    uncompress$5: function(inPtr, x, y, width, height) {
      var t1, out, maxX, maxY, t2, t3, n, count, count0, t4, data, len, i, t10, si, si0, t11, t20;
      t1 = inPtr.end;
      out = U.OutputBuffer$(false, J.$mul$ns(J.$sub$n(t1, inPtr.offset), 2));
      if (width == null)
        width = this._header.width;
      if (height == null)
        height = this._header._linesInBuffer;
      if (typeof width !== "number")
        return H.iae(width);
      maxX = x + width - 1;
      if (typeof height !== "number")
        return H.iae(height);
      maxY = y + height - 1;
      t2 = this._header;
      t3 = t2.width;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (maxX > t3)
        maxX = t3 - 1;
      t2 = t2.height;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (maxY > t2)
        maxY = t2 - 1;
      this.decodedWidth = maxX - x + 1;
      this.decodedHeight = maxY - y + 1;
      for (; !J.$ge$n(inPtr.offset, t1);) {
        t2 = inPtr.buffer;
        t3 = inPtr.offset;
        inPtr.offset = J.$add$ns(t3, 1);
        t3 = J.$index$asx(t2, t3);
        $.get$__uint8()[0] = t3;
        t3 = $.get$__uint8ToInt8();
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        n = t3[0];
        if (n < 0) {
          count = -n;
          for (; count0 = count - 1, count > 0; count = count0) {
            t2 = inPtr.buffer;
            t3 = inPtr.offset;
            inPtr.offset = J.$add$ns(t3, 1);
            t3 = J.$index$asx(t2, t3);
            if (J.$eq(out.length, out._buffer.length))
              out._expandBuffer$0();
            t2 = out._buffer;
            t4 = out.length;
            out.length = J.$add$ns(t4, 1);
            t3 = J.$and$n(t3, 255);
            if (t4 >>> 0 !== t4 || t4 >= t2.length)
              return H.ioore(t2, t4);
            t2[t4] = t3;
          }
        } else
          for (count = n; count0 = count - 1, count >= 0; count = count0) {
            t2 = inPtr.buffer;
            t3 = inPtr.offset;
            inPtr.offset = J.$add$ns(t3, 1);
            t3 = J.$index$asx(t2, t3);
            if (J.$eq(out.length, out._buffer.length))
              out._expandBuffer$0();
            t2 = out._buffer;
            t4 = out.length;
            out.length = J.$add$ns(t4, 1);
            t3 = J.$and$n(t3, 255);
            if (t4 >>> 0 !== t4 || t4 >= t2.length)
              return H.ioore(t2, t4);
            t2[t4] = t3;
          }
      }
      data = H.NativeUint8List_NativeUint8List$view(out._buffer.buffer, 0, out.length);
      for (len = data.length, i = 1; i < len; ++i)
        data[i] = data[i - 1] + data[i] - 128;
      t1 = this._outCache;
      if (t1 == null || t1.length !== len) {
        t1 = new Uint8Array(len);
        this._outCache = t1;
      }
      t2 = C.JSInt_methods._tdivFast$1(len + 1, 2);
      for (t10 = 0, si = 0; true; t2 = t20, t10 = t11) {
        if (si < len) {
          si0 = si + 1;
          t11 = t10 + 1;
          if (t10 >= len)
            return H.ioore(data, t10);
          t3 = data[t10];
          t4 = t1.length;
          if (si >= t4)
            return H.ioore(t1, si);
          t1[si] = t3;
        } else
          break;
        if (si0 < len) {
          si = si0 + 1;
          t20 = t2 + 1;
          if (t2 >= len)
            return H.ioore(data, t2);
          t2 = data[t2];
          if (si0 >= t4)
            return H.ioore(t1, si0);
          t1[si0] = t2;
        } else
          break;
      }
      return t1;
    },
    uncompress$3: function(inPtr, x, y) {
      return this.uncompress$5(inPtr, x, y, null, null);
    }
  },
  ExrZipCompressor: {
    "^": "ExrCompressor;zlib,_maxScanLineSize,_numScanLines,_outCache,decodedWidth,decodedHeight,_header",
    numScanLines$0: function() {
      return this._numScanLines;
    },
    uncompress$5: function(input, x, y, width, height) {
      var data, maxX, maxY, t1, t2, len, i, t10, si, si0, t11, t3, t4, t20;
      data = this.zlib.decodeBuffer$2$verify(T.InputStream$(input.toUint8List$0(), 1, null, 0), true);
      if (width == null)
        width = this._header.width;
      if (height == null)
        height = this._header._linesInBuffer;
      if (typeof width !== "number")
        return H.iae(width);
      maxX = x + width - 1;
      if (typeof height !== "number")
        return H.iae(height);
      maxY = y + height - 1;
      t1 = this._header;
      t2 = t1.width;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (maxX > t2)
        maxX = t2 - 1;
      t1 = t1.height;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (maxY > t1)
        maxY = t1 - 1;
      this.decodedWidth = maxX - x + 1;
      this.decodedHeight = maxY - y + 1;
      for (len = data.length, i = 1; i < len; ++i)
        data[i] = data[i - 1] + data[i] - 128;
      t1 = this._outCache;
      if (t1 == null || t1.length !== len) {
        t1 = new Uint8Array(len);
        this._outCache = t1;
      }
      t2 = C.JSInt_methods._tdivFast$1(len + 1, 2);
      for (t10 = 0, si = 0; true; t2 = t20, t10 = t11) {
        if (si < len) {
          si0 = si + 1;
          t11 = t10 + 1;
          if (t10 >= len)
            return H.ioore(data, t10);
          t3 = data[t10];
          t4 = t1.length;
          if (si >= t4)
            return H.ioore(t1, si);
          t1[si] = t3;
        } else
          break;
        if (si0 < len) {
          si = si0 + 1;
          t20 = t2 + 1;
          if (t2 >= len)
            return H.ioore(data, t2);
          t2 = data[t2];
          if (si0 >= t4)
            return H.ioore(t1, si0);
          t1[si0] = t2;
        } else
          break;
      }
      return t1;
    },
    uncompress$3: function(input, x, y) {
      return this.uncompress$5(input, x, y, null, null);
    }
  },
  ExrDecoder: {
    "^": "Decoder;exrImage,exposure,gamma,reinhard,bloomAmount,bloomRadius,progressCallback",
    startDecode$1: function(data) {
      var t1 = U.ExrImage$(data);
      this.exrImage = t1;
      return t1;
    },
    decodeFrame$1: function(frame) {
      var t1 = this.exrImage;
      if (t1 == null)
        return;
      t1 = t1.parts;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return U.hdrToImage(t1[0].get$framebuffer(), this.exposure);
    }
  },
  GifColorMap: {
    "^": "Object;bitsPerPixel,numColors,transparent,colors",
    $index: function(_, index) {
      var t1 = this.colors;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this.colors;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
      return value;
    },
    color$1: function(_, index) {
      var ci, a, t1, t2, t3, t4, t5;
      ci = index * 3;
      a = index === this.transparent ? 0 : 255;
      t1 = this.colors;
      t2 = t1.length;
      if (ci >= t2)
        return H.ioore(t1, ci);
      t3 = t1[ci];
      t4 = ci + 1;
      if (t4 >= t2)
        return H.ioore(t1, t4);
      t4 = t1[t4];
      t5 = ci + 2;
      if (t5 >= t2)
        return H.ioore(t1, t5);
      return U.getColor(t3, t4, t1[t5], a);
    },
    alpha$1: [function(_, color) {
      return J.$eq(color, this.transparent) ? 0 : 255;
    }, "call$1", "get$alpha", 2, 0, 113],
    _bitSize$1: function(n) {
      var i;
      for (i = 1; i <= 8; ++i)
        if (C.JSInt_methods._shlPositive$1(1, i) >= n)
          return i;
      return 0;
    },
    GifColorMap$1: function(numColors) {
      this.bitsPerPixel = this._bitSize$1(numColors);
    },
    static: {GifColorMap$: function(numColors) {
        var t1 = new U.GifColorMap(null, numColors, null, new Uint8Array(numColors * 3));
        t1.GifColorMap$1(numColors);
        return t1;
      }}
  },
  GifImageDesc: {
    "^": "Object;x*,y*,width>,height>,interlaced<,colorMap<,duration',clearFrame?,_inputPosition<",
    GifImageDesc$1: function(input) {
      var t1, t2, b, i, t3, t4, t5, ci;
      this.x = input.readUint16$0();
      this.y = input.readUint16$0();
      this.width = input.readUint16$0();
      this.height = input.readUint16$0();
      t1 = input.buffer;
      t2 = input.offset;
      input.offset = J.$add$ns(t2, 1);
      b = J.$index$asx(t1, t2);
      t2 = J.getInterceptor$n(b);
      t1 = t2.$and(b, 7);
      this.interlaced = t2.$and(b, 64) !== 0;
      if (t2.$and(b, 128) !== 0) {
        this.colorMap = U.GifColorMap$(C.JSInt_methods._shlPositive$1(1, t1 + 1));
        for (i = 0; t1 = this.colorMap, i < t1.numColors; ++i) {
          t2 = input.buffer;
          t3 = input.offset;
          input.offset = J.$add$ns(t3, 1);
          t3 = J.$index$asx(t2, t3);
          t2 = input.buffer;
          t4 = input.offset;
          input.offset = J.$add$ns(t4, 1);
          t4 = J.$index$asx(t2, t4);
          t2 = input.buffer;
          t5 = input.offset;
          input.offset = J.$add$ns(t5, 1);
          t5 = J.$index$asx(t2, t5);
          ci = i * 3;
          t1 = t1.colors;
          t2 = t1.length;
          if (ci >= t2)
            return H.ioore(t1, ci);
          t1[ci] = t3;
          t3 = ci + 1;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = t4;
          t4 = ci + 2;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = t5;
        }
      }
      this._inputPosition = J.$sub$n(input.offset, input.start);
    },
    static: {GifImageDesc$: function(input) {
        var t1 = new U.GifImageDesc(null, null, null, null, null, null, 80, true, null);
        t1.GifImageDesc$1(input);
        return t1;
      }}
  },
  GifInfo: {
    "^": "DecodeInfo;colorResolution,globalColorMap,isGif89,frames,width,height,backgroundColor"
  },
  GifDecoder: {
    "^": "Decoder;info,_input,_frame,_numFrames,_buffer,_stack,_suffix,_prefix,_bitsPerPixel,_pixelCount,_currentShiftDWord,_currentShiftState,_stackPtr,_currentCode,_lastCode,_maxCode1,_runningBits,_runningCode,_eofCode,_clearCode,progressCallback",
    startDecode$1: function(bytes) {
      var recordType, gifImage, extCode, b, duration, transparent, disposalMethod, transparentFlag, gifImage0, t1, t2, t3, pos, exception;
      this._input = U.InputBuffer$(bytes, false, null, 0);
      this.info = new U.GifInfo(0, null, false, [], 0, 0, 4294967295);
      if (!this._getInfo$0())
        return;
      try {
        for (; t1 = this._input, !J.$ge$n(t1.offset, t1.end);) {
          t1 = this._input;
          t2 = t1.buffer;
          t3 = t1.offset;
          t1.offset = J.$add$ns(t3, 1);
          recordType = J.$index$asx(t2, t3);
          switch (recordType) {
            case 44:
              gifImage = this._skipImage$0();
              if (gifImage == null) {
                t1 = this.info;
                return t1;
              }
              this.info.frames.push(gifImage);
              break;
            case 33:
              t1 = this._input;
              t2 = t1.buffer;
              t3 = t1.offset;
              t1.offset = J.$add$ns(t3, 1);
              extCode = J.$index$asx(t2, t3);
              if (J.$eq(extCode, 249)) {
                t1 = this._input;
                t2 = t1.buffer;
                t3 = t1.offset;
                t1.offset = J.$add$ns(t3, 1);
                J.$index$asx(t2, t3);
                t3 = this._input;
                t2 = t3.buffer;
                t1 = t3.offset;
                t3.offset = J.$add$ns(t1, 1);
                b = J.$index$asx(t2, t1);
                duration = this._input.readUint16$0();
                t1 = this._input;
                t2 = t1.buffer;
                t3 = t1.offset;
                t1.offset = J.$add$ns(t3, 1);
                transparent = J.$index$asx(t2, t3);
                t3 = this._input;
                t2 = t3.buffer;
                t1 = t3.offset;
                t3.offset = J.$add$ns(t1, 1);
                J.$index$asx(t2, t1);
                t1 = b;
                if (typeof t1 !== "number")
                  return t1.$shr();
                disposalMethod = C.JSNumber_methods._shrOtherPositive$1(t1, 3) & 7;
                t1 = b;
                if (typeof t1 !== "number")
                  return t1.$shr();
                C.JSNumber_methods._shrOtherPositive$1(t1, 1);
                transparentFlag = J.$and$n(b, 1);
                t1 = this._input;
                t1.toString;
                pos = J.$add$ns(t1.offset, 0);
                t2 = t1.buffer;
                t1.bigEndian;
                recordType = J.$index$asx(t2, J.$add$ns(pos, 0));
                if (J.$eq(recordType, 44)) {
                  t1 = this._input;
                  t1.offset = J.$add$ns(t1.offset, 1);
                  gifImage0 = this._skipImage$0();
                  if (gifImage0 == null) {
                    t1 = this.info;
                    return t1;
                  }
                  J.set$duration$x(gifImage0, duration);
                  gifImage0.set$clearFrame(J.$eq(disposalMethod, 2));
                  if (!J.$eq(transparentFlag, 0))
                    if (gifImage0.get$colorMap() != null)
                      gifImage0.get$colorMap().transparent = transparent;
                    else {
                      t1 = this.info.globalColorMap;
                      if (t1 != null)
                        t1.transparent = transparent;
                    }
                  this.info.frames.push(gifImage0);
                }
              } else
                this._skipRemainder$0();
              break;
            case 59:
              t1 = this.info;
              this._numFrames = t1.frames.length;
              return t1;
            default:
              break;
          }
        }
      } catch (exception) {
        H.unwrapException(exception);
      }

      t1 = this.info;
      this._numFrames = t1.frames.length;
      return t1;
    },
    decodeFrame$1: function(frame) {
      var t1, t2, t3, t4;
      t1 = this._input;
      if (t1 == null || this.info == null)
        return;
      t2 = this.info.frames;
      t3 = t2.length;
      if (frame >= t3 || false)
        return;
      this._frame = frame;
      if (frame >= t3)
        return H.ioore(t2, frame);
      t4 = t2[frame];
      t1.offset = t4.get$_inputPosition();
      if (frame >= t3)
        return H.ioore(t2, frame);
      return this._decodeImage$1(t4);
    },
    _skipImage$0: function() {
      var t1, gifImage;
      t1 = this._input;
      if (J.$ge$n(t1.offset, t1.end))
        return;
      gifImage = U.GifImageDesc$(this._input);
      t1 = this._input;
      t1.offset = J.$add$ns(t1.offset, 1);
      this._skipRemainder$0();
      return gifImage;
    },
    _decodeImage$1: function(gifImage) {
      var t1, t2, t3, width, height, colorMap, image, line, row, i, j, y;
      if (this._buffer == null) {
        this._buffer = new Uint8Array(256);
        this._stack = new Uint8Array(4095);
        this._suffix = new Uint8Array(4096);
        this._prefix = new Uint32Array(4096);
      }
      t1 = this._input;
      t2 = t1.buffer;
      t3 = t1.offset;
      t1.offset = J.$add$ns(t3, 1);
      t3 = J.$index$asx(t2, t3);
      this._bitsPerPixel = t3;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t2 = C.JSInt_methods.$shl(1, t3);
      this._clearCode = t2;
      ++t2;
      this._eofCode = t2;
      this._runningCode = t2 + 1;
      ++t3;
      this._runningBits = t3;
      this._maxCode1 = C.JSInt_methods.$shl(1, t3);
      this._stackPtr = 0;
      this._lastCode = 4098;
      this._currentShiftState = 0;
      this._currentShiftDWord = 0;
      this._buffer[0] = 0;
      t3 = this._prefix;
      J.fillRange$3$ax(t3, 0, t3.length, 4098);
      t3 = J.getInterceptor$x(gifImage);
      width = t3.get$width(gifImage);
      height = t3.get$height(gifImage);
      if (J.$gt$n(J.$add$ns(t3.get$x(gifImage), width), this.info.width) || J.$gt$n(J.$add$ns(t3.get$y(gifImage), height), this.info.height))
        return;
      colorMap = gifImage.get$colorMap();
      colorMap = colorMap != null ? colorMap : this.info.globalColorMap;
      this._pixelCount = J.$mul$ns(width, height);
      image = U.Image$(width, height, 4);
      if (typeof width !== "number" || Math.floor(width) !== width)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(width)));
      line = new Uint8Array(width);
      if (gifImage.get$interlaced()) {
        row = gifImage.y;
        for (t1 = J.getInterceptor$ns(row), i = 0, j = 0; i < 4; ++i)
          for (y = t1.$add(row, C.List_0_4_2_1[i]); t2 = J.getInterceptor$n(y), t2.$lt(y, t1.$add(row, height)); y = t2.$add(y, C.List_8_8_4_2[i]), ++j) {
            if (!this._getLine$1(line))
              return image;
            this._updateImage$4(image, y, colorMap, line);
          }
      } else {
        if (typeof height !== "number")
          return H.iae(height);
        y = 0;
        for (; y < height; ++y) {
          if (!this._getLine$1(line))
            return image;
          this._updateImage$4(image, y, colorMap, line);
        }
      }
      return image;
    },
    _updateImage$4: function(image, y, colorMap, line) {
      var width, t1, t2, t3, t4, t5, t6, x, t7, t8;
      if (colorMap != null)
        for (width = line.length, t1 = J.getInterceptor$x(colorMap), t2 = image.width, t3 = J.getInterceptor$ns(y), t4 = image.height, t5 = image.data, t6 = t5.length, x = 0; x < width; ++x) {
          t7 = t1.color$1(colorMap, line[x]);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t8 = x < t2 && t3.$ge(y, 0) && t3.$lt(y, t4);
          if (t8) {
            t8 = J.$add$ns(t3.$mul(y, t2), x);
            if (t8 >>> 0 !== t8 || t8 >= t6)
              return H.ioore(t5, t8);
            t5[t8] = t7;
          }
        }
    },
    _getInfo$0: function() {
      var tag, t1, t2, t3, b, t4, t5, t6, i, r, g, ci;
      tag = this._input.readString$1(6);
      if (tag !== "GIF87a" && tag !== "GIF89a")
        return false;
      this.info.width = this._input.readUint16$0();
      this.info.height = this._input.readUint16$0();
      t1 = this._input;
      t2 = t1.buffer;
      t3 = t1.offset;
      t1.offset = J.$add$ns(t3, 1);
      b = J.$index$asx(t2, t3);
      t3 = J.getInterceptor$n(b);
      this.info.colorResolution = (t3.$and(b, 112) + 1 >>> 4) + 1;
      t2 = t3.$and(b, 7);
      t1 = this.info;
      t4 = this._input;
      t5 = t4.buffer;
      t6 = t4.offset;
      t4.offset = J.$add$ns(t6, 1);
      t1.backgroundColor = J.$index$asx(t5, t6);
      t6 = this._input;
      t6.offset = J.$add$ns(t6.offset, 1);
      if (t3.$and(b, 128) !== 0) {
        this.info.globalColorMap = U.GifColorMap$(C.JSInt_methods._shlPositive$1(1, t2 + 1));
        for (i = 0; i < this.info.globalColorMap.numColors; ++i) {
          t1 = this._input;
          t2 = t1.buffer;
          t3 = t1.offset;
          t1.offset = J.$add$ns(t3, 1);
          r = J.$index$asx(t2, t3);
          t3 = this._input;
          t2 = t3.buffer;
          t1 = t3.offset;
          t3.offset = J.$add$ns(t1, 1);
          g = J.$index$asx(t2, t1);
          t1 = this._input;
          t2 = t1.buffer;
          t3 = t1.offset;
          t1.offset = J.$add$ns(t3, 1);
          b = J.$index$asx(t2, t3);
          ci = i * 3;
          t3 = this.info.globalColorMap.colors;
          t2 = t3.length;
          if (ci >= t2)
            return H.ioore(t3, ci);
          t3[ci] = r;
          t1 = ci + 1;
          if (t1 >= t2)
            return H.ioore(t3, t1);
          t3[t1] = g;
          t1 = ci + 2;
          if (t1 >= t2)
            return H.ioore(t3, t1);
          t3[t1] = b;
        }
      }
      this.info.isGif89 = tag === "GIF89a";
      return true;
    },
    _getLine$1: function(line) {
      this._pixelCount = J.$sub$n(this._pixelCount, line.length);
      if (!this._decompressLine$1(line))
        return false;
      if (J.$eq(this._pixelCount, 0))
        this._skipRemainder$0();
      return true;
    },
    _skipRemainder$0: function() {
      var t1, t2, t3, b;
      t1 = this._input;
      if (J.$ge$n(t1.offset, t1.end))
        return true;
      t1 = this._input;
      t2 = t1.buffer;
      t3 = t1.offset;
      t1.offset = J.$add$ns(t3, 1);
      b = J.$index$asx(t2, t3);
      while (true) {
        if (!J.$eq(b, 0)) {
          t1 = this._input;
          t1 = !J.$ge$n(t1.offset, t1.end);
        } else
          t1 = false;
        if (!t1)
          break;
        t1 = this._input;
        t1.offset = J.$add$ns(t1.offset, b);
        t1 = this._input;
        if (J.$ge$n(t1.offset, t1.end))
          return true;
        t1 = this._input;
        t2 = t1.buffer;
        t3 = t1.offset;
        t1.offset = J.$add$ns(t3, 1);
        b = J.$index$asx(t2, t3);
      }
      return true;
    },
    _decompressLine$1: function(line) {
      var t1, lineLen, i, i0, t2, currentPrefix, t3, j, t4, t5, t6, j0;
      t1 = this._stackPtr;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 4095)
        return false;
      lineLen = line.length;
      if (t1 !== 0) {
        i = 0;
        while (true) {
          if (!(t1 !== 0 && i < lineLen))
            break;
          i0 = i + 1;
          t2 = this._stack;
          if (typeof t1 !== "number")
            return t1.$sub();
          --t1;
          this._stackPtr = t1;
          t2.length;
          if (t1 < 0 || t1 >= 4095)
            return H.ioore(t2, t1);
          t2 = t2[t1];
          if (i >= lineLen)
            return H.ioore(line, i);
          line[i] = t2;
          i = i0;
        }
      } else
        i = 0;
      for (currentPrefix = null; i < lineLen;) {
        t1 = this._decompressInput$0();
        this._currentCode = t1;
        if (t1 == null)
          return false;
        t2 = this._eofCode;
        if (t1 == null ? t2 == null : t1 === t2)
          return false;
        t3 = this._clearCode;
        if (t1 == null ? t3 == null : t1 === t3) {
          for (t1 = this._prefix, j = 0; j <= 4095; ++j) {
            if (j >= t1.length)
              return H.ioore(t1, j);
            t1[j] = 4098;
          }
          if (typeof t2 !== "number")
            return t2.$add();
          this._runningCode = t2 + 1;
          t1 = J.$add$ns(this._bitsPerPixel, 1);
          this._runningBits = t1;
          if (typeof t1 !== "number")
            return H.iae(t1);
          this._maxCode1 = C.JSInt_methods.$shl(1, t1);
          this._lastCode = 4098;
        } else {
          if (typeof t1 !== "number")
            return t1.$lt();
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t1 < t3) {
            i0 = i + 1;
            if (i < 0)
              return H.ioore(line, i);
            line[i] = t1;
            i = i0;
          } else {
            t2 = this._prefix;
            if (t1 >= t2.length)
              return H.ioore(t2, t1);
            if (t2[t1] === 4098) {
              t4 = this._runningCode;
              if (typeof t4 !== "number")
                return t4.$sub();
              t4 -= 2;
              if (t1 === t4) {
                currentPrefix = this._lastCode;
                t1 = this._suffix;
                t5 = this._stack;
                t6 = this._stackPtr;
                if (typeof t6 !== "number")
                  return t6.$add();
                this._stackPtr = t6 + 1;
                t3 = this._getPrefixChar$3(t2, currentPrefix, t3);
                t5.length;
                if (t6 < 0 || t6 >= 4095)
                  return H.ioore(t5, t6);
                t5[t6] = t3;
                if (t4 < 0 || t4 >= t1.length)
                  return H.ioore(t1, t4);
                t1[t4] = t3;
              } else
                return false;
            } else
              currentPrefix = t1;
            j = 0;
            while (true) {
              j0 = j + 1;
              if (j <= 4095) {
                t1 = this._clearCode;
                if (typeof currentPrefix !== "number")
                  return currentPrefix.$gt();
                if (typeof t1 !== "number")
                  return H.iae(t1);
                t1 = currentPrefix > t1 && currentPrefix <= 4095;
              } else
                t1 = false;
              if (!t1)
                break;
              t1 = this._stack;
              t2 = this._stackPtr;
              if (typeof t2 !== "number")
                return t2.$add();
              this._stackPtr = t2 + 1;
              t3 = this._suffix;
              if (currentPrefix >>> 0 !== currentPrefix || currentPrefix >= t3.length)
                return H.ioore(t3, currentPrefix);
              t3 = t3[currentPrefix];
              t1.length;
              if (t2 < 0 || t2 >= 4095)
                return H.ioore(t1, t2);
              t1[t2] = t3;
              t3 = this._prefix;
              if (currentPrefix >= t3.length)
                return H.ioore(t3, currentPrefix);
              currentPrefix = t3[currentPrefix];
              j = j0;
            }
            if (j0 < 4095) {
              if (typeof currentPrefix !== "number")
                return currentPrefix.$gt();
              t1 = currentPrefix > 4095;
            } else
              t1 = true;
            if (t1)
              return false;
            t1 = this._stack;
            t2 = this._stackPtr;
            if (typeof t2 !== "number")
              return t2.$add();
            t3 = t2 + 1;
            this._stackPtr = t3;
            t1.length;
            if (t2 < 0 || t2 >= 4095)
              return H.ioore(t1, t2);
            t1[t2] = currentPrefix;
            t2 = t3;
            while (true) {
              if (!(t2 !== 0 && i < lineLen))
                break;
              i0 = i + 1;
              --t2;
              this._stackPtr = t2;
              t1.length;
              if (t2 < 0 || t2 >= 4095)
                return H.ioore(t1, t2);
              t3 = t1[t2];
              if (i < 0 || i >= lineLen)
                return H.ioore(line, i);
              line[i] = t3;
              i = i0;
            }
          }
          t1 = this._lastCode;
          if (t1 !== 4098) {
            t2 = this._prefix;
            t3 = this._runningCode;
            if (typeof t3 !== "number")
              return t3.$sub();
            t3 -= 2;
            if (t3 < 0 || t3 >= t2.length)
              return H.ioore(t2, t3);
            t3 = t2[t3] === 4098;
            t2 = t3;
          } else
            t2 = false;
          if (t2) {
            t2 = this._prefix;
            t3 = this._runningCode;
            if (typeof t3 !== "number")
              return t3.$sub();
            t3 -= 2;
            if (t3 < 0 || t3 >= t2.length)
              return H.ioore(t2, t3);
            t2[t3] = t1;
            t4 = this._currentCode;
            t5 = this._suffix;
            t6 = this._clearCode;
            if (t4 === t3) {
              t1 = this._getPrefixChar$3(t2, t1, t6);
              if (t3 >= t5.length)
                return H.ioore(t5, t3);
              t5[t3] = t1;
            } else {
              t1 = this._getPrefixChar$3(t2, t4, t6);
              if (t3 >= t5.length)
                return H.ioore(t5, t3);
              t5[t3] = t1;
            }
          }
          this._lastCode = this._currentCode;
        }
      }
      return true;
    },
    _decompressInput$0: function() {
      var t1, t2, nextByte, t3, t4, t5;
      if (J.$gt$n(this._runningBits, 12))
        return;
      while (true) {
        t1 = this._currentShiftState;
        t2 = this._runningBits;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(t1 < t2))
          break;
        nextByte = this._bufferedInput$0();
        t1 = this._currentShiftDWord;
        t2 = this._currentShiftState;
        if (typeof nextByte !== "number")
          return nextByte.$shl();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = C.JSInt_methods.$shl(nextByte, t2);
        if (typeof t1 !== "number")
          return t1.$or();
        this._currentShiftDWord = (t1 | t3) >>> 0;
        this._currentShiftState = t2 + 8;
      }
      t3 = this._currentShiftDWord;
      if (t2 >>> 0 !== t2 || t2 >= 13)
        return H.ioore(C.List_Qw3, t2);
      t4 = C.List_Qw3[t2];
      if (typeof t3 !== "number")
        return t3.$and();
      if (typeof t4 !== "number")
        return H.iae(t4);
      this._currentShiftDWord = C.JSInt_methods._shrBothPositive$1(t3, t2);
      this._currentShiftState = t1 - t2;
      t1 = this._runningCode;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < 4097) {
        ++t1;
        this._runningCode = t1;
        t5 = this._maxCode1;
        if (typeof t5 !== "number")
          return H.iae(t5);
        t1 = t1 > t5 && t2 < 12;
      } else
        t1 = false;
      if (t1) {
        t1 = this._maxCode1;
        if (typeof t1 !== "number")
          return t1.$shl();
        this._maxCode1 = t1 << 1 >>> 0;
        this._runningBits = J.$add$ns(this._runningBits, 1);
      }
      return (t3 & t4) >>> 0;
    },
    _getPrefixChar$3: function(prefix, code, clearCode) {
      var i, i0, t1;
      i = 0;
      while (true) {
        if (typeof code !== "number")
          return code.$gt();
        if (typeof clearCode !== "number")
          return H.iae(clearCode);
        if (code > clearCode) {
          i0 = i + 1;
          t1 = i <= 4095;
          i = i0;
        } else
          t1 = false;
        if (!t1)
          break;
        if (code > 4095)
          return 4098;
        if (code >= prefix.length)
          return H.ioore(prefix, code);
        code = prefix[code];
      }
      return code;
    },
    _bufferedInput$0: function() {
      var t1, t2, t3, t4, pos, t5, t6, nextByte;
      t1 = this._buffer;
      t2 = t1[0];
      if (t2 === 0) {
        t2 = this._input;
        t3 = t2.buffer;
        t4 = t2.offset;
        t2.offset = J.$add$ns(t4, 1);
        t1[0] = J.$index$asx(t3, t4);
        t1 = this._buffer;
        t2 = t1[0];
        if (t2 === 0)
          return;
        t3 = this._input;
        t3.toString;
        pos = J.$add$ns(t3.offset, 0);
        t4 = t3.buffer;
        t5 = t3.bigEndian;
        t6 = J.$add$ns(pos, t2);
        t3.offset = J.$add$ns(t3.offset, J.$sub$n(t6, pos));
        J.setRange$3$ax(t1, 1, 1 + t2, new U.InputBuffer(t4, pos, t6, pos, t5).toUint8List$0());
        t5 = this._buffer;
        nextByte = t5[1];
        t5[1] = 2;
        t5[0] = t5[0] - 1;
      } else {
        t3 = t1[1];
        t1[1] = t3 + 1;
        if (t3 >= 256)
          return H.ioore(t1, t3);
        nextByte = t1[t3];
        t1[0] = t2 - 1;
      }
      return nextByte;
    },
    static: {"^": "GifDecoder_STAMP_SIZE,GifDecoder_GIF87_STAMP,GifDecoder_GIF89_STAMP,GifDecoder_IMAGE_DESC_RECORD_TYPE,GifDecoder_EXTENSION_RECORD_TYPE,GifDecoder_TERMINATE_RECORD_TYPE,GifDecoder_GRAPHIC_CONTROL_EXT,GifDecoder_LZ_MAX_CODE,GifDecoder_LZ_BITS,GifDecoder_NO_SUCH_CODE,GifDecoder_CODE_MASKS,GifDecoder_INTERLACED_OFFSET,GifDecoder_INTERLACED_JUMP"}
  },
  JpegAdobe: {
    "^": "Object;version,flags0,flags1,transformCode"
  },
  JpegComponent: {
    "^": "Object;h<,v<,quantizationTableList,quantizationIndex,blocksPerLine<,blocksPerColumn,blocks,huffmanTableDC<,huffmanTableAC<,pred?"
  },
  JpegData: {
    "^": "Object;progressCallback,input,jfif,adobe,frame,resetInterval,quantizationTables,frames,huffmanTablesAC,huffmanTablesDC,components,_progressTotal,_progress",
    validate$1: function(bytes) {
      var marker, hasSOF, hasSOS, t1, $length;
      this.input = U.InputBuffer$(bytes, true, null, 0);
      if (!J.$eq(this._nextMarker$0(), 216))
        return false;
      marker = this._nextMarker$0();
      hasSOF = false;
      hasSOS = false;
      while (true) {
        if (!J.$eq(marker, 217)) {
          t1 = this.input;
          t1 = !J.$ge$n(t1.offset, t1.end);
        } else
          t1 = false;
        if (!t1)
          break;
        $length = this.input.readUint16$0();
        if ($length < 2)
          H.throwExpression(U.ImageException$("Invalid Block"));
        t1 = this.input;
        t1.offset = J.$add$ns(t1.offset, $length - 2);
        switch (marker) {
          case 192:
          case 193:
          case 194:
            hasSOF = true;
            break;
          case 218:
            hasSOS = true;
            break;
        }
        marker = this._nextMarker$0();
      }
      return hasSOF && hasSOS;
    },
    readInfo$1: function(bytes) {
      var marker, hasSOF, hasSOS, t1, $length, pos, t2, t3, t4;
      this.input = U.InputBuffer$(bytes, true, null, 0);
      if (!J.$eq(this._nextMarker$0(), 216))
        return;
      marker = this._nextMarker$0();
      hasSOF = false;
      hasSOS = false;
      while (true) {
        if (!J.$eq(marker, 217)) {
          t1 = this.input;
          t1 = !J.$ge$n(t1.offset, t1.end);
        } else
          t1 = false;
        if (!t1)
          break;
        switch (marker) {
          case 192:
          case 193:
          case 194:
            $length = this.input.readUint16$0();
            if ($length < 2)
              H.throwExpression(U.ImageException$("Invalid Block"));
            t1 = this.input;
            t1.toString;
            pos = J.$add$ns(t1.offset, 0);
            t2 = t1.buffer;
            t3 = t1.bigEndian;
            t4 = J.$add$ns(pos, $length - 2);
            t1.offset = J.$add$ns(t1.offset, J.$sub$n(t4, pos));
            this._readFrame$2(marker, new U.InputBuffer(t2, pos, t4, pos, t3));
            hasSOF = true;
            break;
          case 218:
            $length = this.input.readUint16$0();
            if ($length < 2)
              H.throwExpression(U.ImageException$("Invalid Block"));
            t1 = this.input;
            t1.offset = J.$add$ns(t1.offset, $length - 2);
            hasSOS = true;
            break;
          default:
            $length = this.input.readUint16$0();
            if ($length < 2)
              H.throwExpression(U.ImageException$("Invalid Block"));
            t1 = this.input;
            t1.offset = J.$add$ns(t1.offset, $length - 2);
            break;
        }
        marker = this._nextMarker$0();
      }
      t1 = this.frame;
      if (t1 != null) {
        C.JSNull_methods.set$width(null, t1.samplesPerLine);
        C.JSNull_methods.set$height(null, t1.scanLines);
      }
      this.frame = null;
      C.JSArray_methods.set$length(this.frames, 0);
      if (hasSOF && hasSOS)
        ;
      return;
    },
    read$1: function(bytes) {
      var i, t1, t2, component, t3, t4, t5, t6;
      this.input = U.InputBuffer$(bytes, true, null, 0);
      this._read$0();
      if (this.frames.length !== 1)
        throw H.wrapException(U.ImageException$("Only single frame JPEGs supported"));
      this._progressTotal = 0;
      this._progress = 0;
      for (i = 0; t1 = this.frame, t2 = t1.componentsOrder, i < t2.length; ++i) {
        component = t1.components.$index(0, t2[i]);
        t1 = this._progressTotal;
        t2 = component.blocksPerColumn;
        if (typeof t2 !== "number")
          return H.iae(t2);
        this._progressTotal = t1 + t2;
      }
      for (t1 = this.components, i = 0; t2 = this.frame, t3 = t2.componentsOrder, i < t3.length; ++i) {
        component = t2.components.$index(0, t3[i]);
        t2 = component.h;
        t3 = this.frame;
        t4 = t3.maxH;
        t5 = component.v;
        t6 = t3.maxV;
        if (typeof t5 !== "number")
          return t5.$div();
        if (typeof t6 !== "number")
          return H.iae(t6);
        t1.push(P.LinkedHashMap_LinkedHashMap$_literal(["scaleX", t2 / t4, "scaleY", t5 / t6, "lines", this._buildComponentData$2(t3, component)], null, null));
      }
    },
    get$width: function(_) {
      return this.frame.samplesPerLine;
    },
    get$height: function(_) {
      return this.frame.scanLines;
    },
    getData$2: function(width, height) {
      var t1, dataLength, data, t2, component1, offset, $Y, y, t3, t4, component1Line, x, offset0, component2, t5, component2Line, t6, component3, sy1, sy2, sy3, sx1, sx2, sx3, lines1, lines2, lines3, Cb, Cr, $R, $G, $B, component3Line, t7, t8, colorTransform, component4, $K, $C, $M, Ye, component4Line, t9, t10, t11, t12, t13, t14;
      t1 = this.components;
      dataLength = J.$mul$ns(J.$mul$ns(width, height), t1.length);
      if (typeof dataLength !== "number" || Math.floor(dataLength) !== dataLength)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(dataLength)));
      data = new Uint8Array(dataLength);
      t2 = t1.length;
      switch (t2) {
        case 1:
          if (0 >= t2)
            return H.ioore(t1, 0);
          component1 = t1[0];
          if (typeof height !== "number")
            return H.iae(height);
          t1 = data.length;
          t2 = J.getInterceptor$asx(component1);
          offset = 0;
          $Y = null;
          y = 0;
          for (; y < height; ++y) {
            t3 = t2.$index(component1, "lines");
            t4 = t2.$index(component1, "scaleY");
            if (typeof t4 !== "number")
              return H.iae(t4);
            component1Line = J.$index$asx(t3, C.JSNumber_methods.toInt$0(y * t4));
            if (typeof width !== "number")
              return H.iae(width);
            t3 = J.getInterceptor$asx(component1Line);
            x = 0;
            for (; x < width; ++x, offset = offset0) {
              t4 = t2.$index(component1, "scaleX");
              if (typeof t4 !== "number")
                return H.iae(t4);
              $Y = t3.$index(component1Line, C.JSNumber_methods.toInt$0(x * t4));
              offset0 = offset + 1;
              if (offset < 0 || offset >= t1)
                return H.ioore(data, offset);
              data[offset] = $Y;
            }
          }
          break;
        case 2:
          if (0 >= t2)
            return H.ioore(t1, 0);
          component1 = t1[0];
          if (1 >= t2)
            return H.ioore(t1, 1);
          component2 = t1[1];
          if (typeof height !== "number")
            return H.iae(height);
          t1 = data.length;
          t2 = J.getInterceptor$asx(component1);
          t3 = J.getInterceptor$asx(component2);
          offset = 0;
          $Y = null;
          y = 0;
          for (; y < height; ++y) {
            t4 = t2.$index(component1, "lines");
            t5 = t2.$index(component1, "scaleY");
            if (typeof t5 !== "number")
              return H.iae(t5);
            component1Line = J.$index$asx(t4, y * t5);
            t5 = t3.$index(component2, "lines");
            t4 = t3.$index(component2, "scaleY");
            if (typeof t4 !== "number")
              return H.iae(t4);
            component2Line = J.$index$asx(t5, y * t4);
            if (typeof width !== "number")
              return H.iae(width);
            t4 = J.getInterceptor$asx(component1Line);
            t5 = J.getInterceptor$asx(component2Line);
            x = 0;
            for (; x < width; ++x) {
              t6 = t2.$index(component1, "scaleX");
              if (typeof t6 !== "number")
                return H.iae(t6);
              $Y = t4.$index(component1Line, C.JSNumber_methods.toInt$0(x * t6));
              offset0 = offset + 1;
              if (offset < 0 || offset >= t1)
                return H.ioore(data, offset);
              data[offset] = $Y;
              t6 = t3.$index(component2, "scaleX");
              if (typeof t6 !== "number")
                return H.iae(t6);
              $Y = t5.$index(component2Line, C.JSNumber_methods.toInt$0(x * t6));
              offset = offset0 + 1;
              if (offset0 < 0 || offset0 >= t1)
                return H.ioore(data, offset0);
              data[offset0] = $Y;
            }
          }
          break;
        case 3:
          if (0 >= t2)
            return H.ioore(t1, 0);
          component1 = t1[0];
          if (1 >= t2)
            return H.ioore(t1, 1);
          component2 = t1[1];
          if (2 >= t2)
            return H.ioore(t1, 2);
          component3 = t1[2];
          t1 = J.getInterceptor$asx(component1);
          sy1 = J.toDouble$0$n(J.$mul$ns(t1.$index(component1, "scaleY"), 1));
          t2 = J.getInterceptor$asx(component2);
          sy2 = J.toDouble$0$n(J.$mul$ns(t2.$index(component2, "scaleY"), 1));
          t3 = J.getInterceptor$asx(component3);
          sy3 = J.toDouble$0$n(J.$mul$ns(t3.$index(component3, "scaleY"), 1));
          sx1 = J.toDouble$0$n(J.$mul$ns(t1.$index(component1, "scaleX"), 1));
          sx2 = J.toDouble$0$n(J.$mul$ns(t2.$index(component2, "scaleX"), 1));
          sx3 = J.toDouble$0$n(J.$mul$ns(t3.$index(component3, "scaleX"), 1));
          lines1 = t1.$index(component1, "lines");
          lines2 = t2.$index(component2, "lines");
          lines3 = t3.$index(component3, "lines");
          if (typeof height !== "number")
            return H.iae(height);
          t1 = data.length;
          t2 = J.getInterceptor$asx(lines1);
          t3 = J.getInterceptor$asx(lines2);
          t4 = J.getInterceptor$asx(lines3);
          offset = 0;
          $Y = null;
          Cb = null;
          Cr = null;
          $R = null;
          $G = null;
          $B = null;
          y = 0;
          for (; y < height; ++y) {
            component1Line = t2.$index(lines1, C.JSNumber_methods.toInt$0(y * sy1));
            component2Line = t3.$index(lines2, C.JSNumber_methods.toInt$0(y * sy2));
            component3Line = t4.$index(lines3, C.JSNumber_methods.toInt$0(y * sy3));
            if (typeof width !== "number")
              return H.iae(width);
            t5 = J.getInterceptor$asx(component1Line);
            t6 = J.getInterceptor$asx(component2Line);
            t7 = J.getInterceptor$asx(component3Line);
            x = 0;
            for (; x < width; ++x) {
              $Y = t5.$index(component1Line, C.JSNumber_methods.toInt$0(x * sx1));
              Cb = t6.$index(component2Line, C.JSNumber_methods.toInt$0(x * sx2));
              Cr = t7.$index(component3Line, C.JSNumber_methods.toInt$0(x * sx3));
              if ($Y >>> 0 !== $Y || $Y >= 256)
                return H.ioore(C.List_65X, $Y);
              t8 = C.List_65X[$Y];
              if (Cr >>> 0 !== Cr || Cr >= 256)
                return H.ioore(C.List_V7h, Cr);
              $R = J.$add$ns(t8, C.List_V7h[Cr]);
              t8 = C.List_65X[$Y];
              if (Cb >>> 0 !== Cb || Cb >= 256)
                return H.ioore(C.List_fkS, Cb);
              $G = J.$sub$n(J.$sub$n(t8, C.List_fkS[Cb]), C.List_int[Cr]);
              $B = J.$add$ns(C.List_65X[$Y], C.List_chs[Cb]);
              offset0 = offset + 1;
              if (J.getInterceptor$n($R).$gt($R, 0)) {
                if (typeof $R !== "number")
                  return $R.$shr();
                t8 = C.JSNumber_methods._shrOtherPositive$1($R, 4);
                if (t8 > 255)
                  t8 = 255;
              } else
                t8 = 0;
              if (offset < 0 || offset >= t1)
                return H.ioore(data, offset);
              data[offset] = t8;
              offset = offset0 + 1;
              if (J.getInterceptor$n($G).$gt($G, 0)) {
                if (typeof $G !== "number")
                  return $G.$shr();
                t8 = C.JSNumber_methods._shrOtherPositive$1($G, 4);
                if (t8 > 255)
                  t8 = 255;
              } else
                t8 = 0;
              if (offset0 < 0 || offset0 >= t1)
                return H.ioore(data, offset0);
              data[offset0] = t8;
              offset0 = offset + 1;
              if (J.getInterceptor$n($B).$gt($B, 0)) {
                if (typeof $B !== "number")
                  return $B.$shr();
                t8 = C.JSNumber_methods._shrOtherPositive$1($B, 4);
                if (t8 > 255)
                  t8 = 255;
              } else
                t8 = 0;
              if (offset < 0 || offset >= t1)
                return H.ioore(data, offset);
              data[offset] = t8;
              offset = offset0;
            }
          }
          break;
        case 4:
          t2 = this.adobe;
          if (t2 == null)
            throw H.wrapException(U.ImageException$("Unsupported color mode (4 components)"));
          colorTransform = !J.$eq(t2.transformCode, 0) && true;
          t2 = t1.length;
          if (0 >= t2)
            return H.ioore(t1, 0);
          component1 = t1[0];
          if (1 >= t2)
            return H.ioore(t1, 1);
          component2 = t1[1];
          if (2 >= t2)
            return H.ioore(t1, 2);
          component3 = t1[2];
          if (3 >= t2)
            return H.ioore(t1, 3);
          component4 = t1[3];
          if (typeof height !== "number")
            return H.iae(height);
          t1 = data.length;
          t2 = !colorTransform;
          t3 = J.getInterceptor$asx(component1);
          t4 = J.getInterceptor$asx(component2);
          t5 = J.getInterceptor$asx(component3);
          t6 = J.getInterceptor$asx(component4);
          offset = 0;
          $Y = null;
          Cb = null;
          Cr = null;
          $K = null;
          $C = null;
          $M = null;
          Ye = null;
          y = 0;
          for (; y < height; ++y) {
            t7 = t3.$index(component1, "lines");
            t8 = t3.$index(component1, "scaleY");
            if (typeof t8 !== "number")
              return H.iae(t8);
            component1Line = J.$index$asx(t7, y * t8);
            t8 = t4.$index(component2, "lines");
            t7 = t4.$index(component2, "scaleY");
            if (typeof t7 !== "number")
              return H.iae(t7);
            component2Line = J.$index$asx(t8, y * t7);
            t7 = t5.$index(component3, "lines");
            t8 = t5.$index(component3, "scaleY");
            if (typeof t8 !== "number")
              return H.iae(t8);
            component3Line = J.$index$asx(t7, y * t8);
            t8 = t6.$index(component4, "lines");
            t7 = t6.$index(component4, "scaleY");
            if (typeof t7 !== "number")
              return H.iae(t7);
            component4Line = J.$index$asx(t8, y * t7);
            if (typeof width !== "number")
              return H.iae(width);
            t7 = J.getInterceptor$asx(component1Line);
            t8 = J.getInterceptor$asx(component2Line);
            t9 = J.getInterceptor$asx(component3Line);
            t10 = J.getInterceptor$asx(component4Line);
            x = 0;
            for (; x < width; ++x) {
              if (t2) {
                t11 = t3.$index(component1, "scaleX");
                if (typeof t11 !== "number")
                  return H.iae(t11);
                $C = t7.$index(component1Line, x * t11);
                t11 = t4.$index(component2, "scaleX");
                if (typeof t11 !== "number")
                  return H.iae(t11);
                $M = t8.$index(component2Line, x * t11);
                t11 = t5.$index(component3, "scaleX");
                if (typeof t11 !== "number")
                  return H.iae(t11);
                Ye = t9.$index(component3Line, x * t11);
                t11 = t6.$index(component4, "scaleX");
                if (typeof t11 !== "number")
                  return H.iae(t11);
                $K = t10.$index(component4Line, x * t11);
              } else {
                t11 = t3.$index(component1, "scaleX");
                if (typeof t11 !== "number")
                  return H.iae(t11);
                $Y = t7.$index(component1Line, x * t11);
                t11 = t4.$index(component2, "scaleX");
                if (typeof t11 !== "number")
                  return H.iae(t11);
                Cb = t8.$index(component2Line, x * t11);
                t11 = t5.$index(component3, "scaleX");
                if (typeof t11 !== "number")
                  return H.iae(t11);
                Cr = t9.$index(component3Line, x * t11);
                t11 = t6.$index(component4, "scaleX");
                if (typeof t11 !== "number")
                  return H.iae(t11);
                $K = t10.$index(component4Line, x * t11);
                t11 = J.getInterceptor$n(Cr);
                t12 = t11.$sub(Cr, 128);
                if (typeof t12 !== "number")
                  return H.iae(t12);
                t13 = J.getInterceptor$ns($Y);
                t12 = J.toInt$0$n(t13.$add($Y, 1.402 * t12));
                if (t12 < 0)
                  t12 = 0;
                else if (t12 > 255)
                  t12 = 255;
                $C = 255 - t12;
                t12 = J.getInterceptor$n(Cb);
                t14 = t12.$sub(Cb, 128);
                if (typeof t14 !== "number")
                  return H.iae(t14);
                t14 = t13.$sub($Y, 0.3441363 * t14);
                t11 = t11.$sub(Cr, 128);
                if (typeof t11 !== "number")
                  return H.iae(t11);
                t11 = J.toInt$0$n(J.$sub$n(t14, 0.71413636 * t11));
                if (t11 < 0)
                  t11 = 0;
                else if (t11 > 255)
                  t11 = 255;
                $M = 255 - t11;
                t12 = t12.$sub(Cb, 128);
                if (typeof t12 !== "number")
                  return H.iae(t12);
                t12 = J.toInt$0$n(t13.$add($Y, 1.772 * t12));
                if (t12 < 0)
                  t11 = 0;
                else
                  t11 = t12 > 255 ? 255 : t12;
                Ye = 255 - t11;
              }
              offset0 = offset + 1;
              if (offset < 0 || offset >= t1)
                return H.ioore(data, offset);
              data[offset] = $C;
              offset = offset0 + 1;
              if (offset0 < 0 || offset0 >= t1)
                return H.ioore(data, offset0);
              data[offset0] = $M;
              offset0 = offset + 1;
              if (offset < 0 || offset >= t1)
                return H.ioore(data, offset);
              data[offset] = Ye;
              offset = offset0 + 1;
              if (offset0 < 0 || offset0 >= t1)
                return H.ioore(data, offset0);
              data[offset0] = $K;
            }
          }
          break;
        default:
          throw H.wrapException(U.ImageException$("Unsupported color mode"));
      }
      return data;
    },
    _read$0: function() {
      var marker, t1, t2, $length, pos, t3, t4, t5, bytes, t6, pos0;
      if (!J.$eq(this._nextMarker$0(), 216))
        throw H.wrapException(U.ImageException$("Start Of Image marker not found."));
      marker = this._nextMarker$0();
      while (true) {
        t1 = J.getInterceptor(marker);
        if (!t1.$eq(marker, 217)) {
          t2 = this.input;
          t2 = !J.$ge$n(t2.offset, t2.end);
        } else
          t2 = false;
        if (!t2)
          break;
        $length = this.input.readUint16$0();
        if ($length < 2)
          H.throwExpression(U.ImageException$("Invalid Block"));
        t2 = this.input;
        t2.toString;
        pos = J.$add$ns(t2.offset, 0);
        t3 = t2.buffer;
        t4 = t2.bigEndian;
        t5 = J.$add$ns(pos, $length - 2);
        bytes = new U.InputBuffer(t3, pos, t5, pos, t4);
        t2.offset = J.$add$ns(t2.offset, J.$sub$n(t5, pos));
        switch (marker) {
          case 224:
          case 225:
          case 226:
          case 227:
          case 228:
          case 229:
          case 230:
          case 231:
          case 232:
          case 233:
          case 234:
          case 235:
          case 236:
          case 237:
          case 238:
          case 239:
          case 254:
            if (t1.$eq(marker, 224))
              if (J.$eq(J.$index$asx(t3, J.$add$ns(pos, 0)), 74) && J.$eq(J.$index$asx(t3, J.$add$ns(pos, 1)), 70) && J.$eq(J.$index$asx(t3, J.$add$ns(pos, 2)), 73) && J.$eq(J.$index$asx(t3, J.$add$ns(pos, 3)), 70) && J.$eq(J.$index$asx(t3, J.$add$ns(pos, 4)), 0)) {
                t2 = new U.JpegJfif(null, null, null, null, null, null, null, null);
                this.jfif = t2;
                t2.majorVersion = J.$index$asx(t3, J.$add$ns(pos, 5));
                this.jfif.minorVersion = J.$index$asx(t3, J.$add$ns(pos, 6));
                this.jfif.densityUnits = J.$index$asx(t3, J.$add$ns(pos, 7));
                this.jfif.xDensity = J.$or$n(J.$mul$ns(J.$index$asx(t3, J.$add$ns(pos, 8)), 256), J.$index$asx(t3, J.$add$ns(pos, 9)));
                this.jfif.yDensity = J.$or$n(J.$mul$ns(J.$index$asx(t3, J.$add$ns(pos, 10)), 256), J.$index$asx(t3, J.$add$ns(pos, 11)));
                this.jfif.thumbWidth = J.$index$asx(t3, J.$add$ns(pos, 12));
                this.jfif.thumbHeight = J.$index$asx(t3, J.$add$ns(pos, 13));
                t2 = this.jfif;
                t5 = t2.thumbWidth;
                if (typeof t5 !== "number")
                  return H.iae(t5);
                t6 = t2.thumbHeight;
                if (typeof t6 !== "number")
                  return H.iae(t6);
                pos0 = J.$add$ns(pos, 14);
                t5 = J.$add$ns(pos0, 14 + 3 * t5 * t6);
                t2.thumbData = new U.InputBuffer(t3, pos0, t5, pos0, t4);
              }
            if (t1.$eq(marker, 238))
              if (J.$eq(J.$index$asx(t3, J.$add$ns(pos, 0)), 65) && J.$eq(J.$index$asx(t3, J.$add$ns(pos, 1)), 100) && J.$eq(J.$index$asx(t3, J.$add$ns(pos, 2)), 111) && J.$eq(J.$index$asx(t3, J.$add$ns(pos, 3)), 98) && J.$eq(J.$index$asx(t3, J.$add$ns(pos, 4)), 101) && J.$eq(J.$index$asx(t3, J.$add$ns(pos, 5)), 0)) {
                t1 = new U.JpegAdobe(null, null, null, null);
                this.adobe = t1;
                t1.version = J.$index$asx(t3, J.$add$ns(pos, 6));
                this.adobe.flags0 = J.$or$n(J.$mul$ns(J.$index$asx(t3, J.$add$ns(pos, 7)), 256), J.$index$asx(t3, J.$add$ns(pos, 8)));
                this.adobe.flags1 = J.$or$n(J.$mul$ns(J.$index$asx(t3, J.$add$ns(pos, 9)), 256), J.$index$asx(t3, J.$add$ns(pos, 10)));
                this.adobe.transformCode = J.$index$asx(t3, J.$add$ns(pos, 11));
              }
            break;
          case 219:
            this._readDQT$1(bytes);
            break;
          case 192:
          case 193:
          case 194:
            this._readFrame$2(marker, bytes);
            break;
          case 195:
          case 197:
          case 198:
          case 199:
          case 200:
          case 201:
          case 202:
          case 203:
          case 205:
          case 206:
          case 207:
            throw H.wrapException(U.ImageException$("Unhandled frame type " + t1.toRadixString$1(marker, 16)));
          case 196:
            this._readDHT$1(bytes);
            break;
          case 221:
            this.resetInterval = bytes.readUint16$0();
            break;
          case 218:
            this._readSOS$1(bytes);
            break;
          default:
            t2 = this.input;
            if (J.$eq(J.$index$asx(t2.buffer, J.$add$ns(t2.offset, -3)), 255)) {
              t2 = this.input;
              if (J.$ge$n(J.$index$asx(t2.buffer, J.$add$ns(t2.offset, -2)), 192)) {
                t2 = this.input;
                t2 = J.$le$n(J.$index$asx(t2.buffer, J.$add$ns(t2.offset, -2)), 254);
              } else
                t2 = false;
            } else
              t2 = false;
            if (t2) {
              t1 = this.input;
              t1.offset = J.$sub$n(t1.offset, 3);
              break;
            }
            if (!t1.$eq(marker, 0))
              throw H.wrapException(U.ImageException$("Unknown JPEG marker " + t1.toRadixString$1(marker, 16)));
            break;
        }
        marker = this._nextMarker$0();
      }
    },
    _nextMarker$0: function() {
      var t1, t2, t3, c;
      do {
        do {
          t1 = this.input;
          t2 = t1.buffer;
          t3 = t1.offset;
          t1.offset = J.$add$ns(t3, 1);
          if (!J.$eq(J.$index$asx(t2, t3), 255)) {
            t1 = this.input;
            t1 = !J.$ge$n(t1.offset, t1.end);
          } else
            t1 = false;
        } while (t1);
        do {
          t1 = this.input;
          t2 = t1.buffer;
          t3 = t1.offset;
          t1.offset = J.$add$ns(t3, 1);
          c = J.$index$asx(t2, t3);
          t1 = J.getInterceptor(c);
          if (t1.$eq(c, 255)) {
            t2 = this.input;
            t2 = !J.$ge$n(t2.offset, t2.end);
          } else
            t2 = false;
        } while (t2);
        if (t1.$eq(c, 0)) {
          t1 = this.input;
          t1 = !J.$ge$n(t1.offset, t1.end);
        } else
          t1 = false;
      } while (t1);
      return c;
    },
    _readDQT$1: function(block) {
      var t1, t2, t3, t4, n, prec, t5, i, tmp, t6, t7;
      for (t1 = block.end, t2 = this.quantizationTables; !J.$ge$n(block.offset, t1);) {
        t3 = block.buffer;
        t4 = block.offset;
        block.offset = J.$add$ns(t4, 1);
        n = J.$index$asx(t3, t4);
        prec = J.floor$0$n(J.$div$n(n, 16));
        if (typeof n !== "number")
          return n.$and();
        n &= 15;
        if (n >= 4)
          throw H.wrapException(U.ImageException$("Invalid number of quantization tables"));
        t3 = t2[n];
        if (t3 == null) {
          t3 = new Int32Array(64);
          t2[n] = t3;
        }
        for (t4 = J.getInterceptor$ax(t3), t5 = prec !== 0, i = 0; i < 64; ++i) {
          if (t5)
            tmp = block.readUint16$0();
          else {
            t6 = block.buffer;
            t7 = block.offset;
            block.offset = J.$add$ns(t7, 1);
            tmp = J.$index$asx(t6, t7);
          }
          t4.$indexSet(t3, C.List_AZw[i], tmp);
        }
      }
      if (!J.$ge$n(block.offset, t1))
        throw H.wrapException(U.ImageException$("Bad length for DQT block"));
    },
    _readFrame$2: function(marker, block) {
      var t1, t2, t3, numComponents, i, componentId, x, t4, qId;
      if (this.frame != null)
        throw H.wrapException(U.ImageException$("Duplicate JPG frame data found."));
      t1 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t2 = [];
      t2.$builtinTypeInfo = [J.JSInt];
      t1 = new U.JpegFrame(null, null, null, null, null, 0, 0, null, null, t1, t2);
      this.frame = t1;
      t2 = J.getInterceptor(marker);
      t1.extended = t2.$eq(marker, 193);
      this.frame.progressive = t2.$eq(marker, 194);
      t2 = this.frame;
      t1 = block.buffer;
      t3 = block.offset;
      block.offset = J.$add$ns(t3, 1);
      t2.precision = J.$index$asx(t1, t3);
      this.frame.scanLines = block.readUint16$0();
      this.frame.samplesPerLine = block.readUint16$0();
      t3 = block.buffer;
      t1 = block.offset;
      block.offset = J.$add$ns(t1, 1);
      numComponents = J.$index$asx(t3, t1);
      if (typeof numComponents !== "number")
        return H.iae(numComponents);
      t1 = this.quantizationTables;
      i = 0;
      for (; i < numComponents; ++i) {
        t2 = block.buffer;
        t3 = block.offset;
        block.offset = J.$add$ns(t3, 1);
        componentId = J.$index$asx(t2, t3);
        t3 = block.buffer;
        t2 = block.offset;
        block.offset = J.$add$ns(t2, 1);
        x = J.$index$asx(t3, t2);
        t2 = J.floor$0$n(J.$div$n(x, 16));
        if (typeof x !== "number")
          return x.$and();
        t3 = block.buffer;
        t4 = block.offset;
        block.offset = J.$add$ns(t4, 1);
        qId = J.$index$asx(t3, t4);
        this.frame.componentsOrder.push(componentId);
        this.frame.components.$indexSet(0, componentId, new U.JpegComponent(t2 & 15, x & 15, t1, qId, null, null, null, null, null, null));
      }
      this.frame.prepare$0();
      this.frames.push(this.frame);
    },
    _readDHT$1: function(block) {
      var t1, ht, ht0, t2, t3, index, bits, count, j, huffmanValues, ht1;
      for (t1 = block.end, ht = this.huffmanTablesDC, ht0 = this.huffmanTablesAC; !J.$ge$n(block.offset, t1);) {
        t2 = block.buffer;
        t3 = block.offset;
        block.offset = J.$add$ns(t3, 1);
        index = J.$index$asx(t2, t3);
        bits = new Uint8Array(16);
        for (count = 0, j = 0; j < 16; ++j) {
          t2 = block.buffer;
          t3 = block.offset;
          block.offset = J.$add$ns(t3, 1);
          bits[j] = J.$index$asx(t2, t3);
          count += bits[j];
        }
        huffmanValues = new Uint8Array(count);
        for (j = 0; j < count; ++j) {
          t2 = block.buffer;
          t3 = block.offset;
          block.offset = J.$add$ns(t3, 1);
          t3 = J.$index$asx(t2, t3);
          if (j >= count)
            return H.ioore(huffmanValues, j);
          huffmanValues[j] = t3;
        }
        t2 = J.getInterceptor$n(index);
        if (t2.$and(index, 16) !== 0) {
          index = t2.$sub(index, 16);
          ht1 = ht0;
        } else
          ht1 = ht;
        t2 = ht1.length;
        if (typeof index !== "number")
          return H.iae(index);
        if (t2 <= index)
          C.JSArray_methods.set$length(ht1, index + 1);
        t2 = this._buildHuffmanTable$2(bits, huffmanValues);
        if (index >>> 0 !== index || index >= ht1.length)
          return H.ioore(ht1, index);
        ht1[index] = t2;
      }
    },
    _readSOS$1: function(block) {
      var t1, t2, n, components, t3, i, t4, t5, id, c, component, dc_tbl_no, ac_tbl_no, spectralStart, spectralEnd, successiveApproximation;
      t1 = block.buffer;
      t2 = block.offset;
      block.offset = J.$add$ns(t2, 1);
      n = J.$index$asx(t1, t2);
      t1 = J.getInterceptor$n(n);
      if (t1.$lt(n, 1) || t1.$gt(n, 4))
        throw H.wrapException(U.ImageException$("Invalid SOS block"));
      if (typeof n !== "number")
        return H.iae(n);
      components = Array(n);
      for (t1 = this.huffmanTablesAC, t2 = this.huffmanTablesDC, t3 = components.length, i = 0; t4 = block.buffer, t5 = block.offset, i < n; ++i) {
        block.offset = J.$add$ns(t5, 1);
        id = J.$index$asx(t4, t5);
        t4 = block.buffer;
        t5 = block.offset;
        block.offset = J.$add$ns(t5, 1);
        c = J.$index$asx(t4, t5);
        if (!this.frame.components.containsKey$1(id))
          throw H.wrapException(U.ImageException$("Invalid Component in SOS block"));
        component = this.frame.components.$index(0, id);
        if (i >= t3)
          return H.ioore(components, i);
        components[i] = component;
        dc_tbl_no = J.floor$0$n(J.$div$n(c, 16)) & 15;
        if (typeof c !== "number")
          return c.$and();
        ac_tbl_no = c & 15;
        t4 = t2.length;
        if (dc_tbl_no < t4) {
          if (dc_tbl_no >= t4)
            return H.ioore(t2, dc_tbl_no);
          component.huffmanTableDC = t2[dc_tbl_no];
        }
        t4 = t1.length;
        if (ac_tbl_no < t4) {
          if (ac_tbl_no >= t4)
            return H.ioore(t1, ac_tbl_no);
          component.huffmanTableAC = t1[ac_tbl_no];
        }
      }
      block.offset = J.$add$ns(t5, 1);
      spectralStart = J.$index$asx(t4, t5);
      t1 = block.buffer;
      t2 = block.offset;
      block.offset = J.$add$ns(t2, 1);
      spectralEnd = J.$index$asx(t1, t2);
      t2 = block.buffer;
      t1 = block.offset;
      block.offset = J.$add$ns(t1, 1);
      successiveApproximation = J.$index$asx(t2, t1);
      t1 = J.floor$0$n(J.$div$n(successiveApproximation, 16));
      if (typeof successiveApproximation !== "number")
        return successiveApproximation.$and();
      t2 = this.input;
      t3 = this.frame;
      t1 = new U.JpegScan(t2, t3, null, null, null, null, null, null, null, components, this.resetInterval, spectralStart, spectralEnd, t1 & 15, successiveApproximation & 15, 0, 0, 0, 0, null);
      t1.precision = t3.precision;
      t1.samplesPerLine = t3.samplesPerLine;
      t1.scanLines = t3.scanLines;
      t1.mcusPerLine = t3.mcusPerLine;
      t1.progressive = t3.progressive;
      t1.maxH = t3.maxH;
      t1.maxV = t3.maxV;
      t1.decode$0();
    },
    _buildHuffmanTable$2: function(codeLengths, values) {
      var code, $length, p, t1, k, q, i, j, t2, t3;
      code = [];
      $length = 16;
      while (true) {
        if (!($length > 0 && codeLengths[$length - 1] === 0))
          break;
        --$length;
      }
      code.push(P.LinkedHashMap_LinkedHashMap$_literal(["children", [], "index", 0], null, null));
      if (0 >= code.length)
        return H.ioore(code, 0);
      p = code[0];
      for (t1 = values.length, k = 0, q = null, i = 0; i < $length;) {
        for (j = 0; j < codeLengths[i]; ++j) {
          if (0 >= code.length)
            return H.ioore(code, 0);
          p = code.pop();
          t2 = J.getInterceptor$asx(p);
          if (J.$le$n(J.get$length$asx(t2.$index(p, "children")), t2.$index(p, "index")))
            J.set$length$asx(t2.$index(p, "children"), J.$add$ns(t2.$index(p, "index"), 1));
          t3 = t2.$index(p, "children");
          t2 = t2.$index(p, "index");
          if (k < 0 || k >= t1)
            return H.ioore(values, k);
          J.$indexSet$ax(t3, t2, values[k]);
          for (; t2 = J.getInterceptor$asx(p), J.$gt$n(t2.$index(p, "index"), 0);) {
            if (0 >= code.length)
              return H.ioore(code, 0);
            p = code.pop();
          }
          t2.$indexSet(p, "index", J.$add$ns(t2.$index(p, "index"), 1));
          code.push(p);
          for (; code.length <= i; p = q) {
            q = P.LinkedHashMap_LinkedHashMap$_literal(["children", [], "index", 0], null, null);
            code.push(q);
            t2 = J.getInterceptor$asx(p);
            if (J.$le$n(J.get$length$asx(t2.$index(p, "children")), t2.$index(p, "index")))
              J.set$length$asx(t2.$index(p, "children"), J.$add$ns(t2.$index(p, "index"), 1));
            J.$indexSet$ax(t2.$index(p, "children"), t2.$index(p, "index"), q.$index(0, "children"));
          }
          ++k;
        }
        ++i;
        if (i < $length) {
          q = P.LinkedHashMap_LinkedHashMap$_literal(["children", [], "index", 0], null, null);
          code.push(q);
          t2 = J.getInterceptor$asx(p);
          if (J.$le$n(J.get$length$asx(t2.$index(p, "children")), t2.$index(p, "index")))
            J.set$length$asx(t2.$index(p, "children"), J.$add$ns(t2.$index(p, "index"), 1));
          J.$indexSet$ax(t2.$index(p, "children"), t2.$index(p, "index"), q.$index(0, "children"));
          p = q;
        }
      }
      if (0 >= code.length)
        return H.ioore(code, 0);
      return J.$index$asx(code[0], "children");
    },
    _buildComponentData$2: function(frame, component) {
      var blocksPerLine, blocksPerColumn, samplesPerLine, $R, r, t1, lines, t2, t3, l, blockRow, scanLine, i, l0, t4, blockCol, t5, sample, offset, j, line, offset0;
      blocksPerLine = component.blocksPerLine;
      blocksPerColumn = component.blocksPerColumn;
      if (typeof blocksPerLine !== "number")
        return blocksPerLine.$mul();
      samplesPerLine = blocksPerLine * 8;
      $R = new Int32Array(64);
      r = new Uint8Array(64);
      if (typeof blocksPerColumn !== "number")
        return blocksPerColumn.$mul();
      t1 = blocksPerColumn * 8;
      lines = Array(t1);
      lines.fixed$length = init;
      for (t2 = component.quantizationTableList, t3 = component.quantizationIndex, l = 0, blockRow = 0; blockRow < blocksPerColumn; ++blockRow) {
        scanLine = blockRow * 8;
        for (i = 0; i < 8; ++i, l = l0) {
          l0 = l + 1;
          t4 = new Uint8Array(samplesPerLine);
          if (l < 0 || l >= t1)
            return H.ioore(lines, l);
          lines[l] = t4;
        }
        for (blockCol = 0; blockCol < blocksPerLine; ++blockCol) {
          if (t3 >>> 0 !== t3 || t3 >= 4)
            return H.ioore(t2, t3);
          t4 = t2[t3];
          t5 = component.blocks;
          if (blockRow >= t5.length)
            return H.ioore(t5, blockRow);
          this._quantizeAndInverse$4(t4, J.$index$asx(t5[blockRow], blockCol), r, $R);
          sample = blockCol * 8;
          for (offset = 0, j = 0; j < 8; ++j) {
            t4 = scanLine + j;
            if (t4 >= t1)
              return H.ioore(lines, t4);
            line = lines[t4];
            for (t4 = J.getInterceptor$ax(line), i = 0; i < 8; ++i, offset = offset0) {
              offset0 = offset + 1;
              if (offset < 0 || offset >= 64)
                return H.ioore(r, offset);
              t4.$indexSet(line, sample + i, r[offset]);
            }
          }
        }
      }
      return lines;
    },
    _quantizeAndInverse$4: function(quantizationTable, zz, dataOut, dataIn) {
      var t1, t2, i, row, v0, v1, t3, v2, t4, v3, t5, t6, v4, v7, v5, t7, v6, t, t8, t9, t10, t11;
      for (t1 = J.getInterceptor$asx(zz), t2 = J.getInterceptor$asx(quantizationTable), i = 0; i < 64; ++i)
        dataIn[i] = J.$mul$ns(t1.$index(zz, i), t2.$index(quantizationTable, i));
      for (row = 0, i = 0; i < 8; ++i, row += 8) {
        t1 = 1 + row;
        if (t1 >= 64)
          return H.ioore(dataIn, t1);
        if (dataIn[t1] === 0) {
          t2 = 2 + row;
          if (t2 >= 64)
            return H.ioore(dataIn, t2);
          if (dataIn[t2] === 0) {
            t2 = 3 + row;
            if (t2 >= 64)
              return H.ioore(dataIn, t2);
            if (dataIn[t2] === 0) {
              t2 = 4 + row;
              if (t2 >= 64)
                return H.ioore(dataIn, t2);
              if (dataIn[t2] === 0) {
                t2 = 5 + row;
                if (t2 >= 64)
                  return H.ioore(dataIn, t2);
                if (dataIn[t2] === 0) {
                  t2 = 6 + row;
                  if (t2 >= 64)
                    return H.ioore(dataIn, t2);
                  if (dataIn[t2] === 0) {
                    t2 = 7 + row;
                    if (t2 >= 64)
                      return H.ioore(dataIn, t2);
                    t2 = dataIn[t2] === 0;
                  } else
                    t2 = false;
                } else
                  t2 = false;
              } else
                t2 = false;
            } else
              t2 = false;
          } else
            t2 = false;
        } else
          t2 = false;
        if (t2) {
          if (row >= 64)
            return H.ioore(dataIn, row);
          C.NativeInt32List_methods.fillRange$3(dataIn, row, row + 8, C.JSInt_methods.floor$0((5793 * dataIn[row] + 512) / 1024));
          continue;
        }
        if (row >= 64)
          return H.ioore(dataIn, row);
        v0 = C.JSInt_methods.floor$0((5793 * dataIn[row] + 128) / 256);
        t2 = 4 + row;
        if (t2 >= 64)
          return H.ioore(dataIn, t2);
        v1 = C.JSInt_methods.floor$0((5793 * dataIn[t2] + 128) / 256);
        t3 = 2 + row;
        if (t3 >= 64)
          return H.ioore(dataIn, t3);
        v2 = dataIn[t3];
        t4 = 6 + row;
        if (t4 >= 64)
          return H.ioore(dataIn, t4);
        v3 = dataIn[t4];
        t5 = dataIn[t1];
        t6 = 7 + row;
        if (t6 >= 64)
          return H.ioore(dataIn, t6);
        v4 = C.JSInt_methods.floor$0((2896 * (t5 - dataIn[t6]) + 128) / 256);
        v7 = C.JSInt_methods.floor$0((2896 * (dataIn[t1] + dataIn[t6]) + 128) / 256);
        t5 = 3 + row;
        if (t5 >= 64)
          return H.ioore(dataIn, t5);
        v5 = dataIn[t5] * 16;
        t7 = 5 + row;
        if (t7 >= 64)
          return H.ioore(dataIn, t7);
        v6 = dataIn[t7] * 16;
        t = C.JSInt_methods.floor$0((v0 - v1 + 1) / 2);
        v0 = C.JSInt_methods.floor$0((v0 + v1 + 1) / 2);
        t8 = C.JSInt_methods.floor$0((v2 * 3784 + v3 * 1567 + 128) / 256);
        v2 = C.JSInt_methods.floor$0((v2 * 1567 - v3 * 3784 + 128) / 256);
        t9 = C.JSInt_methods.floor$0((v4 - v6 + 1) / 2);
        v4 = C.JSInt_methods.floor$0((v4 + v6 + 1) / 2);
        t10 = C.JSInt_methods.floor$0((v7 + v5 + 1) / 2);
        v5 = C.JSInt_methods.floor$0((v7 - v5 + 1) / 2);
        t11 = C.JSInt_methods.floor$0((v0 - t8 + 1) / 2);
        v0 = C.JSInt_methods.floor$0((v0 + t8 + 1) / 2);
        t8 = C.JSInt_methods.floor$0((t - v2 + 1) / 2);
        v1 = C.JSInt_methods.floor$0((t + v2 + 1) / 2);
        t = C.JSInt_methods.floor$0((v4 * 2276 + t10 * 3406 + 2048) / 4096);
        v4 = C.JSInt_methods.floor$0((v4 * 3406 - t10 * 2276 + 2048) / 4096);
        t10 = C.JSInt_methods.floor$0((v5 * 799 + t9 * 4017 + 2048) / 4096);
        v5 = C.JSInt_methods.floor$0((v5 * 4017 - t9 * 799 + 2048) / 4096);
        dataIn[row] = v0 + t;
        dataIn[t6] = v0 - t;
        dataIn[t1] = v1 + t10;
        dataIn[t4] = v1 - t10;
        dataIn[t3] = t8 + v5;
        dataIn[t7] = t8 - v5;
        dataIn[t5] = t11 + v4;
        dataIn[t2] = t11 - v4;
      }
      for (i = 0; i < 8; ++i) {
        t1 = 8 + i;
        if (dataIn[t1] === 0 && dataIn[16 + i] === 0 && dataIn[24 + i] === 0 && dataIn[32 + i] === 0 && dataIn[40 + i] === 0 && dataIn[48 + i] === 0 && dataIn[56 + i] === 0) {
          t = C.JSInt_methods.floor$0((5793 * dataIn[i] + 8192) / 16384);
          dataIn[i] = t;
          dataIn[t1] = t;
          dataIn[16 + i] = t;
          dataIn[24 + i] = t;
          dataIn[32 + i] = t;
          dataIn[40 + i] = t;
          dataIn[48 + i] = t;
          dataIn[56 + i] = t;
          continue;
        }
        v0 = C.JSInt_methods.floor$0((5793 * dataIn[i] + 2048) / 4096);
        t2 = 32 + i;
        v1 = C.JSInt_methods.floor$0((5793 * dataIn[t2] + 2048) / 4096);
        t3 = 16 + i;
        v2 = dataIn[t3];
        t4 = 48 + i;
        v3 = dataIn[t4];
        t5 = 56 + i;
        v4 = C.JSInt_methods.floor$0((2896 * (dataIn[t1] - dataIn[t5]) + 2048) / 4096);
        v7 = C.JSInt_methods.floor$0((2896 * (dataIn[t1] + dataIn[t5]) + 2048) / 4096);
        t6 = 24 + i;
        v5 = dataIn[t6];
        t7 = 40 + i;
        v6 = dataIn[t7];
        t = C.JSInt_methods.floor$0((v0 - v1 + 1) / 2);
        v0 = C.JSInt_methods.floor$0((v0 + v1 + 1) / 2);
        t8 = C.JSInt_methods.floor$0((v2 * 3784 + v3 * 1567 + 2048) / 4096);
        v2 = C.JSInt_methods.floor$0((v2 * 1567 - v3 * 3784 + 2048) / 4096);
        t9 = C.JSInt_methods.floor$0((v4 - v6 + 1) / 2);
        v4 = C.JSInt_methods.floor$0((v4 + v6 + 1) / 2);
        t10 = C.JSInt_methods.floor$0((v7 + v5 + 1) / 2);
        v5 = C.JSInt_methods.floor$0((v7 - v5 + 1) / 2);
        t11 = C.JSInt_methods.floor$0((v0 - t8 + 1) / 2);
        v0 = C.JSInt_methods.floor$0((v0 + t8 + 1) / 2);
        t8 = C.JSInt_methods.floor$0((t - v2 + 1) / 2);
        v1 = C.JSInt_methods.floor$0((t + v2 + 1) / 2);
        t = C.JSInt_methods.floor$0((v4 * 2276 + t10 * 3406 + 2048) / 4096);
        v4 = C.JSInt_methods.floor$0((v4 * 3406 - t10 * 2276 + 2048) / 4096);
        t10 = C.JSInt_methods.floor$0((v5 * 799 + t9 * 4017 + 2048) / 4096);
        v5 = C.JSInt_methods.floor$0((v5 * 4017 - t9 * 799 + 2048) / 4096);
        dataIn[i] = v0 + t;
        dataIn[t5] = v0 - t;
        dataIn[t1] = v1 + t10;
        dataIn[t4] = v1 - t10;
        dataIn[t3] = t8 + v5;
        dataIn[t7] = t8 - v5;
        dataIn[t6] = t11 + v4;
        dataIn[t2] = t11 - v4;
      }
      for (i = 0; i < 64; ++i) {
        t1 = 128 + C.JSInt_methods.floor$0((dataIn[i] + 8) / 16);
        if (t1 < 0)
          t1 = 0;
        else if (t1 > 255)
          t1 = 255;
        dataOut[i] = t1;
      }
    },
    static: {"^": "JpegData_Y16,JpegData_R_CR,JpegData_G_CB,JpegData_G_CR,JpegData_B_CB"}
  },
  JpegFrame: {
    "^": "Object;extended,progressive,precision,scanLines,samplesPerLine,maxH,maxV,mcusPerLine,mcusPerColumn,components,componentsOrder",
    prepare$0: function() {
      var t1, t2, t3, component, t4, t5, blocksPerLine, t6, blocksPerColumn, blocksPerLineForMcu, blocksPerColumnForMcu, blocks, i, row, j;
      for (t1 = this.components, t2 = t1.get$keys()._map, t3 = new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), t3._cell = t2._first; t3.moveNext$0();) {
        component = t1.$index(0, t3._collection$_current);
        t4 = this.maxH;
        t5 = component.h;
        if (t4 < t5)
          this.maxH = t5;
        t4 = this.maxV;
        t5 = component.v;
        if (typeof t4 !== "number")
          return t4.$lt();
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (t4 < t5)
          this.maxV = t5;
      }
      t3 = this.samplesPerLine;
      if (typeof t3 !== "number")
        return t3.$div();
      this.mcusPerLine = C.JSNumber_methods.toInt$0(Math.ceil(t3 / 8 / this.maxH));
      t3 = this.scanLines;
      if (typeof t3 !== "number")
        return t3.$div();
      t4 = this.maxV;
      if (typeof t4 !== "number")
        return H.iae(t4);
      this.mcusPerColumn = C.JSNumber_methods.toInt$0(Math.ceil(t3 / 8 / t4));
      for (t3 = new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), t3._cell = t2._first; t3.moveNext$0();) {
        component = t1.$index(0, t3._collection$_current);
        t2 = this.samplesPerLine;
        if (typeof t2 !== "number")
          return t2.$div();
        t2 = C.JSNumber_methods.toInt$0(Math.ceil(t2 / 8));
        t4 = component.h;
        blocksPerLine = C.JSNumber_methods.toInt$0(Math.ceil(t2 * t4 / this.maxH));
        t2 = this.scanLines;
        if (typeof t2 !== "number")
          return t2.$div();
        t2 = C.JSNumber_methods.toInt$0(Math.ceil(t2 / 8));
        t5 = component.v;
        if (typeof t5 !== "number")
          return H.iae(t5);
        t6 = this.maxV;
        if (typeof t6 !== "number")
          return H.iae(t6);
        blocksPerColumn = C.JSNumber_methods.toInt$0(Math.ceil(t2 * t5 / t6));
        t6 = this.mcusPerLine;
        if (typeof t6 !== "number")
          return t6.$mul();
        blocksPerLineForMcu = t6 * t4;
        t4 = this.mcusPerColumn;
        t6 = component.v;
        if (typeof t4 !== "number")
          return t4.$mul();
        if (typeof t6 !== "number")
          return H.iae(t6);
        blocksPerColumnForMcu = t4 * t6;
        blocks = Array(blocksPerColumnForMcu);
        for (i = 0; i < blocksPerColumnForMcu; ++i) {
          row = Array(blocksPerLineForMcu);
          row.fixed$length = init;
          for (j = 0; j < blocksPerLineForMcu; ++j)
            row[j] = new Int32Array(64);
          if (i >= blocksPerColumnForMcu)
            return H.ioore(blocks, i);
          blocks[i] = row;
        }
        component.blocksPerLine = blocksPerLine;
        component.blocksPerColumn = blocksPerColumn;
        component.blocks = blocks;
      }
    }
  },
  JpegJfif: {
    "^": "Object;majorVersion,minorVersion,densityUnits,xDensity,yDensity,thumbWidth,thumbHeight,thumbData"
  },
  JpegScan: {
    "^": "Object;input,frame,precision,samplesPerLine,scanLines,mcusPerLine,progressive,maxH,maxV,components,resetInterval,spectralStart,spectralEnd,successivePrev,successive,bitsData,bitsCount,eobrun,successiveACState,successiveACNextValue",
    decode$0: function() {
      var t1, componentsLength, decodeFn, t2, t3, t4, mcuExpected, component, mcu, h, v, i, n, blockRow, blockCol, j, k, mcuRow, mcuCol, m1, m2;
      t1 = this.components;
      componentsLength = t1.length;
      if (this.progressive === true)
        if (J.$eq(this.spectralStart, 0))
          decodeFn = this.successivePrev === 0 ? this.get$_decodeDCFirst() : this.get$_decodeDCSuccessive();
        else
          decodeFn = this.successivePrev === 0 ? this.get$_decodeACFirst() : this.get$_decodeACSuccessive();
      else
        decodeFn = this.get$_decodeBaseline();
      t2 = componentsLength === 1;
      if (t2) {
        if (0 >= componentsLength)
          return H.ioore(t1, 0);
        t3 = t1[0];
        t4 = t3.get$blocksPerLine();
        t3 = t3.blocksPerColumn;
        if (typeof t4 !== "number")
          return t4.$mul();
        if (typeof t3 !== "number")
          return H.iae(t3);
        mcuExpected = t4 * t3;
      } else {
        t3 = this.mcusPerLine;
        t4 = this.frame.mcusPerColumn;
        if (typeof t3 !== "number")
          return t3.$mul();
        if (typeof t4 !== "number")
          return H.iae(t4);
        mcuExpected = t3 * t4;
      }
      t3 = this.resetInterval;
      if (t3 == null || t3 === 0)
        this.resetInterval = mcuExpected;
      for (component = null, mcu = 0, h = null, v = null; mcu < mcuExpected;) {
        for (i = 0; i < componentsLength; ++i)
          t1[i].set$pred(0);
        this.eobrun = 0;
        if (t2) {
          if (0 >= componentsLength)
            return H.ioore(t1, 0);
          component = t1[0];
          n = 0;
          while (true) {
            t3 = this.resetInterval;
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(n < t3))
              break;
            t3 = component.get$blocksPerLine();
            if (typeof t3 !== "number")
              return H.iae(t3);
            blockRow = C.JSInt_methods.$tdiv(mcu, t3);
            t3 = component.blocksPerLine;
            if (typeof t3 !== "number")
              return H.iae(t3);
            blockCol = C.JSInt_methods.$mod(mcu, t3);
            t3 = component.blocks;
            if (blockRow < 0 || blockRow >= t3.length)
              return H.ioore(t3, blockRow);
            decodeFn.call$2(component, J.$index$asx(t3[blockRow], blockCol));
            ++mcu;
            ++n;
          }
        } else {
          n = 0;
          while (true) {
            t3 = this.resetInterval;
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(n < t3))
              break;
            for (i = 0; i < componentsLength; ++i) {
              component = t1[i];
              h = component.get$h();
              v = component.v;
              if (typeof v !== "number")
                return H.iae(v);
              t3 = component.h;
              j = 0;
              for (; j < v; ++j)
                for (k = 0; k < h; ++k) {
                  t4 = this.mcusPerLine;
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  mcuRow = C.JSInt_methods.$tdiv(mcu, t4);
                  mcuCol = C.JSInt_methods.$mod(mcu, t4);
                  t4 = component.v;
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  blockRow = mcuRow * t4 + j;
                  t4 = component.blocks;
                  if (blockRow < 0 || blockRow >= t4.length)
                    return H.ioore(t4, blockRow);
                  decodeFn.call$2(component, J.$index$asx(t4[blockRow], mcuCol * t3 + k));
                }
            }
            ++mcu;
            ++n;
          }
        }
        this.bitsCount = 0;
        t3 = this.input;
        m1 = J.$index$asx(t3.buffer, J.$add$ns(t3.offset, 0));
        t3 = this.input;
        m2 = J.$index$asx(t3.buffer, J.$add$ns(t3.offset, 1));
        if (J.$eq(m1, 255)) {
          t3 = J.getInterceptor$n(m2);
          if (t3.$ge(m2, 208) && t3.$le(m2, 215)) {
            t3 = this.input;
            t3.offset = J.$add$ns(t3.offset, 2);
          } else
            break;
        }
      }
    },
    _readBit$0: function() {
      var t1, t2, t3, nextByte;
      t1 = this.bitsCount;
      if (t1 > 0) {
        --t1;
        this.bitsCount = t1;
        t2 = this.bitsData;
        if (typeof t2 !== "number")
          return t2.$shr();
        return C.JSNumber_methods.$shr(t2, t1) & 1;
      }
      t1 = this.input;
      t2 = t1.buffer;
      t3 = t1.offset;
      t1.offset = J.$add$ns(t3, 1);
      t3 = J.$index$asx(t2, t3);
      this.bitsData = t3;
      if (J.$eq(t3, 255)) {
        t1 = this.input;
        t2 = t1.buffer;
        t3 = t1.offset;
        t1.offset = J.$add$ns(t3, 1);
        nextByte = J.$index$asx(t2, t3);
        if (!J.$eq(nextByte, 0)) {
          t1 = this.bitsData;
          if (typeof t1 !== "number")
            return t1.$shl();
          if (typeof nextByte !== "number")
            return H.iae(nextByte);
          throw H.wrapException(U.ImageException$("unexpected marker: " + C.JSInt_methods.toRadixString$1((t1 << 8 | nextByte) >>> 0, 16)));
        }
      }
      this.bitsCount = 7;
      t1 = this.bitsData;
      if (typeof t1 !== "number")
        return t1.$shr();
      return C.JSNumber_methods._shrOtherPositive$1(t1, 7);
    },
    _image$_decodeHuffman$1: function(tree) {
      var node, bit;
      for (node = tree; bit = this._readBit$0(), true;) {
        node = J.$index$asx(node, bit);
        if (typeof node === "number")
          return C.JSNumber_methods.toInt$0(node);
      }
      return;
    },
    _receive$1: function($length) {
      var n, bit;
      n = 0;
      while (true) {
        if (typeof $length !== "number")
          return $length.$gt();
        if (!($length > 0))
          break;
        bit = this._readBit$0();
        n = (n << 1 | bit) >>> 0;
        --$length;
      }
      return n;
    },
    _receiveAndExtend$1: function($length) {
      var n, t1;
      n = this._receive$1($length);
      if (typeof $length !== "number")
        return $length.$sub();
      t1 = C.JSInt_methods.$shl(1, $length - 1);
      if (typeof n !== "number")
        return n.$ge();
      if (n >= t1)
        return n;
      return n + C.JSInt_methods.$shl(-1, $length) + 1;
    },
    _decodeBaseline$2: [function(component, zz) {
      var t, diff, t1, t2, k, rs, s, r;
      t = this._image$_decodeHuffman$1(component.get$huffmanTableDC());
      diff = t === 0 ? 0 : this._receiveAndExtend$1(t);
      t1 = component.pred;
      if (typeof t1 !== "number")
        return t1.$add();
      t1 += diff;
      component.pred = t1;
      t2 = J.getInterceptor$ax(zz);
      t2.$indexSet(zz, 0, t1);
      for (k = 1; k < 64;) {
        rs = this._image$_decodeHuffman$1(component.huffmanTableAC);
        if (typeof rs !== "number")
          return rs.$and();
        s = rs & 15;
        r = C.JSInt_methods._shrOtherPositive$1(rs, 4);
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        if (k < 0 || k >= 80)
          return H.ioore(C.List_AZw, k);
        t2.$indexSet(zz, C.List_AZw[k], this._receiveAndExtend$1(s));
        ++k;
      }
    }, "call$2", "get$_decodeBaseline", 4, 0, 114],
    _decodeDCFirst$2: [function(component, zz) {
      var t, diff, t1, t2;
      t = this._image$_decodeHuffman$1(component.get$huffmanTableDC());
      if (t === 0)
        diff = 0;
      else {
        t1 = this._receiveAndExtend$1(t);
        t2 = this.successive;
        if (typeof t2 !== "number")
          return H.iae(t2);
        diff = C.JSInt_methods._shlPositive$1(t1, t2);
      }
      t1 = component.pred;
      if (typeof t1 !== "number")
        return t1.$add();
      t1 += diff;
      component.pred = t1;
      J.$indexSet$ax(zz, 0, t1);
    }, "call$2", "get$_decodeDCFirst", 4, 0, 114],
    _decodeDCSuccessive$2: [function(component, zz) {
      var t1, t2, t3, t4;
      t1 = J.getInterceptor$asx(zz);
      t2 = t1.$index(zz, 0);
      t3 = this._readBit$0();
      t4 = this.successive;
      if (typeof t4 !== "number")
        return H.iae(t4);
      t1.$indexSet(zz, 0, J.$or$n(t2, C.JSInt_methods._shlPositive$1(t3, t4)));
    }, "call$2", "get$_decodeDCSuccessive", 4, 0, 114],
    _decodeACFirst$2: [function(component, zz) {
      var t1, k, e, t2, rs, s, r, z, t3;
      t1 = this.eobrun;
      if (t1 > 0) {
        this.eobrun = t1 - 1;
        return;
      }
      k = this.spectralStart;
      e = this.spectralEnd;
      for (t1 = J.getInterceptor$ax(zz); t2 = J.getInterceptor$n(k), t2.$le(k, e);) {
        rs = this._image$_decodeHuffman$1(component.get$huffmanTableAC());
        if (typeof rs !== "number")
          return rs.$and();
        s = rs & 15;
        r = C.JSInt_methods._shrOtherPositive$1(rs, 4);
        if (s === 0) {
          if (r < 15) {
            t1 = this._receive$1(r);
            t2 = C.JSInt_methods._shlPositive$1(1, r);
            if (typeof t1 !== "number")
              return t1.$add();
            this.eobrun = t1 + t2 - 1;
            break;
          }
          k = t2.$add(k, 16);
          continue;
        }
        k = t2.$add(k, r);
        if (k >>> 0 !== k || k >= 80)
          return H.ioore(C.List_AZw, k);
        z = C.List_AZw[k];
        t2 = this._receiveAndExtend$1(s);
        t3 = this.successive;
        if (typeof t3 !== "number")
          return H.iae(t3);
        t1.$indexSet(zz, z, t2 * C.JSInt_methods._shlPositive$1(1, t3));
        ++k;
      }
    }, "call$2", "get$_decodeACFirst", 4, 0, 114],
    _decodeACSuccessive$2: [function(component, zz) {
      var k, e, t1, t2, r, z, rs, s, r0, t3, t4;
      k = this.spectralStart;
      e = this.spectralEnd;
      for (t1 = J.getInterceptor$asx(zz), t2 = this.successive, r = 0; J.$le$n(k, e);) {
        if (k >>> 0 !== k || k >= 80)
          return H.ioore(C.List_AZw, k);
        z = C.List_AZw[k];
        switch (this.successiveACState) {
          case 0:
            rs = this._image$_decodeHuffman$1(component.get$huffmanTableAC());
            if (typeof rs !== "number")
              return rs.$and();
            s = rs & 15;
            r0 = C.JSInt_methods._shrOtherPositive$1(rs, 4);
            if (s === 0)
              if (r0 < 15) {
                t3 = this._receive$1(r0);
                t4 = C.JSInt_methods._shlPositive$1(1, r0);
                if (typeof t3 !== "number")
                  return t3.$add();
                this.eobrun = t3 + t4;
                this.successiveACState = 4;
              } else
                this.successiveACState = 1;
            else {
              if (s !== 1)
                throw H.wrapException(U.ImageException$("invalid ACn encoding"));
              this.successiveACNextValue = this._receiveAndExtend$1(s);
              this.successiveACState = r0 !== 0 ? 2 : 3;
            }
            continue;
          case 1:
          case 2:
            if (!J.$eq(t1.$index(zz, z), 0)) {
              t3 = t1.$index(zz, z);
              t4 = this._readBit$0();
              if (typeof t2 !== "number")
                return H.iae(t2);
              t1.$indexSet(zz, z, J.$add$ns(t3, C.JSInt_methods._shlPositive$1(t4, t2)));
            } else {
              --r;
              if (r === 0)
                this.successiveACState = this.successiveACState === 2 ? 3 : 0;
            }
            break;
          case 3:
            if (!J.$eq(t1.$index(zz, z), 0)) {
              t3 = t1.$index(zz, z);
              t4 = this._readBit$0();
              if (typeof t2 !== "number")
                return H.iae(t2);
              t1.$indexSet(zz, z, J.$add$ns(t3, C.JSInt_methods._shlPositive$1(t4, t2)));
            } else {
              t3 = this.successiveACNextValue;
              if (typeof t3 !== "number")
                return t3.$shl();
              if (typeof t2 !== "number")
                return H.iae(t2);
              t1.$indexSet(zz, z, C.JSInt_methods._shlPositive$1(t3, t2));
              this.successiveACState = 0;
            }
            break;
          case 4:
            if (!J.$eq(t1.$index(zz, z), 0)) {
              t3 = t1.$index(zz, z);
              t4 = this._readBit$0();
              if (typeof t2 !== "number")
                return H.iae(t2);
              t1.$indexSet(zz, z, J.$add$ns(t3, C.JSInt_methods._shlPositive$1(t4, t2)));
            }
            break;
        }
        ++k;
      }
      if (this.successiveACState === 4)
        if (--this.eobrun === 0)
          this.successiveACState = 0;
    }, "call$2", "get$_decodeACSuccessive", 4, 0, 115]
  },
  JpegDecoder: {
    "^": "Decoder;info,input,progressCallback",
    startDecode$1: function(data) {
      var t1;
      this.input = U.InputBuffer$(data, true, null, 0);
      t1 = new U.JpegData(null, null, null, null, null, null, Array(4), [], [], [], [], 0, 0).readInfo$1(data);
      this.info = t1;
      return t1;
    },
    decodeFrame$1: function(frame) {
      var t1, t2, jpeg, image;
      t1 = this.input;
      if (t1 == null)
        return;
      t2 = [];
      jpeg = new U.JpegData(null, null, null, null, null, null, Array(4), t2, [], [], [], 0, 0);
      jpeg.progressCallback = this.progressCallback;
      jpeg.read$1(t1.buffer);
      if (t2.length !== 1)
        throw H.wrapException(U.ImageException$("only single frame JPEGs supported"));
      t1 = jpeg.frame;
      image = U.Image$(t1.samplesPerLine, t1.scanLines, 3);
      this._copyToImage$2(jpeg, image);
      return image;
    },
    _copyToImage$2: function(jpeg, imageData) {
      var width, height, data, t1, t2, t3, i, j, y, x, i0, $Y, j0, t4, t5, t6, t7, $R, $G, $B, $C, $M, $K;
      width = imageData.width;
      height = imageData.height;
      data = jpeg.getData$2(width, height);
      switch (jpeg.components.length) {
        case 1:
          if (typeof height !== "number")
            return H.iae(height);
          t1 = data.length;
          t2 = imageData.data;
          t3 = t2.length;
          i = 0;
          j = 0;
          y = 0;
          for (; y < height; ++y) {
            if (typeof width !== "number")
              return H.iae(width);
            x = 0;
            for (; x < width; ++x, j = j0, i = i0) {
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(data, i);
              $Y = data[i];
              j0 = j + 1;
              t4 = C.JSInt_methods.clamp$2(255, 0, 255);
              t5 = C.JSInt_methods.clamp$2($Y, 0, 255);
              t6 = C.JSInt_methods.clamp$2($Y, 0, 255);
              t7 = C.JSInt_methods.clamp$2($Y, 0, 255);
              if (j < 0 || j >= t3)
                return H.ioore(t2, j);
              t2[j] = (t4 << 24 | t5 << 16 | t6 << 8 | t7) >>> 0;
            }
          }
          break;
        case 3:
          if (typeof height !== "number")
            return H.iae(height);
          t1 = data.length;
          t2 = imageData.data;
          t3 = t2.length;
          i = 0;
          j = 0;
          y = 0;
          for (; y < height; ++y) {
            if (typeof width !== "number")
              return H.iae(width);
            x = 0;
            for (; x < width; ++x, j = j0, i = i0) {
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(data, i);
              $R = data[i];
              i = i0 + 1;
              if (i0 < 0 || i0 >= t1)
                return H.ioore(data, i0);
              $G = data[i0];
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(data, i);
              $B = data[i];
              t4 = C.JSInt_methods.clamp$2(255, 0, 255);
              t5 = C.JSInt_methods.clamp$2($B, 0, 255);
              t6 = C.JSInt_methods.clamp$2($G, 0, 255);
              t7 = C.JSInt_methods.clamp$2($R, 0, 255);
              j0 = j + 1;
              if (j < 0 || j >= t3)
                return H.ioore(t2, j);
              t2[j] = (t4 << 24 | t5 << 16 | t6 << 8 | t7) >>> 0;
            }
          }
          break;
        case 4:
          if (typeof height !== "number")
            return H.iae(height);
          t1 = imageData.data;
          t2 = t1.length;
          t3 = data.length;
          i = 0;
          j = 0;
          y = 0;
          for (; y < height; ++y) {
            if (typeof width !== "number")
              return H.iae(width);
            x = 0;
            for (; x < width; ++x, j = j0) {
              i0 = i + 1;
              if (i < 0 || i >= t3)
                return H.ioore(data, i);
              $C = data[i];
              i = i0 + 1;
              if (i0 < 0 || i0 >= t3)
                return H.ioore(data, i0);
              $M = data[i0];
              i0 = i + 1;
              if (i < 0 || i >= t3)
                return H.ioore(data, i);
              $Y = data[i];
              i = i0 + 1;
              if (i0 < 0 || i0 >= t3)
                return H.ioore(data, i0);
              $K = data[i0];
              t4 = 1 - ($K / 255 | 0);
              t5 = $C * t4 + $K;
              if (t5 < 0)
                t5 = 0;
              else if (t5 > 255)
                t5 = 255;
              t6 = $M * t4 + $K;
              if (t6 < 0)
                t6 = 0;
              else if (t6 > 255)
                t6 = 255;
              t4 = $Y * t4 + $K;
              if (t4 < 0)
                t4 = 0;
              else if (t4 > 255)
                t4 = 255;
              j0 = j + 1;
              t7 = C.JSInt_methods.clamp$2(255, 0, 255);
              t4 = C.JSInt_methods.clamp$2(255 - t4, 0, 255);
              t6 = C.JSInt_methods.clamp$2(255 - t6, 0, 255);
              t5 = C.JSInt_methods.clamp$2(255 - t5, 0, 255);
              if (j < 0 || j >= t2)
                return H.ioore(t1, j);
              t1[j] = (t7 << 24 | t4 << 16 | t6 << 8 | t5) >>> 0;
            }
          }
          break;
        default:
          throw H.wrapException("Unsupported color mode");
      }
    }
  },
  PngFrame: {
    "^": "Object;sequenceNumber,width>,height>,xOffset,yOffset,delayNum,delayDen,dispose,blend,_fdat<",
    static: {"^": "PngFrame_APNG_DISPOSE_OP_NONE,PngFrame_APNG_DISPOSE_OP_BACKGROUND,PngFrame_APNG_DISPOSE_OP_PREVIOUS,PngFrame_APNG_BLEND_OP_SOURCE,PngFrame_APNG_BLEND_OP_OVER"}
  },
  PngInfo: {
    "^": "DecodeInfo;bits,colorType,compressionMethod,filterMethod,interlaceMethod,palette,transparency,colorLut,gamma,image$PngInfo$backgroundColor,numFrames,repeat,frames,_idat,width,height,backgroundColor",
    get$isAnimated: function() {
      return this.frames.length !== 0;
    },
    isAnimated$0: function() {
      return this.get$isAnimated().call$0();
    }
  },
  PngDecoder: {
    "^": "Decoder;info,_image$_bitBuffer,_image$_bitBufferLen,_input,_progressY,_frame,_numFrames,progressCallback",
    isValidFile$1: function(data) {
      var pngHeader, i;
      pngHeader = U.InputBuffer$(data, true, null, 0).readBytes$1(8);
      for (i = 0; i < 8; ++i)
        if (!J.$eq(J.$index$asx(pngHeader.buffer, J.$add$ns(pngHeader.offset, i)), C.List_2Vk[i]))
          return false;
      return true;
    },
    startDecode$1: function(data) {
      var t1, pngHeader, i, inputPos, chunkSize, chunkType, pos, t2, t3, t4, hdr, hdrBytes, t5, gammaInt, frame;
      t1 = U.InputBuffer$(data, true, null, 0);
      this._input = t1;
      pngHeader = t1.readBytes$1(8);
      for (i = 0; i < 8; ++i)
        if (!J.$eq(J.$index$asx(pngHeader.buffer, J.$add$ns(pngHeader.offset, i)), C.List_2Vk[i]))
          return;
      for (; true;) {
        t1 = this._input;
        inputPos = J.$sub$n(t1.offset, t1.start);
        chunkSize = this._input.readUint32$0();
        chunkType = this._input.readString$1(4);
        switch (chunkType) {
          case "IHDR":
            t1 = this._input;
            t1.toString;
            pos = J.$add$ns(t1.offset, 0);
            t2 = t1.buffer;
            t3 = t1.bigEndian;
            t4 = J.$add$ns(pos, chunkSize);
            t1.offset = J.$add$ns(t1.offset, J.$sub$n(t4, pos));
            hdr = U.InputBuffer$from(new U.InputBuffer(t2, pos, t4, pos, t3), null, 0);
            hdrBytes = hdr.toUint8List$0();
            t3 = new U.PngInfo(null, null, null, null, null, null, null, null, null, 16777215, 1, 0, [], [], 0, 0, 4294967295);
            this.info = t3;
            t3.width = hdr.readUint32$0();
            this.info.height = hdr.readUint32$0();
            t3 = this.info;
            t4 = hdr.buffer;
            t2 = hdr.offset;
            hdr.offset = J.$add$ns(t2, 1);
            t3.bits = J.$index$asx(t4, t2);
            t2 = this.info;
            t4 = hdr.buffer;
            t3 = hdr.offset;
            hdr.offset = J.$add$ns(t3, 1);
            t2.colorType = J.$index$asx(t4, t3);
            t3 = this.info;
            t4 = hdr.buffer;
            t2 = hdr.offset;
            hdr.offset = J.$add$ns(t2, 1);
            t3.compressionMethod = J.$index$asx(t4, t2);
            t2 = this.info;
            t4 = hdr.buffer;
            t3 = hdr.offset;
            hdr.offset = J.$add$ns(t3, 1);
            t2.filterMethod = J.$index$asx(t4, t3);
            t3 = this.info;
            t4 = hdr.buffer;
            t2 = hdr.offset;
            hdr.offset = J.$add$ns(t2, 1);
            t3.interlaceMethod = J.$index$asx(t4, t2);
            if (!C.JSArray_methods.contains$1([0, 2, 3, 4, 6], this.info.colorType))
              return;
            if (!J.$eq(this.info.filterMethod, 0))
              return;
            t1 = this.info;
            switch (t1.colorType) {
              case 0:
                if (!C.JSArray_methods.contains$1([1, 2, 4, 8, 16], t1.bits))
                  return;
                break;
              case 2:
                if (!C.JSArray_methods.contains$1([8, 16], t1.bits))
                  return;
                break;
              case 3:
                if (!C.JSArray_methods.contains$1([1, 2, 4, 8], t1.bits))
                  return;
                break;
              case 4:
                if (!C.JSArray_methods.contains$1([8, 16], t1.bits))
                  return;
                break;
              case 6:
                if (!C.JSArray_methods.contains$1([8, 16], t1.bits))
                  return;
                break;
            }
            if (this._input.readUint32$0() !== T.getCrc32(hdrBytes, T.getCrc32(new J._CodeUnits(chunkType), 0)))
              throw H.wrapException(U.ImageException$("Invalid " + chunkType + " checksum"));
            break;
          case "PLTE":
            t1 = this.info;
            t2 = this._input;
            t2.toString;
            pos = J.$add$ns(t2.offset, 0);
            t3 = t2.buffer;
            t4 = t2.bigEndian;
            t5 = J.$add$ns(pos, chunkSize);
            t2.offset = J.$add$ns(t2.offset, J.$sub$n(t5, pos));
            t1.palette = new U.InputBuffer(t3, pos, t5, pos, t4).toUint8List$0();
            if (this._input.readUint32$0() !== T.getCrc32(this.info.palette, T.getCrc32(new J._CodeUnits(chunkType), 0)))
              throw H.wrapException(U.ImageException$("Invalid " + chunkType + " checksum"));
            break;
          case "tRNS":
            t1 = this.info;
            t2 = this._input;
            t2.toString;
            pos = J.$add$ns(t2.offset, 0);
            t3 = t2.buffer;
            t4 = t2.bigEndian;
            t5 = J.$add$ns(pos, chunkSize);
            t2.offset = J.$add$ns(t2.offset, J.$sub$n(t5, pos));
            t1.transparency = new U.InputBuffer(t3, pos, t5, pos, t4).toUint8List$0();
            if (this._input.readUint32$0() !== T.getCrc32(this.info.transparency, T.getCrc32(new J._CodeUnits(chunkType), 0)))
              throw H.wrapException(U.ImageException$("Invalid " + chunkType + " checksum"));
            break;
          case "IEND":
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, 4);
            break;
          case "gAMA":
            if (chunkSize !== 4)
              throw H.wrapException(U.ImageException$("Invalid gAMA chunk"));
            gammaInt = this._input.readUint32$0();
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, 4);
            if (gammaInt !== 100000)
              this.info.gamma = gammaInt / 100000;
            break;
          case "IDAT":
            this.info._idat.push(inputPos);
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, chunkSize);
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, 4);
            break;
          case "acTL":
            this.info.numFrames = this._input.readUint32$0();
            this.info.repeat = this._input.readUint32$0();
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, 4);
            break;
          case "fcTL":
            frame = new U.PngFrame(null, null, null, null, null, null, null, null, null, []);
            this.info.frames.push(frame);
            frame.sequenceNumber = this._input.readUint32$0();
            frame.width = this._input.readUint32$0();
            frame.height = this._input.readUint32$0();
            frame.xOffset = this._input.readUint32$0();
            frame.yOffset = this._input.readUint32$0();
            frame.delayNum = this._input.readUint16$0();
            frame.delayDen = this._input.readUint16$0();
            t1 = this._input;
            t2 = t1.buffer;
            t3 = t1.offset;
            t1.offset = J.$add$ns(t3, 1);
            frame.dispose = J.$index$asx(t2, t3);
            t3 = this._input;
            t2 = t3.buffer;
            t1 = t3.offset;
            t3.offset = J.$add$ns(t1, 1);
            frame.blend = J.$index$asx(t2, t1);
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, 4);
            break;
          case "fdAT":
            this._input.readUint32$0();
            C.JSArray_methods.get$last(this.info.frames).get$_fdat().push(inputPos);
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, chunkSize - 4);
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, 4);
            break;
          case "bKGD":
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, chunkSize);
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, 4);
            break;
          default:
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, chunkSize);
            t1 = this._input;
            t1.offset = J.$add$ns(t1.offset, 4);
            break;
        }
        if (chunkType === "IEND")
          break;
        t1 = this._input;
        if (J.$ge$n(t1.offset, t1.end))
          return;
      }
      return this.info;
    },
    decodeFrame$1: function(frame) {
      var t1, imageData, width, height, t2, t3, len, i, chunkSize, chunkType, pos, t4, data, f, t5, t6, image, input, c, origW, origH;
      t1 = this.info;
      if (t1 == null)
        return;
      imageData = [];
      width = t1.width;
      height = t1.height;
      t2 = t1.frames;
      t3 = t2.length;
      if (t3 === 0 || frame === 0)
        for (len = t1._idat.length, i = 0; i < len; ++i) {
          t1 = this._input;
          t2 = this.info._idat;
          if (i >= t2.length)
            return H.ioore(t2, i);
          t1.offset = t2[i];
          chunkSize = t1.readUint32$0();
          chunkType = this._input.readString$1(4);
          t1 = this._input;
          t1.toString;
          pos = J.$add$ns(t1.offset, 0);
          t2 = t1.buffer;
          t3 = t1.bigEndian;
          t4 = J.$add$ns(pos, chunkSize);
          t1.offset = J.$add$ns(t1.offset, J.$sub$n(t4, pos));
          data = new U.InputBuffer(t2, pos, t4, pos, t3).toUint8List$0();
          C.JSArray_methods.addAll$1(imageData, data);
          if (this._input.readUint32$0() !== T.getCrc32(data, T.getCrc32(new J._CodeUnits(chunkType), 0)))
            throw H.wrapException(U.ImageException$("Invalid " + chunkType + " checksum"));
        }
      else {
        if (frame >= t3)
          throw H.wrapException(U.ImageException$("Invalid Frame Number: " + frame));
        if (frame >= t3)
          return H.ioore(t2, frame);
        f = t2[frame];
        t1 = J.getInterceptor$x(f);
        width = t1.get$width(f);
        height = t1.get$height(f);
        for (t1 = f.get$_fdat(), t2 = f._fdat, i = 0; i < t1.length; ++i) {
          t3 = this._input;
          if (i >= t2.length)
            return H.ioore(t2, i);
          t3.offset = t2[i];
          chunkSize = t3.readUint32$0();
          this._input.readString$1(4);
          t3 = this._input;
          t3.offset = J.$add$ns(t3.offset, 4);
          t3 = this._input;
          t3.toString;
          pos = J.$add$ns(t3.offset, 0);
          t4 = t3.buffer;
          t5 = t3.bigEndian;
          t6 = J.$add$ns(pos, chunkSize);
          t3.offset = J.$add$ns(t3.offset, J.$sub$n(t6, pos));
          C.JSArray_methods.addAll$1(imageData, new U.InputBuffer(t4, pos, t6, pos, t5).toUint8List$0());
        }
        this._frame = frame;
        this._numFrames = this.info.numFrames;
      }
      image = U.Image$(width, height, J.$eq(this.info.colorType, 4) || J.$eq(this.info.colorType, 6) || this.info.transparency != null ? 4 : 3);
      input = U.InputBuffer$(new T.ZLibDecoder().decodeBuffer$2$verify(T.InputStream$(imageData, 1, null, 0), true), true, null, 0);
      this._image$_bitBuffer = 0;
      this._image$_bitBufferLen = 0;
      t1 = this.info;
      if (t1.colorLut == null) {
        t1.colorLut = H.setRuntimeTypeInfo(Array(256), [J.JSInt]);
        for (i = 0; i < 256; ++i) {
          t1 = this.info.gamma;
          if (t1 != null) {
            if (typeof t1 !== "number")
              H.throwExpression(P.ArgumentError$(t1));
            c = C.JSNumber_methods.toInt$0(Math.pow(i / 255, t1) * 255);
          } else
            c = i;
          this.info.colorLut[i] = c;
        }
        t1 = this.info;
        t2 = t1.palette;
        if (t2 != null && t1.gamma != null)
          for (t3 = t2.length, i = 0; i < t3; ++i) {
            t4 = t1.colorLut;
            t5 = t2[i];
            t4.length;
            if (t5 >= 256)
              return H.ioore(t4, t5);
            t2[i] = t4[t5];
          }
      }
      t1 = this.info;
      origW = t1.width;
      origH = t1.height;
      t1.width = width;
      t1.height = height;
      this._progressY = 0;
      if (!J.$eq(t1.interlaceMethod, 0)) {
        t1 = J.getInterceptor$ns(width);
        t2 = t1.$add(width, 7);
        if (typeof t2 !== "number")
          return t2.$shr();
        t2 = C.JSNumber_methods._shrOtherPositive$1(t2, 3);
        t3 = J.getInterceptor$ns(height);
        t4 = t3.$add(height, 7);
        if (typeof t4 !== "number")
          return t4.$shr();
        this._processPass$8(input, image, 0, 0, 8, 8, t2, C.JSNumber_methods._shrOtherPositive$1(t4, 3));
        t4 = t1.$add(width, 3);
        if (typeof t4 !== "number")
          return t4.$shr();
        t4 = C.JSNumber_methods._shrOtherPositive$1(t4, 3);
        t2 = t3.$add(height, 7);
        if (typeof t2 !== "number")
          return t2.$shr();
        this._processPass$8(input, image, 4, 0, 8, 8, t4, C.JSNumber_methods._shrOtherPositive$1(t2, 3));
        t2 = t1.$add(width, 3);
        if (typeof t2 !== "number")
          return t2.$shr();
        t2 = C.JSNumber_methods._shrOtherPositive$1(t2, 2);
        t4 = t3.$add(height, 3);
        if (typeof t4 !== "number")
          return t4.$shr();
        this._processPass$8(input, image, 0, 4, 4, 8, t2, C.JSNumber_methods._shrOtherPositive$1(t4, 3));
        t4 = t1.$add(width, 1);
        if (typeof t4 !== "number")
          return t4.$shr();
        t4 = C.JSNumber_methods._shrOtherPositive$1(t4, 2);
        t2 = t3.$add(height, 3);
        if (typeof t2 !== "number")
          return t2.$shr();
        this._processPass$8(input, image, 2, 0, 4, 4, t4, C.JSNumber_methods._shrOtherPositive$1(t2, 2));
        t1 = t1.$add(width, 1);
        if (typeof t1 !== "number")
          return t1.$shr();
        t1 = C.JSNumber_methods._shrOtherPositive$1(t1, 1);
        t2 = t3.$add(height, 1);
        if (typeof t2 !== "number")
          return t2.$shr();
        this._processPass$8(input, image, 0, 2, 2, 4, t1, C.JSNumber_methods._shrOtherPositive$1(t2, 2));
        if (typeof width !== "number")
          return width.$shr();
        t2 = C.JSNumber_methods._shrOtherPositive$1(width, 1);
        t3 = t3.$add(height, 1);
        if (typeof t3 !== "number")
          return t3.$shr();
        this._processPass$8(input, image, 1, 0, 2, 2, t2, C.JSNumber_methods._shrOtherPositive$1(t3, 1));
        if (typeof height !== "number")
          return height.$shr();
        this._processPass$8(input, image, 0, 1, 1, 2, width, C.JSNumber_methods._shrOtherPositive$1(height, 1));
      } else
        this._process$2(input, image);
      t1 = this.info;
      t1.width = origW;
      t1.height = origH;
      return image;
    },
    _processPass$8: function(input, image, xOffset, yOffset, xStep, yStep, passWidth, passHeight) {
      var channels, t1, pixelDepth, bpp, rowBytes, line, inData, pixel, t2, t3, t4, t5, blockWidth, dstY, srcY, ri, t6, t7, filterType, pos, t8, rowInput, dstX, srcX, c, i, j, t9;
      if (J.$eq(this.info.colorType, 4))
        channels = 2;
      else if (J.$eq(this.info.colorType, 2))
        channels = 3;
      else {
        t1 = J.$eq(this.info.colorType, 6) ? 4 : 1;
        channels = t1;
      }
      t1 = this.info.bits;
      if (typeof t1 !== "number")
        return H.iae(t1);
      pixelDepth = channels * t1;
      bpp = C.JSNumber_methods._shrOtherPositive$1(pixelDepth + 7, 3);
      rowBytes = C.JSNumber_methods._shrOtherPositive$1(pixelDepth * passWidth + 7, 3);
      line = P.List_List$filled(rowBytes, 0, J.JSInt);
      inData = [line, line];
      pixel = [0, 0, 0, 0];
      t1 = image.width;
      t2 = image.height;
      t3 = image.data;
      t4 = t3.length;
      t5 = xStep > 1;
      blockWidth = xStep - xOffset;
      dstY = yOffset;
      srcY = 0;
      ri = 0;
      while (srcY < passHeight) {
        t6 = input.buffer;
        t7 = input.offset;
        input.offset = J.$add$ns(t7, 1);
        filterType = J.$index$asx(t6, t7);
        pos = J.$add$ns(input.offset, 0);
        t6 = input.buffer;
        t7 = input.bigEndian;
        t8 = J.$add$ns(pos, rowBytes);
        input.offset = J.$add$ns(input.offset, J.$sub$n(t8, pos));
        t7 = new U.InputBuffer(t6, pos, t8, pos, t7).toUint8List$0();
        if (ri < 0 || ri >= 2)
          return H.ioore(inData, ri);
        inData[ri] = t7;
        ri = 1 - ri;
        this._unfilter$4(filterType, bpp, t7, inData[ri]);
        this._image$_bitBuffer = 0;
        this._image$_bitBufferLen = 0;
        t6 = t7.length;
        rowInput = new U.InputBuffer(t7, 0, t6, 0, true);
        P.min(dstY + xStep, this.info.height);
        for (t6 = blockWidth <= 1, dstX = xOffset, srcX = 0; srcX < passWidth; ++srcX, dstX += xStep) {
          this._readPixel$2(rowInput, pixel);
          c = this._getColor$1(pixel);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (dstX < t1) {
            if (typeof t2 !== "number")
              return H.iae(t2);
            t7 = dstY < t2;
          } else
            t7 = false;
          if (t7) {
            if (typeof t1 !== "number")
              return H.iae(t1);
            t7 = dstY * t1 + dstX;
            if (t7 >>> 0 !== t7 || t7 >= t4)
              return H.ioore(t3, t7);
            t3[t7] = c;
          }
          if (!t6 || t5) {
            P.min(dstX + blockWidth, this.info.width);
            for (i = 0; i < xStep; ++i)
              for (j = 0; j < blockWidth; ++j) {
                t7 = dstX + j;
                t8 = dstY + j;
                if (typeof t1 !== "number")
                  return H.iae(t1);
                if (t7 < t1) {
                  if (typeof t2 !== "number")
                    return H.iae(t2);
                  t9 = t8 < t2;
                } else
                  t9 = false;
                if (t9) {
                  if (typeof t1 !== "number")
                    return H.iae(t1);
                  t7 = t8 * t1 + t7;
                  if (t7 >>> 0 !== t7 || t7 >= t4)
                    return H.ioore(t3, t7);
                  t3[t7] = c;
                }
              }
          }
        }
        ++srcY;
        dstY += yStep;
        t6 = this._progressY;
        if (typeof t6 !== "number")
          return t6.$add();
        this._progressY = t6 + 1;
      }
    },
    _process$2: function(input, image) {
      var channels, t1, t2, pixelDepth, w, h, bpp, line, inData, pixel, t3, y, pi, ri, t4, t5, filterType, pos, t6, ri0, rowInput, x, pi0;
      if (J.$eq(this.info.colorType, 4))
        channels = 2;
      else if (J.$eq(this.info.colorType, 2))
        channels = 3;
      else {
        t1 = J.$eq(this.info.colorType, 6) ? 4 : 1;
        channels = t1;
      }
      t1 = this.info;
      t2 = t1.bits;
      if (typeof t2 !== "number")
        return H.iae(t2);
      pixelDepth = channels * t2;
      w = t1.width;
      h = t1.height;
      t1 = J.$add$ns(J.$mul$ns(w, pixelDepth), 7);
      if (typeof t1 !== "number")
        return t1.$shr();
      t1 = C.JSNumber_methods._shrOtherPositive$1(t1, 3);
      bpp = C.JSNumber_methods._shrOtherPositive$1(pixelDepth + 7, 3);
      line = P.List_List$filled(t1, 0, J.JSInt);
      inData = [line, line];
      pixel = [0, 0, 0, 0];
      if (typeof h !== "number")
        return H.iae(h);
      t2 = image.data;
      t3 = t2.length;
      y = 0;
      pi = 0;
      ri = 0;
      for (; y < h; ++y, ri = ri0) {
        t4 = input.buffer;
        t5 = input.offset;
        input.offset = J.$add$ns(t5, 1);
        filterType = J.$index$asx(t4, t5);
        pos = J.$add$ns(input.offset, 0);
        t4 = input.buffer;
        t5 = input.bigEndian;
        t6 = J.$add$ns(pos, t1);
        input.offset = J.$add$ns(input.offset, J.$sub$n(t6, pos));
        t5 = new U.InputBuffer(t4, pos, t6, pos, t5).toUint8List$0();
        if (ri < 0 || ri >= 2)
          return H.ioore(inData, ri);
        inData[ri] = t5;
        ri0 = 1 - ri;
        this._unfilter$4(filterType, bpp, t5, inData[ri0]);
        this._image$_bitBuffer = 0;
        this._image$_bitBufferLen = 0;
        t5 = inData[ri];
        t4 = J.get$length$asx(t5);
        rowInput = new U.InputBuffer(t5, 0, t4, 0, true);
        if (typeof w !== "number")
          return H.iae(w);
        x = 0;
        for (; x < w; ++x, pi = pi0) {
          this._readPixel$2(rowInput, pixel);
          pi0 = pi + 1;
          t4 = this._getColor$1(pixel);
          if (pi < 0 || pi >= t3)
            return H.ioore(t2, pi);
          t2[pi] = t4;
        }
      }
    },
    _unfilter$4: function(filterType, bpp, row, prevRow) {
      var t1, rowBytes, x, t2, a, b, t3, t4, c, p, pa, pb, pc, paeth;
      t1 = J.getInterceptor$asx(row);
      rowBytes = t1.get$length(row);
      switch (filterType) {
        case 0:
          break;
        case 1:
          if (typeof rowBytes !== "number")
            return H.iae(rowBytes);
          x = bpp;
          for (; x < rowBytes; ++x)
            t1.$indexSet(row, x, J.$and$n(J.$add$ns(t1.$index(row, x), t1.$index(row, x - bpp)), 255));
          break;
        case 2:
          if (typeof rowBytes !== "number")
            return H.iae(rowBytes);
          t2 = J.getInterceptor$asx(prevRow);
          x = 0;
          for (; x < rowBytes; ++x)
            t1.$indexSet(row, x, J.$and$n(J.$add$ns(t1.$index(row, x), t2.$index(prevRow, x)), 255));
          break;
        case 3:
          if (typeof rowBytes !== "number")
            return H.iae(rowBytes);
          t2 = J.getInterceptor$asx(prevRow);
          x = 0;
          for (; x < rowBytes; ++x) {
            a = x < bpp ? 0 : t1.$index(row, x - bpp);
            b = t2.$index(prevRow, x);
            t3 = t1.$index(row, x);
            t4 = J.$add$ns(a, b);
            if (typeof t4 !== "number")
              return t4.$shr();
            t1.$indexSet(row, x, J.$and$n(J.$add$ns(t3, C.JSNumber_methods._shrOtherPositive$1(t4, 1)), 255));
          }
          break;
        case 4:
          if (typeof rowBytes !== "number")
            return H.iae(rowBytes);
          t2 = J.getInterceptor$asx(prevRow);
          x = 0;
          for (; x < rowBytes; ++x) {
            t3 = x < bpp;
            a = t3 ? 0 : t1.$index(row, x - bpp);
            b = t2.$index(prevRow, x);
            c = t3 ? 0 : t2.$index(prevRow, x - bpp);
            p = J.$sub$n(J.$add$ns(a, b), c);
            t3 = J.getInterceptor$n(p);
            pa = J.abs$0$n(t3.$sub(p, a));
            pb = J.abs$0$n(t3.$sub(p, b));
            pc = J.abs$0$n(t3.$sub(p, c));
            if (pa <= pb && pa <= pc)
              paeth = a;
            else
              paeth = pb <= pc ? b : c;
            t1.$indexSet(row, x, J.$and$n(J.$add$ns(t1.$index(row, x), paeth), 255));
          }
          break;
        default:
          throw H.wrapException(U.ImageException$("Invalid filter value: " + H.S(filterType)));
      }
    },
    _image$_readBits$2: function(input, numBits) {
      var t1, t2, t3, octet, mask;
      t1 = J.getInterceptor(numBits);
      if (t1.$eq(numBits, 0))
        return 0;
      if (t1.$eq(numBits, 8)) {
        t1 = input.buffer;
        t2 = input.offset;
        input.offset = J.$add$ns(t2, 1);
        return J.$index$asx(t1, t2);
      }
      if (t1.$eq(numBits, 16))
        return input.readUint16$0();
      if (typeof numBits !== "number")
        return H.iae(numBits);
      t1 = input.end;
      for (; t2 = this._image$_bitBufferLen, t2 < numBits;) {
        if (J.$ge$n(input.offset, t1))
          throw H.wrapException(U.ImageException$("Invalid PNG data."));
        t2 = input.buffer;
        t3 = input.offset;
        input.offset = J.$add$ns(t3, 1);
        octet = J.$index$asx(t2, t3);
        t3 = this._image$_bitBufferLen;
        if (typeof octet !== "number")
          return octet.$shl();
        this._image$_bitBuffer = C.JSNumber_methods.$shl(octet, t3);
        this._image$_bitBufferLen = t3 + 8;
      }
      if (numBits === 1)
        mask = 1;
      else if (numBits === 2)
        mask = 3;
      else {
        if (numBits === 4)
          t1 = 15;
        else if (numBits === 8)
          t1 = 255;
        else
          t1 = numBits === 16 ? 65535 : 0;
        mask = t1;
      }
      t1 = t2 - numBits;
      t2 = C.JSInt_methods._shrReceiverPositive$1(this._image$_bitBuffer, t1);
      this._image$_bitBufferLen = t1;
      return t2 & mask;
    },
    _readPixel$2: function(input, pixel) {
      var t1, t2;
      t1 = this.info;
      t2 = t1.colorType;
      switch (t2) {
        case 0:
          pixel[0] = this._image$_readBits$2(input, t1.bits);
          return;
        case 2:
          pixel[0] = this._image$_readBits$2(input, t1.bits);
          pixel[1] = this._image$_readBits$2(input, this.info.bits);
          pixel[2] = this._image$_readBits$2(input, this.info.bits);
          return;
        case 3:
          pixel[0] = this._image$_readBits$2(input, t1.bits);
          return;
        case 4:
          pixel[0] = this._image$_readBits$2(input, t1.bits);
          pixel[1] = this._image$_readBits$2(input, this.info.bits);
          return;
        case 6:
          pixel[0] = this._image$_readBits$2(input, t1.bits);
          pixel[1] = this._image$_readBits$2(input, this.info.bits);
          pixel[2] = this._image$_readBits$2(input, this.info.bits);
          pixel[3] = this._image$_readBits$2(input, this.info.bits);
          return;
      }
      throw H.wrapException(U.ImageException$("Invalid color type: " + H.S(t2) + "."));
    },
    _getColor$1: function(raw) {
      var t1, t2, g, t3, t4, r, b, t5, t6, t7, p, a;
      t1 = this.info;
      t2 = t1.colorType;
      switch (t2) {
        case 0:
          switch (t1.bits) {
            case 1:
              g = J.$eq(raw[0], 0) ? 0 : 255;
              break;
            case 2:
              g = J.$mul$ns(raw[0], 85);
              break;
            case 4:
              t1 = raw[0];
              if (typeof t1 !== "number")
                return t1.$shl();
              g = t1 << 4 >>> 0;
              break;
            case 8:
              g = raw[0];
              break;
            case 16:
              t1 = raw[0];
              if (typeof t1 !== "number")
                return t1.$shr();
              g = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              break;
            default:
              g = null;
          }
          t1 = this.info;
          t2 = t1.colorLut;
          t2.length;
          if (g >>> 0 !== g || g >= 256)
            return H.ioore(t2, g);
          g = t2[g];
          t1 = t1.transparency;
          if (t1 != null) {
            t2 = t1.length;
            if (0 >= t2)
              return H.ioore(t1, 0);
            t3 = t1[0];
            if (1 >= t2)
              return H.ioore(t1, 1);
            t1 = t1[1];
            if (J.$eq(raw[0], ((t3 & 255) << 24 | t1 & 255) >>> 0)) {
              t1 = C.JSInt_methods.clamp$2(0, 0, 255);
              t2 = J.getInterceptor$n(g);
              t3 = t2.clamp$2(g, 0, 255);
              if (typeof t3 !== "number")
                return t3.$shl();
              t4 = t2.clamp$2(g, 0, 255);
              if (typeof t4 !== "number")
                return t4.$shl();
              t2 = t2.clamp$2(g, 0, 255);
              if (typeof t2 !== "number")
                return H.iae(t2);
              return (t1 << 24 | t3 << 16 | t4 << 8 | t2) >>> 0;
            }
          }
          t1 = C.JSInt_methods.clamp$2(255, 0, 255);
          t2 = J.getInterceptor$n(g);
          t3 = t2.clamp$2(g, 0, 255);
          if (typeof t3 !== "number")
            return t3.$shl();
          t4 = t2.clamp$2(g, 0, 255);
          if (typeof t4 !== "number")
            return t4.$shl();
          t2 = t2.clamp$2(g, 0, 255);
          if (typeof t2 !== "number")
            return H.iae(t2);
          return (t1 << 24 | t3 << 16 | t4 << 8 | t2) >>> 0;
        case 2:
          switch (t1.bits) {
            case 1:
              r = J.$eq(raw[0], 0) ? 0 : 255;
              g = J.$eq(raw[1], 0) ? 0 : 255;
              b = J.$eq(raw[2], 0) ? 0 : 255;
              break;
            case 2:
              r = J.$mul$ns(raw[0], 85);
              g = J.$mul$ns(raw[1], 85);
              b = J.$mul$ns(raw[2], 85);
              break;
            case 4:
              t1 = raw[0];
              if (typeof t1 !== "number")
                return t1.$shl();
              r = t1 << 4 >>> 0;
              t1 = raw[1];
              if (typeof t1 !== "number")
                return t1.$shl();
              g = t1 << 4 >>> 0;
              t1 = raw[2];
              if (typeof t1 !== "number")
                return t1.$shl();
              b = t1 << 4 >>> 0;
              break;
            case 8:
              r = raw[0];
              g = raw[1];
              b = raw[2];
              break;
            case 16:
              t1 = raw[0];
              if (typeof t1 !== "number")
                return t1.$shr();
              r = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              t1 = raw[1];
              if (typeof t1 !== "number")
                return t1.$shr();
              g = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              t1 = raw[2];
              if (typeof t1 !== "number")
                return t1.$shr();
              b = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              break;
            default:
              r = null;
              g = null;
              b = null;
          }
          t1 = this.info;
          t2 = t1.colorLut;
          t2.length;
          if (r >>> 0 !== r || r >= 256)
            return H.ioore(t2, r);
          r = t2[r];
          if (g >>> 0 !== g || g >= 256)
            return H.ioore(t2, g);
          g = t2[g];
          if (b >>> 0 !== b || b >= 256)
            return H.ioore(t2, b);
          b = t2[b];
          t1 = t1.transparency;
          if (t1 != null) {
            t2 = t1.length;
            if (0 >= t2)
              return H.ioore(t1, 0);
            t3 = t1[0];
            if (1 >= t2)
              return H.ioore(t1, 1);
            t4 = t1[1];
            if (2 >= t2)
              return H.ioore(t1, 2);
            t5 = t1[2];
            if (3 >= t2)
              return H.ioore(t1, 3);
            t6 = t1[3];
            if (4 >= t2)
              return H.ioore(t1, 4);
            t7 = t1[4];
            if (5 >= t2)
              return H.ioore(t1, 5);
            t1 = t1[5];
            if (J.$eq(raw[0], ((t3 & 255) << 8 | t4 & 255) >>> 0) && J.$eq(raw[1], ((t5 & 255) << 8 | t6 & 255) >>> 0) && J.$eq(raw[2], ((t7 & 255) << 8 | t1 & 255) >>> 0)) {
              t1 = C.JSInt_methods.clamp$2(0, 0, 255);
              t2 = J.clamp$2$n(b, 0, 255);
              if (typeof t2 !== "number")
                return t2.$shl();
              t3 = J.clamp$2$n(g, 0, 255);
              if (typeof t3 !== "number")
                return t3.$shl();
              t4 = J.clamp$2$n(r, 0, 255);
              if (typeof t4 !== "number")
                return H.iae(t4);
              return (t1 << 24 | t2 << 16 | t3 << 8 | t4) >>> 0;
            }
          }
          t1 = C.JSInt_methods.clamp$2(255, 0, 255);
          t2 = J.clamp$2$n(b, 0, 255);
          if (typeof t2 !== "number")
            return t2.$shl();
          t3 = J.clamp$2$n(g, 0, 255);
          if (typeof t3 !== "number")
            return t3.$shl();
          t4 = J.clamp$2$n(r, 0, 255);
          if (typeof t4 !== "number")
            return H.iae(t4);
          return (t1 << 24 | t2 << 16 | t3 << 8 | t4) >>> 0;
        case 3:
          p = J.$mul$ns(raw[0], 3);
          t1 = this.info.transparency;
          if (t1 != null && J.$lt$n(raw[0], t1.length)) {
            t1 = this.info.transparency;
            t2 = raw[0];
            if (t2 >>> 0 !== t2 || t2 >= t1.length)
              return H.ioore(t1, t2);
            a = t1[t2];
          } else
            a = 255;
          if (J.$ge$n(p, this.info.palette.length))
            return (C.JSInt_methods.clamp$2(a, 0, 255) << 24 | C.JSInt_methods.clamp$2(255, 0, 255) << 16 | C.JSInt_methods.clamp$2(255, 0, 255) << 8 | C.JSInt_methods.clamp$2(255, 0, 255)) >>> 0;
          t1 = this.info;
          t2 = t1.colorLut;
          t1 = t1.palette;
          t3 = t1.length;
          if (p >>> 0 !== p || p >= t3)
            return H.ioore(t1, p);
          t4 = t1[p];
          t2.length;
          if (t4 >= 256)
            return H.ioore(t2, t4);
          r = t2[t4];
          t4 = p + 1;
          if (t4 >= t3)
            return H.ioore(t1, t4);
          t4 = t1[t4];
          if (t4 >= 256)
            return H.ioore(t2, t4);
          g = t2[t4];
          t4 = p + 2;
          if (t4 >= t3)
            return H.ioore(t1, t4);
          t4 = t1[t4];
          if (t4 >= 256)
            return H.ioore(t2, t4);
          b = t2[t4];
          t4 = C.JSInt_methods.clamp$2(a, 0, 255);
          t2 = J.clamp$2$n(b, 0, 255);
          if (typeof t2 !== "number")
            return t2.$shl();
          t1 = J.clamp$2$n(g, 0, 255);
          if (typeof t1 !== "number")
            return t1.$shl();
          t3 = J.clamp$2$n(r, 0, 255);
          if (typeof t3 !== "number")
            return H.iae(t3);
          return (t4 << 24 | t2 << 16 | t1 << 8 | t3) >>> 0;
        case 4:
          switch (t1.bits) {
            case 1:
              g = J.$eq(raw[0], 0) ? 0 : 255;
              a = J.$eq(raw[1], 0) ? 0 : 255;
              break;
            case 2:
              g = J.$mul$ns(raw[0], 85);
              a = J.$mul$ns(raw[1], 85);
              break;
            case 4:
              t1 = raw[0];
              if (typeof t1 !== "number")
                return t1.$shl();
              g = t1 << 4 >>> 0;
              t1 = raw[1];
              if (typeof t1 !== "number")
                return t1.$shl();
              a = t1 << 4 >>> 0;
              break;
            case 8:
              g = raw[0];
              a = raw[1];
              break;
            case 16:
              t1 = raw[0];
              if (typeof t1 !== "number")
                return t1.$shr();
              g = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              t1 = raw[1];
              if (typeof t1 !== "number")
                return t1.$shr();
              a = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              break;
            default:
              g = null;
              a = null;
          }
          t1 = this.info.colorLut;
          t1.length;
          if (g >>> 0 !== g || g >= 256)
            return H.ioore(t1, g);
          g = t1[g];
          if (a >>> 0 !== a || a >= 256)
            return H.ioore(t1, a);
          t1 = J.clamp$2$n(t1[a], 0, 255);
          if (typeof t1 !== "number")
            return t1.$shl();
          t2 = J.getInterceptor$n(g);
          t3 = t2.clamp$2(g, 0, 255);
          if (typeof t3 !== "number")
            return t3.$shl();
          t4 = t2.clamp$2(g, 0, 255);
          if (typeof t4 !== "number")
            return t4.$shl();
          t2 = t2.clamp$2(g, 0, 255);
          if (typeof t2 !== "number")
            return H.iae(t2);
          return (t1 << 24 | t3 << 16 | t4 << 8 | t2) >>> 0;
        case 6:
          switch (t1.bits) {
            case 1:
              r = J.$eq(raw[0], 0) ? 0 : 255;
              g = J.$eq(raw[1], 0) ? 0 : 255;
              b = J.$eq(raw[2], 0) ? 0 : 255;
              a = J.$eq(raw[3], 0) ? 0 : 255;
              break;
            case 2:
              r = J.$mul$ns(raw[0], 85);
              g = J.$mul$ns(raw[1], 85);
              b = J.$mul$ns(raw[2], 85);
              a = J.$mul$ns(raw[3], 85);
              break;
            case 4:
              t1 = raw[0];
              if (typeof t1 !== "number")
                return t1.$shl();
              r = t1 << 4 >>> 0;
              t1 = raw[1];
              if (typeof t1 !== "number")
                return t1.$shl();
              g = t1 << 4 >>> 0;
              t1 = raw[2];
              if (typeof t1 !== "number")
                return t1.$shl();
              b = t1 << 4 >>> 0;
              t1 = raw[3];
              if (typeof t1 !== "number")
                return t1.$shl();
              a = t1 << 4 >>> 0;
              break;
            case 8:
              r = raw[0];
              g = raw[1];
              b = raw[2];
              a = raw[3];
              break;
            case 16:
              t1 = raw[0];
              if (typeof t1 !== "number")
                return t1.$shr();
              r = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              t1 = raw[1];
              if (typeof t1 !== "number")
                return t1.$shr();
              g = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              t1 = raw[2];
              if (typeof t1 !== "number")
                return t1.$shr();
              b = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              t1 = raw[3];
              if (typeof t1 !== "number")
                return t1.$shr();
              a = C.JSNumber_methods._shrOtherPositive$1(t1, 8);
              break;
            default:
              r = null;
              g = null;
              b = null;
              a = null;
          }
          t1 = this.info.colorLut;
          t1.length;
          if (r >>> 0 !== r || r >= 256)
            return H.ioore(t1, r);
          r = t1[r];
          if (g >>> 0 !== g || g >= 256)
            return H.ioore(t1, g);
          g = t1[g];
          if (b >>> 0 !== b || b >= 256)
            return H.ioore(t1, b);
          b = t1[b];
          if (a >>> 0 !== a || a >= 256)
            return H.ioore(t1, a);
          t1 = J.clamp$2$n(t1[a], 0, 255);
          if (typeof t1 !== "number")
            return t1.$shl();
          t2 = J.clamp$2$n(b, 0, 255);
          if (typeof t2 !== "number")
            return t2.$shl();
          t3 = J.clamp$2$n(g, 0, 255);
          if (typeof t3 !== "number")
            return t3.$shl();
          t4 = J.clamp$2$n(r, 0, 255);
          if (typeof t4 !== "number")
            return H.iae(t4);
          return (t1 << 24 | t2 << 16 | t3 << 8 | t4) >>> 0;
      }
      throw H.wrapException(U.ImageException$("Invalid color type: " + H.S(t2) + "."));
    },
    static: {"^": "PngDecoder_GRAYSCALE,PngDecoder_RGB,PngDecoder_INDEXED,PngDecoder_GRAYSCALE_ALPHA,PngDecoder_RGBA,PngDecoder_FILTER_NONE,PngDecoder_FILTER_SUB,PngDecoder_FILTER_UP,PngDecoder_FILTER_AVERAGE,PngDecoder_FILTER_PAETH"}
  },
  PsdLayerAdditionalData: {
    "^": "PsdLayerData;data>,tag"
  },
  PsdLayerSectionDivider: {
    "^": "PsdLayerData;type>,key,subType,tag",
    PsdLayerSectionDivider$2: function(tag, data) {
      var len, t1;
      len = J.$sub$n(data.end, data.offset);
      this.type = data.readUint32$0();
      t1 = J.getInterceptor$n(len);
      if (t1.$ge(len, 12)) {
        if (data.readString$1(4) !== "8BIM")
          throw H.wrapException(U.ImageException$("Invalid key in layer additional data"));
        this.key = data.readString$1(4);
      }
      if (t1.$ge(len, 16))
        this.subType = data.readUint32$0();
    },
    static: {"^": "PsdLayerSectionDivider_TAG,PsdLayerSectionDivider_NORMAL,PsdLayerSectionDivider_OPEN_FOLDER,PsdLayerSectionDivider_CLOSED_FOLDER,PsdLayerSectionDivider_SECTION_DIVIDER,PsdLayerSectionDivider_SUBTYPE_NORMAL,PsdLayerSectionDivider_SUBTYPE_SCENE_GROUP"}
  },
  PsdBlendingRanges: {
    "^": "Object;grayBlackSrc,grayWhiteSrc,grayBlackDst,grayWhiteDst,blackSrc,whiteSrc,blackDst,whiteDst",
    PsdBlendingRanges$1: function(input) {
      var numChannels, t1, i, t2;
      this.grayBlackSrc = input.readUint16$0();
      this.grayWhiteSrc = input.readUint16$0();
      this.grayBlackDst = input.readUint16$0();
      this.grayWhiteDst = input.readUint16$0();
      numChannels = J.$tdiv$n(J.$sub$n(input.end, input.offset), 8);
      if (J.$gt$n(numChannels, 0)) {
        t1 = typeof numChannels !== "number" || Math.floor(numChannels) !== numChannels;
        if (t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(numChannels)));
        this.blackSrc = new Uint16Array(numChannels);
        if (t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(numChannels)));
        this.whiteSrc = new Uint16Array(numChannels);
        if (t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(numChannels)));
        this.blackDst = new Uint16Array(numChannels);
        if (t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(numChannels)));
        this.whiteDst = new Uint16Array(numChannels);
        if (typeof numChannels !== "number")
          return H.iae(numChannels);
        i = 0;
        for (; i < numChannels; ++i) {
          t1 = this.blackSrc;
          t2 = input.readUint16$0();
          if (i >= t1.length)
            return H.ioore(t1, i);
          t1[i] = t2;
          t2 = this.whiteSrc;
          t1 = input.readUint16$0();
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2[i] = t1;
          t1 = this.blackDst;
          t2 = input.readUint16$0();
          if (i >= t1.length)
            return H.ioore(t1, i);
          t1[i] = t2;
          t2 = this.whiteDst;
          t1 = input.readUint16$0();
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2[i] = t1;
        }
      }
    },
    static: {PsdBlendingRanges$: function(input) {
        var t1 = new U.PsdBlendingRanges(null, null, null, null, null, null, null, null);
        t1.PsdBlendingRanges$1(input);
        return t1;
      }}
  },
  PsdChannel: {
    "^": "Object;id>,dataLength,data>",
    readPlane$7: function(input, width, height, bitDepth, compression, lineLengths, planeNum) {
      if (compression == null)
        compression = input.readUint16$0();
      switch (compression) {
        case 0:
          this._readPlaneUncompressed$4(input, width, height, bitDepth);
          break;
        case 1:
          this._readPlaneRleCompressed$6(input, width, height, bitDepth, lineLengths == null ? this._readLineLengths$2(input, height) : lineLengths, planeNum);
          break;
        default:
          throw H.wrapException(U.ImageException$("Unsupported compression: " + H.S(compression)));
      }
    },
    readPlane$4: function(input, width, height, bitDepth) {
      return this.readPlane$7(input, width, height, bitDepth, null, null, 0);
    },
    _readLineLengths$2: function(input, height) {
      var lineLengths, t1, i, t2;
      if (typeof height !== "number" || Math.floor(height) !== height)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(height)));
      lineLengths = new Uint16Array(height);
      if (typeof height !== "number")
        return H.iae(height);
      t1 = lineLengths.length;
      i = 0;
      for (; i < height; ++i) {
        t2 = input.readUint16$0();
        if (i >= t1)
          return H.ioore(lineLengths, i);
        lineLengths[i] = t2;
      }
      return lineLengths;
    },
    _readPlaneUncompressed$4: function(input, width, height, bitDepth) {
      var len, t1;
      len = J.$mul$ns(width, height);
      if (bitDepth === 16)
        len = J.$mul$ns(len, 2);
      if (J.$gt$n(len, J.$sub$n(input.end, input.offset))) {
        if (typeof len !== "number" || Math.floor(len) !== len)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(len)));
        t1 = new Uint8Array(len);
        this.data = t1;
        C.NativeUint8List_methods.fillRange$3(t1, 0, len, 255);
        return;
      }
      this.data = input.readBytes$1(len).toUint8List$0();
    },
    _readPlaneRleCompressed$6: function(input, width, height, bitDepth, lineLengths, planeNum) {
      var len, t1, lineIndex, t2, pos, i, lineIndex0, pos0, t3, t4;
      len = J.$mul$ns(width, height);
      if (bitDepth === 16)
        len = J.$mul$ns(len, 2);
      if (typeof len !== "number" || Math.floor(len) !== len)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(len)));
      t1 = new Uint8Array(len);
      this.data = t1;
      if (typeof height !== "number")
        return H.iae(height);
      lineIndex = planeNum * height;
      t2 = lineLengths.length;
      if (lineIndex >= t2) {
        C.NativeUint8List_methods.fillRange$3(t1, 0, t1.length, 255);
        return;
      }
      for (pos = 0, i = 0; i < height; ++i, lineIndex = lineIndex0) {
        lineIndex0 = lineIndex + 1;
        if (lineIndex >>> 0 !== lineIndex || lineIndex >= t2)
          return H.ioore(lineLengths, lineIndex);
        len = lineLengths[lineIndex];
        input.toString;
        pos0 = J.$add$ns(input.offset, 0);
        t1 = input.buffer;
        t3 = input.bigEndian;
        t4 = J.$add$ns(pos0, len);
        input.offset = J.$add$ns(input.offset, J.$sub$n(t4, pos0));
        this._decodeRLE$3(new U.InputBuffer(t1, pos0, t4, pos0, t3), this.data, pos);
        if (typeof width !== "number")
          return H.iae(width);
        pos += width;
      }
    },
    _decodeRLE$3: function(src, dst, dstIndex) {
      var t1, t2, t3, n, b, i, dstIndex0;
      for (t1 = src.end; !J.$ge$n(src.offset, t1);) {
        t2 = src.buffer;
        t3 = src.offset;
        src.offset = J.$add$ns(t3, 1);
        t3 = J.$index$asx(t2, t3);
        $.get$__uint8()[0] = t3;
        t3 = $.get$__uint8ToInt8();
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        n = t3[0];
        if (n < 0) {
          n = 1 - n;
          t2 = src.buffer;
          t3 = src.offset;
          src.offset = J.$add$ns(t3, 1);
          b = J.$index$asx(t2, t3);
          for (i = 0; i < n; ++i, dstIndex = dstIndex0) {
            dstIndex0 = dstIndex + 1;
            if (dstIndex >>> 0 !== dstIndex || dstIndex >= dst.length)
              return H.ioore(dst, dstIndex);
            dst[dstIndex] = b;
          }
        } else {
          ++n;
          for (i = 0; i < n; ++i, dstIndex = dstIndex0) {
            dstIndex0 = dstIndex + 1;
            t2 = src.buffer;
            t3 = src.offset;
            src.offset = J.$add$ns(t3, 1);
            t3 = J.$index$asx(t2, t3);
            if (dstIndex >>> 0 !== dstIndex || dstIndex >= dst.length)
              return H.ioore(dst, dstIndex);
            dst[dstIndex] = t3;
          }
        }
      }
    },
    static: {"^": "PsdChannel_RED,PsdChannel_GREEN,PsdChannel_BLUE,PsdChannel_BLACK,PsdChannel_ALPHA,PsdChannel_MASK,PsdChannel_REAL_MASK,PsdChannel_COMPRESS_NONE,PsdChannel_COMPRESS_RLE,PsdChannel_COMPRESS_ZIP,PsdChannel_COMPRESS_ZIP_PREDICTOR"}
  },
  PsdImage: {
    "^": "DecodeInfo;signature,version,channels,depth,colorMode,layers,mergeImageChannels,mergedImage,imageResources,hasAlpha,_input,_colorData,_imageResourceData,_layerAndMaskData,_imageData,width,height,backgroundColor",
    decode$0: function() {
      if (this.signature !== 943870035 || this._input == null)
        return false;
      this._readImageResources$0();
      this._readLayerAndMaskData$0();
      this._readMergeImageData$0();
      this._input = null;
      this._colorData = null;
      this._imageResourceData = null;
      this._layerAndMaskData = null;
      this._imageData = null;
      return true;
    },
    decodeImage$0: function() {
      if (!this.decode$0())
        return;
      return this.renderImage$0();
    },
    renderImage$0: function() {
      var t1, pixels, li, t2, layer, opacity, blendMode, srcP, sy, y, si, t3, t4, sx, di, x, si0, br, bg, bb, ba, ar, ag, t5, ab, aa, da, b, g, r, di0, di1;
      t1 = this.mergedImage;
      if (t1 != null)
        return t1;
      t1 = U.Image$(this.width, this.height, 4);
      this.mergedImage = t1;
      t1 = t1.data;
      C.NativeUint32List_methods.fillRange$3(t1, 0, t1.length, this.backgroundColor);
      pixels = H.NativeUint8List_NativeUint8List$view(this.mergedImage.data.buffer, 0, null);
      for (t1 = pixels.length, li = 0; t2 = this.layers, li < t2.length; ++li) {
        layer = t2[li];
        if (!layer.isVisible$0())
          continue;
        opacity = J.$div$n(layer.opacity, 255);
        blendMode = layer.blendMode;
        if (this.depth === 16)
          ;
        t2 = layer.layerImage.data.buffer;
        H._checkViewArguments(t2, 0, null);
        srcP = new Uint8Array(t2, 0);
        for (sy = layer.top, t2 = srcP.length, y = 0, si = 0; y < layer.height; ++y, ++sy) {
          t3 = layer.top;
          t4 = this.width;
          if (typeof t4 !== "number")
            return H.iae(t4);
          sx = layer.left;
          di = (t3 + y) * t4 * 4 + sx * 4;
          for (t3 = sy >= 0, x = 0; x < layer.width; ++x, ++sx) {
            si0 = si + 1;
            if (si < 0 || si >= t2)
              return H.ioore(srcP, si);
            br = srcP[si];
            si = si0 + 1;
            if (si0 < 0 || si0 >= t2)
              return H.ioore(srcP, si0);
            bg = srcP[si0];
            si0 = si + 1;
            if (si < 0 || si >= t2)
              return H.ioore(srcP, si);
            bb = srcP[si];
            si = si0 + 1;
            if (si0 < 0 || si0 >= t2)
              return H.ioore(srcP, si0);
            ba = srcP[si0];
            if (sx >= 0) {
              t4 = this.width;
              if (typeof t4 !== "number")
                return H.iae(t4);
              if (sx < t4)
                if (t3) {
                  t4 = this.height;
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  t4 = sy < t4;
                } else
                  t4 = false;
              else
                t4 = false;
            } else
              t4 = false;
            if (t4) {
              if (di >>> 0 !== di || di >= t1)
                return H.ioore(pixels, di);
              ar = pixels[di];
              t4 = di + 1;
              if (t4 >= t1)
                return H.ioore(pixels, t4);
              ag = pixels[t4];
              t5 = di + 2;
              if (t5 >= t1)
                return H.ioore(pixels, t5);
              ab = pixels[t5];
              t5 = di + 3;
              if (t5 >= t1)
                return H.ioore(pixels, t5);
              aa = pixels[t5];
              if (typeof opacity !== "number")
                return H.iae(opacity);
              da = ba / 255 * opacity;
              switch (blendMode) {
                case 1885434739:
                  b = ab;
                  g = ag;
                  r = ar;
                  break;
                case 1852797549:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                case 1684632435:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                case 1684107883:
                  r = P.min(ar, br);
                  g = P.min(ag, bg);
                  b = P.min(ab, bb);
                  break;
                case 1836411936:
                  r = ar * br >>> 8;
                  g = ag * bg >>> 8;
                  b = ab * bb >>> 8;
                  break;
                case 1768188278:
                  r = U.PsdImage__blendColorBurn(ar, br);
                  g = U.PsdImage__blendColorBurn(ag, bg);
                  b = U.PsdImage__blendColorBurn(ab, bb);
                  break;
                case 1818391150:
                  r = C.JSInt_methods.clamp$2(ar + br - 255, 0, 255);
                  g = C.JSInt_methods.clamp$2(ag + bg - 255, 0, 255);
                  b = C.JSInt_methods.clamp$2(ab + bb - 255, 0, 255);
                  break;
                case 1684751212:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                case 1818850405:
                  r = P.max(ar, br);
                  g = P.max(ag, bg);
                  b = P.max(ab, bb);
                  break;
                case 1935897198:
                  r = C.JSInt_methods.clamp$2(255 - (255 - br) * (255 - ar), 0, 255);
                  g = C.JSInt_methods.clamp$2(255 - (255 - bg) * (255 - ag), 0, 255);
                  b = C.JSInt_methods.clamp$2(255 - (255 - bb) * (255 - ab), 0, 255);
                  break;
                case 1684633120:
                  r = U.PsdImage__blendColorDodge(ar, br);
                  g = U.PsdImage__blendColorDodge(ag, bg);
                  b = U.PsdImage__blendColorDodge(ab, bb);
                  break;
                case 1818518631:
                  r = br + ar > 255 ? 255 : ar + br;
                  g = bg + ag > 255 ? 255 : ag + bg;
                  b = bb + ab > 255 ? 255 : ab + bb;
                  break;
                case 1818706796:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                case 1870030194:
                  r = U.PsdImage__blendOverlay(ar, br, aa, ba);
                  g = U.PsdImage__blendOverlay(ag, bg, aa, ba);
                  b = U.PsdImage__blendOverlay(ab, bb, aa, ba);
                  break;
                case 1934387572:
                  r = U.PsdImage__blendSoftLight(ar, br);
                  g = U.PsdImage__blendSoftLight(ag, bg);
                  b = U.PsdImage__blendSoftLight(ab, bb);
                  break;
                case 1749838196:
                  r = U.PsdImage__blendHardLight(ar, br);
                  g = U.PsdImage__blendHardLight(ag, bg);
                  b = U.PsdImage__blendHardLight(ab, bb);
                  break;
                case 1984719220:
                  r = U.PsdImage__blendVividLight(ar, br);
                  g = U.PsdImage__blendVividLight(ag, bg);
                  b = U.PsdImage__blendVividLight(ab, bb);
                  break;
                case 1816947060:
                  r = U.PsdImage__blendLinearLight(ar, br);
                  g = U.PsdImage__blendLinearLight(ag, bg);
                  b = U.PsdImage__blendLinearLight(ab, bb);
                  break;
                case 1884055924:
                  r = br < 128 ? P.min(ar, 2 * br) : P.max(ar, 2 * (br - 128));
                  g = bg < 128 ? P.min(ag, 2 * bg) : P.max(ag, 2 * (bg - 128));
                  b = bb < 128 ? P.min(ab, 2 * bb) : P.max(ab, 2 * (bb - 128));
                  break;
                case 1749903736:
                  r = br < 255 - ar ? 0 : 255;
                  g = bg < 255 - ag ? 0 : 255;
                  b = bb < 255 - ab ? 0 : 255;
                  break;
                case 1684629094:
                  r = Math.abs(br - ar);
                  g = Math.abs(bg - ag);
                  b = Math.abs(bb - ab);
                  break;
                case 1936553316:
                  r = C.JSNumber_methods.toInt$0(C.JSInt_methods.roundToDouble$0(br + ar - 2 * br * ar / 255));
                  g = C.JSNumber_methods.toInt$0(C.JSInt_methods.roundToDouble$0(bg + ag - 2 * bg * ag / 255));
                  b = C.JSNumber_methods.toInt$0(C.JSInt_methods.roundToDouble$0(bb + ab - 2 * bb * ab / 255));
                  break;
                case 1718842722:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                case 1717856630:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                case 1752524064:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                case 1935766560:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                case 1668246642:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                case 1819634976:
                  b = bb;
                  g = bg;
                  r = br;
                  break;
                default:
                  b = bb;
                  g = bg;
                  r = br;
              }
              t5 = 1 - da;
              r = C.JSNumber_methods.toInt$0(ar * t5 + r * da);
              g = C.JSNumber_methods.toInt$0(ag * t5 + g * da);
              b = C.JSNumber_methods.toInt$0(ab * t5 + b * da);
              pixels[di] = r;
              di0 = t4 + 1;
              pixels[t4] = g;
              di1 = di0 + 1;
              if (di0 >= t1)
                return H.ioore(pixels, di0);
              pixels[di0] = b;
              if (di1 >= t1)
                return H.ioore(pixels, di1);
              pixels[di1] = aa;
              di += 4;
            }
          }
        }
      }
      return this.mergedImage;
    },
    _readHeader$0: function() {
      var t1, padding, i;
      this.signature = this._input.readUint32$0();
      t1 = this._input.readUint16$0();
      this.version = t1;
      if (t1 !== 1) {
        this.signature = 0;
        return;
      }
      padding = this._input.readBytes$1(6);
      for (i = 0; i < 6; ++i)
        if (!J.$eq(J.$index$asx(padding.buffer, J.$add$ns(padding.offset, i)), 0)) {
          this.signature = 0;
          return;
        }
      this.channels = this._input.readUint16$0();
      this.height = this._input.readUint32$0();
      this.width = this._input.readUint32$0();
      this.depth = this._input.readUint16$0();
      this.colorMode = this._input.readUint16$0();
    },
    _readImageResources$0: function() {
      var t1, t2, blockSignature, blockId, t3, t4, len, blockName, pos, t5;
      t1 = this._imageResourceData;
      t1.offset = t1.start;
      for (t1 = this.imageResources; t2 = this._imageResourceData, !J.$ge$n(t2.offset, t2.end);) {
        blockSignature = this._imageResourceData.readUint32$0();
        blockId = this._imageResourceData.readUint16$0();
        t2 = this._imageResourceData;
        t3 = t2.buffer;
        t4 = t2.offset;
        t2.offset = J.$add$ns(t4, 1);
        len = J.$index$asx(t3, t4);
        blockName = this._imageResourceData.readString$1(len);
        if (J.$and$n(len, 1) === 0) {
          t2 = this._imageResourceData;
          t2.offset = J.$add$ns(t2.offset, 1);
        }
        len = this._imageResourceData.readUint32$0();
        t2 = this._imageResourceData;
        t2.toString;
        pos = J.$add$ns(t2.offset, 0);
        t3 = t2.buffer;
        t4 = t2.bigEndian;
        t5 = J.$add$ns(pos, len);
        t2.offset = J.$add$ns(t2.offset, J.$sub$n(t5, pos));
        if ((len & 1) === 1) {
          t2 = this._imageResourceData;
          t2.offset = J.$add$ns(t2.offset, 1);
        }
        if (blockSignature === 943868237)
          t1.$indexSet(0, blockId, new U.PsdImageResource(blockId, blockName, new U.InputBuffer(t3, pos, t5, pos, t4)));
      }
    },
    _readLayerAndMaskData$0: function() {
      var t1, len, layerData, count, i, layer, maskData, t2;
      t1 = this._layerAndMaskData;
      t1.offset = t1.start;
      len = t1.readUint32$0();
      if ((len & 1) !== 0)
        ++len;
      layerData = this._layerAndMaskData.readBytes$1(len);
      this.layers = [];
      if (len > 0) {
        t1 = layerData.readUint16$0();
        $.get$__uint16()[0] = t1;
        t1 = $.get$__uint16ToInt16();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        count = t1[0];
        if (count < 0) {
          this.hasAlpha = true;
          count = -count;
        }
        for (i = 0; i < count; ++i) {
          layer = U.PsdLayer$(layerData);
          this.layers.push(layer);
        }
      }
      for (i = 0; t1 = this.layers, i < t1.length; ++i)
        t1[i].readImageData$2(layerData, this);
      len = this._layerAndMaskData.readUint32$0();
      maskData = this._layerAndMaskData.readBytes$1(len);
      if (len > 0) {
        maskData.readUint16$0();
        maskData.readUint16$0();
        maskData.readUint16$0();
        maskData.readUint16$0();
        maskData.readUint16$0();
        maskData.readUint16$0();
        t1 = maskData.buffer;
        t2 = maskData.offset;
        maskData.offset = J.$add$ns(t2, 1);
        J.$index$asx(t1, t2);
      }
    },
    _readMergeImageData$0: function() {
      var t1, compression, numLines, lineLengths, i, t2, t3;
      t1 = this._imageData;
      t1.offset = t1.start;
      compression = t1.readUint16$0();
      if (compression === 1) {
        numLines = J.$mul$ns(this.height, this.channels);
        if (typeof numLines !== "number" || Math.floor(numLines) !== numLines)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(numLines)));
        lineLengths = new Uint16Array(numLines);
        if (typeof numLines !== "number")
          return H.iae(numLines);
        t1 = lineLengths.length;
        i = 0;
        for (; i < numLines; ++i) {
          t2 = this._imageData.readUint16$0();
          if (i >= t1)
            return H.ioore(lineLengths, i);
          lineLengths[i] = t2;
        }
      } else
        lineLengths = null;
      this.mergeImageChannels = [];
      i = 0;
      while (true) {
        t1 = this.channels;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this.mergeImageChannels;
        if (!(i < t1))
          break;
        t1 = this._imageData;
        t3 = i === 3 ? -1 : i;
        t3 = new U.PsdChannel(t3, null, null);
        t3.readPlane$7(t1, this.width, this.height, this.depth, compression, lineLengths, i);
        t2.push(t3);
        ++i;
      }
      this.mergedImage = U.PsdImage_createImageFromChannels(this.colorMode, this.depth, this.width, this.height, t2);
    },
    PsdImage$1: function(bytes) {
      var len, t1;
      this._input = U.InputBuffer$(bytes, true, null, 0);
      this._readHeader$0();
      if (this.signature !== 943870035)
        return;
      len = this._input.readUint32$0();
      this._colorData = this._input.readBytes$1(len);
      len = this._input.readUint32$0();
      this._imageResourceData = this._input.readBytes$1(len);
      len = this._input.readUint32$0();
      this._layerAndMaskData = this._input.readBytes$1(len);
      t1 = this._input;
      this._imageData = t1.readBytes$1(J.$sub$n(t1.end, t1.offset));
    },
    static: {"^": "PsdImage_SIGNATURE,PsdImage_COLORMODE_BITMAP,PsdImage_COLORMODE_GRAYSCALE,PsdImage_COLORMODE_INDEXED,PsdImage_COLORMODE_RGB,PsdImage_COLORMODE_CMYK,PsdImage_COLORMODE_MULTICHANNEL,PsdImage_COLORMODE_DUOTONE,PsdImage_COLORMODE_LAB,PsdImage_RESOURCE_BLOCK_SIGNATURE", PsdImage$: function(bytes) {
        var t1 = new U.PsdImage(null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), false, null, null, null, null, null, 0, 0, 4294967295);
        t1.PsdImage$1(bytes);
        return t1;
      }, PsdImage__blendOverlay: function(a, b, aAlpha, bAlpha) {
        var x, y, aa, ba, t1, t2;
        x = a / 255;
        y = b / 255;
        aa = aAlpha / 255;
        ba = bAlpha / 255;
        t1 = 1 - aa;
        t2 = 1 - ba;
        return C.JSInt_methods.clamp$2(C.JSInt_methods.toInt$0((2 * x < aa ? 2 * y * x + y * t1 + x * t2 : ba * aa - 2 * (aa - x) * (ba - y) + y * t1 + x * t2) * 255), 0, 255);
      }, PsdImage__blendColorBurn: function(a, b) {
        if (b === 0)
          return 0;
        return C.JSInt_methods.clamp$2(C.JSInt_methods.toInt$0(255 * (1 - (1 - a / 255) / (b / 255))), 0, 255);
      }, PsdImage__blendColorDodge: function(a, b) {
        if (b === 255)
          return 255;
        return C.JSInt_methods.clamp$2(C.JSInt_methods.toInt$0(a / 255 / (1 - b / 255) * 255), 0, 255);
      }, PsdImage__blendSoftLight: function(a, b) {
        var aa, bb, t1;
        aa = a / 255;
        bb = b / 255;
        t1 = 1 - bb;
        return C.JSNumber_methods.toInt$0(C.JSInt_methods.roundToDouble$0(255 * (t1 * bb * aa + bb * (1 - t1 * (1 - aa)))));
      }, PsdImage__blendHardLight: function(bottom, $top) {
        var a, b;
        a = $top / 255;
        b = bottom / 255;
        if (b < 0.5)
          return C.JSNumber_methods.toInt$0(C.JSInt_methods.roundToDouble$0(510 * a * b));
        else
          return C.JSNumber_methods.toInt$0(C.JSInt_methods.roundToDouble$0(255 * (1 - 2 * (1 - a) * (1 - b))));
      }, PsdImage__blendVividLight: function(bottom, $top) {
        if ($top < 128)
          return U.PsdImage__blendColorBurn(bottom, 2 * $top);
        else
          return U.PsdImage__blendColorDodge(bottom, 2 * ($top - 128));
      }, PsdImage__blendLinearLight: function(bottom, $top) {
        var t1;
        if ($top < 128)
          return C.JSInt_methods.clamp$2(bottom + 2 * $top - 255, 0, 255);
        else {
          t1 = 2 * ($top - 128);
          return t1 + bottom > 255 ? 255 : bottom + t1;
        }
      }, PsdImage_createImageFromChannels: function(colorMode, bitDepth, width, height, channelList) {
        var output, pixels, channels, t1, ch, numChannels, ns, t2, t3, t4, t5, t6, y, di, si, x, di0, t7, t8, t9, t10, a, b, alpha, y0, x0, z, y3, x3, z3, $R, $G, $B, rgb, gray, c, m, k, r, g;
        output = U.Image$(width, height, 4);
        pixels = H.NativeUint8List_NativeUint8List$view(output.data.buffer, 0, null);
        channels = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        for (t1 = new H.ListIterator(channelList, channelList.length, 0, null); t1.moveNext$0();) {
          ch = t1._current;
          channels.$indexSet(0, J.get$id$x(ch), ch);
        }
        numChannels = channelList.length;
        if (bitDepth === 8)
          ns = 1;
        else
          ns = bitDepth === 16 ? 2 : -1;
        if (ns === -1)
          throw H.wrapException(U.ImageException$("PSD: unsupported bit depth: " + H.S(bitDepth)));
        if (typeof height !== "number")
          return H.iae(height);
        t1 = pixels.length;
        t2 = numChannels >= 5;
        t3 = ns === 1;
        t4 = numChannels === 4;
        t5 = numChannels >= 2;
        t6 = numChannels >= 4;
        y = 0;
        di = 0;
        si = 0;
        for (; y < height; ++y) {
          if (typeof width !== "number")
            return H.iae(width);
          x = 0;
          for (; x < width; ++x, si += ns)
            switch (colorMode) {
              case 3:
                di0 = di + 1;
                t7 = J.get$data$x(channels.$index(0, 0));
                t8 = J.getInterceptor$asx(t7);
                if (t3)
                  t7 = t8.$index(t7, si);
                else {
                  t9 = t8.$index(t7, si);
                  if (typeof t9 !== "number")
                    return t9.$shl();
                  t7 = t8.$index(t7, si + 1);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  t7 = (t9 << 8 | t7) >>> 8;
                }
                if (di < 0 || di >= t1)
                  return H.ioore(pixels, di);
                pixels[di] = t7;
                di = di0 + 1;
                t7 = J.get$data$x(channels.$index(0, 1));
                t8 = J.getInterceptor$asx(t7);
                if (t3)
                  t7 = t8.$index(t7, si);
                else {
                  t9 = t8.$index(t7, si);
                  if (typeof t9 !== "number")
                    return t9.$shl();
                  t7 = t8.$index(t7, si + 1);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  t7 = (t9 << 8 | t7) >>> 8;
                }
                if (di0 < 0 || di0 >= t1)
                  return H.ioore(pixels, di0);
                pixels[di0] = t7;
                di0 = di + 1;
                t7 = J.get$data$x(channels.$index(0, 2));
                t8 = J.getInterceptor$asx(t7);
                if (t3)
                  t7 = t8.$index(t7, si);
                else {
                  t9 = t8.$index(t7, si);
                  if (typeof t9 !== "number")
                    return t9.$shl();
                  t7 = t8.$index(t7, si + 1);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  t7 = (t9 << 8 | t7) >>> 8;
                }
                if (di < 0 || di >= t1)
                  return H.ioore(pixels, di);
                pixels[di] = t7;
                di = di0 + 1;
                if (t6) {
                  t7 = J.get$data$x(channels.$index(0, -1));
                  t8 = J.getInterceptor$asx(t7);
                  if (t3)
                    t7 = t8.$index(t7, si);
                  else {
                    t9 = t8.$index(t7, si);
                    if (typeof t9 !== "number")
                      return t9.$shl();
                    t7 = t8.$index(t7, si + 1);
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    t7 = (t9 << 8 | t7) >>> 8;
                  }
                } else
                  t7 = 255;
                if (di0 < 0 || di0 >= t1)
                  return H.ioore(pixels, di0);
                pixels[di0] = t7;
                break;
              case 9:
                t7 = J.get$data$x(channels.$index(0, 0));
                t8 = J.getInterceptor$asx(t7);
                if (t3)
                  t7 = t8.$index(t7, si);
                else {
                  t9 = t8.$index(t7, si);
                  if (typeof t9 !== "number")
                    return t9.$shl();
                  t7 = t8.$index(t7, si + 1);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  t7 = (t9 << 8 | t7) >>> 8;
                }
                t7 = J.$mul$ns(t7, 100);
                if (typeof t7 !== "number")
                  return t7.$shr();
                t7 = C.JSNumber_methods._shrOtherPositive$1(t7, 8);
                t8 = J.get$data$x(channels.$index(0, 1));
                t9 = J.getInterceptor$asx(t8);
                if (t3)
                  t8 = t9.$index(t8, si);
                else {
                  t10 = t9.$index(t8, si);
                  if (typeof t10 !== "number")
                    return t10.$shl();
                  t8 = t9.$index(t8, si + 1);
                  if (typeof t8 !== "number")
                    return H.iae(t8);
                  t8 = (t10 << 8 | t8) >>> 8;
                }
                a = J.$sub$n(t8, 128);
                t8 = J.get$data$x(channels.$index(0, 2));
                t9 = J.getInterceptor$asx(t8);
                if (t3)
                  t8 = t9.$index(t8, si);
                else {
                  t10 = t9.$index(t8, si);
                  if (typeof t10 !== "number")
                    return t10.$shl();
                  t8 = t9.$index(t8, si + 1);
                  if (typeof t8 !== "number")
                    return H.iae(t8);
                  t8 = (t10 << 8 | t8) >>> 8;
                }
                b = J.$sub$n(t8, 128);
                if (t6) {
                  t8 = J.get$data$x(channels.$index(0, -1));
                  t9 = J.getInterceptor$asx(t8);
                  if (t3) {
                    t8 = t9.$index(t8, si);
                    alpha = t8;
                  } else {
                    t10 = t9.$index(t8, si);
                    if (typeof t10 !== "number")
                      return t10.$shl();
                    t8 = t9.$index(t8, si + 1);
                    if (typeof t8 !== "number")
                      return H.iae(t8);
                    t8 = (t10 << 8 | t8) >>> 8;
                    alpha = t8;
                  }
                } else
                  alpha = 255;
                y0 = (t7 + 16) / 116;
                x0 = J.$add$ns(J.$div$n(a, 500), y0);
                t7 = J.$div$n(b, 200);
                if (typeof t7 !== "number")
                  return H.iae(t7);
                z = y0 - t7;
                y3 = Math.pow(y0, 3);
                y0 = y3 > 0.008856 ? y3 : (y0 - 0.13793103448275862) / 7.787;
                if (typeof x0 !== "number")
                  H.throwExpression(P.ArgumentError$(x0));
                x3 = Math.pow(x0, 3);
                x0 = x3 > 0.008856 ? x3 : J.$div$n(J.$sub$n(x0, 0.13793103448275862), 7.787);
                z3 = Math.pow(z, 3);
                z = z3 > 0.008856 ? z3 : (z - 0.13793103448275862) / 7.787;
                x0 = J.$div$n(J.$mul$ns(x0, 95.047), 100);
                y0 = y0 * 100 / 100;
                z = z * 108.883 / 100;
                t7 = J.getInterceptor$ns(x0);
                $R = J.$add$ns(J.$add$ns(t7.$mul(x0, 3.2406), y0 * -1.5372), z * -0.4986);
                $G = J.$add$ns(J.$add$ns(t7.$mul(x0, -0.9689), y0 * 1.8758), z * 0.0415);
                $B = J.$add$ns(J.$add$ns(t7.$mul(x0, 0.0557), y0 * -0.204), z * 1.057);
                if (J.$gt$n($R, 0.0031308)) {
                  if (typeof $R !== "number")
                    H.throwExpression(P.ArgumentError$($R));
                  $R = 1.055 * Math.pow($R, 0.4166666666666667) - 0.055;
                } else {
                  if (typeof $R !== "number")
                    return H.iae($R);
                  $R = 12.92 * $R;
                }
                if (J.$gt$n($G, 0.0031308)) {
                  if (typeof $G !== "number")
                    H.throwExpression(P.ArgumentError$($G));
                  $G = 1.055 * Math.pow($G, 0.4166666666666667) - 0.055;
                } else {
                  if (typeof $G !== "number")
                    return H.iae($G);
                  $G = 12.92 * $G;
                }
                if (J.$gt$n($B, 0.0031308)) {
                  if (typeof $B !== "number")
                    H.throwExpression(P.ArgumentError$($B));
                  $B = 1.055 * Math.pow($B, 0.4166666666666667) - 0.055;
                } else {
                  if (typeof $B !== "number")
                    return H.iae($B);
                  $B = 12.92 * $B;
                }
                rgb = [C.JSInt_methods.clamp$2(C.JSDouble_methods.toInt$0($R * 255), 0, 255), C.JSInt_methods.clamp$2(C.JSDouble_methods.toInt$0($G * 255), 0, 255), C.JSInt_methods.clamp$2(C.JSDouble_methods.toInt$0($B * 255), 0, 255)];
                di0 = di + 1;
                t7 = rgb[0];
                if (di < 0 || di >= t1)
                  return H.ioore(pixels, di);
                pixels[di] = t7;
                di = di0 + 1;
                t7 = rgb[1];
                if (di0 < 0 || di0 >= t1)
                  return H.ioore(pixels, di0);
                pixels[di0] = t7;
                di0 = di + 1;
                t7 = rgb[2];
                if (di < 0 || di >= t1)
                  return H.ioore(pixels, di);
                pixels[di] = t7;
                di = di0 + 1;
                if (di0 < 0 || di0 >= t1)
                  return H.ioore(pixels, di0);
                pixels[di0] = alpha;
                break;
              case 1:
                t7 = J.get$data$x(channels.$index(0, 0));
                t8 = J.getInterceptor$asx(t7);
                if (t3)
                  gray = t8.$index(t7, si);
                else {
                  t9 = t8.$index(t7, si);
                  if (typeof t9 !== "number")
                    return t9.$shl();
                  t7 = t8.$index(t7, si + 1);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  gray = (t9 << 8 | t7) >>> 8;
                }
                if (t5) {
                  t7 = J.get$data$x(channels.$index(0, -1));
                  t8 = J.getInterceptor$asx(t7);
                  if (t3) {
                    t7 = t8.$index(t7, si);
                    alpha = t7;
                  } else {
                    t9 = t8.$index(t7, si);
                    if (typeof t9 !== "number")
                      return t9.$shl();
                    t7 = t8.$index(t7, si + 1);
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    t7 = (t9 << 8 | t7) >>> 8;
                    alpha = t7;
                  }
                } else
                  alpha = 255;
                di0 = di + 1;
                if (di < 0 || di >= t1)
                  return H.ioore(pixels, di);
                pixels[di] = gray;
                di = di0 + 1;
                if (di0 < 0 || di0 >= t1)
                  return H.ioore(pixels, di0);
                pixels[di0] = gray;
                di0 = di + 1;
                if (di < 0 || di >= t1)
                  return H.ioore(pixels, di);
                pixels[di] = gray;
                di = di0 + 1;
                if (di0 < 0 || di0 >= t1)
                  return H.ioore(pixels, di0);
                pixels[di0] = alpha;
                break;
              case 4:
                t7 = J.get$data$x(channels.$index(0, 0));
                t8 = J.getInterceptor$asx(t7);
                if (t3)
                  c = t8.$index(t7, si);
                else {
                  t9 = t8.$index(t7, si);
                  if (typeof t9 !== "number")
                    return t9.$shl();
                  t7 = t8.$index(t7, si + 1);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  c = (t9 << 8 | t7) >>> 8;
                }
                t7 = J.get$data$x(channels.$index(0, 1));
                t8 = J.getInterceptor$asx(t7);
                if (t3)
                  m = t8.$index(t7, si);
                else {
                  t9 = t8.$index(t7, si);
                  if (typeof t9 !== "number")
                    return t9.$shl();
                  t7 = t8.$index(t7, si + 1);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  m = (t9 << 8 | t7) >>> 8;
                }
                t7 = J.get$data$x(channels.$index(0, 2));
                t8 = J.getInterceptor$asx(t7);
                if (t3)
                  y0 = t8.$index(t7, si);
                else {
                  t9 = t8.$index(t7, si);
                  if (typeof t9 !== "number")
                    return t9.$shl();
                  t7 = t8.$index(t7, si + 1);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  y0 = (t9 << 8 | t7) >>> 8;
                }
                t7 = J.get$data$x(channels.$index(0, t4 ? -1 : 3));
                t8 = J.getInterceptor$asx(t7);
                if (t3)
                  k = t8.$index(t7, si);
                else {
                  t9 = t8.$index(t7, si);
                  if (typeof t9 !== "number")
                    return t9.$shl();
                  t7 = t8.$index(t7, si + 1);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  k = (t9 << 8 | t7) >>> 8;
                }
                if (t2) {
                  t7 = J.get$data$x(channels.$index(0, -1));
                  t8 = J.getInterceptor$asx(t7);
                  if (t3) {
                    t7 = t8.$index(t7, si);
                    alpha = t7;
                  } else {
                    t9 = t8.$index(t7, si);
                    if (typeof t9 !== "number")
                      return t9.$shl();
                    t7 = t8.$index(t7, si + 1);
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    t7 = (t9 << 8 | t7) >>> 8;
                    alpha = t7;
                  }
                } else
                  alpha = 255;
                if (typeof c !== "number")
                  return H.iae(c);
                if (typeof m !== "number")
                  return H.iae(m);
                if (typeof y0 !== "number")
                  return H.iae(y0);
                if (typeof k !== "number")
                  return H.iae(k);
                t7 = 255 - k;
                t8 = 255 - t7;
                t7 = t7 << 8 >>> 0;
                r = C.JSNumber_methods._shrOtherPositive$1(65535 - ((255 - c) * t8 + t7), 8);
                g = C.JSNumber_methods._shrOtherPositive$1(65535 - ((255 - m) * t8 + t7), 8);
                b = C.JSNumber_methods._shrOtherPositive$1(65535 - ((255 - y0) * t8 + t7), 8);
                rgb = [C.JSInt_methods.clamp$2(r, 0, 255), C.JSInt_methods.clamp$2(g, 0, 255), C.JSInt_methods.clamp$2(b, 0, 255)];
                di0 = di + 1;
                t7 = rgb[0];
                if (di < 0 || di >= t1)
                  return H.ioore(pixels, di);
                pixels[di] = t7;
                di = di0 + 1;
                t7 = rgb[1];
                if (di0 < 0 || di0 >= t1)
                  return H.ioore(pixels, di0);
                pixels[di0] = t7;
                di0 = di + 1;
                t7 = rgb[2];
                if (di < 0 || di >= t1)
                  return H.ioore(pixels, di);
                pixels[di] = t7;
                di = di0 + 1;
                if (di0 < 0 || di0 >= t1)
                  return H.ioore(pixels, di0);
                pixels[di0] = alpha;
                break;
              default:
                throw H.wrapException(U.ImageException$("Unhandled color mode: " + H.S(colorMode)));
            }
        }
        return output;
      }}
  },
  PsdImageResource: {
    "^": "Object;id>,name>,data>"
  },
  PsdLayer: {
    "^": "Object;top,left,bottom,right,width>,height>,blendMode,opacity,clipping,flags,compression,name>,channels,mask,blendingRanges,additionalData,children>,parent,layerImage",
    isVisible$0: function() {
      return J.$and$n(this.flags, 2) === 0;
    },
    type$0: [function(_) {
      var t1, section;
      t1 = this.additionalData;
      if (t1.containsKey$1("lsct")) {
        section = t1.$index(0, "lsct");
        return section.get$type(section);
      }
      return 0;
    }, "call$0", "get$type", 0, 0, 92],
    readImageData$2: function(input, psd) {
      var i, t1, t2, t3, t4, t5;
      for (i = 0; t1 = this.channels, t2 = t1.length, t3 = psd.depth, t4 = this.width, t5 = this.height, i < t2; ++i)
        t1[i].readPlane$4(input, t4, t5, t3);
      this.layerImage = U.PsdImage_createImageFromChannels(psd.colorMode, t3, t4, t5, t1);
    },
    PsdLayer$1: function(input) {
      var t1, t2, numChannels, i, id, len, sig, extra, padding, tag, pos, t3, t4, t5, t6;
      t1 = input.readUint32$0();
      t2 = $.get$__uint32();
      t2[0] = t1;
      t1 = $.get$__uint32ToInt32();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.top = t1[0];
      t2[0] = input.readUint32$0();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.left = t1[0];
      t2[0] = input.readUint32$0();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.bottom = t1[0];
      t2[0] = input.readUint32$0();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = t1[0];
      this.right = t1;
      this.width = t1 - this.left;
      this.height = this.bottom - this.top;
      this.channels = [];
      numChannels = input.readUint16$0();
      for (i = 0; i < numChannels; ++i) {
        t1 = input.readUint16$0();
        $.get$__uint16()[0] = t1;
        t1 = $.get$__uint16ToInt16();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        id = t1[0];
        len = input.readUint32$0();
        this.channels.push(new U.PsdChannel(id, len, null));
      }
      sig = input.readUint32$0();
      if (sig !== 943868237)
        throw H.wrapException(U.ImageException$("Invalid PSD layer signature: " + C.JSInt_methods.toRadixString$1(sig, 16)));
      this.blendMode = input.readUint32$0();
      t1 = input.buffer;
      t2 = input.offset;
      input.offset = J.$add$ns(t2, 1);
      this.opacity = J.$index$asx(t1, t2);
      t2 = input.buffer;
      t1 = input.offset;
      input.offset = J.$add$ns(t1, 1);
      this.clipping = J.$index$asx(t2, t1);
      t1 = input.buffer;
      t2 = input.offset;
      input.offset = J.$add$ns(t2, 1);
      this.flags = J.$index$asx(t1, t2);
      t2 = input.buffer;
      t1 = input.offset;
      input.offset = J.$add$ns(t1, 1);
      if (!J.$eq(J.$index$asx(t2, t1), 0))
        throw H.wrapException(U.ImageException$("Invalid PSD layer data"));
      len = input.readUint32$0();
      extra = input.readBytes$1(len);
      if (len > 0) {
        len = extra.readUint32$0();
        if (len > 0) {
          t1 = new U.PsdMask(null, null, null, null, null, null, 0);
          t1.PsdMask$1(extra.readBytes$1(len));
          this.mask = t1;
        }
        len = extra.readUint32$0();
        if (len > 0)
          this.blendingRanges = U.PsdBlendingRanges$(extra.readBytes$1(len));
        t1 = extra.buffer;
        t2 = extra.offset;
        extra.offset = J.$add$ns(t2, 1);
        len = J.$index$asx(t1, t2);
        this.name = extra.readString$1(len);
        t2 = J.$mod$n(len, 4);
        if (typeof t2 !== "number")
          return H.iae(t2);
        padding = 4 - t2 - 1;
        if (padding > 0)
          extra.offset = J.$add$ns(extra.offset, padding);
        for (t1 = extra.end, t2 = this.additionalData; !J.$ge$n(extra.offset, t1);) {
          sig = extra.readUint32$0();
          if (sig !== 943868237)
            throw H.wrapException(U.ImageException$("PSD invalid signature for layer additional data: " + C.JSInt_methods.toRadixString$1(sig, 16)));
          tag = extra.readString$1(4);
          len = extra.readUint32$0();
          pos = J.$add$ns(extra.offset, 0);
          t3 = extra.buffer;
          t4 = extra.bigEndian;
          t5 = J.$add$ns(pos, len);
          t6 = J.$add$ns(extra.offset, J.$sub$n(t5, pos));
          extra.offset = t6;
          if ((len & 1) === 1)
            extra.offset = J.$add$ns(t6, 1);
          t2.$indexSet(0, tag, U.PsdLayerData_PsdLayerData(tag, new U.InputBuffer(t3, pos, t5, pos, t4)));
        }
      }
    },
    static: {"^": "PsdLayer_SIGNATURE,PsdLayer_BLEND_PASSTHROUGH,PsdLayer_BLEND_NORMAL,PsdLayer_BLEND_DISSOLVE,PsdLayer_BLEND_DARKEN,PsdLayer_BLEND_MULTIPLY,PsdLayer_BLEND_COLOR_BURN,PsdLayer_BLEND_LINEAR_BURN,PsdLayer_BLEND_DARKEN_COLOR,PsdLayer_BLEND_LIGHTEN,PsdLayer_BLEND_SCREEN,PsdLayer_BLEND_COLOR_DODGE,PsdLayer_BLEND_LINEAR_DODGE,PsdLayer_BLEND_LIGHTER_COLOR,PsdLayer_BLEND_OVERLAY,PsdLayer_BLEND_SOFT_LIGHT,PsdLayer_BLEND_HARD_LIGHT,PsdLayer_BLEND_VIVID_LIGHT,PsdLayer_BLEND_LINEAR_LIGHT,PsdLayer_BLEND_PIN_LIGHT,PsdLayer_BLEND_HARD_MIX,PsdLayer_BLEND_DIFFERENCE,PsdLayer_BLEND_EXCLUSION,PsdLayer_BLEND_SUBTRACT,PsdLayer_BLEND_DIVIDE,PsdLayer_BLEND_HUE,PsdLayer_BLEND_SATURATION,PsdLayer_BLEND_COLOR,PsdLayer_BLEND_LUMINOSITY,PsdLayer_FLAG_TRANSPARENCY_PROTECTED,PsdLayer_FLAG_HIDDEN,PsdLayer_FLAG_OBSOLETE,PsdLayer_FLAG_PHOTOSHOP_5,PsdLayer_FLAG_PIXEL_DATA_IRRELEVANT_TO_APPEARANCE", PsdLayer$: function(input) {
        var t1 = new U.PsdLayer(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), [], null, null);
        t1.PsdLayer$1(input);
        return t1;
      }}
  },
  PsdLayerData: {
    "^": "Object;tag",
    static: {PsdLayerData_PsdLayerData: function(tag, data) {
        var t1;
        switch (tag) {
          case "lsct":
            t1 = new U.PsdLayerSectionDivider(null, null, 0, tag);
            t1.PsdLayerSectionDivider$2(tag, data);
            return t1;
          default:
            return new U.PsdLayerAdditionalData(data, tag);
        }
      }}
  },
  PsdMask: {
    "^": "Object;top,left,right,bottom,defaultColor,flags,params",
    PsdMask$1: function(input) {
      var len, t1, t2;
      len = J.$sub$n(input.end, input.offset);
      this.top = input.readUint32$0();
      this.left = input.readUint32$0();
      this.right = input.readUint32$0();
      this.bottom = input.readUint32$0();
      t1 = input.buffer;
      t2 = input.offset;
      input.offset = J.$add$ns(t2, 1);
      this.defaultColor = J.$index$asx(t1, t2);
      t2 = input.buffer;
      t1 = input.offset;
      input.offset = J.$add$ns(t1, 1);
      this.flags = J.$index$asx(t2, t1);
      t1 = J.$eq(len, 20);
      t2 = input.offset;
      if (t1)
        input.offset = J.$add$ns(t2, 2);
      else {
        t1 = input.buffer;
        input.offset = J.$add$ns(t2, 1);
        this.flags = J.$index$asx(t1, t2);
        t2 = input.buffer;
        t1 = input.offset;
        input.offset = J.$add$ns(t1, 1);
        this.defaultColor = J.$index$asx(t2, t1);
        this.top = input.readUint32$0();
        this.left = input.readUint32$0();
        this.right = input.readUint32$0();
        this.bottom = input.readUint32$0();
      }
    }
  },
  PsdDecoder: {
    "^": "Decoder;info,progressCallback",
    startDecode$1: function(bytes) {
      var t1 = U.PsdImage$(bytes);
      this.info = t1;
      return t1;
    },
    decodeFrame$1: function(frame) {
      var t1 = this.info;
      if (t1 == null)
        return;
      return t1.decodeImage$0();
    }
  },
  TiffBitReader: {
    "^": "Object;input,_image$_bitBuffer,_bitPos",
    readBits$1: function(numBits) {
      var t1, t2, t3, value, t4;
      if (numBits === 0)
        return 0;
      if (this._bitPos === 0) {
        this._bitPos = 8;
        t1 = this.input;
        t2 = t1.buffer;
        t3 = t1.offset;
        t1.offset = J.$add$ns(t3, 1);
        this._image$_bitBuffer = J.$index$asx(t2, t3);
      }
      for (value = 0; t1 = this._bitPos, numBits > t1;) {
        t2 = C.JSInt_methods.$shl(value, t1);
        t3 = this._image$_bitBuffer;
        if (t1 < 0 || t1 >= 9)
          return H.ioore(C.List_knt, t1);
        t1 = J.$and$n(t3, C.List_knt[t1]);
        if (typeof t1 !== "number")
          return H.iae(t1);
        value = t2 + t1;
        numBits -= this._bitPos;
        this._bitPos = 8;
        t1 = this.input;
        t2 = t1.buffer;
        t3 = t1.offset;
        t1.offset = J.$add$ns(t3, 1);
        this._image$_bitBuffer = J.$index$asx(t2, t3);
      }
      if (numBits > 0) {
        if (t1 === 0) {
          this._bitPos = 8;
          t1 = this.input;
          t2 = t1.buffer;
          t3 = t1.offset;
          t1.offset = J.$add$ns(t3, 1);
          this._image$_bitBuffer = J.$index$asx(t2, t3);
        }
        t1 = C.JSInt_methods.$shl(value, numBits);
        t2 = this._image$_bitBuffer;
        t3 = this._bitPos - numBits;
        if (typeof t2 !== "number")
          return t2.$shr();
        t2 = C.JSNumber_methods.$shr(t2, t3);
        if (numBits >= 9)
          return H.ioore(C.List_knt, numBits);
        t4 = C.List_knt[numBits];
        if (typeof t4 !== "number")
          return H.iae(t4);
        value = t1 + ((t2 & t4) >>> 0);
        this._bitPos = t3;
      }
      return value;
    },
    static: {"^": "TiffBitReader__BIT_MASK"}
  },
  TiffEntry: {
    "^": "Object;tag,type>,numValues,valueOffset",
    toString$0: function(_) {
      var t1 = this.tag;
      if (C.Map_Od2I8.containsKey$1(t1) === true)
        return H.S(C.Map_Od2I8.$index(0, t1)) + ": " + this.type + " " + this.numValues;
      return "<" + t1 + ">: " + this.type + " " + this.numValues;
    },
    readValues$1: function(p) {
      var values, t1, i;
      p.offset = this.valueOffset;
      values = [];
      for (t1 = this.numValues, i = 0; i < t1; ++i)
        values.push(this._readValue$1(p));
      return values;
    },
    _readValue$1: function(p) {
      var t1, t2, num, den;
      switch (this.type) {
        case 1:
        case 2:
          t1 = p.buffer;
          t2 = p.offset;
          p.offset = J.$add$ns(t2, 1);
          return J.$index$asx(t1, t2);
        case 3:
          return p.readUint16$0();
        case 4:
          return p.readUint32$0();
        case 5:
          num = p.readUint32$0();
          den = p.readUint32$0();
          if (den === 0)
            return 0;
          return num / den;
        case 6:
          throw H.wrapException(U.ImageException$("Unhandled value type: SBYTE"));
        case 7:
          t1 = p.buffer;
          t2 = p.offset;
          p.offset = J.$add$ns(t2, 1);
          return J.$index$asx(t1, t2);
        case 8:
          throw H.wrapException(U.ImageException$("Unhandled value type: SSHORT"));
        case 9:
          throw H.wrapException(U.ImageException$("Unhandled value type: SLONG"));
        case 10:
          throw H.wrapException(U.ImageException$("Unhandled value type: SRATIONAL"));
        case 11:
          throw H.wrapException(U.ImageException$("Unhandled value type: FLOAT"));
        case 12:
          throw H.wrapException(U.ImageException$("Unhandled value type: DOUBLE"));
      }
      return 0;
    },
    static: {"^": "TiffEntry_TYPE_BYTE,TiffEntry_TYPE_ASCII,TiffEntry_TYPE_SHORT,TiffEntry_TYPE_LONG,TiffEntry_TYPE_RATIONAL,TiffEntry_TYPE_SBYTE,TiffEntry_TYPE_UNDEFINED,TiffEntry_TYPE_SSHORT,TiffEntry_TYPE_SLONG,TiffEntry_TYPE_SRATIONAL,TiffEntry_TYPE_FLOAT,TiffEntry_TYPE_DOUBLE,TiffEntry_SIZE_OF_TYPE"}
  },
  TiffFaxDecoder: {
    "^": "Object;width>,height>,fillOrder,changingElemSize,prevChangingElems,currChangingElems,data>,bitPointer,bytePointer,lastChangingElement,compression,uncompressedMode,fillBits,oneD<",
    decode1D$4: function(out, compData, startX, height) {
      var scanlineStride, lineOffset, i;
      this.data = compData;
      this.bitPointer = 0;
      this.bytePointer = 0;
      scanlineStride = J.$tdiv$n(J.$add$ns(this.width, 7), 8);
      if (typeof height !== "number")
        return H.iae(height);
      lineOffset = 0;
      i = 0;
      for (; i < height; ++i) {
        this._decodeNextScanline$3(out, lineOffset, startX);
        if (typeof scanlineStride !== "number")
          return H.iae(scanlineStride);
        lineOffset += scanlineStride;
      }
    },
    _decodeNextScanline$3: function(buffer, lineOffset, bitOffset) {
      var bits, code, isT, current, entry, twoBits, isWhite, t1, t2;
      this.changingElemSize = 0;
      bits = 0;
      code = 0;
      isT = 0;
      current = null;
      entry = null;
      twoBits = null;
      isWhite = true;
      while (true) {
        t1 = this.width;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(bitOffset < t1))
          break;
        for (; isWhite;) {
          current = this._nextNBits$1(10);
          if (current >= 1024)
            return H.ioore(C.List_VSP, current);
          entry = C.List_VSP[current];
          isT = J.getInterceptor$n(entry).$and(entry, 1);
          if (typeof entry !== "number")
            return entry.$shr();
          bits = C.JSNumber_methods._shrOtherPositive$1(entry, 1) & 15;
          if (bits === 12) {
            twoBits = this._nextLesserThan8Bits$1(2);
            current = (current << 2 & 12 | twoBits) >>> 0;
            if (current >= 16)
              return H.ioore(C.List_MEg, current);
            entry = C.List_MEg[current];
            if (typeof entry !== "number")
              return entry.$shr();
            bits = C.JSNumber_methods._shrOtherPositive$1(entry, 1) & 7;
            code = C.JSNumber_methods._shrOtherPositive$1(entry, 4) & 4095;
            bitOffset += code;
            this._updatePointer$1(4 - bits);
          } else if (bits === 0)
            throw H.wrapException(U.ImageException$("TIFFFaxDecoder0"));
          else if (bits === 15)
            throw H.wrapException(U.ImageException$("TIFFFaxDecoder1"));
          else {
            code = C.JSNumber_methods._shrOtherPositive$1(entry, 5) & 2047;
            bitOffset += code;
            this._updatePointer$1(10 - bits);
            if (isT === 0) {
              t1 = this.currChangingElems;
              t2 = this.changingElemSize++;
              if (t2 >= t1.length)
                return H.ioore(t1, t2);
              t1[t2] = bitOffset;
              isWhite = false;
            }
          }
        }
        if (bitOffset === this.width) {
          if (this.compression === 2)
            if (this.bitPointer !== 0) {
              t1 = this.bytePointer;
              if (typeof t1 !== "number")
                return t1.$add();
              this.bytePointer = t1 + 1;
              this.bitPointer = 0;
            }
          break;
        }
        for (; !isWhite;) {
          current = this._nextLesserThan8Bits$1(4);
          if (current >= 16)
            return H.ioore(C.List_89P, current);
          entry = C.List_89P[current];
          isT = J.getInterceptor$n(entry).$and(entry, 1);
          if (typeof entry !== "number")
            return entry.$shr();
          bits = C.JSNumber_methods._shrOtherPositive$1(entry, 1) & 15;
          code = C.JSNumber_methods._shrOtherPositive$1(entry, 5) & 2047;
          if (code === 100) {
            current = this._nextNBits$1(9);
            if (current >= 512)
              return H.ioore(C.List_nLG, current);
            entry = C.List_nLG[current];
            isT = J.getInterceptor$n(entry).$and(entry, 1);
            if (typeof entry !== "number")
              return entry.$shr();
            bits = C.JSNumber_methods._shrOtherPositive$1(entry, 1) & 15;
            code = C.JSNumber_methods._shrOtherPositive$1(entry, 5) & 2047;
            if (bits === 12) {
              this._updatePointer$1(5);
              current = this._nextLesserThan8Bits$1(4);
              if (current >= 16)
                return H.ioore(C.List_MEg, current);
              entry = C.List_MEg[current];
              if (typeof entry !== "number")
                return entry.$shr();
              bits = C.JSNumber_methods._shrOtherPositive$1(entry, 1) & 7;
              code = C.JSNumber_methods._shrOtherPositive$1(entry, 4) & 4095;
              this._setToBlack$4(buffer, lineOffset, bitOffset, code);
              bitOffset += code;
              this._updatePointer$1(4 - bits);
            } else if (bits === 15)
              throw H.wrapException(U.ImageException$("TIFFFaxDecoder2"));
            else {
              this._setToBlack$4(buffer, lineOffset, bitOffset, code);
              bitOffset += code;
              this._updatePointer$1(9 - bits);
              if (isT === 0) {
                t1 = this.currChangingElems;
                t2 = this.changingElemSize++;
                if (t2 >= t1.length)
                  return H.ioore(t1, t2);
                t1[t2] = bitOffset;
                isWhite = true;
              }
            }
          } else {
            if (code === 200) {
              current = this._nextLesserThan8Bits$1(2);
              if (current >= 4)
                return H.ioore(C.List_292_260_226_226, current);
              entry = C.List_292_260_226_226[current];
              if (typeof entry !== "number")
                return entry.$shr();
              code = C.JSNumber_methods._shrOtherPositive$1(entry, 5) & 2047;
              bits = C.JSNumber_methods._shrOtherPositive$1(entry, 1) & 15;
              this._setToBlack$4(buffer, lineOffset, bitOffset, code);
              bitOffset += code;
              this._updatePointer$1(2 - bits);
              t1 = this.currChangingElems;
              t2 = this.changingElemSize++;
              if (t2 >= t1.length)
                return H.ioore(t1, t2);
              t1[t2] = bitOffset;
            } else {
              this._setToBlack$4(buffer, lineOffset, bitOffset, code);
              bitOffset += code;
              this._updatePointer$1(4 - bits);
              t1 = this.currChangingElems;
              t2 = this.changingElemSize++;
              if (t2 >= t1.length)
                return H.ioore(t1, t2);
              t1[t2] = bitOffset;
            }
            isWhite = true;
          }
        }
        if (bitOffset === this.width) {
          if (this.compression === 2)
            if (this.bitPointer !== 0) {
              t1 = this.bytePointer;
              if (typeof t1 !== "number")
                return t1.$add();
              this.bytePointer = t1 + 1;
              this.bitPointer = 0;
            }
          break;
        }
      }
      t1 = this.currChangingElems;
      t2 = this.changingElemSize++;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = bitOffset;
    },
    decode2D$5: function(out, compData, startX, height, tiffT4Options) {
      var scanlineStride, b, t1, lineOffset, a0, a1, b1, b2, entry, code, bits, isWhite, currIndex, temp, bitOffset, lines, currIndex0, number;
      this.data = compData;
      this.compression = 3;
      this.bitPointer = 0;
      this.bytePointer = 0;
      scanlineStride = J.$tdiv$n(J.$add$ns(this.width, 7), 8);
      b = H.setRuntimeTypeInfo(Array(2), [J.JSInt]);
      t1 = J.getInterceptor$n(tiffT4Options);
      this.oneD = t1.$and(tiffT4Options, 1);
      this.uncompressedMode = t1.$and(tiffT4Options, 2) >>> 1;
      this.fillBits = t1.$and(tiffT4Options, 4) >>> 2;
      if (this._readEOL$0() !== 1)
        throw H.wrapException(U.ImageException$("TIFFFaxDecoder3"));
      this._decodeNextScanline$3(out, 0, startX);
      if (typeof scanlineStride !== "number")
        return H.iae(scanlineStride);
      lineOffset = 0 + scanlineStride;
      if (typeof height !== "number")
        return H.iae(height);
      a0 = null;
      a1 = null;
      b1 = null;
      b2 = null;
      entry = null;
      code = null;
      bits = null;
      isWhite = null;
      currIndex = 0;
      temp = null;
      bitOffset = null;
      lines = 1;
      for (; lines < height; ++lines) {
        if (this._readEOL$0() === 0) {
          temp = this.prevChangingElems;
          this.prevChangingElems = this.currChangingElems;
          this.currChangingElems = temp;
          this.lastChangingElement = 0;
          for (bitOffset = startX, a0 = -1, isWhite = true, currIndex = 0; t1 = J.getInterceptor$n(bitOffset), t1.$lt(bitOffset, this.width);) {
            this._getNextChangingElement$3(a0, isWhite, b);
            b1 = b[0];
            b2 = b[1];
            entry = this._nextLesserThan8Bits$1(7);
            if (entry >= 128)
              return H.ioore(C.List_8co, entry);
            entry = J.$and$n(C.List_8co[entry], 255);
            code = (entry & 120) >>> 3;
            bits = entry & 7;
            if (code === 0) {
              if (!isWhite)
                this._setToBlack$4(out, lineOffset, bitOffset, J.$sub$n(b2, bitOffset));
              this._updatePointer$1(7 - bits);
              bitOffset = b2;
              a0 = bitOffset;
            } else if (code === 1) {
              this._updatePointer$1(7 - bits);
              currIndex0 = currIndex + 1;
              if (isWhite) {
                bitOffset = t1.$add(bitOffset, this._decodeWhiteCodeWord$0());
                t1 = this.currChangingElems;
                if (currIndex >= t1.length)
                  return H.ioore(t1, currIndex);
                t1[currIndex] = bitOffset;
                number = this._decodeBlackCodeWord$0();
                this._setToBlack$4(out, lineOffset, bitOffset, number);
                bitOffset = J.$add$ns(bitOffset, number);
                t1 = this.currChangingElems;
                currIndex = currIndex0 + 1;
                if (currIndex0 >= t1.length)
                  return H.ioore(t1, currIndex0);
                t1[currIndex0] = bitOffset;
              } else {
                number = this._decodeBlackCodeWord$0();
                this._setToBlack$4(out, lineOffset, bitOffset, number);
                bitOffset = t1.$add(bitOffset, number);
                t1 = this.currChangingElems;
                if (currIndex >= t1.length)
                  return H.ioore(t1, currIndex);
                t1[currIndex] = bitOffset;
                bitOffset = J.$add$ns(bitOffset, this._decodeWhiteCodeWord$0());
                t1 = this.currChangingElems;
                currIndex = currIndex0 + 1;
                if (currIndex0 >= t1.length)
                  return H.ioore(t1, currIndex0);
                t1[currIndex0] = bitOffset;
              }
              a0 = bitOffset;
            } else {
              if (code <= 8) {
                a1 = J.$add$ns(b1, code - 5);
                t1 = this.currChangingElems;
                currIndex0 = currIndex + 1;
                if (currIndex >= t1.length)
                  return H.ioore(t1, currIndex);
                t1[currIndex] = a1;
                isWhite = !isWhite;
                if (isWhite)
                  this._setToBlack$4(out, lineOffset, bitOffset, J.$sub$n(a1, bitOffset));
                this._updatePointer$1(7 - bits);
              } else
                throw H.wrapException(U.ImageException$("TIFFFaxDecoder4"));
              bitOffset = a1;
              currIndex = currIndex0;
              a0 = bitOffset;
            }
          }
          t1 = this.currChangingElems;
          currIndex0 = currIndex + 1;
          if (currIndex >= t1.length)
            return H.ioore(t1, currIndex);
          t1[currIndex] = bitOffset;
          this.changingElemSize = currIndex0;
          currIndex = currIndex0;
        } else
          this._decodeNextScanline$3(out, lineOffset, startX);
        lineOffset += scanlineStride;
      }
    },
    decodeT6$5: function(out, compData, startX, height, tiffT6Options) {
      var scanlineStride, b, cce, t1, t2, a1, b1, b2, entry, code, bits, lineOffset, lines, temp, bitOffset, a0, isWhite, currIndex, currIndex0, number, zeros, exit;
      this.data = compData;
      this.compression = 4;
      this.bitPointer = 0;
      this.bytePointer = 0;
      scanlineStride = J.$tdiv$n(J.$add$ns(this.width, 7), 8);
      b = H.setRuntimeTypeInfo(Array(2), [J.JSInt]);
      this.uncompressedMode = J.$and$n(tiffT6Options, 2) >>> 1;
      cce = this.currChangingElems;
      this.changingElemSize = 0;
      this.changingElemSize = 1;
      t1 = this.width;
      t2 = cce.length;
      if (0 >= t2)
        return H.ioore(cce, 0);
      cce[0] = t1;
      this.changingElemSize = 2;
      if (1 >= t2)
        return H.ioore(cce, 1);
      cce[1] = t1;
      if (typeof height !== "number")
        return H.iae(height);
      a1 = null;
      b1 = null;
      b2 = null;
      entry = null;
      code = null;
      bits = null;
      lineOffset = 0;
      lines = 0;
      for (; lines < height; ++lines) {
        temp = this.prevChangingElems;
        this.prevChangingElems = this.currChangingElems;
        this.currChangingElems = temp;
        this.lastChangingElement = 0;
        for (t1 = temp.length, bitOffset = startX, a0 = -1, isWhite = true, currIndex = 0; t2 = J.getInterceptor$n(bitOffset), t2.$lt(bitOffset, this.width);) {
          this._getNextChangingElement$3(a0, isWhite, b);
          b1 = b[0];
          b2 = b[1];
          entry = this._nextLesserThan8Bits$1(7);
          if (entry >= 128)
            return H.ioore(C.List_8co, entry);
          entry = J.$and$n(C.List_8co[entry], 255);
          code = (entry & 120) >>> 3;
          bits = entry & 7;
          if (code === 0) {
            if (!isWhite)
              this._setToBlack$4(out, lineOffset, bitOffset, J.$sub$n(b2, bitOffset));
            this._updatePointer$1(7 - bits);
            bitOffset = b2;
            a0 = bitOffset;
          } else if (code === 1) {
            this._updatePointer$1(7 - bits);
            currIndex0 = currIndex + 1;
            if (isWhite) {
              bitOffset = t2.$add(bitOffset, this._decodeWhiteCodeWord$0());
              if (currIndex < 0 || currIndex >= t1)
                return H.ioore(temp, currIndex);
              temp[currIndex] = bitOffset;
              number = this._decodeBlackCodeWord$0();
              this._setToBlack$4(out, lineOffset, bitOffset, number);
              bitOffset = J.$add$ns(bitOffset, number);
              currIndex = currIndex0 + 1;
              if (currIndex0 < 0 || currIndex0 >= t1)
                return H.ioore(temp, currIndex0);
              temp[currIndex0] = bitOffset;
            } else {
              number = this._decodeBlackCodeWord$0();
              this._setToBlack$4(out, lineOffset, bitOffset, number);
              bitOffset = t2.$add(bitOffset, number);
              if (currIndex < 0 || currIndex >= t1)
                return H.ioore(temp, currIndex);
              temp[currIndex] = bitOffset;
              bitOffset = J.$add$ns(bitOffset, this._decodeWhiteCodeWord$0());
              currIndex = currIndex0 + 1;
              if (currIndex0 < 0 || currIndex0 >= t1)
                return H.ioore(temp, currIndex0);
              temp[currIndex0] = bitOffset;
            }
            a0 = bitOffset;
          } else if (code <= 8) {
            a1 = J.$add$ns(b1, code - 5);
            currIndex0 = currIndex + 1;
            if (currIndex < 0 || currIndex >= t1)
              return H.ioore(temp, currIndex);
            temp[currIndex] = a1;
            isWhite = !isWhite;
            if (isWhite)
              this._setToBlack$4(out, lineOffset, bitOffset, J.$sub$n(a1, bitOffset));
            this._updatePointer$1(7 - bits);
            bitOffset = a1;
            currIndex = currIndex0;
            a0 = bitOffset;
          } else if (code === 11) {
            if (this._nextLesserThan8Bits$1(3) !== 7)
              throw H.wrapException(U.ImageException$("TIFFFaxDecoder5"));
            for (zeros = 0, exit = false; !exit;) {
              for (; this._nextLesserThan8Bits$1(1) !== 1;)
                ++zeros;
              if (zeros > 5) {
                zeros -= 6;
                if (!isWhite && zeros > 0) {
                  currIndex0 = currIndex + 1;
                  if (currIndex < 0 || currIndex >= t1)
                    return H.ioore(temp, currIndex);
                  temp[currIndex] = bitOffset;
                  currIndex = currIndex0;
                }
                bitOffset = J.$add$ns(bitOffset, zeros);
                if (zeros > 0)
                  isWhite = true;
                if (this._nextLesserThan8Bits$1(1) === 0) {
                  if (!isWhite) {
                    currIndex0 = currIndex + 1;
                    if (currIndex < 0 || currIndex >= t1)
                      return H.ioore(temp, currIndex);
                    temp[currIndex] = bitOffset;
                    currIndex = currIndex0;
                  }
                  isWhite = true;
                } else {
                  if (isWhite) {
                    currIndex0 = currIndex + 1;
                    if (currIndex < 0 || currIndex >= t1)
                      return H.ioore(temp, currIndex);
                    temp[currIndex] = bitOffset;
                    currIndex = currIndex0;
                  }
                  isWhite = false;
                }
                exit = true;
              }
              if (zeros === 5) {
                if (!isWhite) {
                  currIndex0 = currIndex + 1;
                  if (currIndex < 0 || currIndex >= t1)
                    return H.ioore(temp, currIndex);
                  temp[currIndex] = bitOffset;
                  currIndex = currIndex0;
                }
                bitOffset = J.$add$ns(bitOffset, zeros);
                isWhite = true;
              } else {
                bitOffset = J.$add$ns(bitOffset, zeros);
                currIndex0 = currIndex + 1;
                if (currIndex < 0 || currIndex >= t1)
                  return H.ioore(temp, currIndex);
                temp[currIndex] = bitOffset;
                this._setToBlack$4(out, lineOffset, bitOffset, 1);
                bitOffset = J.$add$ns(bitOffset, 1);
                currIndex = currIndex0;
                isWhite = false;
              }
            }
          } else
            throw H.wrapException(U.ImageException$("TIFFFaxDecoder5 " + code));
        }
        if (currIndex < 0 || currIndex >= t1)
          return H.ioore(temp, currIndex);
        temp[currIndex] = bitOffset;
        this.changingElemSize = currIndex + 1;
        if (typeof scanlineStride !== "number")
          return H.iae(scanlineStride);
        lineOffset += scanlineStride;
      }
    },
    _decodeWhiteCodeWord$0: function() {
      var twoBits, runLength, isWhite, current, entry, isT, bits, t1;
      for (twoBits = null, runLength = 0, isWhite = true; isWhite;) {
        current = this._nextNBits$1(10);
        if (current >= 1024)
          return H.ioore(C.List_VSP, current);
        entry = C.List_VSP[current];
        isT = J.getInterceptor$n(entry).$and(entry, 1);
        if (typeof entry !== "number")
          return entry.$shr();
        bits = C.JSNumber_methods._shrOtherPositive$1(entry, 1) & 15;
        if (bits === 12) {
          twoBits = this._nextLesserThan8Bits$1(2);
          current = (current << 2 & 12 | twoBits) >>> 0;
          if (current >= 16)
            return H.ioore(C.List_MEg, current);
          entry = C.List_MEg[current];
          if (typeof entry !== "number")
            return entry.$shr();
          t1 = C.JSNumber_methods._shrOtherPositive$1(entry, 1);
          runLength += C.JSNumber_methods._shrOtherPositive$1(entry, 4) & 4095;
          this._updatePointer$1(4 - (t1 & 7));
        } else if (bits === 0)
          throw H.wrapException(U.ImageException$("TIFFFaxDecoder0"));
        else if (bits === 15)
          throw H.wrapException(U.ImageException$("TIFFFaxDecoder1"));
        else {
          runLength += C.JSNumber_methods._shrOtherPositive$1(entry, 5) & 2047;
          this._updatePointer$1(10 - bits);
          if (isT === 0)
            isWhite = false;
        }
      }
      return runLength;
    },
    _decodeBlackCodeWord$0: function() {
      var runLength, isWhite, current, entry, t1, code, isT, bits;
      for (runLength = 0, isWhite = false; !isWhite;) {
        current = this._nextLesserThan8Bits$1(4);
        if (current >= 16)
          return H.ioore(C.List_89P, current);
        entry = C.List_89P[current];
        J.getInterceptor$n(entry).$and(entry, 1);
        if (typeof entry !== "number")
          return entry.$shr();
        t1 = C.JSNumber_methods._shrOtherPositive$1(entry, 1);
        code = C.JSNumber_methods._shrOtherPositive$1(entry, 5) & 2047;
        if (code === 100) {
          current = this._nextNBits$1(9);
          if (current >= 512)
            return H.ioore(C.List_nLG, current);
          entry = C.List_nLG[current];
          isT = J.getInterceptor$n(entry).$and(entry, 1);
          if (typeof entry !== "number")
            return entry.$shr();
          bits = C.JSNumber_methods._shrOtherPositive$1(entry, 1) & 15;
          t1 = C.JSNumber_methods._shrOtherPositive$1(entry, 5);
          if (bits === 12) {
            this._updatePointer$1(5);
            current = this._nextLesserThan8Bits$1(4);
            if (current >= 16)
              return H.ioore(C.List_MEg, current);
            entry = C.List_MEg[current];
            if (typeof entry !== "number")
              return entry.$shr();
            t1 = C.JSNumber_methods._shrOtherPositive$1(entry, 1);
            runLength += C.JSNumber_methods._shrOtherPositive$1(entry, 4) & 4095;
            this._updatePointer$1(4 - (t1 & 7));
          } else if (bits === 15)
            throw H.wrapException(U.ImageException$("TIFFFaxDecoder2"));
          else {
            runLength += t1 & 2047;
            this._updatePointer$1(9 - bits);
            if (isT === 0)
              isWhite = true;
          }
        } else {
          if (code === 200) {
            current = this._nextLesserThan8Bits$1(2);
            if (current >= 4)
              return H.ioore(C.List_292_260_226_226, current);
            entry = C.List_292_260_226_226[current];
            if (typeof entry !== "number")
              return entry.$shr();
            runLength += C.JSNumber_methods._shrOtherPositive$1(entry, 5) & 2047;
            this._updatePointer$1(2 - (C.JSNumber_methods._shrOtherPositive$1(entry, 1) & 15));
          } else {
            runLength += code;
            this._updatePointer$1(4 - (t1 & 15));
          }
          isWhite = true;
        }
      }
      return runLength;
    },
    _readEOL$0: function() {
      var t1, bitsLeft, n;
      t1 = this.fillBits;
      if (t1 === 0) {
        if (this._nextNBits$1(12) !== 1)
          throw H.wrapException(U.ImageException$("TIFFFaxDecoder6"));
      } else if (t1 === 1) {
        t1 = this.bitPointer;
        if (typeof t1 !== "number")
          return H.iae(t1);
        bitsLeft = 8 - t1;
        if (this._nextNBits$1(bitsLeft) !== 0)
          throw H.wrapException(U.ImageException$("TIFFFaxDecoder8"));
        if (bitsLeft < 4)
          if (this._nextNBits$1(8) !== 0)
            throw H.wrapException(U.ImageException$("TIFFFaxDecoder8"));
        for (; n = this._nextNBits$1(8), n !== 1;)
          if (n !== 0)
            throw H.wrapException(U.ImageException$("TIFFFaxDecoder8"));
      }
      if (this.oneD === 0)
        return 1;
      else
        return this._nextLesserThan8Bits$1(1);
    },
    _getNextChangingElement$3: function(a0, isWhite, ret) {
      var pce, ces, t1, start, i, temp, t2;
      pce = this.prevChangingElems;
      ces = this.changingElemSize;
      t1 = this.lastChangingElement;
      start = t1 > 0 ? t1 - 1 : 0;
      start = isWhite ? (start & 4294967294) >>> 0 : (start | 1) >>> 0;
      for (t1 = pce.length, i = start; i < ces; i += 2) {
        if (i >= t1)
          return H.ioore(pce, i);
        temp = pce[i];
        if (J.$gt$n(temp, a0)) {
          this.lastChangingElement = i;
          ret[0] = temp;
          break;
        }
      }
      t2 = i + 1;
      if (t2 < ces) {
        if (t2 >= t1)
          return H.ioore(pce, t2);
        ret[1] = pce[t2];
      }
    },
    _setToBlack$4: function(buffer, lineOffset, bitOffset, numBits) {
      var bitNum, lastBit, byteNum, shift, maskVal, val, t1, byteNum0;
      if (typeof bitOffset !== "number")
        return H.iae(bitOffset);
      bitNum = 8 * lineOffset + bitOffset;
      if (typeof numBits !== "number")
        return H.iae(numBits);
      lastBit = bitNum + numBits;
      byteNum = C.JSNumber_methods._shrOtherPositive$1(bitNum, 3);
      shift = bitNum & 7;
      if (shift > 0) {
        maskVal = C.JSInt_methods.$shl(1, 7 - shift);
        val = J.$index$asx(buffer.buffer, J.$add$ns(buffer.offset, byteNum));
        while (true) {
          if (!(maskVal > 0 && bitNum < lastBit))
            break;
          val = J.$or$n(val, maskVal);
          maskVal = maskVal >>> 1;
          ++bitNum;
        }
        J.$indexSet$ax(buffer.buffer, J.$add$ns(buffer.offset, byteNum), val);
      }
      byteNum = C.JSNumber_methods._shrOtherPositive$1(bitNum, 3);
      for (t1 = lastBit - 7; bitNum < t1; byteNum = byteNum0) {
        byteNum0 = byteNum + 1;
        J.$indexSet$ax(buffer.buffer, J.$add$ns(buffer.offset, byteNum), 255);
        bitNum += 8;
      }
      for (; bitNum < lastBit;) {
        byteNum = C.JSNumber_methods._shrOtherPositive$1(bitNum, 3);
        t1 = J.$or$n(J.$index$asx(buffer.buffer, J.$add$ns(buffer.offset, byteNum)), C.JSInt_methods.$shl(1, 7 - (bitNum & 7)));
        J.$indexSet$ax(buffer.buffer, J.$add$ns(buffer.offset, byteNum), t1);
        ++bitNum;
      }
    },
    _nextNBits$1: function(bitsToGet) {
      var t1, l, bp, b, next, next2next, t2, bitsLeft, bitsFromNextByte, bitsFromNext2NextByte, bitsFromNextByte0, i2;
      t1 = this.data;
      l = J.$sub$n(J.$sub$n(t1.end, t1.offset), 1);
      bp = this.bytePointer;
      if (J.$eq(this.fillOrder, 1)) {
        t1 = this.data;
        b = J.$index$asx(t1.buffer, J.$add$ns(t1.offset, bp));
        if (bp == null ? l == null : bp === l) {
          next = 0;
          next2next = 0;
        } else {
          if (typeof bp !== "number")
            return bp.$add();
          t1 = bp + 1;
          t2 = this.data;
          if (t1 === l) {
            next = J.$index$asx(t2.buffer, J.$add$ns(t2.offset, t1));
            next2next = 0;
          } else {
            next = J.$index$asx(t2.buffer, J.$add$ns(t2.offset, t1));
            t1 = this.data;
            next2next = J.$index$asx(t1.buffer, J.$add$ns(t1.offset, bp + 2));
          }
        }
      } else if (J.$eq(this.fillOrder, 2)) {
        t1 = this.data;
        t1 = J.$and$n(J.$index$asx(t1.buffer, J.$add$ns(t1.offset, bp)), 255);
        if (t1 >= 256)
          return H.ioore(C.List_VvJ, t1);
        b = C.List_VvJ[t1];
        if (bp == null ? l == null : bp === l) {
          next = 0;
          next2next = 0;
        } else {
          if (typeof bp !== "number")
            return bp.$add();
          t1 = bp + 1;
          t2 = this.data;
          if (t1 === l) {
            t1 = J.$and$n(J.$index$asx(t2.buffer, J.$add$ns(t2.offset, t1)), 255);
            if (t1 >= 256)
              return H.ioore(C.List_VvJ, t1);
            next = C.List_VvJ[t1];
            next2next = 0;
          } else {
            t1 = J.$and$n(J.$index$asx(t2.buffer, J.$add$ns(t2.offset, t1)), 255);
            if (t1 >= 256)
              return H.ioore(C.List_VvJ, t1);
            next = C.List_VvJ[t1];
            t1 = this.data;
            t1 = J.$and$n(J.$index$asx(t1.buffer, J.$add$ns(t1.offset, bp + 2)), 255);
            if (t1 >= 256)
              return H.ioore(C.List_VvJ, t1);
            next2next = C.List_VvJ[t1];
          }
        }
      } else
        throw H.wrapException(U.ImageException$("TIFFFaxDecoder7"));
      t1 = this.bitPointer;
      if (typeof t1 !== "number")
        return H.iae(t1);
      bitsLeft = 8 - t1;
      bitsFromNextByte = bitsToGet - bitsLeft;
      if (bitsFromNextByte > 8) {
        bitsFromNext2NextByte = bitsFromNextByte - 8;
        bitsFromNextByte0 = 8;
      } else {
        bitsFromNextByte0 = bitsFromNextByte;
        bitsFromNext2NextByte = 0;
      }
      t1 = this.bytePointer;
      if (typeof t1 !== "number")
        return t1.$add();
      this.bytePointer = t1 + 1;
      if (bitsLeft >>> 0 !== bitsLeft || bitsLeft >= 9)
        return H.ioore(C.List_knt, bitsLeft);
      t1 = J.$and$n(b, C.List_knt[bitsLeft]);
      if (typeof t1 !== "number")
        return t1.$shl();
      t1 = C.JSInt_methods.$shl(t1, bitsFromNextByte);
      if (bitsFromNextByte0 >>> 0 !== bitsFromNextByte0 || bitsFromNextByte0 >= 9)
        return H.ioore(C.List_knt0, bitsFromNextByte0);
      t2 = J.$and$n(next, C.List_knt0[bitsFromNextByte0]);
      if (typeof t2 !== "number")
        return t2.$shr();
      i2 = C.JSInt_methods._shrReceiverPositive$1(t2, 8 - bitsFromNextByte0);
      if (bitsFromNext2NextByte !== 0) {
        i2 = C.JSInt_methods.$shl(i2, bitsFromNext2NextByte);
        if (bitsFromNext2NextByte >>> 0 !== bitsFromNext2NextByte || bitsFromNext2NextByte >= 9)
          return H.ioore(C.List_knt0, bitsFromNext2NextByte);
        t2 = J.$and$n(next2next, C.List_knt0[bitsFromNext2NextByte]);
        if (typeof t2 !== "number")
          return t2.$shr();
        i2 |= C.JSInt_methods._shrReceiverPositive$1(t2, 8 - bitsFromNext2NextByte);
        t2 = this.bytePointer;
        if (typeof t2 !== "number")
          return t2.$add();
        this.bytePointer = t2 + 1;
        this.bitPointer = bitsFromNext2NextByte;
      } else if (bitsFromNextByte0 === 8) {
        this.bitPointer = 0;
        t2 = this.bytePointer;
        if (typeof t2 !== "number")
          return t2.$add();
        this.bytePointer = t2 + 1;
      } else
        this.bitPointer = bitsFromNextByte0;
      return (t1 | i2) >>> 0;
    },
    _nextLesserThan8Bits$1: function(bitsToGet) {
      var t1, l, bp, b, next, bitsLeft, bitsFromNextByte, shift, i1, t2;
      t1 = this.data;
      l = J.$sub$n(J.$sub$n(t1.end, t1.offset), 1);
      bp = this.bytePointer;
      if (J.$eq(this.fillOrder, 1)) {
        t1 = this.data;
        b = J.$index$asx(t1.buffer, J.$add$ns(t1.offset, bp));
        if (bp == null ? l == null : bp === l)
          next = 0;
        else {
          t1 = this.data;
          if (typeof bp !== "number")
            return bp.$add();
          next = J.$index$asx(t1.buffer, J.$add$ns(t1.offset, bp + 1));
        }
      } else if (J.$eq(this.fillOrder, 2)) {
        t1 = this.data;
        t1 = J.$and$n(J.$index$asx(t1.buffer, J.$add$ns(t1.offset, bp)), 255);
        if (t1 >= 256)
          return H.ioore(C.List_VvJ, t1);
        b = C.List_VvJ[t1];
        if (bp == null ? l == null : bp === l)
          next = 0;
        else {
          t1 = this.data;
          if (typeof bp !== "number")
            return bp.$add();
          t1 = J.$and$n(J.$index$asx(t1.buffer, J.$add$ns(t1.offset, bp + 1)), 255);
          if (t1 >= 256)
            return H.ioore(C.List_VvJ, t1);
          next = C.List_VvJ[t1];
        }
      } else
        throw H.wrapException(U.ImageException$("TIFFFaxDecoder7"));
      t1 = this.bitPointer;
      if (typeof t1 !== "number")
        return H.iae(t1);
      bitsLeft = 8 - t1;
      bitsFromNextByte = bitsToGet - bitsLeft;
      shift = bitsLeft - bitsToGet;
      t1 = J.getInterceptor$n(b);
      if (shift >= 0) {
        if (bitsLeft >>> 0 !== bitsLeft || bitsLeft >= 9)
          return H.ioore(C.List_knt, bitsLeft);
        t1 = t1.$and(b, C.List_knt[bitsLeft]);
        if (typeof t1 !== "number")
          return t1.$shr();
        i1 = C.JSInt_methods._shrReceiverPositive$1(t1, shift);
        t1 = this.bitPointer;
        if (typeof t1 !== "number")
          return t1.$add();
        t1 += bitsToGet;
        this.bitPointer = t1;
        if (t1 === 8) {
          this.bitPointer = 0;
          t1 = this.bytePointer;
          if (typeof t1 !== "number")
            return t1.$add();
          this.bytePointer = t1 + 1;
        }
      } else {
        if (bitsLeft >>> 0 !== bitsLeft || bitsLeft >= 9)
          return H.ioore(C.List_knt, bitsLeft);
        t1 = t1.$and(b, C.List_knt[bitsLeft]);
        if (typeof t1 !== "number")
          return t1.$shl();
        t1 = C.JSInt_methods.$shl(t1, -shift);
        if (bitsFromNextByte >>> 0 !== bitsFromNextByte || bitsFromNextByte >= 9)
          return H.ioore(C.List_knt0, bitsFromNextByte);
        t2 = J.$and$n(next, C.List_knt0[bitsFromNextByte]);
        if (typeof t2 !== "number")
          return t2.$shr();
        i1 = (t1 | C.JSInt_methods._shrReceiverPositive$1(t2, 8 - bitsFromNextByte)) >>> 0;
        t2 = this.bytePointer;
        if (typeof t2 !== "number")
          return t2.$add();
        this.bytePointer = t2 + 1;
        this.bitPointer = bitsFromNextByte;
      }
      return i1;
    },
    _updatePointer$1: function(bitsToMoveBack) {
      var t1, i;
      t1 = this.bitPointer;
      if (typeof t1 !== "number")
        return t1.$sub();
      i = t1 - bitsToMoveBack;
      if (i < 0) {
        t1 = this.bytePointer;
        if (typeof t1 !== "number")
          return t1.$sub();
        this.bytePointer = t1 - 1;
        this.bitPointer = 8 + i;
      } else
        this.bitPointer = i;
    },
    TiffFaxDecoder$3: function(fillOrder, width, height) {
      var t1 = this.width;
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.prevChangingElems = H.setRuntimeTypeInfo(Array(t1), [J.JSInt]);
      t1 = this.width;
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.currChangingElems = H.setRuntimeTypeInfo(Array(t1), [J.JSInt]);
    },
    static: {"^": "TiffFaxDecoder_TABLE1,TiffFaxDecoder_TABLE2,TiffFaxDecoder_FLIP_TABLE,TiffFaxDecoder_WHITE,TiffFaxDecoder_ADDITIONAL_MAKEUP,TiffFaxDecoder_INIT_BLACK,TiffFaxDecoder_TWO_BIT_BLACK,TiffFaxDecoder_BLACK,TiffFaxDecoder_TWO_D_CODES", TiffFaxDecoder$: function(fillOrder, width, height) {
        var t1 = new U.TiffFaxDecoder(width, height, fillOrder, 0, null, null, null, null, null, 0, 2, 0, 0, null);
        t1.TiffFaxDecoder$3(fillOrder, width, height);
        return t1;
      }}
  },
  TiffImage: {
    "^": "Object;tags,width>,height>,photometricType,compression,bitsPerSample<,samplesPerPixel<,imageType,isWhiteZero,predictor,chromaSubH,chromaSubV,tiled,tileWidth,tileHeight,tileOffsets,tileByteCounts,tilesX,tilesY,tileSize,fillOrder,t4Options,t6Options,extraSamples,colorMap<,colorMapRed,colorMapGreen,colorMapBlue,image",
    decode$1: function(p) {
      var tileY, ti, t1, tileX;
      this.image = U.Image$(this.width, this.height, 4);
      tileY = 0;
      ti = 0;
      while (true) {
        t1 = this.tilesY;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(tileY < t1))
          break;
        tileX = 0;
        while (true) {
          t1 = this.tilesX;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(tileX < t1))
            break;
          this._decodeTile$3(p, tileX, tileY);
          ++tileX;
          ++ti;
        }
        ++tileY;
      }
      return this.image;
    },
    _decodeTile$3: function(p, tileX, tileY) {
      var byteCount, bdata, decoder, t1, tileIndex, outX, t2, outY, t3, bytesInThisTile, exception, j, count, i, len, t4, t5, t6, t7, t8, data, outData, jpeg, py, pi, y, px, x, pi0, gray, c;
      if (this.imageType === 0) {
        this._decodeBilevelTile$3(p, tileX, tileY);
        return;
      }
      t1 = this.tilesX;
      if (typeof t1 !== "number")
        return H.iae(t1);
      tileIndex = tileY * t1 + tileX;
      t1 = this.tileOffsets;
      if (tileIndex >>> 0 !== tileIndex || tileIndex >= t1.length)
        return H.ioore(t1, tileIndex);
      J.set$offset$x(p, t1[tileIndex]);
      t1 = this.tileWidth;
      if (typeof t1 !== "number")
        return H.iae(t1);
      outX = tileX * t1;
      t2 = this.tileHeight;
      if (typeof t2 !== "number")
        return H.iae(t2);
      outY = tileY * t2;
      t3 = this.tileByteCounts;
      if (tileIndex >= t3.length)
        return H.ioore(t3, tileIndex);
      byteCount = t3[tileIndex];
      t3 = this.samplesPerPixel;
      if (typeof t3 !== "number")
        return H.iae(t3);
      bytesInThisTile = t1 * t2 * t3;
      if (J.$eq(this.bitsPerSample, 16))
        bytesInThisTile *= 2;
      bdata = null;
      if (J.$eq(this.bitsPerSample, 8) || J.$eq(this.bitsPerSample, 16)) {
        if (J.$eq(this.compression, 1))
          bdata = p;
        else if (J.$eq(this.compression, 5)) {
          if (typeof bytesInThisTile !== "number" || Math.floor(bytesInThisTile) !== bytesInThisTile)
            H.throwExpression(P.ArgumentError$("Invalid length " + H.S(bytesInThisTile)));
          t1 = new Uint8Array(bytesInThisTile);
          t2 = t1.length;
          bdata = new U.InputBuffer(t1, 0, t2, 0, false);
          decoder = new U.LzwDecoder(9, 0, 0, 0, 0, null, null, null, null, new Uint8Array(4096), null, null, null, null);
          try {
            decoder.decode$2(U.InputBuffer$from(p, byteCount, 0), J.get$buffer$x(bdata));
          } catch (exception) {
            H.unwrapException(exception);
          }

          if (J.$eq(this.predictor, 2)) {
            j = 0;
            while (true) {
              t1 = this.tileHeight;
              if (typeof t1 !== "number")
                return H.iae(t1);
              if (!(j < t1))
                break;
              t1 = this.samplesPerPixel;
              t2 = this.tileWidth;
              if (typeof t2 !== "number")
                return H.iae(t2);
              count = J.$mul$ns(t1, j * t2 + 1);
              for (i = this.samplesPerPixel, len = J.$mul$ns(this.tileWidth, i); t1 = J.getInterceptor$n(i), t1.$lt(i, len); i = t1.$add(i, 1)) {
                t2 = bdata;
                t3 = J.getInterceptor$x(t2);
                t4 = J.$index$asx(t3.get$buffer(t2), J.$add$ns(t3.get$offset(t2), count));
                t5 = bdata;
                t6 = J.getInterceptor$n(count);
                t7 = t6.$sub(count, this.samplesPerPixel);
                t8 = J.getInterceptor$x(t5);
                t7 = J.$add$ns(t4, J.$index$asx(t8.get$buffer(t5), J.$add$ns(t8.get$offset(t5), t7)));
                J.$indexSet$ax(t3.get$buffer(t2), J.$add$ns(t3.get$offset(t2), count), t7);
                count = t6.$add(count, 1);
              }
              ++j;
            }
          }
        } else if (J.$eq(this.compression, 32773)) {
          if (typeof bytesInThisTile !== "number" || Math.floor(bytesInThisTile) !== bytesInThisTile)
            H.throwExpression(P.ArgumentError$("Invalid length " + H.S(bytesInThisTile)));
          t1 = new Uint8Array(bytesInThisTile);
          t2 = t1.length;
          bdata = new U.InputBuffer(t1, 0, t2, 0, false);
          this._decodePackbits$3(p, bytesInThisTile, J.get$buffer$x(bdata));
        } else if (J.$eq(this.compression, 32946)) {
          data = J.toList$2$ax(p, 0, byteCount);
          t1 = T.HuffmanTable$(C.List_2Bc);
          t2 = T.HuffmanTable$(C.List_X3d);
          t3 = new T.InputStream(data, null, 0, 0, null);
          t3._archive$_length = data.length;
          t3.offset = 0;
          t4 = new T.OutputStream(0, 0, new Uint8Array(32768));
          new T.Inflate(t3, t4, 0, 0, 0, t1, t2)._inflate$0();
          t2 = t4._archive$_buffer.buffer;
          t4 = t4.length;
          H._checkViewArguments(t2, 0, t4);
          outData = t4 == null ? new Uint8Array(t2, 0) : new Uint8Array(t2, 0, t4);
          t1 = outData.length;
          bdata = new U.InputBuffer(outData, 0, t1, 0, false);
        } else if (J.$eq(this.compression, 8)) {
          data = J.toList$2$ax(p, 0, byteCount);
          t1 = new T.InputStream(data, null, 0, 1, null);
          t1._archive$_length = data.length;
          t1.offset = 0;
          outData = new T.ZLibDecoder().decodeBuffer$2$verify(t1, true);
          t1 = outData.length;
          bdata = new U.InputBuffer(outData, 0, t1, 0, false);
        } else if (J.$eq(this.compression, 6)) {
          jpeg = new U.JpegData(null, null, null, null, null, null, Array(4), [], [], [], [], 0, 0);
          jpeg.read$1(J.toList$2$ax(p, 0, byteCount));
          this._jpegToImage$6(jpeg, this.image, outX, outY, this.tileWidth, this.tileHeight);
          return;
        } else
          throw H.wrapException(U.ImageException$("Unsupported Compression Type: " + H.S(this.compression)));
        if (bdata == null)
          return;
        py = outY;
        pi = 0;
        y = 0;
        while (true) {
          t1 = this.tileHeight;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (y < t1) {
            t1 = this.height;
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = py < t1;
          } else
            t1 = false;
          if (!t1)
            break;
          t1 = py >= 0;
          px = outX;
          x = 0;
          while (true) {
            t2 = this.tileWidth;
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (x < t2) {
              t2 = this.width;
              if (typeof t2 !== "number")
                return H.iae(t2);
              t2 = px < t2;
            } else
              t2 = false;
            if (!t2)
              break;
            if (J.$eq(this.samplesPerPixel, 1)) {
              t2 = bdata;
              pi0 = pi + 1;
              t3 = J.getInterceptor$x(t2);
              gray = J.$index$asx(t3.get$buffer(t2), J.$add$ns(t3.get$offset(t2), pi));
              if (J.$eq(this.photometricType, 3) && this.colorMap != null) {
                t2 = this.colorMap;
                t3 = this.colorMapRed;
                if (typeof t3 !== "number")
                  return t3.$add();
                if (typeof gray !== "number")
                  return H.iae(gray);
                t3 += gray;
                t4 = t2.length;
                if (t3 >>> 0 !== t3 || t3 >= t4)
                  return H.ioore(t2, t3);
                t3 = t2[t3];
                t5 = this.colorMapGreen;
                if (typeof t5 !== "number")
                  return t5.$add();
                t5 += gray;
                if (t5 >>> 0 !== t5 || t5 >= t4)
                  return H.ioore(t2, t5);
                t5 = t2[t5];
                t6 = this.colorMapBlue;
                if (typeof t6 !== "number")
                  return t6.$add();
                t6 += gray;
                if (t6 >>> 0 !== t6 || t6 >= t4)
                  return H.ioore(t2, t6);
                t6 = t2[t6];
                t2 = C.JSInt_methods.clamp$2(255, 0, 255);
                t6 = J.clamp$2$n(t6, 0, 255);
                if (typeof t6 !== "number")
                  return t6.$shl();
                t5 = J.clamp$2$n(t5, 0, 255);
                if (typeof t5 !== "number")
                  return t5.$shl();
                t3 = J.clamp$2$n(t3, 0, 255);
                if (typeof t3 !== "number")
                  return H.iae(t3);
                c = (t2 << 24 | t6 << 16 | t5 << 8 | t3) >>> 0;
              } else {
                t2 = C.JSInt_methods.clamp$2(255, 0, 255);
                t3 = J.getInterceptor$n(gray);
                t4 = t3.clamp$2(gray, 0, 255);
                if (typeof t4 !== "number")
                  return t4.$shl();
                t5 = t3.clamp$2(gray, 0, 255);
                if (typeof t5 !== "number")
                  return t5.$shl();
                t3 = t3.clamp$2(gray, 0, 255);
                if (typeof t3 !== "number")
                  return H.iae(t3);
                c = (t2 << 24 | t4 << 16 | t5 << 8 | t3) >>> 0;
              }
              t2 = this.image;
              t2.toString;
              if (px >= 0) {
                t3 = t2.width;
                if (typeof t3 !== "number")
                  return H.iae(t3);
                if (px < t3)
                  if (t1) {
                    t3 = t2.height;
                    if (typeof t3 !== "number")
                      return H.iae(t3);
                    t3 = py < t3;
                  } else
                    t3 = false;
                else
                  t3 = false;
              } else
                t3 = false;
              if (t3) {
                t3 = t2.data;
                t2 = t2.width;
                if (typeof t2 !== "number")
                  return H.iae(t2);
                t2 = py * t2 + px;
                if (t2 >>> 0 !== t2 || t2 >= t3.length)
                  return H.ioore(t3, t2);
                t3[t2] = c;
              }
              pi = pi0;
            } else if (J.$eq(this.samplesPerPixel, 2)) {
              t2 = bdata;
              pi0 = pi + 1;
              t3 = J.getInterceptor$x(t2);
              gray = J.$index$asx(t3.get$buffer(t2), J.$add$ns(t3.get$offset(t2), pi));
              t2 = bdata;
              pi = pi0 + 1;
              t3 = J.getInterceptor$x(t2);
              t2 = J.clamp$2$n(J.$index$asx(t3.get$buffer(t2), J.$add$ns(t3.get$offset(t2), pi0)), 0, 255);
              if (typeof t2 !== "number")
                return t2.$shl();
              t3 = J.getInterceptor$n(gray);
              t4 = t3.clamp$2(gray, 0, 255);
              if (typeof t4 !== "number")
                return t4.$shl();
              t5 = t3.clamp$2(gray, 0, 255);
              if (typeof t5 !== "number")
                return t5.$shl();
              t3 = t3.clamp$2(gray, 0, 255);
              if (typeof t3 !== "number")
                return H.iae(t3);
              t6 = this.image;
              t6.toString;
              if (px >= 0) {
                t7 = t6.width;
                if (typeof t7 !== "number")
                  return H.iae(t7);
                if (px < t7)
                  if (t1) {
                    t7 = t6.height;
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    t7 = py < t7;
                  } else
                    t7 = false;
                else
                  t7 = false;
              } else
                t7 = false;
              if (t7) {
                t7 = t6.data;
                t6 = t6.width;
                if (typeof t6 !== "number")
                  return H.iae(t6);
                t6 = py * t6 + px;
                if (t6 >>> 0 !== t6 || t6 >= t7.length)
                  return H.ioore(t7, t6);
                t7[t6] = (t2 << 24 | t4 << 16 | t5 << 8 | t3) >>> 0;
              }
            } else if (J.$eq(this.samplesPerPixel, 3)) {
              t2 = bdata;
              pi0 = pi + 1;
              t3 = J.getInterceptor$x(t2);
              t2 = J.$index$asx(t3.get$buffer(t2), J.$add$ns(t3.get$offset(t2), pi));
              t3 = bdata;
              pi = pi0 + 1;
              t4 = J.getInterceptor$x(t3);
              t3 = J.$index$asx(t4.get$buffer(t3), J.$add$ns(t4.get$offset(t3), pi0));
              t4 = bdata;
              pi0 = pi + 1;
              t5 = J.getInterceptor$x(t4);
              t4 = J.$index$asx(t5.get$buffer(t4), J.$add$ns(t5.get$offset(t4), pi));
              t5 = C.JSInt_methods.clamp$2(255, 0, 255);
              t4 = J.clamp$2$n(t4, 0, 255);
              if (typeof t4 !== "number")
                return t4.$shl();
              t3 = J.clamp$2$n(t3, 0, 255);
              if (typeof t3 !== "number")
                return t3.$shl();
              t2 = J.clamp$2$n(t2, 0, 255);
              if (typeof t2 !== "number")
                return H.iae(t2);
              t6 = this.image;
              t6.toString;
              if (px >= 0) {
                t7 = t6.width;
                if (typeof t7 !== "number")
                  return H.iae(t7);
                if (px < t7)
                  if (t1) {
                    t7 = t6.height;
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    t7 = py < t7;
                  } else
                    t7 = false;
                else
                  t7 = false;
              } else
                t7 = false;
              if (t7) {
                t7 = t6.data;
                t6 = t6.width;
                if (typeof t6 !== "number")
                  return H.iae(t6);
                t6 = py * t6 + px;
                if (t6 >>> 0 !== t6 || t6 >= t7.length)
                  return H.ioore(t7, t6);
                t7[t6] = (t5 << 24 | t4 << 16 | t3 << 8 | t2) >>> 0;
              }
              pi = pi0;
            } else if (J.$ge$n(this.samplesPerPixel, 4)) {
              t2 = bdata;
              pi0 = pi + 1;
              t3 = J.getInterceptor$x(t2);
              t2 = J.$index$asx(t3.get$buffer(t2), J.$add$ns(t3.get$offset(t2), pi));
              t3 = bdata;
              pi = pi0 + 1;
              t4 = J.getInterceptor$x(t3);
              t3 = J.$index$asx(t4.get$buffer(t3), J.$add$ns(t4.get$offset(t3), pi0));
              t4 = bdata;
              pi0 = pi + 1;
              t5 = J.getInterceptor$x(t4);
              t4 = J.$index$asx(t5.get$buffer(t4), J.$add$ns(t5.get$offset(t4), pi));
              t5 = bdata;
              pi = pi0 + 1;
              t6 = J.getInterceptor$x(t5);
              t5 = J.clamp$2$n(J.$index$asx(t6.get$buffer(t5), J.$add$ns(t6.get$offset(t5), pi0)), 0, 255);
              if (typeof t5 !== "number")
                return t5.$shl();
              t4 = J.clamp$2$n(t4, 0, 255);
              if (typeof t4 !== "number")
                return t4.$shl();
              t3 = J.clamp$2$n(t3, 0, 255);
              if (typeof t3 !== "number")
                return t3.$shl();
              t2 = J.clamp$2$n(t2, 0, 255);
              if (typeof t2 !== "number")
                return H.iae(t2);
              t6 = this.image;
              t6.toString;
              if (px >= 0) {
                t7 = t6.width;
                if (typeof t7 !== "number")
                  return H.iae(t7);
                if (px < t7)
                  if (t1) {
                    t7 = t6.height;
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    t7 = py < t7;
                  } else
                    t7 = false;
                else
                  t7 = false;
              } else
                t7 = false;
              if (t7) {
                t7 = t6.data;
                t6 = t6.width;
                if (typeof t6 !== "number")
                  return H.iae(t6);
                t6 = py * t6 + px;
                if (t6 >>> 0 !== t6 || t6 >= t7.length)
                  return H.ioore(t7, t6);
                t7[t6] = (t5 << 24 | t4 << 16 | t3 << 8 | t2) >>> 0;
              }
            }
            ++x;
            ++px;
          }
          ++y;
          ++py;
        }
      } else
        throw H.wrapException(U.ImageException$("Unsupported bitsPerSample: " + H.S(this.bitsPerSample)));
    },
    _jpegToImage$6: function(jpeg, image, outX, outY, tileWidth, tileHeight) {
      var data, t1, i, y, t2, t3, x, i0, $Y, t4, t5, t6, t7, t8, t9, t10, $R, $G, $B, $C, $M, $K;
      data = jpeg.getData$2(tileWidth, tileHeight);
      switch (jpeg.components.length) {
        case 1:
          if (typeof tileHeight !== "number")
            return H.iae(tileHeight);
          t1 = data.length;
          i = 0;
          y = 0;
          for (; y < tileHeight; ++y) {
            if (typeof tileWidth !== "number")
              return H.iae(tileWidth);
            t2 = y + outY;
            t3 = t2 >= 0;
            x = 0;
            for (; x < tileWidth; ++x, i = i0) {
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(data, i);
              $Y = data[i];
              t4 = x + outX;
              t5 = C.JSInt_methods.clamp$2(255, 0, 255);
              t6 = C.JSInt_methods.clamp$2($Y, 0, 255);
              t7 = C.JSInt_methods.clamp$2($Y, 0, 255);
              t8 = C.JSInt_methods.clamp$2($Y, 0, 255);
              image.toString;
              if (t4 >= 0) {
                t9 = image.width;
                if (typeof t9 !== "number")
                  return H.iae(t9);
                if (t4 < t9)
                  if (t3) {
                    t9 = image.height;
                    if (typeof t9 !== "number")
                      return H.iae(t9);
                    t9 = t2 < t9;
                  } else
                    t9 = false;
                else
                  t9 = false;
              } else
                t9 = false;
              if (t9) {
                t9 = image.data;
                t10 = image.width;
                if (typeof t10 !== "number")
                  return H.iae(t10);
                t4 = t2 * t10 + t4;
                if (t4 >>> 0 !== t4 || t4 >= t9.length)
                  return H.ioore(t9, t4);
                t9[t4] = (t5 << 24 | t6 << 16 | t7 << 8 | t8) >>> 0;
              }
            }
          }
          break;
        case 3:
          if (typeof tileHeight !== "number")
            return H.iae(tileHeight);
          t1 = data.length;
          i = 0;
          y = 0;
          for (; y < tileHeight; ++y) {
            if (typeof tileWidth !== "number")
              return H.iae(tileWidth);
            t2 = y + outY;
            t3 = t2 >= 0;
            x = 0;
            for (; x < tileWidth; ++x, i = i0) {
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(data, i);
              $R = data[i];
              i = i0 + 1;
              if (i0 < 0 || i0 >= t1)
                return H.ioore(data, i0);
              $G = data[i0];
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(data, i);
              $B = data[i];
              t4 = C.JSInt_methods.clamp$2(255, 0, 255);
              t5 = C.JSInt_methods.clamp$2($B, 0, 255);
              t6 = C.JSInt_methods.clamp$2($G, 0, 255);
              t7 = C.JSInt_methods.clamp$2($R, 0, 255);
              t8 = x + outX;
              image.toString;
              if (t8 >= 0) {
                t9 = image.width;
                if (typeof t9 !== "number")
                  return H.iae(t9);
                if (t8 < t9)
                  if (t3) {
                    t9 = image.height;
                    if (typeof t9 !== "number")
                      return H.iae(t9);
                    t9 = t2 < t9;
                  } else
                    t9 = false;
                else
                  t9 = false;
              } else
                t9 = false;
              if (t9) {
                t9 = image.data;
                t10 = image.width;
                if (typeof t10 !== "number")
                  return H.iae(t10);
                t8 = t2 * t10 + t8;
                if (t8 >>> 0 !== t8 || t8 >= t9.length)
                  return H.ioore(t9, t8);
                t9[t8] = (t4 << 24 | t5 << 16 | t6 << 8 | t7) >>> 0;
              }
            }
          }
          break;
        case 4:
          if (typeof tileHeight !== "number")
            return H.iae(tileHeight);
          t1 = data.length;
          i = 0;
          y = 0;
          for (; y < tileHeight; ++y) {
            if (typeof tileWidth !== "number")
              return H.iae(tileWidth);
            t2 = y + outY;
            t3 = t2 >= 0;
            x = 0;
            for (; x < tileWidth; ++x) {
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(data, i);
              $C = data[i];
              i = i0 + 1;
              if (i0 < 0 || i0 >= t1)
                return H.ioore(data, i0);
              $M = data[i0];
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(data, i);
              $Y = data[i];
              i = i0 + 1;
              if (i0 < 0 || i0 >= t1)
                return H.ioore(data, i0);
              $K = data[i0];
              t4 = 1 - ($K / 255 | 0);
              t5 = $C * t4 + $K;
              if (t5 < 0)
                t5 = 0;
              else if (t5 > 255)
                t5 = 255;
              t6 = $M * t4 + $K;
              if (t6 < 0)
                t6 = 0;
              else if (t6 > 255)
                t6 = 255;
              t4 = $Y * t4 + $K;
              if (t4 < 0)
                t4 = 0;
              else if (t4 > 255)
                t4 = 255;
              t7 = x + outX;
              t8 = C.JSInt_methods.clamp$2(255, 0, 255);
              t4 = C.JSInt_methods.clamp$2(255 - t4, 0, 255);
              t6 = C.JSInt_methods.clamp$2(255 - t6, 0, 255);
              t5 = C.JSInt_methods.clamp$2(255 - t5, 0, 255);
              image.toString;
              if (t7 >= 0) {
                t9 = image.width;
                if (typeof t9 !== "number")
                  return H.iae(t9);
                if (t7 < t9)
                  if (t3) {
                    t9 = image.height;
                    if (typeof t9 !== "number")
                      return H.iae(t9);
                    t9 = t2 < t9;
                  } else
                    t9 = false;
                else
                  t9 = false;
              } else
                t9 = false;
              if (t9) {
                t9 = image.data;
                t10 = image.width;
                if (typeof t10 !== "number")
                  return H.iae(t10);
                t7 = t2 * t10 + t7;
                if (t7 >>> 0 !== t7 || t7 >= t9.length)
                  return H.ioore(t9, t7);
                t9[t7] = (t8 << 24 | t4 << 16 | t6 << 8 | t5) >>> 0;
              }
            }
          }
          break;
        default:
          throw H.wrapException("Unsupported color mode");
      }
    },
    _decodeBilevelTile$3: function(p, tileX, tileY) {
      var bdata, t1, tileIndex, outX, outY, byteCount, t2, bytesInThisTile, j, count, i, t3, t4, t5, t6, t7, t8, exception, br, white, black, py, y, px, x;
      t1 = this.tilesX;
      if (typeof t1 !== "number")
        return H.iae(t1);
      tileIndex = tileY * t1 + tileX;
      t1 = this.tileOffsets;
      if (tileIndex >>> 0 !== tileIndex || tileIndex >= t1.length)
        return H.ioore(t1, tileIndex);
      J.set$offset$x(p, t1[tileIndex]);
      t1 = this.tileWidth;
      if (typeof t1 !== "number")
        return H.iae(t1);
      outX = tileX * t1;
      t1 = this.tileHeight;
      if (typeof t1 !== "number")
        return H.iae(t1);
      outY = tileY * t1;
      t1 = this.tileByteCounts;
      if (tileIndex >= t1.length)
        return H.ioore(t1, tileIndex);
      byteCount = t1[tileIndex];
      bdata = null;
      if (J.$eq(this.compression, 32773)) {
        t1 = J.$mod$n(this.tileWidth, 8);
        t2 = this.tileWidth;
        bytesInThisTile = t1 === 0 ? J.$mul$ns(J.$tdiv$n(t2, 8), this.tileHeight) : J.$mul$ns(J.$add$ns(J.$tdiv$n(t2, 8), 1), this.tileHeight);
        t1 = J.$mul$ns(this.tileWidth, this.tileHeight);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        bdata = U.InputBuffer$(new Uint8Array(t1), false, null, 0);
        this._decodePackbits$3(p, bytesInThisTile, J.get$buffer$x(bdata));
      } else if (J.$eq(this.compression, 5)) {
        t1 = J.$mul$ns(this.tileWidth, this.tileHeight);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        bdata = U.InputBuffer$(new Uint8Array(t1), false, null, 0);
        new U.LzwDecoder(9, 0, 0, 0, 0, null, null, null, null, new Uint8Array(4096), null, null, null, null).decode$2(U.InputBuffer$from(p, byteCount, 0), J.get$buffer$x(bdata));
        if (J.$eq(this.predictor, 2)) {
          j = 0;
          while (true) {
            t1 = this.height;
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (!(j < t1))
              break;
            t1 = this.samplesPerPixel;
            t2 = this.width;
            if (typeof t2 !== "number")
              return H.iae(t2);
            count = J.$mul$ns(t1, j * t2 + 1);
            for (i = this.samplesPerPixel; t1 = J.getInterceptor$n(i), t1.$lt(i, J.$mul$ns(this.width, this.samplesPerPixel)); i = t1.$add(i, 1)) {
              t2 = bdata;
              t3 = J.getInterceptor$x(t2);
              t4 = J.$index$asx(t3.get$buffer(t2), J.$add$ns(t3.get$offset(t2), count));
              t5 = bdata;
              t6 = J.getInterceptor$n(count);
              t7 = t6.$sub(count, this.samplesPerPixel);
              t8 = J.getInterceptor$x(t5);
              t7 = J.$add$ns(t4, J.$index$asx(t8.get$buffer(t5), J.$add$ns(t8.get$offset(t5), t7)));
              J.$indexSet$ax(t3.get$buffer(t2), J.$add$ns(t3.get$offset(t2), count), t7);
              count = t6.$add(count, 1);
            }
            ++j;
          }
        }
      } else if (J.$eq(this.compression, 2)) {
        t1 = J.$mul$ns(this.tileWidth, this.tileHeight);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        bdata = U.InputBuffer$(new Uint8Array(t1), false, null, 0);
        try {
          U.TiffFaxDecoder$(this.fillOrder, this.tileWidth, this.tileHeight).decode1D$4(bdata, p, 0, this.tileHeight);
        } catch (exception) {
          H.unwrapException(exception);
        }

      } else if (J.$eq(this.compression, 3)) {
        t1 = J.$mul$ns(this.tileWidth, this.tileHeight);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        bdata = U.InputBuffer$(new Uint8Array(t1), false, null, 0);
        try {
          U.TiffFaxDecoder$(this.fillOrder, this.tileWidth, this.tileHeight).decode2D$5(bdata, p, 0, this.tileHeight, this.t4Options);
        } catch (exception) {
          H.unwrapException(exception);
        }

      } else if (J.$eq(this.compression, 4)) {
        t1 = J.$mul$ns(this.tileWidth, this.tileHeight);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        bdata = U.InputBuffer$(new Uint8Array(t1), false, null, 0);
        try {
          U.TiffFaxDecoder$(this.fillOrder, this.tileWidth, this.tileHeight).decodeT6$5(bdata, p, 0, this.tileHeight, this.t6Options);
        } catch (exception) {
          H.unwrapException(exception);
        }

      } else if (J.$eq(this.compression, 8))
        bdata = U.InputBuffer$(new T.ZLibDecoder().decodeBuffer$2$verify(T.InputStream$(J.toList$2$ax(p, 0, byteCount), 1, null, 0), true), false, null, 0);
      else if (J.$eq(this.compression, 32946)) {
        t1 = T.Inflate$(J.toList$2$ax(p, 0, byteCount), null).output;
        bdata = U.InputBuffer$(H.NativeUint8List_NativeUint8List$view(t1._archive$_buffer.buffer, 0, t1.length), false, null, 0);
      } else if (J.$eq(this.compression, 1))
        bdata = p;
      else
        throw H.wrapException(U.ImageException$("Unsupported Compression Type: " + H.S(this.compression)));
      if (bdata == null)
        return;
      br = new U.TiffBitReader(bdata, 0, 0);
      t1 = this.isWhiteZero;
      white = t1 ? 4278190080 : 4294967295;
      black = t1 ? 4294967295 : 4278190080;
      py = outY;
      y = 0;
      while (true) {
        t1 = this.tileHeight;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(y < t1))
          break;
        t1 = py >= 0;
        px = outX;
        x = 0;
        while (true) {
          t2 = this.tileWidth;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(x < t2))
            break;
          t2 = br.readBits$1(1);
          t3 = this.image;
          if (t2 === 0) {
            t3.toString;
            if (px >= 0) {
              t2 = t3.width;
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (px < t2)
                if (t1) {
                  t2 = t3.height;
                  if (typeof t2 !== "number")
                    return H.iae(t2);
                  t2 = py < t2;
                } else
                  t2 = false;
              else
                t2 = false;
            } else
              t2 = false;
            if (t2) {
              t2 = t3.data;
              t3 = t3.width;
              if (typeof t3 !== "number")
                return H.iae(t3);
              t3 = py * t3 + px;
              if (t3 >>> 0 !== t3 || t3 >= t2.length)
                return H.ioore(t2, t3);
              t2[t3] = black;
            }
          } else {
            t3.toString;
            if (px >= 0) {
              t2 = t3.width;
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (px < t2)
                if (t1) {
                  t2 = t3.height;
                  if (typeof t2 !== "number")
                    return H.iae(t2);
                  t2 = py < t2;
                } else
                  t2 = false;
              else
                t2 = false;
            } else
              t2 = false;
            if (t2) {
              t2 = t3.data;
              t3 = t3.width;
              if (typeof t3 !== "number")
                return H.iae(t3);
              t3 = py * t3 + px;
              if (t3 >>> 0 !== t3 || t3 >= t2.length)
                return H.ioore(t2, t3);
              t2[t3] = white;
            }
          }
          ++x;
          ++px;
        }
        br._bitPos = 0;
        ++y;
        ++py;
      }
    },
    _decodePackbits$3: function(data, arraySize, dst) {
      var t1, srcCount, dstCount, srcCount0, t2, b, i, dstCount0, repeat;
      if (typeof arraySize !== "number")
        return H.iae(arraySize);
      t1 = J.getInterceptor$ax(dst);
      srcCount = 0;
      dstCount = 0;
      for (; dstCount < arraySize;) {
        srcCount0 = srcCount + 1;
        t2 = J.$index$asx(data.buffer, J.$add$ns(data.offset, srcCount));
        $.get$__uint8()[0] = t2;
        t2 = $.get$__uint8ToInt8();
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        b = t2[0];
        if (b >= 0 && b <= 127)
          for (t2 = b + 1, srcCount = srcCount0, i = 0; i < t2; ++i, dstCount = dstCount0, srcCount = srcCount0) {
            dstCount0 = dstCount + 1;
            srcCount0 = srcCount + 1;
            t1.$indexSet(dst, dstCount, J.$index$asx(data.buffer, J.$add$ns(data.offset, srcCount)));
          }
        else {
          t2 = b <= -1 && b >= -127;
          srcCount = srcCount0 + 1;
          if (t2) {
            repeat = J.$index$asx(data.buffer, J.$add$ns(data.offset, srcCount0));
            for (t2 = -b + 1, i = 0; i < t2; ++i, dstCount = dstCount0) {
              dstCount0 = dstCount + 1;
              t1.$indexSet(dst, dstCount, repeat);
            }
          }
        }
      }
    },
    _readTag$3: function(p, type, defaultValue) {
      var t1 = this.tags;
      if (!t1.containsKey$1(type))
        return defaultValue;
      t1 = t1.$index(0, type);
      p.offset = t1.valueOffset;
      return t1._readValue$1(p);
    },
    _readTag$2: function(p, type) {
      return this._readTag$3(p, type, 0);
    },
    _readTagList$2: function(p, type) {
      var t1 = this.tags;
      if (!t1.containsKey$1(type))
        return;
      return t1.$index(0, type).readValues$1(p);
    },
    TiffImage$1: function(p) {
      var p3, numDirEntries, t1, i, tag, type, numValues, entry, t2, palette, len, t3, l, v, t0;
      p3 = U.InputBuffer$from(p, null, 0);
      numDirEntries = p.readUint16$0();
      for (t1 = this.tags, i = 0; i < numDirEntries; ++i) {
        tag = p.readUint16$0();
        type = p.readUint16$0();
        numValues = p.readUint32$0();
        entry = new U.TiffEntry(tag, type, numValues, null);
        if (type < 13 && type > 0) {
          if (type >= 14)
            return H.ioore(C.List_yYQ, type);
          t2 = C.List_yYQ[type];
        } else
          t2 = 0;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (numValues * t2 > 4)
          entry.valueOffset = p.readUint32$0();
        else {
          t2 = p.offset;
          entry.valueOffset = t2;
          p.offset = J.$add$ns(t2, 4);
        }
        t1.$indexSet(0, tag, entry);
        if (tag === 256) {
          p3.offset = entry.valueOffset;
          this.width = entry._readValue$1(p3);
        } else if (tag === 257) {
          p3.offset = entry.valueOffset;
          this.height = entry._readValue$1(p3);
        } else if (tag === 262) {
          p3.offset = entry.valueOffset;
          this.photometricType = entry._readValue$1(p3);
        } else if (tag === 259) {
          p3.offset = entry.valueOffset;
          this.compression = entry._readValue$1(p3);
        } else if (tag === 258) {
          p3.offset = entry.valueOffset;
          this.bitsPerSample = entry._readValue$1(p3);
        } else if (tag === 277) {
          p3.offset = entry.valueOffset;
          this.samplesPerPixel = entry._readValue$1(p3);
        } else if (tag === 317) {
          p3.offset = entry.valueOffset;
          this.predictor = entry._readValue$1(p3);
        } else if (tag === 320) {
          palette = entry.readValues$1(p3);
          this.colorMap = palette;
          this.colorMapRed = 0;
          t2 = C.JSInt_methods._tdivFast$1(palette.length, 3);
          this.colorMapGreen = t2;
          this.colorMapBlue = t2 * 2;
        }
      }
      if (this.width == null || this.height == null || this.bitsPerSample == null || this.compression == null)
        return;
      if (this.colorMap != null && J.$eq(this.bitsPerSample, 8))
        for (t2 = this.colorMap, len = t2.length, i = 0; i < len; ++i) {
          t3 = t2[i];
          if (typeof t3 !== "number")
            return t3.$shr();
          t2[i] = C.JSNumber_methods._shrOtherPositive$1(t3, 8);
        }
      if (J.$eq(this.photometricType, 0))
        this.isWhiteZero = true;
      if (t1.containsKey$1(324)) {
        this.tiled = true;
        this.tileWidth = this._readTag$2(p3, 322);
        this.tileHeight = this._readTag$2(p3, 323);
        this.tileOffsets = this._readTagList$2(p3, 324);
        this.tileByteCounts = this._readTagList$2(p3, 325);
      } else {
        this.tiled = false;
        this.tileWidth = this._readTag$3(p3, 322, this.width);
        if (!t1.containsKey$1(278))
          this.tileHeight = this._readTag$3(p3, 323, this.height);
        else {
          l = this._readTag$2(p3, 278);
          if (J.$eq(l, -1))
            this.tileHeight = this.height;
          else
            this.tileHeight = l;
        }
        this.tileOffsets = this._readTagList$2(p3, 273);
        this.tileByteCounts = this._readTagList$2(p3, 279);
      }
      this.tilesX = J.$tdiv$n(J.$sub$n(J.$add$ns(this.width, this.tileWidth), 1), this.tileWidth);
      this.tilesY = J.$tdiv$n(J.$sub$n(J.$add$ns(this.height, this.tileHeight), 1), this.tileHeight);
      this.tileSize = J.$mul$ns(J.$mul$ns(this.tileWidth, this.tileHeight), this.samplesPerPixel);
      this.fillOrder = this._readTag$3(p3, 266, 1);
      this.t4Options = this._readTag$3(p3, 292, 0);
      this.t6Options = this._readTag$3(p3, 293, 0);
      this.extraSamples = this._readTag$3(p3, 338, 0);
      switch (this.photometricType) {
        case 0:
        case 1:
          if (J.$eq(this.bitsPerSample, 1) && J.$eq(this.samplesPerPixel, 1))
            this.imageType = 0;
          else if (J.$eq(this.bitsPerSample, 4) && J.$eq(this.samplesPerPixel, 1))
            this.imageType = 1;
          else if (J.$mod$n(this.bitsPerSample, 8) === 0)
            if (J.$eq(this.samplesPerPixel, 1))
              this.imageType = 2;
            else if (J.$eq(this.samplesPerPixel, 2))
              this.imageType = 3;
            else
              this.imageType = 8;
          break;
        case 2:
          if (J.$mod$n(this.bitsPerSample, 8) === 0)
            if (J.$eq(this.samplesPerPixel, 3))
              this.imageType = 5;
            else if (J.$eq(this.samplesPerPixel, 4))
              this.imageType = 6;
            else
              this.imageType = 8;
          break;
        case 3:
          if (J.$eq(this.samplesPerPixel, 1))
            t1 = J.$eq(this.bitsPerSample, 4) || J.$eq(this.bitsPerSample, 8) || J.$eq(this.bitsPerSample, 16);
          else
            t1 = false;
          if (t1)
            this.imageType = 4;
          break;
        case 4:
          if (J.$eq(this.bitsPerSample, 1) && J.$eq(this.samplesPerPixel, 1))
            this.imageType = 0;
          break;
        case 6:
          if (J.$eq(this.compression, 7) && J.$eq(this.bitsPerSample, 8) && J.$eq(this.samplesPerPixel, 3))
            this.imageType = 5;
          else {
            if (t1.containsKey$1(530)) {
              v = t1.$index(0, 530).readValues$1(p3);
              t1 = v.length;
              if (0 >= t1)
                return H.ioore(v, 0);
              t2 = v[0];
              this.chromaSubH = t2;
              if (1 >= t1)
                return H.ioore(v, 1);
              t1 = v[1];
              this.chromaSubV = t1;
              t0 = t2;
              t2 = t1;
              t1 = t0;
            } else {
              this.chromaSubH = 2;
              this.chromaSubV = 2;
              t1 = 2;
              t2 = 2;
            }
            if (J.$eq(J.$mul$ns(t1, t2), 1))
              this.imageType = 8;
            else if (J.$eq(this.bitsPerSample, 8) && J.$eq(this.samplesPerPixel, 3))
              this.imageType = 7;
          }
          break;
        default:
          if (J.$mod$n(this.bitsPerSample, 8) === 0)
            this.imageType = 8;
          break;
      }
    },
    static: {"^": "TiffImage_COMPRESSION_NONE,TiffImage_COMPRESSION_CCITT_RLE,TiffImage_COMPRESSION_CCITT_FAX3,TiffImage_COMPRESSION_CCITT_FAX4,TiffImage_COMPRESSION_LZW,TiffImage_COMPRESSION_OLD_JPEG,TiffImage_COMPRESSION_JPEG,TiffImage_COMPRESSION_NEXT,TiffImage_COMPRESSION_CCITT_RLEW,TiffImage_COMPRESSION_PACKBITS,TiffImage_COMPRESSION_THUNDERSCAN,TiffImage_COMPRESSION_IT8CTPAD,TiffImage_COMPRESSION_IT8LW,TiffImage_COMPRESSION_IT8MP,TiffImage_COMPRESSION_IT8BL,TiffImage_COMPRESSION_PIXARFILM,TiffImage_COMPRESSION_PIXARLOG,TiffImage_COMPRESSION_DEFLATE,TiffImage_COMPRESSION_ZIP,TiffImage_COMPRESSION_DCS,TiffImage_COMPRESSION_JBIG,TiffImage_COMPRESSION_SGILOG,TiffImage_COMPRESSION_SGILOG24,TiffImage_COMPRESSION_JP2000,TiffImage_TYPE_UNSUPPORTED,TiffImage_TYPE_BILEVEL,TiffImage_TYPE_GRAY_4BIT,TiffImage_TYPE_GRAY,TiffImage_TYPE_GRAY_ALPHA,TiffImage_TYPE_PALETTE,TiffImage_TYPE_RGB,TiffImage_TYPE_RGB_ALPHA,TiffImage_TYPE_YCBCR_SUB,TiffImage_TYPE_GENERIC,TiffImage_TAG_ARTIST,TiffImage_TAG_BITS_PER_SAMPLE,TiffImage_TAG_CELL_LENGTH,TiffImage_TAG_CELL_WIDTH,TiffImage_TAG_COLOR_MAP,TiffImage_TAG_COMPRESSION,TiffImage_TAG_DATE_TIME,TiffImage_TAG_EXIF_IFD,TiffImage_TAG_EXTRA_SAMPLES,TiffImage_TAG_FILL_ORDER,TiffImage_TAG_FREE_BYTE_COUNTS,TiffImage_TAG_FREE_OFFSETS,TiffImage_TAG_GRAY_RESPONSE_CURVE,TiffImage_TAG_GRAY_RESPONSE_UNIT,TiffImage_TAG_HOST_COMPUTER,TiffImage_TAG_ICC_PROFILE,TiffImage_TAG_IMAGE_DESCRIPTION,TiffImage_TAG_IMAGE_LENGTH,TiffImage_TAG_IMAGE_WIDTH,TiffImage_TAG_IPTC,TiffImage_TAG_MAKE,TiffImage_TAG_MAX_SAMPLE_VALUE,TiffImage_TAG_MIN_SAMPLE_VALUE,TiffImage_TAG_MODEL,TiffImage_TAG_NEW_SUBFILE_TYPE,TiffImage_TAG_ORIENTATION,TiffImage_TAG_PHOTOMETRIC_INTERPRETATION,TiffImage_TAG_PHOTOSHOP,TiffImage_TAG_PLANAR_CONFIGURATION,TiffImage_TAG_PREDICTOR,TiffImage_TAG_RESOLUTION_UNIT,TiffImage_TAG_ROWS_PER_STRIP,TiffImage_TAG_SAMPLES_PER_PIXEL,TiffImage_TAG_SOFTWARE,TiffImage_TAG_STRIP_BYTE_COUNTS,TiffImage_TAG_STRIP_OFFSETS,TiffImage_TAG_SUBFILE_TYPE,TiffImage_TAG_T4_OPTIONS,TiffImage_TAG_T6_OPTIONS,TiffImage_TAG_THRESHOLDING,TiffImage_TAG_TILE_WIDTH,TiffImage_TAG_TILE_LENGTH,TiffImage_TAG_TILE_OFFSETS,TiffImage_TAG_TILE_BYTE_COUNTS,TiffImage_TAG_XMP,TiffImage_TAG_X_RESOLUTION,TiffImage_TAG_Y_RESOLUTION,TiffImage_TAG_YCBCR_COEFFICIENTS,TiffImage_TAG_YCBCR_SUBSAMPLING,TiffImage_TAG_YCBCR_POSITIONING,TiffImage_TAG_NAME", TiffImage$: function(p) {
        var t1 = new U.TiffImage(P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, 1, 1, 1, -1, false, 1, null, null, false, null, null, null, null, null, null, null, 1, 0, 0, null, null, null, null, null, null);
        t1.TiffImage$1(p);
        return t1;
      }}
  },
  TiffInfo: {
    "^": "DecodeInfo;bigEndian,signature,ifdOffset,images,width,height,backgroundColor"
  },
  LzwDecoder: {
    "^": "Object;_bitsToGet,_bytePointer,_bitPointer,_nextData,_nextBits,_data,_dataLength,_out,_outPointer,_buffer,_table,_prefix,_tableIndex,_bufferLength",
    decode$2: function(p, out) {
      var outLen, t1, code, oldCode, num, t2, i, t3, t4;
      this._out = out;
      outLen = J.get$length$asx(out);
      this._outPointer = 0;
      t1 = p.buffer;
      this._data = t1;
      this._dataLength = J.get$length$asx(t1);
      this._bytePointer = p.offset;
      if (J.$eq(J.$index$asx(this._data, 0), 0) && J.$eq(J.$index$asx(this._data, 1), 1))
        throw H.wrapException(U.ImageException$("Invalid LZW Data"));
      this._initializeStringTable$0();
      this._bitPointer = 0;
      this._nextData = 0;
      this._nextBits = 0;
      code = this._getNextCode$0();
      oldCode = 0;
      num = 0;
      while (true) {
        if (code !== 257) {
          t1 = this._outPointer;
          if (typeof t1 !== "number")
            return t1.$lt();
          if (typeof outLen !== "number")
            return H.iae(outLen);
          t1 = t1 < outLen;
        } else
          t1 = false;
        if (!t1)
          break;
        if (code === 256) {
          this._initializeStringTable$0();
          ++num;
          code = this._getNextCode$0();
          this._bufferLength = 0;
          if (code === 257)
            break;
          t1 = this._out;
          t2 = this._outPointer;
          if (typeof t2 !== "number")
            return t2.$add();
          this._outPointer = t2 + 1;
          J.$indexSet$ax(t1, t2, code);
          oldCode = code;
        } else {
          t1 = this._tableIndex;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (code < t1) {
            this._getString$1(code);
            t1 = this._bufferLength;
            if (typeof t1 !== "number")
              return t1.$sub();
            i = t1 - 1;
            for (; i >= 0; --i) {
              t1 = this._out;
              t2 = this._outPointer;
              if (typeof t2 !== "number")
                return t2.$add();
              this._outPointer = t2 + 1;
              t3 = this._buffer;
              if (i >= 4096)
                return H.ioore(t3, i);
              J.$indexSet$ax(t1, t2, t3[i]);
            }
            t1 = this._buffer;
            t2 = this._bufferLength;
            if (typeof t2 !== "number")
              return t2.$sub();
            --t2;
            if (t2 < 0 || t2 >= 4096)
              return H.ioore(t1, t2);
            this._addString$2(oldCode, t1[t2]);
          } else {
            this._getString$1(oldCode);
            t1 = this._bufferLength;
            if (typeof t1 !== "number")
              return t1.$sub();
            i = t1 - 1;
            for (; t1 = this._out, t2 = this._outPointer, i >= 0; --i) {
              if (typeof t2 !== "number")
                return t2.$add();
              this._outPointer = t2 + 1;
              t3 = this._buffer;
              if (i >= 4096)
                return H.ioore(t3, i);
              J.$indexSet$ax(t1, t2, t3[i]);
            }
            if (typeof t2 !== "number")
              return t2.$add();
            this._outPointer = t2 + 1;
            t3 = this._buffer;
            t4 = this._bufferLength;
            if (typeof t4 !== "number")
              return t4.$sub();
            --t4;
            if (t4 < 0 || t4 >= 4096)
              return H.ioore(t3, t4);
            J.$indexSet$ax(t1, t2, t3[t4]);
            t4 = this._buffer;
            t3 = this._bufferLength;
            if (typeof t3 !== "number")
              return t3.$sub();
            --t3;
            if (t3 < 0 || t3 >= 4096)
              return H.ioore(t4, t3);
            this._addString$2(oldCode, t4[t3]);
          }
          oldCode = code;
        }
        ++num;
        code = this._getNextCode$0();
      }
    },
    _addString$2: function(string, newString) {
      var t1, t2;
      t1 = this._table;
      t2 = this._tableIndex;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = newString;
      t1 = this._prefix;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = string;
      ++t2;
      this._tableIndex = t2;
      if (t2 === 511)
        this._bitsToGet = 10;
      else if (t2 === 1023)
        this._bitsToGet = 11;
      else if (t2 === 2047)
        this._bitsToGet = 12;
    },
    _getString$1: function(code) {
      var t1, t2, t3, c, t4, t5, t6;
      this._bufferLength = 0;
      t1 = this._buffer;
      this._bufferLength = 1;
      t2 = this._table;
      if (code >= t2.length)
        return H.ioore(t2, code);
      t1[0] = t2[code];
      t3 = this._prefix;
      if (code >= t3.length)
        return H.ioore(t3, code);
      c = t3[code];
      for (t4 = t3, t3 = t2, t2 = t1, t1 = 1; c !== 4098; t1 = t5) {
        t5 = t1 + 1;
        this._bufferLength = t5;
        if (c < 0 || c >= t3.length)
          return H.ioore(t3, c);
        t6 = t3[c];
        if (t1 >= 4096)
          return H.ioore(t2, t1);
        t2[t1] = t6;
        if (c >= t4.length)
          return H.ioore(t4, c);
        c = t4[c];
      }
    },
    _getNextCode$0: function() {
      var t1, t2, t3;
      if (J.$ge$n(this._bytePointer, this._dataLength))
        return 257;
      for (; t1 = this._nextBits, t2 = this._bitsToGet, t1 < t2;) {
        if (J.$ge$n(this._bytePointer, this._dataLength))
          return 257;
        t1 = this._nextData;
        t2 = this._data;
        t3 = this._bytePointer;
        this._bytePointer = J.$add$ns(t3, 1);
        t3 = J.$index$asx(t2, t3);
        if (typeof t3 !== "number")
          return H.iae(t3);
        this._nextData = ((t1 << 8 >>> 0) + t3 & 4294967295) >>> 0;
        this._nextBits += 8;
      }
      t1 -= t2;
      this._nextBits = t1;
      t1 = C.JSInt_methods._shrReceiverPositive$1(this._nextData, t1);
      t2 -= 9;
      if (t2 < 0 || t2 >= 4)
        return H.ioore(C.List_511_1023_2047_4095, t2);
      t2 = C.List_511_1023_2047_4095[t2];
      if (typeof t2 !== "number")
        return H.iae(t2);
      return (t1 & t2) >>> 0;
    },
    _initializeStringTable$0: function() {
      var t1, i;
      this._table = new Uint8Array(4096);
      t1 = new Uint32Array(4096);
      this._prefix = t1;
      C.NativeUint32List_methods.fillRange$3(t1, 0, 4096, 4098);
      for (t1 = this._table, i = 0; i < 256; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = i;
      }
      this._bitsToGet = 9;
      this._tableIndex = 258;
    },
    static: {"^": "LzwDecoder_LZ_MAX_CODE,LzwDecoder_NO_SUCH_CODE,LzwDecoder_AND_TABLE"}
  },
  TiffDecoder: {
    "^": "Decoder;info,_input,progressCallback",
    startDecode$1: function(bytes) {
      var t1 = U.InputBuffer$(new Uint8Array(H._ensureNativeList(bytes)), false, null, 0);
      this._input = t1;
      t1 = this._readHeader$1(t1);
      this.info = t1;
      return t1;
    },
    decodeFrame$1: function(frame) {
      var t1 = this.info;
      if (t1 == null)
        return;
      t1 = t1.images;
      if (frame >= t1.length)
        return H.ioore(t1, frame);
      return t1[frame].decode$1(this._input);
    },
    _readHeader$1: function(p) {
      var p2, img, t1, info, byteOrder, t2, offset, t3, exception;
      t1 = [];
      info = new U.TiffInfo(null, null, null, t1, 0, 0, 4294967295);
      byteOrder = p.readUint16$0();
      if (byteOrder !== 18761 && byteOrder !== 19789)
        return;
      if (byteOrder === 19789) {
        p.bigEndian = true;
        info.bigEndian = true;
      } else {
        p.bigEndian = false;
        info.bigEndian = false;
      }
      t2 = p.readUint16$0();
      info.signature = t2;
      if (t2 !== 42)
        return;
      offset = p.readUint32$0();
      info.ifdOffset = offset;
      p2 = U.InputBuffer$from(p, null, 0);
      J.set$offset$x(p2, offset);
      for (; offset !== 0;) {
        img = null;
        try {
          img = U.TiffImage$(p2);
          t2 = img;
          t3 = J.getInterceptor$x(t2);
          if (!(t3.get$width(t2) != null && t3.get$height(t2) != null && t2.get$samplesPerPixel() != null && t2.get$bitsPerSample() != null && t2.compression != null))
            break;
        } catch (exception) {
          H.unwrapException(exception);
          break;
        }

        t1.push(img);
        t2 = t1.length;
        if (t2 === 1) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          info.width = J.get$width$x(t1[0]);
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          info.height = J.get$height$x(t1[0]);
        }
        offset = p2.readUint32$0();
        if (offset !== 0)
          J.set$offset$x(p2, offset);
      }
      return t1.length > 0 ? info : null;
    },
    static: {"^": "TiffDecoder_TIFF_SIGNATURE,TiffDecoder_TIFF_LITTLE_ENDIAN,TiffDecoder_TIFF_BIG_ENDIAN"}
  },
  VP8: {
    "^": "Object;input,webp,br,output,_dsp,_frameHeader,_picHeader,_filterHeader,_segmentHeader,_cropLeft,_cropRight,_cropTop,_cropBottom,_mbWidth,_mbHeight,_tlMbX,_tlMbY,_brMbX,_brMbY,_numPartitions,_partitions,_dither,_ditheringRand,_dqm,_proba,_useSkipProba,_skipP,_intraT,_intraL,_segment,_yuvT,_mbInfo,_fInfo,_yuvBlock,_cacheY,_cacheU,_cacheV,_cacheYStride,_cacheUVStride,_tmpY,_tmpU,_tmpV,_y,_u,_v,_a,_mem,_mbX,_mbY,_mbData,_filterType,_fStrengths,_alpha,_alphaData,_isAlphaDecoded,_alphaPlane,_layerColorspace,_layerData",
    decodeHeader$0: function() {
      var bits, t1, t2;
      bits = this.input.readUint24$0();
      if (J.$and$n(bits, 1) !== 0)
        return false;
      if (typeof bits !== "number")
        return bits.$shr();
      if ((bits >>> 1 & 7) > 3)
        return false;
      t1 = bits >>> 4 & 1;
      if (t1 === 0)
        return false;
      t2 = this._frameHeader;
      t2.keyFrame = (bits & 1) === 0;
      t2.profile = bits >>> 1 & 7;
      t2.show = t1;
      t2.partitionLength = bits >>> 5;
      if (this.input.readUint24$0() !== 2752925)
        return false;
      t1 = this.webp;
      t1.width = this.input.readUint16$0();
      t1.height = this.input.readUint16$0();
      return true;
    },
    decode$0: function() {
      if (!this._getHeaders$0())
        return;
      var t1 = this.webp;
      this.output = U.Image$(t1.width, t1.height, 4);
      if (!this._initFrame$0())
        return;
      if (!this._parseFrame$0())
        return;
      return this.output;
    },
    _getHeaders$0: function() {
      var t1, i, t2, t3, t4;
      if (!this.decodeHeader$0())
        return false;
      this._proba = U.VP8Proba$();
      for (t1 = this._dqm, i = 0; i < 4; ++i) {
        t2 = new Int32Array(2);
        t3 = new Int32Array(2);
        t1[i] = new U.VP8QuantMatrix(t2, t3, new Int32Array(2), null, null);
      }
      t1 = this._picHeader;
      t2 = this.webp;
      t3 = t2.width;
      t1.width = t3;
      t4 = t2.height;
      t1.height = t4;
      if (typeof t3 !== "number")
        return t3.$shr();
      t1.xscale = C.JSNumber_methods._shrOtherPositive$1(t3, 8) >>> 6;
      if (typeof t4 !== "number")
        return t4.$shr();
      t1.yscale = C.JSNumber_methods._shrOtherPositive$1(t4, 8) >>> 6;
      this._cropTop = 0;
      this._cropLeft = 0;
      this._cropRight = t3;
      this._cropBottom = t4;
      this._mbWidth = C.JSNumber_methods._shrOtherPositive$1(t3 + 15, 4);
      t2 = J.$add$ns(t2.height, 15);
      if (typeof t2 !== "number")
        return t2.$shr();
      this._mbHeight = C.JSNumber_methods._shrOtherPositive$1(t2, 4);
      this._segment = 0;
      t2 = this._frameHeader;
      this.br = U.VP8BitReader$(this.input.subset$1(t2.partitionLength));
      t3 = this.input;
      t2 = t2.partitionLength;
      t3.offset = J.$add$ns(t3.offset, t2);
      t1.colorspace = this.br.getValue$1(1);
      t1.clampType = this.br.getValue$1(1);
      if (!this._parseSegmentHeader$2(this._segmentHeader, this._proba))
        return false;
      if (!this._parseFilterHeader$0())
        return false;
      if (!this._parsePartitions$1(this.input))
        return false;
      this._parseQuant$0();
      this.br.getValue$1(1);
      this._parseProba$0();
      return true;
    },
    _parseSegmentHeader$2: function(hdr, proba) {
      var t1, s, t2, value;
      t1 = this.br.getValue$1(1) !== 0;
      hdr.useSegment = t1;
      if (t1) {
        hdr.updateMap = this.br.getValue$1(1) !== 0;
        if (this.br.getValue$1(1) !== 0) {
          hdr.absoluteDelta = this.br.getValue$1(1) !== 0;
          for (t1 = hdr.quantizer, s = 0; s < 4; ++s) {
            if (this.br.getValue$1(1) !== 0) {
              t2 = this.br;
              value = t2.getValue$1(7);
              t2 = t2.getValue$1(1) === 1 ? -value : value;
            } else
              t2 = 0;
            t1[s] = t2;
          }
          for (t1 = hdr.filterStrength, s = 0; s < 4; ++s) {
            if (this.br.getValue$1(1) !== 0) {
              t2 = this.br;
              value = t2.getValue$1(6);
              t2 = t2.getValue$1(1) === 1 ? -value : value;
            } else
              t2 = 0;
            t1[s] = t2;
          }
        }
        if (hdr.updateMap)
          for (s = 0; s < 3; ++s) {
            t1 = proba.segments;
            t1[s] = this.br.getValue$1(1) !== 0 ? this.br.getValue$1(8) : 255;
          }
      } else
        hdr.updateMap = false;
      return true;
    },
    _parseFilterHeader$0: function() {
      var hdr, t1, i, t2, value;
      hdr = this._filterHeader;
      hdr.simple = this.br.getValue$1(1) !== 0;
      hdr.level = this.br.getValue$1(6);
      hdr.sharpness = this.br.getValue$1(3);
      t1 = this.br.getValue$1(1) !== 0;
      hdr.useLfDelta = t1;
      if (t1)
        if (this.br.getValue$1(1) !== 0) {
          for (t1 = hdr.refLfDelta, i = 0; i < 4; ++i)
            if (this.br.getValue$1(1) !== 0) {
              t2 = this.br;
              value = t2.getValue$1(6);
              t1[i] = t2.getValue$1(1) === 1 ? -value : value;
            }
          for (t1 = hdr.modeLfDelta, i = 0; i < 4; ++i)
            if (this.br.getValue$1(1) !== 0) {
              t2 = this.br;
              value = t2.getValue$1(6);
              t1[i] = t2.getValue$1(1) === 1 ? -value : value;
            }
        }
      if (hdr.level === 0)
        t1 = 0;
      else
        t1 = hdr.simple === true ? 1 : 2;
      this._filterType = t1;
      return true;
    },
    _parsePartitions$1: function(input) {
      var bufEnd, t1, lastPart, partStart, t2, sz, p, pos, t3, t4, t5, partEnd;
      bufEnd = J.$sub$n(input.end, input.offset);
      t1 = C.JSInt_methods._shlPositive$1(1, this.br.getValue$1(2));
      this._numPartitions = t1;
      lastPart = t1 - 1;
      partStart = lastPart * 3;
      t1 = J.getInterceptor$n(bufEnd);
      if (t1.$lt(bufEnd, partStart))
        return false;
      for (t2 = this._partitions, sz = 0, p = 0; p < lastPart; ++p, partStart = partEnd) {
        pos = J.$add$ns(input.offset, sz);
        t3 = input.buffer;
        t4 = J.$index$asx(t3, J.$add$ns(pos, 0));
        t5 = J.$index$asx(t3, J.$add$ns(pos, 1));
        if (typeof t5 !== "number")
          return t5.$shl();
        t5 = J.$or$n(t4, t5 << 8 >>> 0);
        t3 = J.$index$asx(t3, J.$add$ns(pos, 2));
        if (typeof t3 !== "number")
          return t3.$shl();
        partEnd = J.$add$ns(partStart, J.$or$n(t5, t3 << 16 >>> 0));
        if (J.$gt$n(partEnd, bufEnd))
          partEnd = bufEnd;
        t3 = J.$sub$n(partEnd, partStart);
        pos = J.$add$ns(J.$add$ns(input.start, partStart), 0);
        t4 = input.buffer;
        t5 = input.bigEndian;
        t3 = t3 == null ? J.get$length$asx(t4) : J.$add$ns(pos, t3);
        t5 = new U.VP8BitReader(new U.InputBuffer(t4, pos, t3, pos, t5), null, null, null, false);
        t5._range = 254;
        t5._image$_value = 0;
        t5._bits = -8;
        if (p >= 8)
          return H.ioore(t2, p);
        t2[p] = t5;
        sz += 3;
      }
      t1 = U.VP8BitReader$(input.subset$2$position(t1.$sub(bufEnd, partStart), J.$add$ns(J.$sub$n(input.offset, input.start), partStart)));
      if (lastPart < 0 || lastPart >= 8)
        return H.ioore(t2, lastPart);
      t2[lastPart] = t1;
      return J.$lt$n(partStart, bufEnd) && true;
    },
    _parseQuant$0: function() {
      var base_q0, dqy1_dc, dqy2_dc, dqy2_ac, dquv_dc, dquv_ac, hdr, t1, t2, i, q, m, t3, t4, t5;
      base_q0 = this.br.getValue$1(7);
      dqy1_dc = this.br.getValue$1(1) !== 0 ? this.br.getSignedValue$1(4) : 0;
      dqy2_dc = this.br.getValue$1(1) !== 0 ? this.br.getSignedValue$1(4) : 0;
      dqy2_ac = this.br.getValue$1(1) !== 0 ? this.br.getSignedValue$1(4) : 0;
      dquv_dc = this.br.getValue$1(1) !== 0 ? this.br.getSignedValue$1(4) : 0;
      dquv_ac = this.br.getValue$1(1) !== 0 ? this.br.getSignedValue$1(4) : 0;
      hdr = this._segmentHeader;
      for (t1 = this._dqm, t2 = hdr.quantizer, i = 0; i < 4; ++i) {
        if (hdr.useSegment) {
          q = t2[i];
          if (!hdr.absoluteDelta)
            q += base_q0;
        } else {
          if (i > 0) {
            t1[i] = t1[0];
            continue;
          }
          q = base_q0;
        }
        m = t1[i];
        t3 = m.get$y1Mat();
        t4 = q + dqy1_dc;
        if (t4 < 0)
          t4 = 0;
        else if (t4 > 127)
          t4 = 127;
        if (t4 >= 128)
          return H.ioore(C.List_8co1, t4);
        t3[0] = C.List_8co1[t4];
        t4 = m.y1Mat;
        if (q < 0)
          t3 = 0;
        else
          t3 = q > 127 ? 127 : q;
        if (t3 >= 128)
          return H.ioore(C.List_AiM, t3);
        t4[1] = C.List_AiM[t3];
        t3 = m.y2Mat;
        t4 = q + dqy2_dc;
        if (t4 < 0)
          t4 = 0;
        else if (t4 > 127)
          t4 = 127;
        if (t4 >= 128)
          return H.ioore(C.List_8co1, t4);
        t3[0] = J.$mul$ns(C.List_8co1[t4], 2);
        t4 = q + dqy2_ac;
        if (t4 < 0)
          t4 = 0;
        else if (t4 > 127)
          t4 = 127;
        if (t4 >= 128)
          return H.ioore(C.List_AiM, t4);
        t4 = J.$mul$ns(C.List_AiM[t4], 101581);
        if (typeof t4 !== "number")
          return t4.$shr();
        t3[1] = C.JSNumber_methods._shrOtherPositive$1(t4, 16);
        if (t3[1] < 8)
          t3[1] = 8;
        t3 = m.uvMat;
        t4 = q + dquv_dc;
        if (t4 < 0)
          t4 = 0;
        else if (t4 > 117)
          t4 = 117;
        if (t4 >= 128)
          return H.ioore(C.List_8co1, t4);
        t3[0] = C.List_8co1[t4];
        t4 = q + dquv_ac;
        if (t4 < 0)
          t5 = 0;
        else
          t5 = t4 > 127 ? 127 : t4;
        if (t5 >= 128)
          return H.ioore(C.List_AiM, t5);
        t3[1] = C.List_AiM[t5];
        m.uvQuant = t4;
      }
    },
    _parseProba$0: function() {
      var proba, t, b, c, p, v, t1;
      proba = this._proba;
      for (t = 0; t < 4; ++t)
        for (b = 0; b < 8; ++b)
          for (c = 0; c < 3; ++c)
            for (p = 0; p < 11; ++p) {
              v = this.br.getBit$1(J.$index$asx(J.$index$asx(J.$index$asx(C.List_MIe[t], b), c), p)) !== 0 ? this.br.getValue$1(8) : J.$index$asx(J.$index$asx(J.$index$asx(C.List_S8N[t], b), c), p);
              J.$indexSet$ax(J.$index$asx(proba.bands[t], b).get$probas()[c], p, v);
            }
      t1 = this.br.getValue$1(1) !== 0;
      this._useSkipProba = t1;
      if (t1)
        this._skipP = this.br.getValue$1(8);
    },
    _precomputeFilterStrengths$0: function() {
      var t1, hdr, t2, t3, t4, s, baseLevel, t5, i4x4, info, level, ilevel, ilevel0;
      t1 = this._filterType;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 0) {
        hdr = this._filterHeader;
        for (t1 = hdr.refLfDelta, t2 = hdr.modeLfDelta, t3 = this._segmentHeader, t4 = t3.filterStrength, s = 0; s < 4; ++s) {
          if (t3.useSegment) {
            baseLevel = t4[s];
            if (!t3.absoluteDelta) {
              t5 = hdr.level;
              if (typeof t5 !== "number")
                return H.iae(t5);
              baseLevel += t5;
            }
          } else
            baseLevel = hdr.level;
          for (i4x4 = 0; i4x4 <= 1; ++i4x4) {
            info = J.$index$asx(this._fStrengths[s], i4x4);
            if (hdr.useLfDelta === true) {
              t5 = t1[0];
              if (typeof baseLevel !== "number")
                return baseLevel.$add();
              level = baseLevel + t5;
              if (i4x4 !== 0)
                level += t2[0];
            } else
              level = baseLevel;
            if (typeof level !== "number")
              return level.$lt();
            if (level < 0)
              level = 0;
            else if (level > 63)
              level = 63;
            if (level > 0) {
              t5 = hdr.sharpness;
              if (typeof t5 !== "number")
                return t5.$gt();
              if (t5 > 0) {
                ilevel = t5 > 4 ? C.JSInt_methods._shrOtherPositive$1(level, 2) : C.JSInt_methods._shrOtherPositive$1(level, 1);
                ilevel0 = 9 - t5;
                if (ilevel > ilevel0)
                  ilevel = ilevel0;
              } else
                ilevel = level;
              if (ilevel < 1)
                ilevel = 1;
              info.set$fInnerLevel(ilevel);
              info.fLimit = 2 * level + ilevel;
              if (level >= 40)
                t5 = 2;
              else
                t5 = level >= 15 ? 1 : 0;
              info.hevThresh = t5;
            } else
              info.set$fLimit(0);
            info.set$fInner(i4x4 !== 0);
          }
        }
      }
    },
    _initFrame$0: function() {
      var t1, t2, i, t3, t4, t5, extra_rows, extra_y, extra_uv, extraPixels;
      t1 = this.webp;
      t2 = t1._alphaData;
      if (t2 != null)
        this._alphaData = t2;
      t2 = H.setRuntimeTypeInfo(Array(4), [[J.JSArray, U.VP8FInfo]]);
      this._fStrengths = t2;
      for (i = 0; i < 4; ++i)
        t2[i] = [new U.VP8FInfo(0, 0, false, 0), new U.VP8FInfo(0, 0, false, 0)];
      t2 = this._mbWidth;
      if (typeof t2 !== "number")
        return H.iae(t2);
      this._yuvT = H.setRuntimeTypeInfo(Array(t2), [U.VP8TopSamples]);
      i = 0;
      while (true) {
        t2 = this._mbWidth;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        t2 = this._yuvT;
        t3 = new Uint8Array(16);
        t4 = new Uint8Array(8);
        t5 = new Uint8Array(8);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = new U.VP8TopSamples(t3, t4, t5);
        ++i;
      }
      this._yuvBlock = new Uint8Array(832);
      t2 = this._mbWidth;
      if (typeof t2 !== "number")
        return H.iae(t2);
      this._intraT = new Uint8Array(4 * t2);
      t2 = this._mbWidth;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = 16 * t2;
      this._cacheYStride = t3;
      this._cacheUVStride = 8 * t2;
      t2 = this._filterType;
      if (t2 >>> 0 !== t2 || t2 >= 3)
        return H.ioore(C.List_0_2_8, t2);
      extra_rows = C.List_0_2_8[t2];
      t2 = J.getInterceptor$ns(extra_rows);
      extra_y = t2.$mul(extra_rows, t3);
      extra_uv = J.$mul$ns(t2.$tdiv(extra_rows, 2), this._cacheUVStride);
      t2 = this._cacheYStride;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof extra_y !== "number")
        return H.iae(extra_y);
      t2 = 16 * t2 + extra_y;
      if (typeof t2 !== "number" || Math.floor(t2) !== t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
      this._cacheY = U.InputBuffer$(new Uint8Array(t2), false, null, extra_y);
      t2 = this._cacheUVStride;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof extra_uv !== "number")
        return H.iae(extra_uv);
      t2 = 8 * t2 + extra_uv;
      if (typeof t2 !== "number" || Math.floor(t2) !== t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
      this._cacheU = U.InputBuffer$(new Uint8Array(t2), false, null, extra_uv);
      t2 = this._cacheUVStride;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = 8 * t2 + extra_uv;
      if (typeof t2 !== "number" || Math.floor(t2) !== t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
      this._cacheV = U.InputBuffer$(new Uint8Array(t2), false, null, extra_uv);
      t2 = t1.width;
      if (typeof t2 !== "number" || Math.floor(t2) !== t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
      this._tmpY = U.InputBuffer$(new Uint8Array(t2), false, null, 0);
      t1 = J.$add$ns(t1.width, 1);
      if (typeof t1 !== "number")
        return t1.$shr();
      t1 = C.JSNumber_methods._shrOtherPositive$1(t1, 1);
      this._tmpU = U.InputBuffer$(new Uint8Array(t1), false, null, 0);
      this._tmpV = U.InputBuffer$(new Uint8Array(t1), false, null, 0);
      t1 = this._filterType;
      if (t1 >>> 0 !== t1 || t1 >= 3)
        return H.ioore(C.List_0_2_8, t1);
      extraPixels = C.List_0_2_8[t1];
      if (t1 === 2) {
        this._tlMbX = 0;
        this._tlMbY = 0;
      } else {
        t1 = this._cropLeft;
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof extraPixels !== "number")
          return H.iae(extraPixels);
        t1 = C.JSNumber_methods._tdivFast$1(t1 - extraPixels, 16);
        this._tlMbX = t1;
        t2 = this._cropTop;
        if (typeof t2 !== "number")
          return t2.$sub();
        t2 = C.JSNumber_methods._tdivFast$1(t2 - extraPixels, 16);
        this._tlMbY = t2;
        if (t1 < 0)
          this._tlMbX = 0;
        if (t2 < 0)
          this._tlMbY = 0;
      }
      this._brMbY = J.$tdiv$n(J.$add$ns(J.$add$ns(this._cropBottom, 15), extraPixels), 16);
      t1 = J.$tdiv$n(J.$add$ns(J.$add$ns(this._cropRight, 15), extraPixels), 16);
      this._brMbX = t1;
      if (J.$gt$n(t1, this._mbWidth))
        this._brMbX = this._mbWidth;
      if (J.$gt$n(this._brMbY, this._mbHeight))
        this._brMbY = this._mbHeight;
      t1 = this._mbWidth;
      if (typeof t1 !== "number")
        return t1.$add();
      this._mbInfo = H.setRuntimeTypeInfo(Array(t1 + 1), [U.VP8MB]);
      t1 = this._mbWidth;
      if (typeof t1 !== "number")
        return H.iae(t1);
      this._mbData = H.setRuntimeTypeInfo(Array(t1), [U.VP8MBData]);
      t1 = this._mbWidth;
      if (typeof t1 !== "number")
        return H.iae(t1);
      this._fInfo = H.setRuntimeTypeInfo(Array(t1), [U.VP8FInfo]);
      i = 0;
      while (true) {
        t1 = this._mbWidth;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this._mbInfo;
        if (!(i < t1))
          break;
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = new U.VP8MB(0, 0);
        t1 = this._mbData;
        t2 = new Int16Array(384);
        t3 = new Uint8Array(16);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = new U.VP8MBData(t2, null, t3, null, null, null, null);
        ++i;
      }
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      t2[t1] = new U.VP8MB(0, 0);
      this._precomputeFilterStrengths$0();
      U.VP8Filter__initTables();
      this._dsp = new U.VP8Filter();
      return true;
    },
    _parseFrame$0: function() {
      var t1, t2, t3, t4, t5, tokenBr, t6, left, t7, mb, block, skip, finfo, useFilter;
      this._mbY = 0;
      t1 = this._intraL;
      t2 = this._segmentHeader;
      t3 = this._partitions;
      t4 = 0;
      while (true) {
        t5 = this._brMbY;
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(t4 < t5))
          break;
        t5 = this._numPartitions;
        if (typeof t5 !== "number")
          return t5.$sub();
        t5 = (t4 & t5 - 1) >>> 0;
        if (t5 < 0 || t5 >= 8)
          return H.ioore(t3, t5);
        tokenBr = t3[t5];
        while (true) {
          t4 = this._mbX;
          t5 = this._mbWidth;
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(t4 < t5))
            break;
          t5 = this._mbInfo;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          left = t5[0];
          t7 = 1 + t4;
          if (t7 >= t6)
            return H.ioore(t5, t7);
          mb = t5[t7];
          t7 = this._mbData;
          if (t4 >= t7.length)
            return H.ioore(t7, t4);
          block = t7[t4];
          if (t2.updateMap) {
            t4 = this.br.getBit$1(this._proba.segments[0]);
            t5 = this.br;
            t6 = this._proba;
            this._segment = t4 === 0 ? t5.getBit$1(t6.segments[1]) : 2 + t5.getBit$1(t6.segments[2]);
          }
          skip = this._useSkipProba === true && this.br.getBit$1(this._skipP) !== 0;
          this._parseIntraMode$0();
          if (!skip)
            skip = this._parseResiduals$2(mb, tokenBr);
          else {
            mb.set$nz(0);
            left.set$nz(0);
            if (block.get$isIntra4x4() !== true) {
              mb.set$nzDc(0);
              left.set$nzDc(0);
            }
            block.nonZeroY = 0;
            block.nonZeroUV = 0;
          }
          t4 = this._filterType;
          if (typeof t4 !== "number")
            return t4.$gt();
          if (t4 > 0) {
            t4 = this._fInfo;
            t5 = this._mbX;
            t6 = this._fStrengths;
            t7 = this._segment;
            t6.length;
            if (t7 >>> 0 !== t7 || t7 >= 4)
              return H.ioore(t6, t7);
            t7 = t6[t7];
            t6 = J.$index$asx(t7, block.get$isIntra4x4() === true ? 1 : 0);
            if (t5 >= t4.length)
              return H.ioore(t4, t5);
            t4[t5] = t6;
            t6 = this._fInfo;
            t5 = this._mbX;
            if (t5 >= t6.length)
              return H.ioore(t6, t5);
            finfo = t6[t5];
            finfo.fInner = finfo.get$fInner() || !skip;
          }
          ++this._mbX;
        }
        t4 = this._mbInfo;
        if (0 >= t4.length)
          return H.ioore(t4, 0);
        left = t4[0];
        left.set$nz(0);
        left.set$nzDc(0);
        C.NativeUint8List_methods.fillRange$3(t1, 0, 4, 0);
        this._mbX = 0;
        this._reconstructRow$0();
        t4 = this._filterType;
        if (typeof t4 !== "number")
          return t4.$gt();
        if (t4 > 0) {
          t4 = this._mbY;
          t5 = this._tlMbY;
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (t4 >= t5) {
            t5 = this._brMbY;
            if (typeof t5 !== "number")
              return H.iae(t5);
            t5 = t4 <= t5;
            useFilter = t5;
          } else
            useFilter = false;
        } else
          useFilter = false;
        if (!this._finishRow$1(useFilter))
          return false;
        t4 = ++this._mbY;
      }
      return true;
    },
    _reconstructRow$0: function() {
      var mb_y, y_dst, u_dst, v_dst, t1, mb_x, t2, block, j, t3, top_yuv, coeffs, bits, topRight, topRight32, p, n, dst, predFunc, bits_uv, pred_func, c1, t4, c2, y_out, u_out;
      mb_y = this._mbY;
      y_dst = U.InputBuffer$(this._yuvBlock, false, null, 40);
      u_dst = U.InputBuffer$(this._yuvBlock, false, null, 584);
      v_dst = U.InputBuffer$(this._yuvBlock, false, null, 600);
      t1 = mb_y > 0;
      mb_x = 0;
      while (true) {
        t2 = this._mbWidth;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(mb_x < t2))
          break;
        t2 = this._mbData;
        if (mb_x >= t2.length)
          return H.ioore(t2, mb_x);
        block = t2[mb_x];
        if (mb_x > 0) {
          for (j = -1; j < 16; ++j) {
            t2 = j * 32;
            y_dst.memcpy$4(t2 - 4, 4, y_dst, t2 + 12);
          }
          for (j = -1; j < 8; ++j) {
            t2 = j * 32;
            t3 = t2 - 4;
            t2 += 4;
            u_dst.memcpy$4(t3, 4, u_dst, t2);
            v_dst.memcpy$4(t3, 4, v_dst, t2);
          }
        } else {
          for (j = 0; j < 16; ++j)
            J.$indexSet$ax(y_dst.buffer, J.$add$ns(y_dst.offset, j * 32 - 1), 129);
          for (j = 0; j < 8; ++j) {
            t2 = j * 32 - 1;
            J.$indexSet$ax(u_dst.buffer, J.$add$ns(u_dst.offset, t2), 129);
            J.$indexSet$ax(v_dst.buffer, J.$add$ns(v_dst.offset, t2), 129);
          }
          if (t1) {
            J.$indexSet$ax(v_dst.buffer, J.$add$ns(v_dst.offset, -33), 129);
            J.$indexSet$ax(u_dst.buffer, J.$add$ns(u_dst.offset, -33), 129);
            J.$indexSet$ax(y_dst.buffer, J.$add$ns(y_dst.offset, -33), 129);
          }
        }
        t2 = this._yuvT;
        if (mb_x >= t2.length)
          return H.ioore(t2, mb_x);
        top_yuv = t2[mb_x];
        coeffs = block.get$coeffs();
        bits = block.nonZeroY;
        if (t1) {
          y_dst.memcpy$3(-32, 16, J.get$y$x(top_yuv));
          u_dst.memcpy$3(-32, 8, top_yuv.get$u());
          v_dst.memcpy$3(-32, 8, top_yuv.get$v());
        } else if (mb_x === 0) {
          J.fillRange$3$ax(y_dst.buffer, J.$add$ns(y_dst.offset, -33), J.$add$ns(J.$add$ns(y_dst.offset, -33), 21), 127);
          J.fillRange$3$ax(u_dst.buffer, J.$add$ns(u_dst.offset, -33), J.$add$ns(J.$add$ns(u_dst.offset, -33), 9), 127);
          J.fillRange$3$ax(v_dst.buffer, J.$add$ns(v_dst.offset, -33), J.$add$ns(J.$add$ns(v_dst.offset, -33), 9), 127);
        }
        if (block.isIntra4x4 === true) {
          topRight = U.InputBuffer$from(y_dst, null, -16);
          topRight32 = topRight.toUint32List$0();
          if (t1) {
            t2 = this._mbWidth;
            if (typeof t2 !== "number")
              return t2.$sub();
            if (mb_x >= t2 - 1) {
              t2 = J.$index$asx(J.get$y$x(top_yuv), 15);
              J.fillRange$3$ax(topRight.buffer, J.$add$ns(topRight.offset, 0), J.$add$ns(J.$add$ns(topRight.offset, 0), 4), t2);
            } else {
              t2 = this._yuvT;
              t3 = mb_x + 1;
              if (t3 >= t2.length)
                return H.ioore(t2, t3);
              topRight.memcpy$3(0, 4, J.get$y$x(t2[t3]));
            }
          }
          t2 = topRight32.length;
          if (0 >= t2)
            return H.ioore(topRight32, 0);
          p = topRight32[0];
          if (96 >= t2)
            return H.ioore(topRight32, 96);
          topRight32[96] = p;
          topRight32[64] = p;
          topRight32[32] = p;
          t2 = block.imodes;
          n = 0;
          while (n < 16) {
            dst = U.InputBuffer$from(y_dst, null, C.List_cGl0[n]);
            t3 = t2[n];
            if (t3 >= 10)
              return H.ioore(C.List_sty, t3);
            C.List_sty[t3].call$1(dst);
            t3 = n * 16;
            this._doTransform$3(bits, new U.InputBuffer(coeffs, t3, 384, t3, false), dst);
            ++n;
            if (typeof bits !== "number")
              return bits.$shl();
            bits = (bits << 2 & 4294967295) >>> 0;
          }
        } else {
          predFunc = U.VP8__checkMode(mb_x, mb_y, block.imodes[0]);
          if (predFunc >>> 0 !== predFunc || predFunc >= 7)
            return H.ioore(C.List_8aB, predFunc);
          C.List_8aB[predFunc].call$1(y_dst);
          if (bits !== 0) {
            n = 0;
            while (n < 16) {
              dst = U.InputBuffer$from(y_dst, null, C.List_cGl0[n]);
              t2 = n * 16;
              this._doTransform$3(bits, new U.InputBuffer(coeffs, t2, 384, t2, false), dst);
              ++n;
              if (typeof bits !== "number")
                return bits.$shl();
              bits = (bits << 2 & 4294967295) >>> 0;
            }
          }
        }
        bits_uv = block.nonZeroUV;
        pred_func = U.VP8__checkMode(mb_x, mb_y, block.uvmode);
        if (pred_func >>> 0 !== pred_func || pred_func >= 7)
          return H.ioore(C.List_0W6, pred_func);
        C.List_0W6[pred_func].call$1(u_dst);
        C.List_0W6[pred_func].call$1(v_dst);
        c1 = new U.InputBuffer(coeffs, 256, 384, 256, false);
        if (typeof bits_uv !== "number")
          return bits_uv.$and();
        if ((bits_uv & 255) !== 0) {
          t2 = this._dsp;
          if ((bits_uv & 170) !== 0) {
            t2.transformOne$2(c1, u_dst);
            t2.transformOne$2(U.InputBuffer$from(c1, null, 16), U.InputBuffer$from(u_dst, null, 4));
            t3 = U.InputBuffer$from(c1, null, 32);
            t4 = U.InputBuffer$from(u_dst, null, 128);
            t2.transformOne$2(t3, t4);
            t2.transformOne$2(U.InputBuffer$from(t3, null, 16), U.InputBuffer$from(t4, null, 4));
          } else
            t2.transformDCUV$2(c1, u_dst);
        }
        c2 = new U.InputBuffer(coeffs, 320, 384, 320, false);
        t2 = bits_uv >>> 8;
        if ((t2 & 255) !== 0) {
          t3 = this._dsp;
          if ((t2 & 170) !== 0) {
            t3.transformOne$2(c2, v_dst);
            t3.transformOne$2(U.InputBuffer$from(c2, null, 16), U.InputBuffer$from(v_dst, null, 4));
            t2 = U.InputBuffer$from(c2, null, 32);
            t4 = U.InputBuffer$from(v_dst, null, 128);
            t3.transformOne$2(t2, t4);
            t3.transformOne$2(U.InputBuffer$from(t2, null, 16), U.InputBuffer$from(t4, null, 4));
          } else
            t3.transformDCUV$2(c2, v_dst);
        }
        t2 = this._mbHeight;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (mb_y < t2 - 1) {
          J.setRange$4$ax(J.get$y$x(top_yuv), 0, 16, y_dst.toUint8List$0(), 480);
          J.setRange$4$ax(top_yuv.get$u(), 0, 8, u_dst.toUint8List$0(), 224);
          J.setRange$4$ax(top_yuv.get$v(), 0, 8, v_dst.toUint8List$0(), 224);
        }
        y_out = mb_x * 16;
        u_out = mb_x * 8;
        for (j = 0; j < 16; ++j) {
          t2 = this._cacheYStride;
          if (typeof t2 !== "number")
            return H.iae(t2);
          this._cacheY.memcpy$4(y_out + j * t2, 16, y_dst, j * 32);
        }
        for (j = 0; j < 8; ++j) {
          t2 = this._cacheUVStride;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = j * 32;
          this._cacheU.memcpy$4(u_out + j * t2, 8, u_dst, t3);
          t2 = this._cacheUVStride;
          if (typeof t2 !== "number")
            return H.iae(t2);
          this._cacheV.memcpy$4(u_out + j * t2, 8, v_dst, t3);
        }
        ++mb_x;
      }
    },
    _doTransform$3: function(bits, src, dst) {
      var a, c4, d4, c1, d1, t1;
      if (typeof bits !== "number")
        return bits.$shr();
      switch (bits >>> 30) {
        case 3:
          this._dsp.transformOne$2(src, dst);
          break;
        case 2:
          this._dsp.toString;
          a = J.$add$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, 0)), 4);
          c4 = J.floor$0$n(J.$div$n(J.$mul$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, 4)), 35468), 65536));
          d4 = J.floor$0$n(J.$div$n(J.$mul$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, 4)), 85627), 65536));
          c1 = J.floor$0$n(J.$div$n(J.$mul$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, 1)), 35468), 65536));
          d1 = J.floor$0$n(J.$div$n(J.$mul$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, 1)), 85627), 65536));
          t1 = J.getInterceptor$ns(a);
          U.VP8Filter__store2(dst, 0, t1.$add(a, d4), d1, c1);
          U.VP8Filter__store2(dst, 1, t1.$add(a, c4), d1, c1);
          U.VP8Filter__store2(dst, 2, t1.$sub(a, c4), d1, c1);
          U.VP8Filter__store2(dst, 3, t1.$sub(a, d4), d1, c1);
          break;
        case 1:
          this._dsp.transformDC$2(src, dst);
          break;
        default:
          break;
      }
    },
    _doFilter$2: function(mbX, mbY) {
      var yBps, t1, fInfo, yDst, ilevel, limit, uvBps, uDst, vDst, hevThresh, t2, u2, v2;
      yBps = this._cacheYStride;
      t1 = this._fInfo;
      if (mbX >>> 0 !== mbX || mbX >= t1.length)
        return H.ioore(t1, mbX);
      fInfo = t1[mbX];
      yDst = U.InputBuffer$from(this._cacheY, null, mbX * 16);
      ilevel = fInfo.get$fInnerLevel();
      limit = fInfo.fLimit;
      if (limit === 0)
        return;
      if (this._filterType === 1) {
        if (mbX > 0)
          this._dsp.simpleHFilter16$3(yDst, yBps, limit + 4);
        if (fInfo.fInner)
          this._dsp.simpleHFilter16i$3(yDst, yBps, limit);
        if (mbY > 0)
          this._dsp.simpleVFilter16$3(yDst, yBps, limit + 4);
        if (fInfo.fInner)
          this._dsp.simpleVFilter16i$3(yDst, yBps, limit);
      } else {
        uvBps = this._cacheUVStride;
        t1 = mbX * 8;
        uDst = U.InputBuffer$from(this._cacheU, null, t1);
        vDst = U.InputBuffer$from(this._cacheV, null, t1);
        hevThresh = fInfo.hevThresh;
        if (mbX > 0) {
          t1 = limit + 4;
          this._dsp._filterLoop26$7(yDst, 1, yBps, 16, t1, ilevel, hevThresh);
          t2 = this._dsp;
          t2._filterLoop26$7(uDst, 1, uvBps, 8, t1, ilevel, hevThresh);
          t2._filterLoop26$7(vDst, 1, uvBps, 8, t1, ilevel, hevThresh);
        }
        if (fInfo.fInner) {
          this._dsp.hFilter16i$5(yDst, yBps, limit, ilevel, hevThresh);
          t1 = this._dsp;
          t1.toString;
          u2 = U.InputBuffer$from(uDst, null, 4);
          v2 = U.InputBuffer$from(vDst, null, 4);
          t1._filterLoop24$7(u2, 1, uvBps, 8, limit, ilevel, hevThresh);
          t1._filterLoop24$7(v2, 1, uvBps, 8, limit, ilevel, hevThresh);
        }
        if (mbY > 0) {
          t1 = limit + 4;
          this._dsp._filterLoop26$7(yDst, yBps, 1, 16, t1, ilevel, hevThresh);
          t2 = this._dsp;
          t2._filterLoop26$7(uDst, uvBps, 1, 8, t1, ilevel, hevThresh);
          t2._filterLoop26$7(vDst, uvBps, 1, 8, t1, ilevel, hevThresh);
        }
        if (fInfo.fInner) {
          this._dsp.vFilter16i$5(yDst, yBps, limit, ilevel, hevThresh);
          t1 = this._dsp;
          t1.toString;
          if (typeof uvBps !== "number")
            return H.iae(uvBps);
          t2 = 4 * uvBps;
          u2 = U.InputBuffer$from(uDst, null, t2);
          v2 = U.InputBuffer$from(vDst, null, t2);
          t1._filterLoop24$7(u2, uvBps, 1, 8, limit, ilevel, hevThresh);
          t1._filterLoop24$7(v2, uvBps, 1, 8, limit, ilevel, hevThresh);
        }
      }
    },
    _filterRow$0: function() {
      var mbX, t1;
      mbX = this._tlMbX;
      while (true) {
        t1 = this._brMbX;
        if (typeof mbX !== "number")
          return mbX.$lt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(mbX < t1))
          break;
        this._doFilter$2(mbX, this._mbY);
        ++mbX;
      }
    },
    _finishRow$1: function(useFilter) {
      var t1, extraYRows, ySize, uvSize, yDst, t2, t3, uDst, vDst, mbY, yStart, yEnd, t4, deltaY, t5, t6, t7, t8;
      t1 = this._filterType;
      if (t1 >>> 0 !== t1 || t1 >= 3)
        return H.ioore(C.List_0_2_8, t1);
      extraYRows = C.List_0_2_8[t1];
      t1 = J.getInterceptor$ns(extraYRows);
      ySize = t1.$mul(extraYRows, this._cacheYStride);
      uvSize = J.$mul$ns(t1.$tdiv(extraYRows, 2), this._cacheUVStride);
      t1 = J.getInterceptor$n(ySize);
      yDst = U.InputBuffer$from(this._cacheY, null, t1.$negate(ySize));
      t2 = this._cacheU;
      if (typeof uvSize !== "number")
        return uvSize.$negate();
      t3 = -uvSize;
      uDst = U.InputBuffer$from(t2, null, t3);
      vDst = U.InputBuffer$from(this._cacheV, null, t3);
      mbY = this._mbY;
      t2 = J.$sub$n(this._brMbY, 1);
      if (typeof t2 !== "number")
        return H.iae(t2);
      yStart = mbY * 16;
      yEnd = (mbY + 1) * 16;
      if (useFilter)
        this._filterRow$0();
      if (this._dither)
        ;
      if (mbY !== 0) {
        if (typeof extraYRows !== "number")
          return H.iae(extraYRows);
        yStart -= extraYRows;
        this._y = U.InputBuffer$from(yDst, null, 0);
        this._u = U.InputBuffer$from(uDst, null, 0);
        this._v = U.InputBuffer$from(vDst, null, 0);
      } else {
        this._y = U.InputBuffer$from(this._cacheY, null, 0);
        this._u = U.InputBuffer$from(this._cacheU, null, 0);
        this._v = U.InputBuffer$from(this._cacheV, null, 0);
      }
      t2 = !(mbY >= t2);
      if (t2) {
        if (typeof extraYRows !== "number")
          return H.iae(extraYRows);
        yEnd -= extraYRows;
      }
      t4 = this._cropBottom;
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (yEnd > t4)
        yEnd = t4;
      this._a = null;
      if (this._alphaData != null && yStart < yEnd) {
        t4 = this._decompressAlphaRows$2(yStart, yEnd - yStart);
        this._a = t4;
        if (t4 == null)
          return false;
      }
      t4 = this._cropTop;
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (yStart < t4) {
        deltaY = t4 - yStart;
        t5 = this._y;
        t6 = t5.offset;
        t7 = this._cacheYStride;
        if (typeof t7 !== "number")
          return t7.$mul();
        t5.offset = J.$add$ns(t6, t7 * deltaY);
        t7 = this._u;
        t6 = t7.offset;
        t5 = this._cacheUVStride;
        t8 = C.JSNumber_methods._shrOtherPositive$1(deltaY, 1);
        if (typeof t5 !== "number")
          return t5.$mul();
        t7.offset = J.$add$ns(t6, t5 * t8);
        t5 = this._v;
        t6 = t5.offset;
        t7 = this._cacheUVStride;
        if (typeof t7 !== "number")
          return t7.$mul();
        t5.offset = J.$add$ns(t6, t7 * t8);
        t5 = this._a;
        if (t5 != null)
          t5.offset = J.$add$ns(t5.offset, J.$mul$ns(this.webp.width, deltaY));
        yStart = t4;
      }
      if (yStart < yEnd) {
        t4 = this._y;
        t4.offset = J.$add$ns(t4.offset, this._cropLeft);
        t4 = this._u;
        t5 = t4.offset;
        t6 = this._cropLeft;
        if (typeof t6 !== "number")
          return t6.$shr();
        t4.offset = J.$add$ns(t5, t6 >>> 1);
        t6 = this._v;
        t5 = t6.offset;
        t4 = this._cropLeft;
        if (typeof t4 !== "number")
          return t4.$shr();
        t6.offset = J.$add$ns(t5, t4 >>> 1);
        t4 = this._a;
        if (t4 != null)
          t4.offset = J.$add$ns(t4.offset, this._cropLeft);
        t4 = this._cropTop;
        if (typeof t4 !== "number")
          return H.iae(t4);
        this._put$3(yStart - t4, J.$sub$n(this._cropRight, this._cropLeft), yEnd - yStart);
      }
      if (t2) {
        t2 = this._cacheY;
        t1 = t1.$negate(ySize);
        t4 = this._cacheYStride;
        if (typeof t4 !== "number")
          return H.iae(t4);
        t2.memcpy$4(t1, ySize, yDst, 16 * t4);
        t4 = this._cacheU;
        t1 = this._cacheUVStride;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t4.memcpy$4(t3, uvSize, uDst, 8 * t1);
        t1 = this._cacheV;
        t4 = this._cacheUVStride;
        if (typeof t4 !== "number")
          return H.iae(t4);
        t1.memcpy$4(t3, uvSize, vDst, 8 * t4);
      }
      return true;
    },
    _put$3: function(mbY, mbW, mbH) {
      if (J.$le$n(mbW, 0) || J.$le$n(mbH, 0))
        return false;
      this._emitFancyRGB$3(mbY, mbW, mbH);
      this._emitAlphaRGB$3(mbY, mbW, mbH);
      return true;
    },
    _upsample$9: function(topY, bottomY, topU, topV, curU, curV, topDst, bottomDst, len) {
      var t1, t2, tl_uv, l_uv, uv0, t3, t4, t5, t6, d, t7, x, t_uv, uv, avg, uv1, t8, t9, t10, t11, t12, t13;
      t1 = new U.VP8__upsample_LOAD_UV();
      t2 = J.$sub$n(len, 1);
      if (typeof t2 !== "number")
        return t2.$shr();
      t2 = C.JSNumber_methods._shrOtherPositive$1(t2, 1);
      tl_uv = t1.call$2(J.$index$asx(topU.buffer, J.$add$ns(topU.offset, 0)), J.$index$asx(topV.buffer, J.$add$ns(topV.offset, 0)));
      l_uv = t1.call$2(J.$index$asx(curU.buffer, J.$add$ns(curU.offset, 0)), J.$index$asx(curV.buffer, J.$add$ns(curV.offset, 0)));
      if (typeof tl_uv !== "number")
        return H.iae(tl_uv);
      if (typeof l_uv !== "number")
        return H.iae(l_uv);
      uv0 = C.JSNumber_methods._shrOtherPositive$1(3 * tl_uv + l_uv + 131074, 2);
      t3 = J.$index$asx(topY.buffer, J.$add$ns(topY.offset, 0));
      t4 = uv0 & 255;
      t5 = uv0 >>> 16;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = 19077 * t3;
      t6 = t3 + 26149 * t5 + -3644112;
      if ((t6 & -4194304) >>> 0 === 0)
        d = C.JSNumber_methods._shrOtherPositive$1(t6, 14);
      else
        d = t6 < 0 ? 0 : 255;
      J.$indexSet$ax(topDst.buffer, J.$add$ns(topDst.offset, 0), d);
      t5 = t3 - 6419 * t4 - 13320 * t5 + 2229552;
      if ((t5 & -4194304) >>> 0 === 0)
        d = C.JSNumber_methods._shrOtherPositive$1(t5, 14);
      else
        d = t5 < 0 ? 0 : 255;
      J.$indexSet$ax(topDst.buffer, J.$add$ns(topDst.offset, 1), d);
      t3 = t3 + 33050 * t4 + -4527440;
      if ((t3 & -4194304) >>> 0 === 0)
        d = C.JSNumber_methods._shrOtherPositive$1(t3, 14);
      else
        d = t3 < 0 ? 0 : 255;
      J.$indexSet$ax(topDst.buffer, J.$add$ns(topDst.offset, 2), d);
      J.$indexSet$ax(topDst.buffer, J.$add$ns(topDst.offset, 3), 255);
      t3 = bottomY != null;
      if (t3) {
        uv0 = C.JSNumber_methods._shrOtherPositive$1(3 * l_uv + tl_uv + 131074, 2);
        t4 = J.$index$asx(bottomY.buffer, J.$add$ns(bottomY.offset, 0));
        t5 = uv0 & 255;
        t6 = uv0 >>> 16;
        if (typeof t4 !== "number")
          return H.iae(t4);
        t4 = 19077 * t4;
        t7 = t4 + 26149 * t6 + -3644112;
        if ((t7 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t7, 14);
        else
          d = t7 < 0 ? 0 : 255;
        J.$indexSet$ax(bottomDst.buffer, J.$add$ns(bottomDst.offset, 0), d);
        t6 = t4 - 6419 * t5 - 13320 * t6 + 2229552;
        if ((t6 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t6, 14);
        else
          d = t6 < 0 ? 0 : 255;
        J.$indexSet$ax(bottomDst.buffer, J.$add$ns(bottomDst.offset, 1), d);
        t4 = t4 + 33050 * t5 + -4527440;
        if ((t4 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t4, 14);
        else
          d = t4 < 0 ? 0 : 255;
        J.$indexSet$ax(bottomDst.buffer, J.$add$ns(bottomDst.offset, 2), d);
        J.$indexSet$ax(bottomDst.buffer, J.$add$ns(bottomDst.offset, 3), 255);
      }
      for (x = 1; x <= t2; ++x, l_uv = uv, tl_uv = t_uv) {
        t_uv = t1.call$2(J.$index$asx(topU.buffer, J.$add$ns(topU.offset, x)), J.$index$asx(topV.buffer, J.$add$ns(topV.offset, x)));
        uv = t1.call$2(J.$index$asx(curU.buffer, J.$add$ns(curU.offset, x)), J.$index$asx(curV.buffer, J.$add$ns(curV.offset, x)));
        t4 = J.getInterceptor$ns(tl_uv);
        avg = J.$add$ns(J.$add$ns(J.$add$ns(t4.$add(tl_uv, t_uv), l_uv), uv), 524296);
        t5 = J.$add$ns(t_uv, l_uv);
        if (typeof t5 !== "number")
          return H.iae(t5);
        t6 = J.getInterceptor$ns(avg);
        t5 = t6.$add(avg, 2 * t5);
        if (typeof t5 !== "number")
          return t5.$shr();
        t5 = C.JSNumber_methods._shrOtherPositive$1(t5, 3);
        t4 = t4.$add(tl_uv, uv);
        if (typeof t4 !== "number")
          return H.iae(t4);
        t4 = t6.$add(avg, 2 * t4);
        if (typeof t4 !== "number")
          return t4.$shr();
        t4 = C.JSNumber_methods._shrOtherPositive$1(t4, 3);
        if (typeof tl_uv !== "number")
          return H.iae(tl_uv);
        uv0 = C.JSNumber_methods._shrOtherPositive$1(t5 + tl_uv, 1);
        if (typeof t_uv !== "number")
          return H.iae(t_uv);
        uv1 = C.JSNumber_methods._shrOtherPositive$1(t4 + t_uv, 1);
        t6 = 2 * x;
        t7 = t6 - 1;
        t8 = J.$index$asx(topY.buffer, J.$add$ns(topY.offset, t7));
        t9 = uv0 & 255;
        t10 = uv0 >>> 16;
        t11 = t7 * 4;
        t12 = U.InputBuffer$from(topDst, null, t11);
        if (typeof t8 !== "number")
          return H.iae(t8);
        t8 = 19077 * t8;
        t13 = t8 + 26149 * t10 + -3644112;
        if ((t13 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t13, 14);
        else
          d = t13 < 0 ? 0 : 255;
        J.$indexSet$ax(t12.buffer, J.$add$ns(t12.offset, 0), d);
        t10 = t8 - 6419 * t9 - 13320 * t10 + 2229552;
        if ((t10 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t10, 14);
        else
          d = t10 < 0 ? 0 : 255;
        J.$indexSet$ax(t12.buffer, J.$add$ns(t12.offset, 1), d);
        t8 = t8 + 33050 * t9 + -4527440;
        if ((t8 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t8, 14);
        else
          d = t8 < 0 ? 0 : 255;
        J.$indexSet$ax(t12.buffer, J.$add$ns(t12.offset, 2), d);
        J.$indexSet$ax(t12.buffer, J.$add$ns(t12.offset, 3), 255);
        t8 = t6 - 0;
        t9 = J.$index$asx(topY.buffer, J.$add$ns(topY.offset, t8));
        t10 = uv1 & 255;
        t12 = uv1 >>> 16;
        t8 = U.InputBuffer$from(topDst, null, t8 * 4);
        if (typeof t9 !== "number")
          return H.iae(t9);
        t9 = 19077 * t9;
        t13 = t9 + 26149 * t12 + -3644112;
        if ((t13 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t13, 14);
        else
          d = t13 < 0 ? 0 : 255;
        J.$indexSet$ax(t8.buffer, J.$add$ns(t8.offset, 0), d);
        t12 = t9 - 6419 * t10 - 13320 * t12 + 2229552;
        if ((t12 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t12, 14);
        else
          d = t12 < 0 ? 0 : 255;
        J.$indexSet$ax(t8.buffer, J.$add$ns(t8.offset, 1), d);
        t9 = t9 + 33050 * t10 + -4527440;
        if ((t9 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t9, 14);
        else
          d = t9 < 0 ? 0 : 255;
        J.$indexSet$ax(t8.buffer, J.$add$ns(t8.offset, 2), d);
        J.$indexSet$ax(t8.buffer, J.$add$ns(t8.offset, 3), 255);
        if (t3) {
          if (typeof l_uv !== "number")
            return H.iae(l_uv);
          uv0 = C.JSNumber_methods._shrOtherPositive$1(t4 + l_uv, 1);
          if (typeof uv !== "number")
            return H.iae(uv);
          uv1 = C.JSNumber_methods._shrOtherPositive$1(t5 + uv, 1);
          t4 = J.$index$asx(bottomY.buffer, J.$add$ns(bottomY.offset, t7));
          t5 = uv0 & 255;
          t7 = uv0 >>> 16;
          t11 = U.InputBuffer$from(bottomDst, null, t11);
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = 19077 * t4;
          t8 = t4 + 26149 * t7 + -3644112;
          if ((t8 & -4194304) >>> 0 === 0)
            d = C.JSNumber_methods._shrOtherPositive$1(t8, 14);
          else
            d = t8 < 0 ? 0 : 255;
          J.$indexSet$ax(t11.buffer, J.$add$ns(t11.offset, 0), d);
          t7 = t4 - 6419 * t5 - 13320 * t7 + 2229552;
          if ((t7 & -4194304) >>> 0 === 0)
            d = C.JSNumber_methods._shrOtherPositive$1(t7, 14);
          else
            d = t7 < 0 ? 0 : 255;
          J.$indexSet$ax(t11.buffer, J.$add$ns(t11.offset, 1), d);
          t4 = t4 + 33050 * t5 + -4527440;
          if ((t4 & -4194304) >>> 0 === 0)
            d = C.JSNumber_methods._shrOtherPositive$1(t4, 14);
          else
            d = t4 < 0 ? 0 : 255;
          J.$indexSet$ax(t11.buffer, J.$add$ns(t11.offset, 2), d);
          J.$indexSet$ax(t11.buffer, J.$add$ns(t11.offset, 3), 255);
          t4 = J.$index$asx(bottomY.buffer, J.$add$ns(bottomY.offset, t6));
          t5 = uv1 & 255;
          t7 = uv1 >>> 16;
          t6 = U.InputBuffer$from(bottomDst, null, t6 * 4);
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = 19077 * t4;
          t8 = t4 + 26149 * t7 + -3644112;
          if ((t8 & -4194304) >>> 0 === 0)
            d = C.JSNumber_methods._shrOtherPositive$1(t8, 14);
          else
            d = t8 < 0 ? 0 : 255;
          J.$indexSet$ax(t6.buffer, J.$add$ns(t6.offset, 0), d);
          t7 = t4 - 6419 * t5 - 13320 * t7 + 2229552;
          if ((t7 & -4194304) >>> 0 === 0)
            d = C.JSNumber_methods._shrOtherPositive$1(t7, 14);
          else
            d = t7 < 0 ? 0 : 255;
          J.$indexSet$ax(t6.buffer, J.$add$ns(t6.offset, 1), d);
          t4 = t4 + 33050 * t5 + -4527440;
          if ((t4 & -4194304) >>> 0 === 0)
            d = C.JSNumber_methods._shrOtherPositive$1(t4, 14);
          else
            d = t4 < 0 ? 0 : 255;
          J.$indexSet$ax(t6.buffer, J.$add$ns(t6.offset, 2), d);
          J.$indexSet$ax(t6.buffer, J.$add$ns(t6.offset, 3), 255);
        }
      }
      if (typeof len !== "number")
        return len.$and();
      if ((len & 1) === 0) {
        if (typeof tl_uv !== "number")
          return H.iae(tl_uv);
        if (typeof l_uv !== "number")
          return H.iae(l_uv);
        uv0 = C.JSNumber_methods._shrOtherPositive$1(3 * tl_uv + l_uv + 131074, 2);
        t1 = len - 1;
        t2 = J.$index$asx(topY.buffer, J.$add$ns(topY.offset, t1));
        t4 = uv0 & 255;
        t5 = uv0 >>> 16;
        t6 = t1 * 4;
        t7 = U.InputBuffer$from(topDst, null, t6);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = 19077 * t2;
        t8 = t2 + 26149 * t5 + -3644112;
        if ((t8 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t8, 14);
        else
          d = t8 < 0 ? 0 : 255;
        J.$indexSet$ax(t7.buffer, J.$add$ns(t7.offset, 0), d);
        t5 = t2 - 6419 * t4 - 13320 * t5 + 2229552;
        if ((t5 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t5, 14);
        else
          d = t5 < 0 ? 0 : 255;
        J.$indexSet$ax(t7.buffer, J.$add$ns(t7.offset, 1), d);
        t2 = t2 + 33050 * t4 + -4527440;
        if ((t2 & -4194304) >>> 0 === 0)
          d = C.JSNumber_methods._shrOtherPositive$1(t2, 14);
        else
          d = t2 < 0 ? 0 : 255;
        J.$indexSet$ax(t7.buffer, J.$add$ns(t7.offset, 2), d);
        J.$indexSet$ax(t7.buffer, J.$add$ns(t7.offset, 3), 255);
        if (t3) {
          uv0 = C.JSNumber_methods._shrOtherPositive$1(3 * l_uv + tl_uv + 131074, 2);
          t1 = J.$index$asx(bottomY.buffer, J.$add$ns(bottomY.offset, t1));
          t2 = uv0 & 255;
          t3 = uv0 >>> 16;
          t6 = U.InputBuffer$from(bottomDst, null, t6);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = 19077 * t1;
          t4 = t1 + 26149 * t3 + -3644112;
          if ((t4 & -4194304) >>> 0 === 0)
            d = C.JSNumber_methods._shrOtherPositive$1(t4, 14);
          else
            d = t4 < 0 ? 0 : 255;
          J.$indexSet$ax(t6.buffer, J.$add$ns(t6.offset, 0), d);
          t3 = t1 - 6419 * t2 - 13320 * t3 + 2229552;
          if ((t3 & -4194304) >>> 0 === 0)
            d = C.JSNumber_methods._shrOtherPositive$1(t3, 14);
          else
            d = t3 < 0 ? 0 : 255;
          J.$indexSet$ax(t6.buffer, J.$add$ns(t6.offset, 1), d);
          t1 = t1 + 33050 * t2 + -4527440;
          if ((t1 & -4194304) >>> 0 === 0)
            d = C.JSNumber_methods._shrOtherPositive$1(t1, 14);
          else
            d = t1 < 0 ? 0 : 255;
          J.$indexSet$ax(t6.buffer, J.$add$ns(t6.offset, 2), d);
          J.$indexSet$ax(t6.buffer, J.$add$ns(t6.offset, 3), 255);
        }
      }
    },
    _emitAlphaRGB$3: function(mbY, mbW, mbH) {
      var t1, stride, alpha, numRows, startY, t2, dst, t3, y, x;
      if (this._a == null)
        return;
      t1 = this.webp;
      stride = J.$mul$ns(t1.width, 4);
      alpha = U.InputBuffer$from(this._a, null, 0);
      if (mbY === 0) {
        numRows = J.$sub$n(mbH, 1);
        startY = mbY;
      } else {
        startY = mbY - 1;
        alpha.offset = J.$sub$n(alpha.offset, t1.width);
        numRows = mbH;
      }
      t2 = H.NativeUint8List_NativeUint8List$view(this.output.data.buffer, 0, null);
      if (typeof stride !== "number")
        return H.iae(stride);
      dst = U.InputBuffer$(t2, false, null, startY * stride + 3);
      t2 = this._cropTop;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof mbH !== "number")
        return H.iae(mbH);
      t3 = this._cropBottom;
      if (t2 + mbY + mbH === t3)
        numRows = J.$sub$n(J.$sub$n(t3, t2), startY);
      if (typeof numRows !== "number")
        return H.iae(numRows);
      y = 0;
      for (; y < numRows; ++y) {
        if (typeof mbW !== "number")
          return H.iae(mbW);
        x = 0;
        for (; t2 = alpha.offset, x < mbW; ++x) {
          t2 = J.$and$n(J.$index$asx(alpha.buffer, J.$add$ns(t2, x)), 255);
          J.$indexSet$ax(dst.buffer, J.$add$ns(dst.offset, 4 * x), t2);
        }
        alpha.offset = J.$add$ns(t2, t1.width);
        dst.offset = J.$add$ns(dst.offset, stride);
      }
    },
    _emitFancyRGB$3: function(mbY, mbW, mbH) {
      var t1, t2, t3, dst, curY, curU, curV, yEnd, stride, topU, topV, numLinesOut, y;
      t1 = H.NativeUint8List_NativeUint8List$view(this.output.data.buffer, 0, null);
      t2 = this.webp;
      t3 = t2.width;
      if (typeof t3 !== "number")
        return H.iae(t3);
      dst = U.InputBuffer$(t1, false, null, mbY * t3 * 4);
      curY = U.InputBuffer$from(this._y, null, 0);
      curU = U.InputBuffer$from(this._u, null, 0);
      curV = U.InputBuffer$from(this._v, null, 0);
      if (typeof mbH !== "number")
        return H.iae(mbH);
      yEnd = mbY + mbH;
      t3 = J.$add$ns(mbW, 1);
      if (typeof t3 !== "number")
        return t3.$shr();
      t3 = C.JSNumber_methods._shrOtherPositive$1(t3, 1);
      stride = J.$mul$ns(t2.width, 4);
      topU = U.InputBuffer$from(this._tmpU, null, 0);
      topV = U.InputBuffer$from(this._tmpV, null, 0);
      t2.progressCallback;
      if (mbY === 0) {
        this._upsample$9(curY, null, curU, curV, curU, curV, dst, null, mbW);
        numLinesOut = mbH;
      } else {
        this._upsample$9(this._tmpY, curY, topU, topV, curU, curV, U.InputBuffer$from(dst, null, J.$negate$n(stride)), dst, mbW);
        numLinesOut = mbH + 1;
      }
      topU.buffer = curU.buffer;
      topV.buffer = curV.buffer;
      for (y = mbY; y += 2, y < yEnd;) {
        topU.offset = curU.offset;
        topV.offset = curV.offset;
        curU.offset = J.$add$ns(curU.offset, this._cacheUVStride);
        curV.offset = J.$add$ns(curV.offset, this._cacheUVStride);
        t1 = dst.offset;
        if (typeof stride !== "number")
          return H.iae(stride);
        dst.offset = J.$add$ns(t1, 2 * stride);
        t1 = curY.offset;
        t2 = this._cacheYStride;
        if (typeof t2 !== "number")
          return H.iae(t2);
        curY.offset = J.$add$ns(t1, 2 * t2);
        t2 = this._cacheYStride;
        if (typeof t2 !== "number")
          return t2.$negate();
        this._upsample$9(U.InputBuffer$from(curY, null, -t2), curY, topU, topV, curU, curV, U.InputBuffer$from(dst, null, -stride), dst, mbW);
      }
      curY.offset = J.$add$ns(curY.offset, this._cacheYStride);
      t1 = this._cropTop;
      if (typeof t1 !== "number")
        return t1.$add();
      t2 = this._cropBottom;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 + yEnd < t2) {
        this._tmpY.memcpy$3(0, mbW, curY);
        this._tmpU.memcpy$3(0, t3, curU);
        this._tmpV.memcpy$3(0, t3, curV);
        --numLinesOut;
      } else if ((yEnd & 1) === 0)
        this._upsample$9(curY, null, curU, curV, curU, curV, U.InputBuffer$from(dst, null, stride), null, mbW);
      return numLinesOut;
    },
    _decompressAlphaRows$2: function(row, numRows) {
      var t1, width, height, t2;
      t1 = this.webp;
      width = t1.width;
      height = t1.height;
      if (!(row < 0))
        if (!J.$le$n(numRows, 0)) {
          if (typeof numRows !== "number")
            return H.iae(numRows);
          if (typeof height !== "number")
            return H.iae(height);
          t1 = row + numRows > height;
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return;
      if (row === 0) {
        t1 = J.$mul$ns(width, height);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        this._alphaPlane = new Uint8Array(t1);
        t1 = this._alphaData;
        t2 = new U.WebPAlpha(t1, width, height, 0, 0, 0, 1, false, null, false);
        t2.WebPAlpha$3(t1, width, height);
        this._alpha = t2;
      }
      t1 = this._alpha;
      if (!t1.isAlphaDecoded)
        if (!t1.decode$3(row, numRows, this._alphaPlane))
          return;
      t1 = this._alphaPlane;
      if (typeof width !== "number")
        return H.iae(width);
      return U.InputBuffer$(t1, false, null, row * width);
    },
    _parseResiduals$2: function(mb, tokenBr) {
      var bands, t1, t2, q, block, dst, leftMb, dc, nz, i, acProba, first, tnz, lnz, nonZeroY, y, l, nzCoeffs, x, nz_coeffs, outLeftNz, outTopNz, nonZeroUV, ch;
      bands = this._proba.bands;
      t1 = this._dqm;
      t2 = this._segment;
      if (t2 >>> 0 !== t2 || t2 >= 4)
        return H.ioore(t1, t2);
      q = t1[t2];
      t2 = this._mbData;
      t1 = this._mbX;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      block = t2[t1];
      dst = U.InputBuffer$(block.get$coeffs(), false, null, 0);
      t1 = this._mbInfo;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      leftMb = t1[0];
      dst.memset$3(0, J.$sub$n(dst.end, dst.offset), 0);
      if (block.isIntra4x4 !== true) {
        dc = U.InputBuffer$(new Int16Array(16), false, null, 0);
        t1 = mb.get$nzDc();
        t2 = leftMb.get$nzDc();
        nz = this._getCoeffs$6(tokenBr, bands[1], t1 + t2, q.get$y2Mat(), 0, dc);
        t1 = nz > 0 ? 1 : 0;
        leftMb.nzDc = t1;
        mb.nzDc = t1;
        if (nz > 1)
          this._transformWHT$2(dc, dst);
        else {
          t1 = J.$add$ns(J.$index$asx(dc.buffer, J.$add$ns(dc.offset, 0)), 3);
          if (typeof t1 !== "number")
            return t1.$shr();
          t1 = C.JSNumber_methods._shrOtherPositive$1(t1, 3);
          for (i = 0; i < 256; i += 16)
            J.$indexSet$ax(dst.buffer, J.$add$ns(dst.offset, i), t1);
        }
        acProba = bands[0];
        first = 1;
      } else {
        acProba = bands[3];
        first = 0;
      }
      tnz = J.$and$n(mb.get$nz(), 15);
      lnz = J.$and$n(leftMb.get$nz(), 15);
      for (nonZeroY = 0, y = 0; y < 4; ++y) {
        l = lnz & 1;
        for (nzCoeffs = 0, x = 0; x < 4; ++x, nzCoeffs = nz_coeffs) {
          nz = this._getCoeffs$6(tokenBr, acProba, l + (tnz & 1), q.get$y1Mat(), first, dst);
          l = nz > first ? 1 : 0;
          tnz = tnz >>> 1 | l << 7;
          t1 = !J.$eq(J.$index$asx(dst.buffer, J.$add$ns(dst.offset, 0)), 0) ? 1 : 0;
          if (nz > 3)
            t1 = 3;
          else if (nz > 1)
            t1 = 2;
          nz_coeffs = nzCoeffs << 2 | t1;
          dst.offset = J.$add$ns(dst.offset, 16);
        }
        tnz = tnz >>> 4;
        lnz = lnz >>> 1 | l << 7;
        nonZeroY = (nonZeroY << 8 | nzCoeffs) >>> 0;
      }
      outLeftNz = lnz >>> 4;
      for (outTopNz = tnz, nonZeroUV = 0, ch = 0; ch < 4; ch += 2) {
        t1 = mb.get$nz();
        t2 = 4 + ch;
        if (typeof t1 !== "number")
          return t1.$shr();
        tnz = C.JSNumber_methods._shrOtherPositive$1(t1, t2);
        t1 = leftMb.get$nz();
        if (typeof t1 !== "number")
          return t1.$shr();
        lnz = C.JSNumber_methods._shrOtherPositive$1(t1, t2);
        for (nzCoeffs = 0, y = 0; y < 2; ++y) {
          l = lnz & 1;
          for (x = 0; x < 2; ++x, nzCoeffs = nz_coeffs) {
            nz = this._getCoeffs$6(tokenBr, bands[2], l + (tnz & 1), q.get$uvMat(), 0, dst);
            l = nz > 0 ? 1 : 0;
            tnz = tnz >>> 1 | l << 3;
            t1 = !J.$eq(J.$index$asx(dst.buffer, J.$add$ns(dst.offset, 0)), 0) ? 1 : 0;
            if (nz > 3)
              t1 = 3;
            else if (nz > 1)
              t1 = 2;
            nz_coeffs = (nzCoeffs << 2 | t1) >>> 0;
            dst.offset = J.$add$ns(dst.offset, 16);
          }
          tnz = tnz >>> 2;
          lnz = lnz >>> 1 | l << 5;
        }
        nonZeroUV = (nonZeroUV | C.JSInt_methods._shlPositive$1(nzCoeffs, 4 * ch)) >>> 0;
        outTopNz = (outTopNz | C.JSInt_methods._shlPositive$1(tnz << 4 >>> 0, ch)) >>> 0;
        outLeftNz = (outLeftNz | C.JSInt_methods._shlPositive$1(lnz & 240, ch)) >>> 0;
      }
      mb.set$nz(outTopNz);
      leftMb.set$nz(outLeftNz);
      block.nonZeroY = nonZeroY;
      block.nonZeroUV = nonZeroUV;
      block.dither = (nonZeroUV & 43690) !== 0 ? 0 : q.get$dither();
      return (nonZeroY | nonZeroUV) >>> 0 === 0;
    },
    _transformWHT$2: function(src, out) {
      var tmp, i, t1, a0, t2, t3, a1, a2, a3, t4, oi, dc;
      tmp = new Int32Array(16);
      for (i = 0; i < 4; ++i) {
        t1 = 12 + i;
        a0 = J.$add$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, i)), J.$index$asx(src.buffer, J.$add$ns(src.offset, t1)));
        t2 = 4 + i;
        t3 = 8 + i;
        a1 = J.$add$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, t2)), J.$index$asx(src.buffer, J.$add$ns(src.offset, t3)));
        a2 = J.$sub$n(J.$index$asx(src.buffer, J.$add$ns(src.offset, t2)), J.$index$asx(src.buffer, J.$add$ns(src.offset, t3)));
        a3 = J.$sub$n(J.$index$asx(src.buffer, J.$add$ns(src.offset, i)), J.$index$asx(src.buffer, J.$add$ns(src.offset, t1)));
        t4 = J.getInterceptor$ns(a0);
        tmp[i] = t4.$add(a0, a1);
        tmp[t3] = t4.$sub(a0, a1);
        t4 = J.getInterceptor$ns(a3);
        tmp[t2] = t4.$add(a3, a2);
        tmp[t1] = t4.$sub(a3, a2);
      }
      for (oi = 0, i = 0; i < 4; ++i) {
        t1 = i * 4;
        if (t1 >= 16)
          return H.ioore(tmp, t1);
        dc = tmp[t1] + 3;
        t2 = 3 + t1;
        if (t2 >= 16)
          return H.ioore(tmp, t2);
        t2 = tmp[t2];
        a0 = dc + t2;
        t3 = 1 + t1;
        if (t3 >= 16)
          return H.ioore(tmp, t3);
        t3 = tmp[t3];
        t1 = 2 + t1;
        if (t1 >= 16)
          return H.ioore(tmp, t1);
        t1 = tmp[t1];
        a1 = t3 + t1;
        a2 = t3 - t1;
        a3 = dc - t2;
        t2 = C.JSInt_methods._shrOtherPositive$1(a0 + a1, 3);
        J.$indexSet$ax(out.buffer, J.$add$ns(out.offset, oi), t2);
        t2 = C.JSInt_methods._shrOtherPositive$1(a3 + a2, 3);
        J.$indexSet$ax(out.buffer, J.$add$ns(out.offset, oi + 16), t2);
        t2 = C.JSInt_methods._shrOtherPositive$1(a0 - a1, 3);
        J.$indexSet$ax(out.buffer, J.$add$ns(out.offset, oi + 32), t2);
        t2 = C.JSInt_methods._shrOtherPositive$1(a3 - a2, 3);
        J.$indexSet$ax(out.buffer, J.$add$ns(out.offset, oi + 48), t2);
        oi += 64;
      }
    },
    _getLargeValue$2: function(br, p) {
      var t1, v, bit1, cat, tab, len, i;
      t1 = J.getInterceptor$asx(p);
      if (br.getBit$1(t1.$index(p, 3)) === 0)
        v = br.getBit$1(t1.$index(p, 4)) === 0 ? 2 : 3 + br.getBit$1(t1.$index(p, 5));
      else if (br.getBit$1(t1.$index(p, 6)) === 0)
        v = br.getBit$1(t1.$index(p, 7)) === 0 ? 5 + br.getBit$1(159) : 7 + 2 * br.getBit$1(165) + br.getBit$1(145);
      else {
        bit1 = br.getBit$1(t1.$index(p, 8));
        cat = 2 * bit1 + br.getBit$1(t1.$index(p, 9 + bit1));
        if (cat >= 4)
          return H.ioore(C.List_sao, cat);
        tab = C.List_sao[cat];
        t1 = J.getInterceptor$asx(tab);
        len = t1.get$length(tab);
        if (typeof len !== "number")
          return H.iae(len);
        v = 0;
        i = 0;
        for (; i < len; ++i)
          v += v + br.getBit$1(t1.$index(tab, i));
        v += 3 + C.JSInt_methods._shlPositive$1(8, cat);
      }
      return v;
    },
    _getCoeffs$6: function(br, prob, ctx, dq, n, out) {
      var t1, t2, p, n0, p_ctx, v, t3, bit, shift, t4;
      t1 = J.getInterceptor$asx(prob);
      t2 = t1.$index(prob, n).get$probas();
      if (ctx >>> 0 !== ctx || ctx >= 3)
        return H.ioore(t2, ctx);
      p = t2[ctx];
      for (; n < 16; n = n0) {
        if (br.getBit$1(J.$index$asx(p, 0)) === 0)
          return n;
        for (; t2 = J.getInterceptor$asx(p), n0 = n + 1, br.getBit$1(t2.$index(p, 1)) === 0; n = n0) {
          if (n0 < 0 || n0 >= 17)
            return H.ioore(C.List_F1L, n0);
          p = t1.$index(prob, C.List_F1L[n0]).get$probas()[0];
          if (n0 === 16)
            return 16;
        }
        if (n0 < 0 || n0 >= 17)
          return H.ioore(C.List_F1L, n0);
        p_ctx = t1.$index(prob, C.List_F1L[n0]).get$probas();
        if (br.getBit$1(t2.$index(p, 2)) === 0) {
          p = p_ctx[1];
          v = 1;
        } else {
          v = this._getLargeValue$2(br, p);
          p = p_ctx[2];
        }
        if (n < 0 || n >= 16)
          return H.ioore(C.List_cGl1, n);
        t2 = C.List_cGl1[n];
        t3 = br._range;
        if (typeof t3 !== "number")
          return t3.$shr();
        bit = br._bitUpdate$1(C.JSNumber_methods._shrOtherPositive$1(t3, 1));
        t3 = br._range;
        if (t3 >>> 0 !== t3 || t3 >= 128)
          return H.ioore(C.List_8co0, t3);
        shift = C.List_8co0[t3];
        br._range = C.List_wmc[t3];
        t3 = br._bits;
        if (typeof shift !== "number")
          return H.iae(shift);
        br._bits = t3 - shift;
        t3 = bit !== 0 ? -v : v;
        t4 = dq[n > 0 ? 1 : 0];
        J.$indexSet$ax(out.buffer, J.$add$ns(out.offset, t2), t3 * t4);
      }
      return 16;
    },
    _parseIntraMode$0: function() {
      var t1, ti, $top, left, t2, block, ymode, modes, mi, y, x, prob, b, i, t3, mi0;
      t1 = this._mbX;
      ti = 4 * t1;
      $top = this._intraT;
      left = this._intraL;
      t2 = this._mbData;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      block = t2[t1];
      block.set$isIntra4x4(this.br.getBit$1(145) === 0);
      if (block.isIntra4x4 !== true) {
        if (this.br.getBit$1(156) !== 0)
          ymode = this.br.getBit$1(128) !== 0 ? 1 : 3;
        else
          ymode = this.br.getBit$1(163) !== 0 ? 2 : 0;
        block.imodes[0] = ymode;
        J.fillRange$3$ax($top, ti, ti + 4, ymode);
        C.NativeUint8List_methods.fillRange$3(left, 0, 4, ymode);
      } else {
        modes = block.imodes;
        for (mi = 0, y = 0; y < 4; ++y, mi = mi0) {
          ymode = left[y];
          for (x = 0; x < 4; ++x) {
            t1 = ti + x;
            if (t1 >= $top.length)
              return H.ioore($top, t1);
            t2 = $top[t1];
            if (t2 >= 10)
              return H.ioore(C.List_799, t2);
            prob = J.$index$asx(C.List_799[t2], ymode);
            t2 = J.getInterceptor$asx(prob);
            b = this.br.getBit$1(t2.$index(prob, 0));
            if (b >= 18)
              return H.ioore(C.List_Y3m, b);
            i = C.List_Y3m[b];
            for (; J.$gt$n(i, 0);) {
              if (typeof i !== "number")
                return H.iae(i);
              t3 = 2 * i + this.br.getBit$1(t2.$index(prob, i));
              if (t3 >>> 0 !== t3 || t3 >= 18)
                return H.ioore(C.List_Y3m, t3);
              i = C.List_Y3m[t3];
            }
            if (typeof i !== "number")
              return i.$negate();
            ymode = -i;
            $top[t1] = ymode;
          }
          mi0 = mi + 4;
          C.NativeUint8List_methods.setRange$4(modes, mi, mi0, $top, ti);
          left[y] = ymode;
        }
      }
      if (this.br.getBit$1(142) === 0)
        t1 = 0;
      else if (this.br.getBit$1(114) === 0)
        t1 = 2;
      else
        t1 = this.br.getBit$1(183) !== 0 ? 1 : 3;
      block.uvmode = t1;
    },
    static: {"^": "VP8_kScan,VP8_kFilterExtraRows,VP8_kBands,VP8_kCat3,VP8_kCat4,VP8_kCat5,VP8_kCat6,VP8_kCat3456,VP8_kZigzag,VP8_kYModesIntra4,VP8_kBModesProba,VP8_COEFFS_PROBA_0,VP8_COEFFS_UPDATE_PROBA,VP8_DC_TABLE,VP8_AC_TABLE,VP8_FILTER_EXTRA_ROWS,VP8_VP8_SIGNATURE,VP8_MB_FEATURE_TREE_PROBS,VP8_NUM_MB_SEGMENTS,VP8_NUM_REF_LF_DELTAS,VP8_NUM_MODE_LF_DELTAS,VP8_MAX_NUM_PARTITIONS,VP8_B_DC_PRED,VP8_B_TM_PRED,VP8_B_VE_PRED,VP8_B_HE_PRED,VP8_B_RD_PRED,VP8_B_VR_PRED,VP8_B_LD_PRED,VP8_B_VL_PRED,VP8_B_HD_PRED,VP8_B_HU_PRED,VP8_NUM_BMODES,VP8_DC_PRED,VP8_V_PRED,VP8_H_PRED,VP8_TM_PRED,VP8_B_PRED,VP8_B_DC_PRED_NOTOP,VP8_B_DC_PRED_NOLEFT,VP8_B_DC_PRED_NOTOPLEFT,VP8_NUM_B_DC_MODES,VP8_NUM_TYPES,VP8_NUM_BANDS,VP8_NUM_CTX,VP8_NUM_PROBAS,VP8_BPS,VP8_YUV_SIZE,VP8_Y_SIZE,VP8_Y_OFF,VP8_U_OFF,VP8_V_OFF,VP8_YUV_FIX,VP8_YUV_HALF,VP8_YUV_MASK,VP8_YUV_RANGE_MIN,VP8_YUV_RANGE_MAX,VP8_YUV_FIX2,VP8_YUV_HALF2,VP8_YUV_MASK2,VP8_XOR_YUV_MASK2,VP8_kYScale,VP8_kVToR,VP8_kUToG,VP8_kVToG,VP8_kUToB,VP8_kRCst,VP8_kGCst,VP8_kBCst", VP8__checkMode: function(mb_x, mb_y, mode) {
        if (mode === 0)
          if (mb_x === 0)
            return mb_y === 0 ? 6 : 5;
          else
            return mb_y === 0 ? 4 : 0;
        return mode;
      }}
  },
  VP8__upsample_LOAD_UV: {
    "^": "Closure:116;",
    call$2: function(u, v) {
      if (typeof v !== "number")
        return v.$shl();
      return J.$or$n(u, v << 16 >>> 0);
    }
  },
  VP8BitReader: {
    "^": "Object;input,_range,_image$_value,_bits,_eof",
    getValue$1: function(bits) {
      var v, bits0;
      for (v = 0; bits0 = bits - 1, bits > 0; bits = bits0)
        v = (v | C.JSInt_methods.$shl(this.getBit$1(128), bits0)) >>> 0;
      return v;
    },
    getSignedValue$1: function(bits) {
      var value = this.getValue$1(bits);
      return this.getValue$1(1) === 1 ? -value : value;
    },
    getBit$1: function(prob) {
      var t1, bit, shift;
      t1 = J.$mul$ns(this._range, prob);
      if (typeof t1 !== "number")
        return t1.$shr();
      bit = this._bitUpdate$1(C.JSNumber_methods._shrOtherPositive$1(t1, 8));
      if (J.$le$n(this._range, 126)) {
        t1 = this._range;
        if (t1 >>> 0 !== t1 || t1 >= 128)
          return H.ioore(C.List_8co0, t1);
        shift = C.List_8co0[t1];
        this._range = C.List_wmc[t1];
        t1 = this._bits;
        if (typeof shift !== "number")
          return H.iae(shift);
        this._bits = t1 - shift;
      }
      return bit;
    },
    _bitUpdate$1: function(split) {
      var t1, t2, t3, bits, pos;
      if (this._bits < 0) {
        t1 = this.input;
        if (J.$ge$n(J.$sub$n(t1.end, t1.offset), 1)) {
          t1 = this.input;
          t2 = t1.buffer;
          t3 = t1.offset;
          t1.offset = J.$add$ns(t3, 1);
          bits = J.$index$asx(t2, t3);
          t3 = this._image$_value;
          if (typeof t3 !== "number")
            return t3.$shl();
          this._image$_value = J.$or$n(bits, t3 << 8 >>> 0);
          this._bits += 8;
        } else {
          t1 = this.input;
          if (!J.$ge$n(t1.offset, t1.end)) {
            t1 = this.input;
            t2 = t1.buffer;
            t3 = t1.offset;
            t1.offset = J.$add$ns(t3, 1);
            t3 = J.$index$asx(t2, t3);
            t2 = this._image$_value;
            if (typeof t2 !== "number")
              return t2.$shl();
            this._image$_value = J.$or$n(t3, t2 << 8 >>> 0);
            this._bits += 8;
          } else if (!this._eof) {
            t1 = this._image$_value;
            if (typeof t1 !== "number")
              return t1.$shl();
            this._image$_value = t1 << 8 >>> 0;
            this._bits += 8;
            this._eof = true;
          }
        }
      }
      pos = this._bits;
      t1 = this._image$_value;
      if (typeof t1 !== "number")
        return t1.$shr();
      if (C.JSNumber_methods.$shr(t1, pos) > split) {
        t1 = split + 1;
        this._range = J.$sub$n(this._range, t1);
        this._image$_value = J.$sub$n(this._image$_value, C.JSInt_methods.$shl(t1, pos));
        return 1;
      } else {
        this._range = split;
        return 0;
      }
    },
    VP8BitReader$1: function(input) {
      this._range = 254;
      this._image$_value = 0;
      this._bits = -8;
    },
    static: {"^": "VP8BitReader_BITS,VP8BitReader_LOG_2_RANGE,VP8BitReader_NEW_RANGE", VP8BitReader$: function(input) {
        var t1 = new U.VP8BitReader(input, null, null, null, false);
        t1.VP8BitReader$1(input);
        return t1;
      }}
  },
  VP8Filter: {
    "^": "Object;",
    simpleVFilter16$3: function(p, stride, thresh) {
      var p2, i;
      p2 = U.InputBuffer$from(p, null, 0);
      for (i = 0; i < 16; ++i) {
        p2.offset = J.$add$ns(p.offset, i);
        if (this._needsFilter$3(p2, stride, thresh))
          this._doFilter2$2(p2, stride);
      }
    },
    simpleHFilter16$3: function(p, stride, thresh) {
      var p2, i, t1;
      p2 = U.InputBuffer$from(p, null, 0);
      for (i = 0; i < 16; ++i) {
        t1 = p.offset;
        if (typeof stride !== "number")
          return H.iae(stride);
        p2.offset = J.$add$ns(t1, i * stride);
        if (this._needsFilter$3(p2, 1, thresh))
          this._doFilter2$2(p2, 1);
      }
    },
    simpleVFilter16i$3: function(p, stride, thresh) {
      var p2, k, t1;
      p2 = U.InputBuffer$from(p, null, 0);
      for (k = 3; k > 0; --k) {
        t1 = p2.offset;
        if (typeof stride !== "number")
          return H.iae(stride);
        p2.offset = J.$add$ns(t1, 4 * stride);
        this.simpleVFilter16$3(p2, stride, thresh);
      }
    },
    simpleHFilter16i$3: function(p, stride, thresh) {
      var p2, k;
      p2 = U.InputBuffer$from(p, null, 0);
      for (k = 3; k > 0; --k) {
        p2.offset = J.$add$ns(p2.offset, 4);
        this.simpleHFilter16$3(p2, stride, thresh);
      }
    },
    vFilter16i$5: function(p, stride, thresh, ithresh, hev_thresh) {
      var p2, k, t1;
      p2 = U.InputBuffer$from(p, null, 0);
      for (k = 3; k > 0; --k) {
        t1 = p2.offset;
        if (typeof stride !== "number")
          return H.iae(stride);
        p2.offset = J.$add$ns(t1, 4 * stride);
        this._filterLoop24$7(p2, stride, 1, 16, thresh, ithresh, hev_thresh);
      }
    },
    hFilter16i$5: function(p, stride, thresh, ithresh, hev_thresh) {
      var p2, k;
      p2 = U.InputBuffer$from(p, null, 0);
      for (k = 3; k > 0; --k) {
        p2.offset = J.$add$ns(p2.offset, 4);
        this._filterLoop24$7(p2, 1, stride, 16, thresh, ithresh, hev_thresh);
      }
    },
    _filterLoop26$7: function(p, hstride, vstride, size, thresh, ithresh, hev_thresh) {
      var p2, size0, t1, p20, t2, p1, t3, p0, q0, q1, t4, q2, t5, t6, t7, t8, a, a1, a2, a3;
      p2 = U.InputBuffer$from(p, null, 0);
      for (; size0 = size - 1, size > 0; size = size0) {
        if (this._needsFilter2$4(p2, hstride, thresh, ithresh))
          if (this._hev$3(p2, hstride, hev_thresh))
            this._doFilter2$2(p2, hstride);
          else {
            if (typeof hstride !== "number")
              return H.iae(hstride);
            t1 = -3 * hstride;
            p20 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, t1));
            t2 = -2 * hstride;
            p1 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, t2));
            t3 = -hstride;
            p0 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, t3));
            q0 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, 0));
            q1 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, hstride));
            t4 = 2 * hstride;
            q2 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, t4));
            t5 = $.get$VP8Filter_sclip1();
            t6 = J.$sub$n(q0, p0);
            if (typeof t6 !== "number")
              return H.iae(t6);
            t7 = $.get$VP8Filter_sclip1();
            if (typeof p1 !== "number")
              return H.iae(p1);
            if (typeof q1 !== "number")
              return H.iae(q1);
            t8 = 1020 + p1 - q1;
            if (t8 >>> 0 !== t8 || t8 >= t7.length)
              return H.ioore(t7, t8);
            t8 = 1020 + 3 * t6 + t7[t8];
            if (t8 >>> 0 !== t8 || t8 >= t5.length)
              return H.ioore(t5, t8);
            a = t5[t8];
            a1 = C.JSInt_methods.floor$0((27 * a + 63) / 128);
            a2 = C.JSInt_methods.floor$0((18 * a + 63) / 128);
            a3 = C.JSInt_methods.floor$0((9 * a + 63) / 128);
            t8 = $.get$VP8Filter_clip1();
            if (typeof p20 !== "number")
              return H.iae(p20);
            t5 = 255 + p20 + a3;
            if (t5 >>> 0 !== t5 || t5 >= t8.length)
              return H.ioore(t8, t5);
            t5 = t8[t5];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, t1), t5);
            t5 = $.get$VP8Filter_clip1();
            t1 = 255 + p1 + a2;
            if (t1 >>> 0 !== t1 || t1 >= t5.length)
              return H.ioore(t5, t1);
            t1 = t5[t1];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, t2), t1);
            t1 = $.get$VP8Filter_clip1();
            if (typeof p0 !== "number")
              return H.iae(p0);
            t2 = 255 + p0 + a1;
            if (t2 >>> 0 !== t2 || t2 >= t1.length)
              return H.ioore(t1, t2);
            t2 = t1[t2];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, t3), t2);
            t2 = $.get$VP8Filter_clip1();
            if (typeof q0 !== "number")
              return H.iae(q0);
            t3 = 255 + q0 - a1;
            if (t3 >>> 0 !== t3 || t3 >= t2.length)
              return H.ioore(t2, t3);
            t3 = t2[t3];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, 0), t3);
            t3 = $.get$VP8Filter_clip1();
            t2 = 255 + q1 - a2;
            if (t2 >>> 0 !== t2 || t2 >= t3.length)
              return H.ioore(t3, t2);
            t2 = t3[t2];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, hstride), t2);
            t2 = $.get$VP8Filter_clip1();
            if (typeof q2 !== "number")
              return H.iae(q2);
            t3 = 255 + q2 - a3;
            if (t3 >>> 0 !== t3 || t3 >= t2.length)
              return H.ioore(t2, t3);
            t3 = t2[t3];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, t4), t3);
          }
        p2.offset = J.$add$ns(p2.offset, vstride);
      }
    },
    _filterLoop24$7: function(p, hstride, vstride, size, thresh, ithresh, hev_thresh) {
      var p2, size0, t1, p1, t2, p0, q0, q1, t3, a, t4, a1, a2, a3;
      p2 = U.InputBuffer$from(p, null, 0);
      for (; size0 = size - 1, size > 0; size = size0) {
        if (this._needsFilter2$4(p2, hstride, thresh, ithresh))
          if (this._hev$3(p2, hstride, hev_thresh))
            this._doFilter2$2(p2, hstride);
          else {
            if (typeof hstride !== "number")
              return H.iae(hstride);
            t1 = -2 * hstride;
            p1 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, t1));
            t2 = -hstride;
            p0 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, t2));
            q0 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, 0));
            q1 = J.$index$asx(p2.buffer, J.$add$ns(p2.offset, hstride));
            t3 = J.$sub$n(q0, p0);
            if (typeof t3 !== "number")
              return H.iae(t3);
            a = 3 * t3;
            t3 = $.get$VP8Filter_sclip2();
            t4 = 112 + C.JSNumber_methods.floor$0((a + 4) / 8);
            if (t4 < 0 || t4 >= t3.length)
              return H.ioore(t3, t4);
            a1 = t3[t4];
            t4 = $.get$VP8Filter_sclip2();
            t3 = 112 + C.JSNumber_methods.floor$0((a + 3) / 8);
            if (t3 < 0 || t3 >= t4.length)
              return H.ioore(t4, t3);
            a2 = t4[t3];
            a3 = C.JSInt_methods.floor$0((a1 + 1) / 2);
            t3 = $.get$VP8Filter_clip1();
            if (typeof p1 !== "number")
              return H.iae(p1);
            t4 = 255 + p1 + a3;
            if (t4 >>> 0 !== t4 || t4 >= t3.length)
              return H.ioore(t3, t4);
            t4 = t3[t4];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, t1), t4);
            t4 = $.get$VP8Filter_clip1();
            if (typeof p0 !== "number")
              return H.iae(p0);
            t1 = 255 + p0 + a2;
            if (t1 >>> 0 !== t1 || t1 >= t4.length)
              return H.ioore(t4, t1);
            t1 = t4[t1];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, t2), t1);
            t1 = $.get$VP8Filter_clip1();
            if (typeof q0 !== "number")
              return H.iae(q0);
            t2 = 255 + q0 - a1;
            if (t2 >>> 0 !== t2 || t2 >= t1.length)
              return H.ioore(t1, t2);
            t2 = t1[t2];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, 0), t2);
            t2 = $.get$VP8Filter_clip1();
            if (typeof q1 !== "number")
              return H.iae(q1);
            t1 = 255 + q1 - a3;
            if (t1 >>> 0 !== t1 || t1 >= t2.length)
              return H.ioore(t2, t1);
            t1 = t2[t1];
            J.$indexSet$ax(p2.buffer, J.$add$ns(p2.offset, hstride), t1);
          }
        p2.offset = J.$add$ns(p2.offset, vstride);
      }
    },
    _doFilter2$2: function(p, step) {
      var p1, t1, p0, q0, q1, t2, t3, t4, a, a1, a2;
      if (typeof step !== "number")
        return H.iae(step);
      p1 = J.$index$asx(p.buffer, J.$add$ns(p.offset, -2 * step));
      t1 = -step;
      p0 = J.$index$asx(p.buffer, J.$add$ns(p.offset, t1));
      q0 = J.$index$asx(p.buffer, J.$add$ns(p.offset, 0));
      q1 = J.$index$asx(p.buffer, J.$add$ns(p.offset, step));
      t2 = J.$sub$n(q0, p0);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = $.get$VP8Filter_sclip1();
      if (typeof p1 !== "number")
        return H.iae(p1);
      if (typeof q1 !== "number")
        return H.iae(q1);
      t4 = 1020 + p1 - q1;
      if (t4 >>> 0 !== t4 || t4 >= t3.length)
        return H.ioore(t3, t4);
      a = 3 * t2 + t3[t4];
      t4 = $.get$VP8Filter_sclip2();
      t3 = 112 + C.JSNumber_methods.floor$0((a + 4) / 8);
      if (t3 < 0 || t3 >= t4.length)
        return H.ioore(t4, t3);
      a1 = t4[t3];
      t3 = $.get$VP8Filter_sclip2();
      t4 = 112 + C.JSNumber_methods.floor$0((a + 3) / 8);
      if (t4 < 0 || t4 >= t3.length)
        return H.ioore(t3, t4);
      a2 = t3[t4];
      t4 = $.get$VP8Filter_clip1();
      if (typeof p0 !== "number")
        return H.iae(p0);
      t3 = 255 + p0 + a2;
      if (t3 >>> 0 !== t3 || t3 >= t4.length)
        return H.ioore(t4, t3);
      t3 = t4[t3];
      J.$indexSet$ax(p.buffer, J.$add$ns(p.offset, t1), t3);
      t3 = $.get$VP8Filter_clip1();
      if (typeof q0 !== "number")
        return H.iae(q0);
      t1 = 255 + q0 - a1;
      if (t1 >>> 0 !== t1 || t1 >= t3.length)
        return H.ioore(t3, t1);
      t1 = t3[t1];
      J.$indexSet$ax(p.buffer, J.$add$ns(p.offset, 0), t1);
    },
    _hev$3: function(p, step, thresh) {
      var p1, p0, q0, q1, t1, t2, t3;
      if (typeof step !== "number")
        return H.iae(step);
      p1 = J.$index$asx(p.buffer, J.$add$ns(p.offset, -2 * step));
      p0 = J.$index$asx(p.buffer, J.$add$ns(p.offset, -step));
      q0 = J.$index$asx(p.buffer, J.$add$ns(p.offset, 0));
      q1 = J.$index$asx(p.buffer, J.$add$ns(p.offset, step));
      t1 = $.get$VP8Filter_abs0();
      if (typeof p1 !== "number")
        return H.iae(p1);
      if (typeof p0 !== "number")
        return H.iae(p0);
      t2 = 255 + p1 - p0;
      t3 = t1.length;
      if (t2 >>> 0 !== t2 || t2 >= t3)
        return H.ioore(t1, t2);
      if (t1[t2] <= thresh) {
        if (typeof q1 !== "number")
          return H.iae(q1);
        if (typeof q0 !== "number")
          return H.iae(q0);
        t2 = 255 + q1 - q0;
        if (t2 >>> 0 !== t2 || t2 >= t3)
          return H.ioore(t1, t2);
        t2 = t1[t2] > thresh;
        t1 = t2;
      } else
        t1 = true;
      return t1;
    },
    _needsFilter$3: function(p, step, thresh) {
      var p1, p0, q0, q1, t1, t2, t3;
      if (typeof step !== "number")
        return H.iae(step);
      p1 = J.$index$asx(p.buffer, J.$add$ns(p.offset, -2 * step));
      p0 = J.$index$asx(p.buffer, J.$add$ns(p.offset, -step));
      q0 = J.$index$asx(p.buffer, J.$add$ns(p.offset, 0));
      q1 = J.$index$asx(p.buffer, J.$add$ns(p.offset, step));
      t1 = $.get$VP8Filter_abs0();
      if (typeof p0 !== "number")
        return H.iae(p0);
      if (typeof q0 !== "number")
        return H.iae(q0);
      t2 = 255 + p0 - q0;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      t2 = t1[t2];
      t1 = $.get$VP8Filter_abs1();
      if (typeof p1 !== "number")
        return H.iae(p1);
      if (typeof q1 !== "number")
        return H.iae(q1);
      t3 = 255 + p1 - q1;
      if (t3 >>> 0 !== t3 || t3 >= t1.length)
        return H.ioore(t1, t3);
      return 2 * t2 + t1[t3] <= thresh;
    },
    _needsFilter2$4: function(p, step, t, it) {
      var p3, p2, p1, p0, q0, q1, q2, q3, t1, t2, t3, t4, t5, t6;
      if (typeof step !== "number")
        return H.iae(step);
      p3 = J.$index$asx(p.buffer, J.$add$ns(p.offset, -4 * step));
      p2 = J.$index$asx(p.buffer, J.$add$ns(p.offset, -3 * step));
      p1 = J.$index$asx(p.buffer, J.$add$ns(p.offset, -2 * step));
      p0 = J.$index$asx(p.buffer, J.$add$ns(p.offset, -step));
      q0 = J.$index$asx(p.buffer, J.$add$ns(p.offset, 0));
      q1 = J.$index$asx(p.buffer, J.$add$ns(p.offset, step));
      q2 = J.$index$asx(p.buffer, J.$add$ns(p.offset, 2 * step));
      q3 = J.$index$asx(p.buffer, J.$add$ns(p.offset, 3 * step));
      t1 = $.get$VP8Filter_abs0();
      if (typeof p0 !== "number")
        return H.iae(p0);
      if (typeof q0 !== "number")
        return H.iae(q0);
      t2 = 255 + p0 - q0;
      t3 = t1.length;
      if (t2 >>> 0 !== t2 || t2 >= t3)
        return H.ioore(t1, t2);
      t2 = t1[t2];
      t4 = $.get$VP8Filter_abs1();
      if (typeof p1 !== "number")
        return H.iae(p1);
      t5 = 255 + p1;
      if (typeof q1 !== "number")
        return H.iae(q1);
      t6 = t5 - q1;
      if (t6 >>> 0 !== t6 || t6 >= t4.length)
        return H.ioore(t4, t6);
      if (2 * t2 + t4[t6] > t)
        return false;
      if (typeof p3 !== "number")
        return H.iae(p3);
      if (typeof p2 !== "number")
        return H.iae(p2);
      t2 = 255 + p3 - p2;
      if (t2 >>> 0 !== t2 || t2 >= t3)
        return H.ioore(t1, t2);
      if (t1[t2] <= it) {
        t2 = 255 + p2 - p1;
        if (t2 >>> 0 !== t2 || t2 >= t3)
          return H.ioore(t1, t2);
        if (t1[t2] <= it) {
          t2 = t5 - p0;
          if (t2 >>> 0 !== t2 || t2 >= t3)
            return H.ioore(t1, t2);
          if (t1[t2] <= it) {
            if (typeof q3 !== "number")
              return H.iae(q3);
            if (typeof q2 !== "number")
              return H.iae(q2);
            t2 = 255 + q3 - q2;
            if (t2 >>> 0 !== t2 || t2 >= t3)
              return H.ioore(t1, t2);
            if (t1[t2] <= it) {
              t2 = 255 + q2 - q1;
              if (t2 >>> 0 !== t2 || t2 >= t3)
                return H.ioore(t1, t2);
              if (t1[t2] <= it) {
                t2 = 255 + q1 - q0;
                if (t2 >>> 0 !== t2 || t2 >= t3)
                  return H.ioore(t1, t2);
                t2 = t1[t2] <= it;
                t1 = t2;
              } else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    transformOne$2: function(src, dst) {
      var $C, si, tmp, i, t1, a, b, t2, c, d, tmp0, t3, di, dc;
      $C = new Int32Array(16);
      for (si = 0, tmp = 0, i = 0; i < 4; ++i) {
        t1 = si + 8;
        a = J.$add$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, si)), J.$index$asx(src.buffer, J.$add$ns(src.offset, t1)));
        b = J.$sub$n(J.$index$asx(src.buffer, J.$add$ns(src.offset, si)), J.$index$asx(src.buffer, J.$add$ns(src.offset, t1)));
        t1 = si + 4;
        t2 = si + 12;
        c = J.floor$0$n(J.$div$n(J.$mul$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, t1)), 35468), 65536)) - J.floor$0$n(J.$div$n(J.$mul$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, t2)), 85627), 65536));
        d = J.floor$0$n(J.$div$n(J.$mul$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, t1)), 85627), 65536)) + J.floor$0$n(J.$div$n(J.$mul$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, t2)), 35468), 65536));
        tmp0 = tmp + 1;
        t2 = J.getInterceptor$ns(a);
        t1 = t2.$add(a, d);
        if (tmp >= 16)
          return H.ioore($C, tmp);
        $C[tmp] = t1;
        tmp = tmp0 + 1;
        t1 = J.getInterceptor$ns(b);
        t3 = t1.$add(b, c);
        if (tmp0 >= 16)
          return H.ioore($C, tmp0);
        $C[tmp0] = t3;
        tmp0 = tmp + 1;
        t1 = t1.$sub(b, c);
        if (tmp >= 16)
          return H.ioore($C, tmp);
        $C[tmp] = t1;
        tmp = tmp0 + 1;
        t2 = t2.$sub(a, d);
        if (tmp0 >= 16)
          return H.ioore($C, tmp0);
        $C[tmp0] = t2;
        ++si;
      }
      for (di = 0, tmp = 0, i = 0; i < 4; ++i) {
        if (tmp >= 16)
          return H.ioore($C, tmp);
        dc = $C[tmp] + 4;
        t1 = tmp + 8;
        if (t1 >= 16)
          return H.ioore($C, t1);
        t1 = $C[t1];
        a = dc + t1;
        b = dc - t1;
        t1 = tmp + 4;
        if (t1 >= 16)
          return H.ioore($C, t1);
        t2 = C.JSInt_methods.floor$0($C[t1] * 35468 / 65536);
        t3 = tmp + 12;
        if (t3 >= 16)
          return H.ioore($C, t3);
        c = t2 - C.JSInt_methods.floor$0($C[t3] * 85627 / 65536);
        d = C.JSInt_methods.floor$0($C[t1] * 85627 / 65536) + C.JSInt_methods.floor$0($C[t3] * 35468 / 65536);
        U.VP8Filter__store(dst, di, 0, 0, a + d);
        U.VP8Filter__store(dst, di, 1, 0, b + c);
        U.VP8Filter__store(dst, di, 2, 0, b - c);
        U.VP8Filter__store(dst, di, 3, 0, a - d);
        ++tmp;
        di += 32;
      }
    },
    transformDC$2: function(src, dst) {
      var DC, j, i;
      DC = J.$add$ns(J.$index$asx(src.buffer, J.$add$ns(src.offset, 0)), 4);
      for (j = 0; j < 4; ++j)
        for (i = 0; i < 4; ++i)
          U.VP8Filter__store(dst, 0, i, j, DC);
    },
    transformDCUV$2: function(src, dst) {
      if (!J.$eq(J.$index$asx(src.buffer, J.$add$ns(src.offset, 0)), 0))
        this.transformDC$2(src, dst);
      if (!J.$eq(J.$index$asx(src.buffer, J.$add$ns(src.offset, 16)), 0))
        this.transformDC$2(U.InputBuffer$from(src, null, 16), U.InputBuffer$from(dst, null, 4));
      if (!J.$eq(J.$index$asx(src.buffer, J.$add$ns(src.offset, 32)), 0))
        this.transformDC$2(U.InputBuffer$from(src, null, 32), U.InputBuffer$from(dst, null, 128));
      if (!J.$eq(J.$index$asx(src.buffer, J.$add$ns(src.offset, 48)), 0))
        this.transformDC$2(U.InputBuffer$from(src, null, 48), U.InputBuffer$from(dst, null, 132));
    },
    static: {"^": "VP8Filter_PredLuma4,VP8Filter_PredLuma16,VP8Filter_PredChroma8,VP8Filter_kC1,VP8Filter_kC2,VP8Filter_abs0,VP8Filter_abs1,VP8Filter_sclip1,VP8Filter_sclip2,VP8Filter_clip1,VP8Filter___maxN,VP8Filter__tablesInitialized", VP8Filter_AVG3: function(a, b, c) {
        if (typeof b !== "number")
          return H.iae(b);
        return J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns(J.$add$ns(a, 2 * b), c), 2), 4));
      }, VP8Filter_VE4: [function(dst) {
        var t1, vals, i;
        t1 = J.getInterceptor$asx(dst);
        vals = [U.VP8Filter_AVG3(t1.$index(dst, -33), t1.$index(dst, -32), t1.$index(dst, -31)), U.VP8Filter_AVG3(t1.$index(dst, -32), t1.$index(dst, -31), t1.$index(dst, -30)), U.VP8Filter_AVG3(t1.$index(dst, -31), t1.$index(dst, -30), t1.$index(dst, -29)), U.VP8Filter_AVG3(t1.$index(dst, -30), t1.$index(dst, -29), t1.$index(dst, -28))];
        for (i = 0; i < 4; ++i)
          dst.memcpy$3(i * 32, 4, vals);
      }, "call$1", "VP8Filter_VE4$closure", 2, 0, 24], VP8Filter_HE4: [function(dst) {
        var t1, $A, $B, $C, $D, $E, d2, t2;
        t1 = J.getInterceptor$asx(dst);
        $A = t1.$index(dst, -33);
        $B = t1.$index(dst, -1);
        $C = t1.$index(dst, 31);
        $D = t1.$index(dst, 63);
        $E = t1.$index(dst, 95);
        d2 = U.InputBuffer$from(dst, null, 0);
        t1 = d2.toUint32List$0();
        t2 = U.VP8Filter_AVG3($A, $B, $C);
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1[0] = 16843009 * t2;
        d2.offset = J.$add$ns(d2.offset, 32);
        t2 = d2.toUint32List$0();
        t1 = U.VP8Filter_AVG3($B, $C, $D);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2[0] = 16843009 * t1;
        d2.offset = J.$add$ns(d2.offset, 32);
        t1 = d2.toUint32List$0();
        t2 = U.VP8Filter_AVG3($C, $D, $E);
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1[0] = 16843009 * t2;
        d2.offset = J.$add$ns(d2.offset, 32);
        t2 = d2.toUint32List$0();
        t1 = U.VP8Filter_AVG3($D, $E, $E);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2[0] = 16843009 * t1;
      }, "call$1", "VP8Filter_HE4$closure", 2, 0, 24], VP8Filter_DC4: [function(dst) {
        var t1, dc, i, t2;
        for (t1 = J.getInterceptor$asx(dst), dc = 4, i = 0; i < 4; ++i) {
          t2 = J.$add$ns(t1.$index(dst, i - 32), t1.$index(dst, -1 + i * 32));
          if (typeof t2 !== "number")
            return H.iae(t2);
          dc += t2;
        }
        dc = C.JSNumber_methods._shrOtherPositive$1(dc, 3);
        for (i = 0; i < 4; ++i)
          dst.memset$3(i * 32, 4, dc);
      }, "call$1", "VP8Filter_DC4$closure", 2, 0, 24], VP8Filter_trueMotion: function(dst, size) {
        var t1, t2, clip0, di, y, clip, x, t3;
        t1 = J.getInterceptor$asx(dst);
        t2 = t1.$index(dst, -33);
        if (typeof t2 !== "number")
          return H.iae(t2);
        clip0 = 255 - t2;
        for (di = 0, y = 0; y < size; ++y) {
          t2 = t1.$index(dst, di - 1);
          if (typeof t2 !== "number")
            return H.iae(t2);
          clip = clip0 + t2;
          for (x = 0; x < size; ++x) {
            t2 = $.get$VP8Filter_clip1();
            t3 = t1.$index(dst, -32 + x);
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = clip + t3;
            if (t3 >>> 0 !== t3 || t3 >= t2.length)
              return H.ioore(t2, t3);
            t1.$indexSet(dst, di + x, t2[t3]);
          }
          di += 32;
        }
      }, VP8Filter_TM4: [function(dst) {
        U.VP8Filter_trueMotion(dst, 4);
      }, "call$1", "VP8Filter_TM4$closure", 2, 0, 24], VP8Filter_TM8uv: [function(dst) {
        U.VP8Filter_trueMotion(dst, 8);
      }, "call$1", "VP8Filter_TM8uv$closure", 2, 0, 24], VP8Filter_TM16: [function(dst) {
        U.VP8Filter_trueMotion(dst, 16);
      }, "call$1", "VP8Filter_TM16$closure", 2, 0, 24], VP8Filter_RD4: [function(dst) {
        var t1, I, $J, $K, $L, $X, $A, $B, $C, $D, t2;
        t1 = J.getInterceptor$asx(dst);
        I = t1.$index(dst, -1);
        $J = t1.$index(dst, 31);
        $K = t1.$index(dst, 63);
        $L = t1.$index(dst, 95);
        $X = t1.$index(dst, -33);
        $A = t1.$index(dst, -32);
        $B = t1.$index(dst, -31);
        $C = t1.$index(dst, -30);
        $D = t1.$index(dst, -29);
        t1.$indexSet(dst, 96, U.VP8Filter_AVG3($J, $K, $L));
        t2 = U.VP8Filter_AVG3(I, $J, $K);
        t1.$indexSet(dst, 97, t2);
        t1.$indexSet(dst, 64, t2);
        t2 = U.VP8Filter_AVG3($X, I, $J);
        t1.$indexSet(dst, 98, t2);
        t1.$indexSet(dst, 65, t2);
        t1.$indexSet(dst, 32, t2);
        t2 = U.VP8Filter_AVG3($A, $X, I);
        t1.$indexSet(dst, 99, t2);
        t1.$indexSet(dst, 66, t2);
        t1.$indexSet(dst, 33, t2);
        t1.$indexSet(dst, 0, t2);
        t2 = U.VP8Filter_AVG3($B, $A, $X);
        t1.$indexSet(dst, 67, t2);
        t1.$indexSet(dst, 34, t2);
        t1.$indexSet(dst, 1, t2);
        t2 = U.VP8Filter_AVG3($C, $B, $A);
        t1.$indexSet(dst, 35, t2);
        t1.$indexSet(dst, 2, t2);
        t1.$indexSet(dst, 3, U.VP8Filter_AVG3($D, $C, $B));
      }, "call$1", "VP8Filter_RD4$closure", 2, 0, 24], VP8Filter_LD4: [function(dst) {
        var t1, $A, $B, $C, $D, $E, $F, $G, $H, t2;
        t1 = J.getInterceptor$asx(dst);
        $A = t1.$index(dst, -32);
        $B = t1.$index(dst, -31);
        $C = t1.$index(dst, -30);
        $D = t1.$index(dst, -29);
        $E = t1.$index(dst, -28);
        $F = t1.$index(dst, -27);
        $G = t1.$index(dst, -26);
        $H = t1.$index(dst, -25);
        t1.$indexSet(dst, 0, U.VP8Filter_AVG3($A, $B, $C));
        t2 = U.VP8Filter_AVG3($B, $C, $D);
        t1.$indexSet(dst, 32, t2);
        t1.$indexSet(dst, 1, t2);
        t2 = U.VP8Filter_AVG3($C, $D, $E);
        t1.$indexSet(dst, 64, t2);
        t1.$indexSet(dst, 33, t2);
        t1.$indexSet(dst, 2, t2);
        t2 = U.VP8Filter_AVG3($D, $E, $F);
        t1.$indexSet(dst, 96, t2);
        t1.$indexSet(dst, 65, t2);
        t1.$indexSet(dst, 34, t2);
        t1.$indexSet(dst, 3, t2);
        t2 = U.VP8Filter_AVG3($E, $F, $G);
        t1.$indexSet(dst, 97, t2);
        t1.$indexSet(dst, 66, t2);
        t1.$indexSet(dst, 35, t2);
        t2 = U.VP8Filter_AVG3($F, $G, $H);
        t1.$indexSet(dst, 98, t2);
        t1.$indexSet(dst, 67, t2);
        t1.$indexSet(dst, 99, U.VP8Filter_AVG3($G, $H, $H));
      }, "call$1", "VP8Filter_LD4$closure", 2, 0, 24], VP8Filter_VR4: [function(dst) {
        var t1, I, $J, $K, $X, $A, $B, $C, $D, t2;
        t1 = J.getInterceptor$asx(dst);
        I = t1.$index(dst, -1);
        $J = t1.$index(dst, 31);
        $K = t1.$index(dst, 63);
        $X = t1.$index(dst, -33);
        $A = t1.$index(dst, -32);
        $B = t1.$index(dst, -31);
        $C = t1.$index(dst, -30);
        $D = t1.$index(dst, -29);
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($X, $A), 1), 2));
        t1.$indexSet(dst, 65, t2);
        t1.$indexSet(dst, 0, t2);
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($A, $B), 1), 2));
        t1.$indexSet(dst, 66, t2);
        t1.$indexSet(dst, 1, t2);
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($B, $C), 1), 2));
        t1.$indexSet(dst, 67, t2);
        t1.$indexSet(dst, 2, t2);
        t1.$indexSet(dst, 3, J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($C, $D), 1), 2)));
        t1.$indexSet(dst, 96, U.VP8Filter_AVG3($K, $J, I));
        t1.$indexSet(dst, 64, U.VP8Filter_AVG3($J, I, $X));
        t2 = U.VP8Filter_AVG3(I, $X, $A);
        t1.$indexSet(dst, 97, t2);
        t1.$indexSet(dst, 32, t2);
        t2 = U.VP8Filter_AVG3($X, $A, $B);
        t1.$indexSet(dst, 98, t2);
        t1.$indexSet(dst, 33, t2);
        t2 = U.VP8Filter_AVG3($A, $B, $C);
        t1.$indexSet(dst, 99, t2);
        t1.$indexSet(dst, 34, t2);
        t1.$indexSet(dst, 35, U.VP8Filter_AVG3($B, $C, $D));
      }, "call$1", "VP8Filter_VR4$closure", 2, 0, 24], VP8Filter_VL4: [function(dst) {
        var t1, $A, $B, $C, $D, $E, $F, $G, $H, t2;
        t1 = J.getInterceptor$asx(dst);
        $A = t1.$index(dst, -32);
        $B = t1.$index(dst, -31);
        $C = t1.$index(dst, -30);
        $D = t1.$index(dst, -29);
        $E = t1.$index(dst, -28);
        $F = t1.$index(dst, -27);
        $G = t1.$index(dst, -26);
        $H = t1.$index(dst, -25);
        t1.$indexSet(dst, 0, J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($A, $B), 1), 2)));
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($B, $C), 1), 2));
        t1.$indexSet(dst, 64, t2);
        t1.$indexSet(dst, 1, t2);
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($C, $D), 1), 2));
        t1.$indexSet(dst, 65, t2);
        t1.$indexSet(dst, 2, t2);
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($D, $E), 1), 2));
        t1.$indexSet(dst, 66, t2);
        t1.$indexSet(dst, 3, t2);
        t1.$indexSet(dst, 32, U.VP8Filter_AVG3($A, $B, $C));
        t2 = U.VP8Filter_AVG3($B, $C, $D);
        t1.$indexSet(dst, 96, t2);
        t1.$indexSet(dst, 33, t2);
        t2 = U.VP8Filter_AVG3($C, $D, $E);
        t1.$indexSet(dst, 97, t2);
        t1.$indexSet(dst, 34, t2);
        t2 = U.VP8Filter_AVG3($D, $E, $F);
        t1.$indexSet(dst, 98, t2);
        t1.$indexSet(dst, 35, t2);
        t1.$indexSet(dst, 67, U.VP8Filter_AVG3($E, $F, $G));
        t1.$indexSet(dst, 99, U.VP8Filter_AVG3($F, $G, $H));
      }, "call$1", "VP8Filter_VL4$closure", 2, 0, 24], VP8Filter_HU4: [function(dst) {
        var t1, I, $J, $K, $L, t2;
        t1 = J.getInterceptor$asx(dst);
        I = t1.$index(dst, -1);
        $J = t1.$index(dst, 31);
        $K = t1.$index(dst, 63);
        $L = t1.$index(dst, 95);
        t1.$indexSet(dst, 0, J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns(I, $J), 1), 2)));
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($J, $K), 1), 2));
        t1.$indexSet(dst, 32, t2);
        t1.$indexSet(dst, 2, t2);
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($K, $L), 1), 2));
        t1.$indexSet(dst, 64, t2);
        t1.$indexSet(dst, 34, t2);
        t1.$indexSet(dst, 1, U.VP8Filter_AVG3(I, $J, $K));
        t2 = U.VP8Filter_AVG3($J, $K, $L);
        t1.$indexSet(dst, 33, t2);
        t1.$indexSet(dst, 3, t2);
        t2 = U.VP8Filter_AVG3($K, $L, $L);
        t1.$indexSet(dst, 65, t2);
        t1.$indexSet(dst, 35, t2);
        t1.$indexSet(dst, 99, $L);
        t1.$indexSet(dst, 98, $L);
        t1.$indexSet(dst, 97, $L);
        t1.$indexSet(dst, 96, $L);
        t1.$indexSet(dst, 66, $L);
        t1.$indexSet(dst, 67, $L);
      }, "call$1", "VP8Filter_HU4$closure", 2, 0, 24], VP8Filter_HD4: [function(dst) {
        var t1, I, $J, $K, $L, $X, $A, $B, $C, t2;
        t1 = J.getInterceptor$asx(dst);
        I = t1.$index(dst, -1);
        $J = t1.$index(dst, 31);
        $K = t1.$index(dst, 63);
        $L = t1.$index(dst, 95);
        $X = t1.$index(dst, -33);
        $A = t1.$index(dst, -32);
        $B = t1.$index(dst, -31);
        $C = t1.$index(dst, -30);
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns(I, $X), 1), 2));
        t1.$indexSet(dst, 34, t2);
        t1.$indexSet(dst, 0, t2);
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($J, I), 1), 2));
        t1.$indexSet(dst, 66, t2);
        t1.$indexSet(dst, 32, t2);
        t2 = J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($K, $J), 1), 2));
        t1.$indexSet(dst, 98, t2);
        t1.$indexSet(dst, 64, t2);
        t1.$indexSet(dst, 96, J.floor$0$n(J.$div$n(J.$add$ns(J.$add$ns($L, $K), 1), 2)));
        t1.$indexSet(dst, 3, U.VP8Filter_AVG3($A, $B, $C));
        t1.$indexSet(dst, 2, U.VP8Filter_AVG3($X, $A, $B));
        t2 = U.VP8Filter_AVG3(I, $X, $A);
        t1.$indexSet(dst, 35, t2);
        t1.$indexSet(dst, 1, t2);
        t2 = U.VP8Filter_AVG3($J, I, $X);
        t1.$indexSet(dst, 67, t2);
        t1.$indexSet(dst, 33, t2);
        t2 = U.VP8Filter_AVG3($K, $J, I);
        t1.$indexSet(dst, 99, t2);
        t1.$indexSet(dst, 65, t2);
        t1.$indexSet(dst, 97, U.VP8Filter_AVG3($L, $K, $J));
      }, "call$1", "VP8Filter_HD4$closure", 2, 0, 24], VP8Filter_VE16: [function(dst) {
        var j;
        for (j = 0; j < 16; ++j)
          dst.memcpy$4(j * 32, 16, dst, -32);
      }, "call$1", "VP8Filter_VE16$closure", 2, 0, 24], VP8Filter_HE16: [function(dst) {
        var t1, di, j;
        for (t1 = J.getInterceptor$asx(dst), di = 0, j = 16; j > 0; --j) {
          dst.memset$3(di, 16, t1.$index(dst, di - 1));
          di += 32;
        }
      }, "call$1", "VP8Filter_HE16$closure", 2, 0, 24], VP8Filter_Put16: function(v, dst) {
        var j;
        for (j = 0; j < 16; ++j)
          dst.memset$3(j * 32, 16, v);
      }, VP8Filter_DC16: [function(dst) {
        var t1, DC, j, t2;
        for (t1 = J.getInterceptor$asx(dst), DC = 16, j = 0; j < 16; ++j) {
          t2 = J.$add$ns(t1.$index(dst, -1 + j * 32), t1.$index(dst, j - 32));
          if (typeof t2 !== "number")
            return H.iae(t2);
          DC += t2;
        }
        U.VP8Filter_Put16(C.JSNumber_methods._shrOtherPositive$1(DC, 5), dst);
      }, "call$1", "VP8Filter_DC16$closure", 2, 0, 24], VP8Filter_DC16NoTop: [function(dst) {
        var t1, DC, j, t2;
        for (t1 = J.getInterceptor$asx(dst), DC = 8, j = 0; j < 16; ++j) {
          t2 = t1.$index(dst, -1 + j * 32);
          if (typeof t2 !== "number")
            return H.iae(t2);
          DC += t2;
        }
        U.VP8Filter_Put16(C.JSNumber_methods._shrOtherPositive$1(DC, 4), dst);
      }, "call$1", "VP8Filter_DC16NoTop$closure", 2, 0, 24], VP8Filter_DC16NoLeft: [function(dst) {
        var t1, DC, i, t2;
        for (t1 = J.getInterceptor$asx(dst), DC = 8, i = 0; i < 16; ++i) {
          t2 = t1.$index(dst, i - 32);
          if (typeof t2 !== "number")
            return H.iae(t2);
          DC += t2;
        }
        U.VP8Filter_Put16(C.JSNumber_methods._shrOtherPositive$1(DC, 4), dst);
      }, "call$1", "VP8Filter_DC16NoLeft$closure", 2, 0, 24], VP8Filter_DC16NoTopLeft: [function(dst) {
        U.VP8Filter_Put16(128, dst);
      }, "call$1", "VP8Filter_DC16NoTopLeft$closure", 2, 0, 24], VP8Filter_VE8uv: [function(dst) {
        var j;
        for (j = 0; j < 8; ++j)
          dst.memcpy$4(j * 32, 8, dst, -32);
      }, "call$1", "VP8Filter_VE8uv$closure", 2, 0, 24], VP8Filter_HE8uv: [function(dst) {
        var t1, di, j;
        for (t1 = J.getInterceptor$asx(dst), di = 0, j = 0; j < 8; ++j) {
          dst.memset$3(di, 8, t1.$index(dst, di - 1));
          di += 32;
        }
      }, "call$1", "VP8Filter_HE8uv$closure", 2, 0, 24], VP8Filter_Put8x8uv: function(value, dst) {
        var j;
        for (j = 0; j < 8; ++j)
          dst.memset$3(j * 32, 8, value);
      }, VP8Filter_DC8uv: [function(dst) {
        var t1, dc0, i, t2;
        for (t1 = J.getInterceptor$asx(dst), dc0 = 8, i = 0; i < 8; ++i) {
          t2 = J.$add$ns(t1.$index(dst, i - 32), t1.$index(dst, -1 + i * 32));
          if (typeof t2 !== "number")
            return H.iae(t2);
          dc0 += t2;
        }
        U.VP8Filter_Put8x8uv(C.JSNumber_methods._shrOtherPositive$1(dc0, 4), dst);
      }, "call$1", "VP8Filter_DC8uv$closure", 2, 0, 24], VP8Filter_DC8uvNoLeft: [function(dst) {
        var t1, dc0, i, t2;
        for (t1 = J.getInterceptor$asx(dst), dc0 = 4, i = 0; i < 8; ++i) {
          t2 = t1.$index(dst, i - 32);
          if (typeof t2 !== "number")
            return H.iae(t2);
          dc0 += t2;
        }
        U.VP8Filter_Put8x8uv(C.JSNumber_methods._shrOtherPositive$1(dc0, 3), dst);
      }, "call$1", "VP8Filter_DC8uvNoLeft$closure", 2, 0, 24], VP8Filter_DC8uvNoTop: [function(dst) {
        var t1, dc0, i, t2;
        for (t1 = J.getInterceptor$asx(dst), dc0 = 4, i = 0; i < 8; ++i) {
          t2 = t1.$index(dst, -1 + i * 32);
          if (typeof t2 !== "number")
            return H.iae(t2);
          dc0 += t2;
        }
        U.VP8Filter_Put8x8uv(C.JSNumber_methods._shrOtherPositive$1(dc0, 3), dst);
      }, "call$1", "VP8Filter_DC8uvNoTop$closure", 2, 0, 24], VP8Filter_DC8uvNoTopLeft: [function(dst) {
        U.VP8Filter_Put8x8uv(128, dst);
      }, "call$1", "VP8Filter_DC8uvNoTopLeft$closure", 2, 0, 24], VP8Filter__store: function(dst, di, x, y, v) {
        var t1, t2;
        t1 = di + x + y * 32;
        t2 = J.$index$asx(dst.buffer, J.$add$ns(dst.offset, t1));
        if (typeof v !== "number")
          return v.$shr();
        t2 = J.$add$ns(t2, C.JSNumber_methods._shrOtherPositive$1(v, 3));
        if (J.$and$n(t2, -256) === 0)
          ;
        else {
          if (typeof t2 !== "number")
            return t2.$lt();
          t2 = t2 < 0 ? 0 : 255;
        }
        J.$indexSet$ax(dst.buffer, J.$add$ns(dst.offset, t1), t2);
      }, VP8Filter__store2: function(dst, y, dc, d, c) {
        var t1 = J.getInterceptor$ns(dc);
        U.VP8Filter__store(dst, 0, 0, y, t1.$add(dc, d));
        U.VP8Filter__store(dst, 0, 1, y, t1.$add(dc, c));
        U.VP8Filter__store(dst, 0, 2, y, t1.$sub(dc, c));
        U.VP8Filter__store(dst, 0, 3, y, t1.$sub(dc, d));
      }, VP8Filter__initTables: function() {
        var i, t1, t2, t3, t4;
        if (!$.VP8Filter__tablesInitialized) {
          for (i = -255; i <= 255; ++i) {
            t1 = $.get$VP8Filter_abs0();
            t2 = 255 + i;
            t3 = i < 0 ? -i : i;
            t4 = t1.length;
            if (t2 >= t4)
              return H.ioore(t1, t2);
            t1[t2] = t3;
            t3 = $.get$VP8Filter_abs1();
            if (t2 >= t4)
              return H.ioore(t1, t2);
            t1 = t1[t2];
            if (t2 >= t3.length)
              return H.ioore(t3, t2);
            t3[t2] = t1 >>> 1;
          }
          for (i = -1020; i <= 1020; ++i) {
            t1 = $.get$VP8Filter_sclip1();
            t2 = 1020 + i;
            if (i < -128)
              t3 = -128;
            else
              t3 = i > 127 ? 127 : i;
            if (t2 >= t1.length)
              return H.ioore(t1, t2);
            t1[t2] = t3;
          }
          for (i = -112; i <= 112; ++i) {
            t1 = $.get$VP8Filter_sclip2();
            t2 = 112 + i;
            if (i < -16)
              t3 = -16;
            else
              t3 = i > 15 ? 15 : i;
            if (t2 >= t1.length)
              return H.ioore(t1, t2);
            t1[t2] = t3;
          }
          for (i = -255; i <= 510; ++i) {
            t1 = $.get$VP8Filter_clip1();
            t2 = 255 + i;
            if (i < 0)
              t3 = 0;
            else
              t3 = i > 255 ? 255 : i;
            if (t2 >= t1.length)
              return H.ioore(t1, t2);
            t1[t2] = t3;
          }
          $.VP8Filter__tablesInitialized = true;
        }
      }}
  },
  VP8FrameHeader: {
    "^": "Object;keyFrame,profile,show,partitionLength"
  },
  VP8PictureHeader: {
    "^": "Object;width>,height>,xscale,yscale,colorspace,clampType"
  },
  VP8SegmentHeader: {
    "^": "Object;useSegment,updateMap,absoluteDelta,quantizer,filterStrength"
  },
  VP8BandProbas: {
    "^": "Object;probas<",
    VP8BandProbas$0: function() {
      var t1, i;
      for (t1 = this.probas, i = 0; i < 3; ++i)
        t1[i] = new Uint8Array(11);
    },
    static: {VP8BandProbas$: function() {
        var t1 = new U.VP8BandProbas(H.setRuntimeTypeInfo(Array(3), [P.Uint8List]));
        t1.VP8BandProbas$0();
        return t1;
      }}
  },
  VP8Proba: {
    "^": "Object;segments,bands",
    VP8Proba$0: function() {
      var t1, i, t2, j;
      for (t1 = this.bands, i = 0; i < 4; ++i) {
        t2 = Array(8);
        t2.fixed$length = init;
        t2.$builtinTypeInfo = [U.VP8BandProbas];
        t1[i] = t2;
        for (j = 0; j < 8; ++j)
          J.$indexSet$ax(t1[i], j, U.VP8BandProbas$());
      }
      C.NativeUint8List_methods.fillRange$3(this.segments, 0, 3, 255);
    },
    static: {VP8Proba$: function() {
        var t1 = new U.VP8Proba(new Uint8Array(3), Array(4));
        t1.VP8Proba$0();
        return t1;
      }}
  },
  VP8FilterHeader: {
    "^": "Object;simple,level,sharpness,useLfDelta,refLfDelta,modeLfDelta"
  },
  VP8FInfo: {
    "^": "Object;fLimit?,fInnerLevel@,fInner@,hevThresh"
  },
  VP8MB: {
    "^": "Object;nz@,nzDc@"
  },
  VP8QuantMatrix: {
    "^": "Object;y1Mat<,y2Mat<,uvMat<,uvQuant,dither<"
  },
  VP8MBData: {
    "^": "Object;coeffs<,isIntra4x4@,imodes,uvmode,nonZeroY,nonZeroUV,dither<"
  },
  VP8TopSamples: {
    "^": "Object;y>,u<,v<"
  },
  VP8L: {
    "^": "Object;input,br,webp,image,_lastPixel,_lastRow,_colorCacheSize,_colorCache,_huffmanMask,_huffmanSubsampleBits,_huffmanXsize,_huffmanImage,_numHtreeGroups,_htreeGroups,_transforms,_transformsSeen,_pixels,_pixels8,_argbCache,_opaque,_ioWidth,_ioHeight",
    decodeHeader$0: function() {
      if (this.br.readBits$1(8) !== 47)
        return false;
      var t1 = this.webp;
      t1.format = 2;
      t1.width = this.br.readBits$1(14) + 1;
      t1.height = this.br.readBits$1(14) + 1;
      t1.hasAlpha = this.br.readBits$1(1) !== 0;
      if (this.br.readBits$1(3) !== 0)
        return false;
      return true;
    },
    decode$0: function() {
      var t1, t2, t3;
      this._lastPixel = 0;
      if (!this.decodeHeader$0())
        return;
      t1 = this.webp;
      this._decodeImageStream$3(t1.width, t1.height, true);
      this._allocateInternalBuffers32b$0();
      this.image = U.Image$(t1.width, t1.height, 4);
      t2 = this._pixels;
      t3 = t1.width;
      t1 = t1.height;
      if (!this._decodeImageData$5(t2, t3, t1, t1, this.get$_processRows()))
        return;
      return this.image;
    },
    _allocateInternalBuffers32b$0: function() {
      var t1, numPixels, cacheTopPixels, cachePixels, totalNumPixels, pixels32;
      t1 = this.webp;
      numPixels = J.$mul$ns(t1.width, t1.height);
      cacheTopPixels = t1.width;
      cachePixels = J.$mul$ns(cacheTopPixels, 16);
      t1 = J.getInterceptor$ns(numPixels);
      totalNumPixels = J.$add$ns(t1.$add(numPixels, cacheTopPixels), cachePixels);
      if (typeof totalNumPixels !== "number" || Math.floor(totalNumPixels) !== totalNumPixels)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(totalNumPixels)));
      pixels32 = new Uint32Array(totalNumPixels);
      this._pixels = pixels32;
      this._pixels8 = H.NativeUint8List_NativeUint8List$view(pixels32.buffer, 0, null);
      this._argbCache = t1.$add(numPixels, cacheTopPixels);
      return true;
    },
    _readTransform$1: function(transformSize) {
      var type, t1, t2, transform, t3, ok, numColors, bits;
      type = this.br.readBits$1(2);
      t1 = this._transformsSeen;
      t2 = C.JSInt_methods._shlPositive$1(1, type);
      if ((t1 & t2) >>> 0 !== 0)
        return false;
      this._transformsSeen = (t1 | t2) >>> 0;
      transform = new U.VP8LTransform(0, 0, 0, null, 0);
      this._transforms.push(transform);
      transform.type = type;
      transform.xsize = transformSize[0];
      transform.ysize = transformSize[1];
      switch (type) {
        case 0:
        case 1:
          t1 = this.br.readBits$1(3) + 2;
          transform.bits = t1;
          t2 = J.$sub$n(J.$add$ns(transform.xsize, C.JSInt_methods._shlPositive$1(1, t1)), 1);
          if (typeof t2 !== "number")
            return t2.$shr();
          t1 = C.JSNumber_methods._shrOtherPositive$1(t2, t1);
          t2 = transform.ysize;
          t3 = transform.bits;
          t2 = J.$sub$n(J.$add$ns(t2, C.JSInt_methods._shlPositive$1(1, t3)), 1);
          if (typeof t2 !== "number")
            return t2.$shr();
          transform.data = this._decodeImageStream$3(t1, C.JSNumber_methods._shrOtherPositive$1(t2, t3), false);
          ok = true;
          break;
        case 3:
          numColors = this.br.readBits$1(8) + 1;
          if (numColors > 16)
            bits = 0;
          else if (numColors > 4)
            bits = 1;
          else {
            t1 = numColors > 2 ? 2 : 3;
            bits = t1;
          }
          t1 = J.$sub$n(J.$add$ns(transform.xsize, C.JSInt_methods._shlPositive$1(1, bits)), 1);
          if (typeof t1 !== "number")
            return t1.$shr();
          transformSize[0] = C.JSNumber_methods._shrOtherPositive$1(t1, bits);
          transform.bits = bits;
          transform.data = this._decodeImageStream$3(numColors, 1, false);
          ok = this._expandColorMap$2(numColors, transform);
          break;
        case 2:
          ok = true;
          break;
        default:
          throw H.wrapException(U.ImageException$("Invalid WebP tranform type: " + type));
      }
      return ok;
    },
    _decodeImageStream$3: function(xsize, ysize, isLevel0) {
      var transformYsize, transformXsize, sizes, colorCacheBits, t1, numBits, t2, t3, totalSize, data;
      if (isLevel0) {
        for (transformYsize = ysize, transformXsize = xsize; this.br.readBits$1(1) !== 0;) {
          sizes = [transformXsize, transformYsize];
          if (!this._readTransform$1(sizes))
            throw H.wrapException(U.ImageException$("Invalid Transform"));
          transformXsize = sizes[0];
          transformYsize = sizes[1];
        }
        isLevel0 = true;
      } else {
        transformYsize = ysize;
        transformXsize = xsize;
      }
      if (this.br.readBits$1(1) !== 0) {
        colorCacheBits = this.br.readBits$1(4);
        if (!(colorCacheBits >= 1 && colorCacheBits <= 11))
          throw H.wrapException(U.ImageException$("Invalid Color Cache"));
      } else
        colorCacheBits = 0;
      if (!this._readHuffmanCodes$4(transformXsize, transformYsize, colorCacheBits, isLevel0))
        throw H.wrapException(U.ImageException$("Invalid Huffman Codes"));
      if (colorCacheBits > 0) {
        t1 = C.JSInt_methods._shlPositive$1(1, colorCacheBits);
        this._colorCacheSize = t1;
        this._colorCache = new U.VP8LColorCache(new Uint32Array(t1), 32 - colorCacheBits);
      } else
        this._colorCacheSize = 0;
      t1 = this.webp;
      t1.width = transformXsize;
      t1.height = transformYsize;
      numBits = this._huffmanSubsampleBits;
      t1 = C.JSInt_methods._shlPositive$1(1, numBits);
      t2 = J.getInterceptor$ns(transformXsize);
      t3 = J.$sub$n(t2.$add(transformXsize, t1), 1);
      if (typeof t3 !== "number")
        return t3.$shr();
      this._huffmanXsize = C.JSNumber_methods._shrOtherPositive$1(t3, numBits);
      this._huffmanMask = numBits === 0 ? 4294967295 : t1 - 1;
      if (isLevel0) {
        this._lastPixel = 0;
        return;
      }
      totalSize = t2.$mul(transformXsize, transformYsize);
      if (typeof totalSize !== "number" || Math.floor(totalSize) !== totalSize)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(totalSize)));
      data = new Uint32Array(totalSize);
      if (!this._decodeImageData$5(data, transformXsize, transformYsize, transformYsize, null))
        throw H.wrapException(U.ImageException$("Failed to decode image data."));
      this._lastPixel = 0;
      return data;
    },
    _decodeImageData$5: function(data, width, height, lastRow, processFunc) {
      var t1, row, col, htreeGroup, src, srcEnd, srcLast, colorCacheLimit, colorCache, mask, lastCached, t2, t3, code, red, blue, alpha, $length, distSymbol, dist, i, t4, key;
      t1 = this._lastPixel;
      if (typeof width !== "number")
        return H.iae(width);
      row = C.JSInt_methods.$tdiv(t1, width);
      col = C.JSInt_methods.$mod(t1, width);
      htreeGroup = this._getHtreeGroupForPos$2(col, row);
      src = this._lastPixel;
      if (typeof height !== "number")
        return H.iae(height);
      srcEnd = width * height;
      if (typeof lastRow !== "number")
        return H.iae(lastRow);
      srcLast = width * lastRow;
      t1 = this._colorCacheSize;
      colorCacheLimit = 280 + t1;
      colorCache = t1 > 0 ? this._colorCache : null;
      mask = this._huffmanMask;
      t1 = processFunc != null;
      lastCached = src;
      while (true) {
        t2 = this.br;
        t3 = t2._input;
        if (!(!(J.$ge$n(t3.offset, t3.end) && t2.bitPos >= 64) && src < srcLast))
          break;
        if ((col & mask) >>> 0 === 0)
          htreeGroup = this._getHtreeGroupForPos$2(col, row);
        t2 = this.br;
        if (t2.bitPos >= 32)
          t2._shiftBytes$0();
        code = htreeGroup.get$htrees()[0].readSymbol$1(this.br);
        if (code < 256) {
          t2 = htreeGroup.htrees;
          red = t2[1].readSymbol$1(this.br);
          t3 = this.br;
          if (t3.bitPos >= 32)
            t3._shiftBytes$0();
          blue = t2[2].readSymbol$1(this.br);
          alpha = t2[3].readSymbol$1(this.br);
          t2 = data.length;
          if (src < 0 || src >= t2)
            return H.ioore(data, src);
          data[src] = (alpha << 24 | red << 16 | code << 8 | blue) >>> 0;
          ++src;
          ++col;
          if (col >= width) {
            ++row;
            if (C.JSNumber_methods.$mod(row, 16) === 0 && t1)
              processFunc.call$1(row);
            if (colorCache != null)
              for (; lastCached < src;) {
                if (lastCached < 0)
                  return H.ioore(data, lastCached);
                colorCache.insert$1(0, data[lastCached]);
                ++lastCached;
              }
            col = 0;
          }
        } else if (code < 280) {
          $length = this._getCopyDistance$1(code - 256);
          distSymbol = htreeGroup.htrees[4].readSymbol$1(this.br);
          t2 = this.br;
          if (t2.bitPos >= 32)
            t2._shiftBytes$0();
          dist = this._planeCodeToDistance$2(width, this._getCopyDistance$1(distSymbol));
          if (src < dist || srcEnd - src < $length)
            return false;
          else {
            for (i = 0; i < $length; ++i) {
              t2 = src + i;
              t3 = src + (i - dist);
              t4 = data.length;
              if (t3 >>> 0 !== t3 || t3 >= t4)
                return H.ioore(data, t3);
              t3 = data[t3];
              if (t2 < 0 || t2 >= t4)
                return H.ioore(data, t2);
              data[t2] = t3;
            }
            src += $length;
          }
          col += $length;
          for (; col >= width;) {
            col -= width;
            ++row;
            if (C.JSNumber_methods.$mod(row, 16) === 0 && t1)
              processFunc.call$1(row);
          }
          if (src < srcLast) {
            if ((col & mask) >>> 0 !== 0)
              htreeGroup = this._getHtreeGroupForPos$2(col, row);
            if (colorCache != null)
              for (; lastCached < src;) {
                if (lastCached < 0 || lastCached >= data.length)
                  return H.ioore(data, lastCached);
                colorCache.insert$1(0, data[lastCached]);
                ++lastCached;
              }
          }
        } else if (code < colorCacheLimit) {
          key = code - 280;
          for (; lastCached < src;) {
            if (lastCached < 0 || lastCached >= data.length)
              return H.ioore(data, lastCached);
            colorCache.insert$1(0, data[lastCached]);
            ++lastCached;
          }
          t2 = colorCache.colors;
          if (key >= t2.length)
            return H.ioore(t2, key);
          t2 = t2[key];
          t3 = data.length;
          if (src < 0 || src >= t3)
            return H.ioore(data, src);
          data[src] = t2;
          ++src;
          ++col;
          if (col >= width) {
            ++row;
            if (C.JSNumber_methods.$mod(row, 16) === 0 && t1)
              processFunc.call$1(row);
            for (; lastCached < src;) {
              if (lastCached < 0)
                return H.ioore(data, lastCached);
              colorCache.insert$1(colorCache, data[lastCached]);
              ++lastCached;
            }
            col = 0;
          }
        } else
          return false;
      }
      if (t1)
        processFunc.call$1(row);
      t1 = this.br;
      t2 = t1._input;
      if (J.$ge$n(t2.offset, t2.end) && t1.bitPos >= 64 && src < srcEnd)
        return false;
      this._lastPixel = src;
      return true;
    },
    _is8bOptimizable$0: function() {
      var t1, t2, t3, i, htrees;
      if (this._colorCacheSize > 0)
        return false;
      for (t1 = this._numHtreeGroups, t2 = this._htreeGroups, t3 = t2.length, i = 0; i < t1; ++i) {
        if (i >= t3)
          return H.ioore(t2, i);
        htrees = t2[i].get$htrees();
        if (htrees[1].get$numNodes() > 1)
          return false;
        if (htrees[2].get$numNodes() > 1)
          return false;
        if (htrees[3].get$numNodes() > 1)
          return false;
      }
      return true;
    },
    _extractAlphaRows$1: [function(row) {
      var numRows, t1, width, cachePixs, di, src, i, t2, t3, t4;
      numRows = J.$sub$n(row, this._lastRow);
      if (J.$le$n(numRows, 0))
        return;
      t1 = this.webp;
      this._applyInverseTransforms$2(numRows, J.$mul$ns(t1.width, this._lastRow));
      width = t1.width;
      t1 = J.getInterceptor$ns(width);
      cachePixs = t1.$mul(width, numRows);
      di = t1.$mul(width, this._lastRow);
      src = U.InputBuffer$(this._pixels, false, null, this._argbCache);
      if (typeof cachePixs !== "number")
        return H.iae(cachePixs);
      t1 = J.getInterceptor$ns(di);
      i = 0;
      for (; i < cachePixs; ++i) {
        t2 = this._opaque;
        t3 = t1.$add(di, i);
        t4 = J.$index$asx(src.buffer, J.$add$ns(src.offset, i));
        if (typeof t4 !== "number")
          return t4.$shr();
        t4 = C.JSNumber_methods._shrOtherPositive$1(t4, 8);
        if (t3 >>> 0 !== t3 || t3 >= t2.length)
          return H.ioore(t2, t3);
        t2[t3] = t4 & 255;
      }
      this._lastRow = row;
    }, "call$1", "get$_extractAlphaRows", 2, 0, 117],
    _decodeAlphaData$3: function(width, height, lastRow) {
      var t1, row, col, htreeGroup, pos, end, last, mask, t2, code, $length, distSymbol, dist, i, t3, t4;
      t1 = this._lastPixel;
      if (typeof width !== "number")
        return H.iae(width);
      row = C.JSInt_methods.$tdiv(t1, width);
      col = C.JSInt_methods.$mod(t1, width);
      htreeGroup = this._getHtreeGroupForPos$2(col, row);
      pos = this._lastPixel;
      if (typeof height !== "number")
        return H.iae(height);
      end = width * height;
      last = width * lastRow;
      mask = this._huffmanMask;
      while (true) {
        t1 = this.br;
        t2 = t1._input;
        if (!(!(J.$ge$n(t2.offset, t2.end) && t1.bitPos >= 64) && pos < last))
          break;
        if ((col & mask) >>> 0 === 0)
          htreeGroup = this._getHtreeGroupForPos$2(col, row);
        t1 = this.br;
        if (t1.bitPos >= 32)
          t1._shiftBytes$0();
        code = htreeGroup.get$htrees()[0].readSymbol$1(this.br);
        if (code < 256) {
          t1 = this._pixels8;
          if (pos < 0 || pos >= t1.length)
            return H.ioore(t1, pos);
          t1[pos] = code;
          ++pos;
          ++col;
          if (col >= width) {
            ++row;
            if (C.JSNumber_methods.$mod(row, 16) === 0)
              this._extractPalettedAlphaRows$1(row);
            col = 0;
          }
        } else if (code < 280) {
          $length = this._getCopyDistance$1(code - 256);
          distSymbol = htreeGroup.htrees[4].readSymbol$1(this.br);
          t1 = this.br;
          if (t1.bitPos >= 32)
            t1._shiftBytes$0();
          dist = this._planeCodeToDistance$2(width, this._getCopyDistance$1(distSymbol));
          if (pos >= dist && end - pos >= $length)
            for (t1 = this._pixels8, i = 0; i < $length; ++i) {
              t2 = pos + i;
              t3 = t2 - dist;
              t4 = t1.length;
              if (t3 >>> 0 !== t3 || t3 >= t4)
                return H.ioore(t1, t3);
              t3 = t1[t3];
              if (t2 < 0 || t2 >= t4)
                return H.ioore(t1, t2);
              t1[t2] = t3;
            }
          else {
            this._lastPixel = pos;
            return true;
          }
          pos += $length;
          col += $length;
          for (; col >= width;) {
            col -= width;
            ++row;
            if (C.JSNumber_methods.$mod(row, 16) === 0)
              this._extractPalettedAlphaRows$1(row);
          }
          if (pos < last && (col & mask) >>> 0 !== 0)
            htreeGroup = this._getHtreeGroupForPos$2(col, row);
        } else
          return false;
      }
      this._extractPalettedAlphaRows$1(row);
      this._lastPixel = pos;
      return true;
    },
    _extractPalettedAlphaRows$1: function(row) {
      var t1, numRows, t2, t3, startRow, endRow, t4, t5, t6, t7;
      t1 = this._lastRow;
      if (typeof t1 !== "number")
        return H.iae(t1);
      numRows = row - t1;
      t2 = this._pixels8;
      t1 = J.$mul$ns(this.webp.width, t1);
      t3 = t2.length;
      if (numRows > 0) {
        startRow = this._lastRow;
        endRow = J.$add$ns(startRow, numRows);
        t4 = this._opaque;
        t5 = J.$mul$ns(this._ioWidth, startRow);
        t6 = t4.length;
        t7 = this._transforms;
        if (0 >= t7.length)
          return H.ioore(t7, 0);
        t7[0].colorIndexInverseTransformAlpha$4(startRow, endRow, new U.InputBuffer(t2, t1, t3, t1, false), new U.InputBuffer(t4, t5, t6, t5, false));
      }
      this._lastRow = row;
    },
    _processRows$1: [function(row) {
      var t1, rows, numRows, pi, dy, y, t2, x, t3, c, t4, t5, t6, t7, t8;
      t1 = this.webp;
      rows = J.$mul$ns(t1.width, this._lastRow);
      numRows = J.$sub$n(row, this._lastRow);
      if (J.$le$n(numRows, 0))
        return;
      this._applyInverseTransforms$2(numRows, rows);
      pi = this._argbCache;
      dy = this._lastRow;
      if (typeof numRows !== "number")
        return H.iae(numRows);
      y = 0;
      for (; y < numRows; ++y, dy = t2.$add(dy, 1)) {
        t1.progressCallback;
        t2 = J.getInterceptor$ns(dy);
        x = 0;
        while (true) {
          t3 = t1.width;
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(x < t3))
            break;
          t3 = this._pixels;
          if (pi >>> 0 !== pi || pi >= t3.length)
            return H.ioore(t3, pi);
          c = t3[pi];
          t3 = this.image;
          t4 = C.JSInt_methods.clamp$2(c >>> 24 & 255, 0, 255);
          t5 = C.JSInt_methods.clamp$2(c & 255, 0, 255);
          t6 = C.JSInt_methods.clamp$2(c >>> 8 & 255, 0, 255);
          t7 = C.JSInt_methods.clamp$2(c >>> 16 & 255, 0, 255);
          t3.toString;
          t8 = t3.width;
          if (typeof t8 !== "number")
            return H.iae(t8);
          t8 = x < t8 && t2.$ge(dy, 0) && t2.$lt(dy, t3.height);
          if (t8) {
            t8 = t3.data;
            t3 = J.$add$ns(t2.$mul(dy, t3.width), x);
            if (t3 >>> 0 !== t3 || t3 >= t8.length)
              return H.ioore(t8, t3);
            t8[t3] = (t4 << 24 | t5 << 16 | t6 << 8 | t7) >>> 0;
          }
          ++x;
          ++pi;
        }
      }
      this._lastRow = row;
    }, "call$1", "get$_processRows", 2, 0, 117],
    _applyInverseTransforms$2: function(numRows, rows) {
      var t1, n, cachePixs, startRow, endRow, rowsOut, rowsIn, n0, transform, t2;
      t1 = this._transforms;
      n = t1.length;
      cachePixs = J.$mul$ns(this.webp.width, numRows);
      startRow = this._lastRow;
      endRow = J.$add$ns(startRow, numRows);
      rowsOut = this._argbCache;
      J.setRange$4$ax(this._pixels, rowsOut, J.$add$ns(rowsOut, cachePixs), this._pixels, rows);
      for (rowsIn = rows; n0 = n - 1, n > 0; rowsIn = rowsOut, n = n0) {
        if (n0 < 0 || n0 >= t1.length)
          return H.ioore(t1, n0);
        transform = t1[n0];
        t2 = this._pixels;
        transform.inverseTransform$6(startRow, endRow, t2, rowsIn, t2, rowsOut);
      }
    },
    _readHuffmanCodes$4: function(xsize, ysize, colorCacheBits, allowRecursion) {
      var huffmanPrecision, t1, t2, huffmanPixs, huffmanImage, numHtreeGroups, i, group, htreeGroups, t3, j, alphabetSize;
      if (allowRecursion && this.br.readBits$1(1) !== 0) {
        huffmanPrecision = this.br.readBits$1(3) + 2;
        t1 = C.JSInt_methods._shlPositive$1(1, huffmanPrecision);
        t2 = J.$sub$n(J.$add$ns(xsize, t1), 1);
        if (typeof t2 !== "number")
          return t2.$shr();
        t2 = C.JSNumber_methods._shrOtherPositive$1(t2, huffmanPrecision);
        t1 = J.$sub$n(J.$add$ns(ysize, t1), 1);
        if (typeof t1 !== "number")
          return t1.$shr();
        t1 = C.JSNumber_methods._shrOtherPositive$1(t1, huffmanPrecision);
        huffmanPixs = t2 * t1;
        huffmanImage = this._decodeImageStream$3(t2, t1, false);
        this._huffmanSubsampleBits = huffmanPrecision;
        for (numHtreeGroups = 1, i = 0; i < huffmanPixs; ++i) {
          if (i >= huffmanImage.length)
            return H.ioore(huffmanImage, i);
          group = huffmanImage[i] >>> 8 & 65535;
          huffmanImage[i] = group;
          if (group >= numHtreeGroups)
            numHtreeGroups = group + 1;
        }
      } else {
        huffmanImage = null;
        numHtreeGroups = 1;
      }
      htreeGroups = H.setRuntimeTypeInfo(Array(numHtreeGroups), [U._HTreeGroup]);
      for (t1 = htreeGroups.length, t2 = colorCacheBits > 0, i = 0; i < numHtreeGroups; ++i) {
        t3 = U._HTreeGroup$();
        if (i >= t1)
          return H.ioore(htreeGroups, i);
        htreeGroups[i] = t3;
        for (j = 0; j < 5; ++j) {
          alphabetSize = C.List_yTu[j];
          if (j === 0 && t2)
            alphabetSize = J.$add$ns(alphabetSize, C.JSInt_methods._shlPositive$1(1, colorCacheBits));
          if (!this._readHuffmanCode$2(alphabetSize, htreeGroups[i].get$htrees()[j]))
            return false;
        }
      }
      this._huffmanImage = huffmanImage;
      this._numHtreeGroups = numHtreeGroups;
      this._htreeGroups = htreeGroups;
      return true;
    },
    _readHuffmanCode$2: function(alphabetSize, tree) {
      var symbols, codes, codeLengths, numSymbols, firstSymbolLenCode, t1, ok, codeLengthCodeLengths, numCodes, i, t2;
      if (this.br.readBits$1(1) !== 0) {
        symbols = [0, 0];
        codes = [0, 0];
        codeLengths = [0, 0];
        numSymbols = this.br.readBits$1(1) + 1;
        firstSymbolLenCode = this.br.readBits$1(1);
        t1 = this.br;
        symbols[0] = t1.readBits$1(firstSymbolLenCode === 0 ? 1 : 8);
        codes[0] = 0;
        t1 = numSymbols - 1;
        codeLengths[0] = t1;
        if (numSymbols === 2) {
          symbols[1] = this.br.readBits$1(8);
          codes[1] = 1;
          codeLengths[1] = t1;
        }
        ok = tree.buildExplicit$5(codeLengths, codes, symbols, alphabetSize, numSymbols);
      } else {
        codeLengthCodeLengths = new Int32Array(19);
        numCodes = this.br.readBits$1(4) + 4;
        if (numCodes > 19)
          return false;
        if (typeof alphabetSize !== "number" || Math.floor(alphabetSize) !== alphabetSize)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(alphabetSize)));
        codeLengths = new Int32Array(alphabetSize);
        for (i = 0; i < numCodes; ++i) {
          t1 = C.List_uSC0[i];
          t2 = this.br.readBits$1(3);
          if (t1 >>> 0 !== t1 || t1 >= 19)
            return H.ioore(codeLengthCodeLengths, t1);
          codeLengthCodeLengths[t1] = t2;
        }
        ok = this._readHuffmanCodeLengths$3(codeLengthCodeLengths, alphabetSize, codeLengths);
        if (ok)
          ok = tree.buildImplicit$2(codeLengths, alphabetSize);
      }
      return ok;
    },
    _readHuffmanCodeLengths$3: function(codeLengthCodeLengths, numSymbols, codeLengths) {
      var t1, t2, tree, max_symbol, symbol, prev_code_len, max_symbol0, code_len, symbol0, slot, extra_bits, repeat_offset, repeat, $length, repeat0;
      t1 = new Uint8Array(128);
      t2 = new Int16Array(128);
      tree = new U._HuffmanTree(t1, t2, new Int16Array(128), null, 0, 0);
      tree._init$1(0);
      if (!tree.buildImplicit$2(codeLengthCodeLengths, 19))
        return false;
      if (this.br.readBits$1(1) !== 0) {
        t1 = this.br.readBits$1(3);
        max_symbol = 2 + this.br.readBits$1(2 + 2 * t1);
        if (typeof numSymbols !== "number")
          return H.iae(numSymbols);
        if (max_symbol > numSymbols)
          return false;
      } else
        max_symbol = numSymbols;
      if (typeof numSymbols !== "number")
        return H.iae(numSymbols);
      t1 = codeLengths.length;
      symbol = 0;
      prev_code_len = 8;
      for (; symbol < numSymbols; max_symbol = max_symbol0) {
        t2 = J.getInterceptor$n(max_symbol);
        max_symbol0 = t2.$sub(max_symbol, 1);
        if (t2.$eq(max_symbol, 0))
          break;
        t2 = this.br;
        if (t2.bitPos >= 32)
          t2._shiftBytes$0();
        code_len = tree.readSymbol$1(this.br);
        if (code_len < 16) {
          symbol0 = symbol + 1;
          if (symbol < 0 || symbol >= t1)
            return H.ioore(codeLengths, symbol);
          codeLengths[symbol] = code_len;
          if (code_len !== 0)
            prev_code_len = code_len;
          symbol = symbol0;
        } else {
          slot = code_len - 16;
          if (slot >= 3)
            return H.ioore(C.List_2_3_7, slot);
          extra_bits = C.List_2_3_7[slot];
          repeat_offset = C.List_3_3_11[slot];
          t2 = this.br.readBits$1(extra_bits);
          if (typeof repeat_offset !== "number")
            return H.iae(repeat_offset);
          repeat = t2 + repeat_offset;
          if (symbol + repeat > numSymbols)
            return false;
          else {
            $length = code_len === 16 ? prev_code_len : 0;
            for (; repeat0 = repeat - 1, repeat > 0; repeat = repeat0, symbol = symbol0) {
              symbol0 = symbol + 1;
              if (symbol < 0 || symbol >= t1)
                return H.ioore(codeLengths, symbol);
              codeLengths[symbol] = $length;
            }
          }
        }
      }
      return true;
    },
    _getCopyDistance$1: function(distanceSymbol) {
      var extraBits;
      if (distanceSymbol < 4)
        return distanceSymbol + 1;
      extraBits = C.JSInt_methods._shrOtherPositive$1(distanceSymbol - 2, 1);
      return C.JSInt_methods._shlPositive$1(2 + (distanceSymbol & 1), extraBits) + this.br.readBits$1(extraBits) + 1;
    },
    _planeCodeToDistance$2: function(xsize, planeCode) {
      var t1, distCode, dist;
      if (planeCode > 120)
        return planeCode - 120;
      else {
        t1 = planeCode - 1;
        if (t1 < 0)
          return H.ioore(C.List_AYZ, t1);
        distCode = C.List_AYZ[t1];
        if (typeof distCode !== "number")
          return distCode.$shr();
        t1 = C.JSNumber_methods._shrOtherPositive$1(distCode, 4);
        if (typeof xsize !== "number")
          return H.iae(xsize);
        dist = t1 * xsize + (8 - (distCode & 15));
        return dist >= 1 ? dist : 1;
      }
    },
    _expandColorMap$2: function(numColors, transform) {
      var finalNumColors, newColorMap, data, newData, t1, len, t2, i, t3, t4;
      finalNumColors = C.JSInt_methods._shlPositive$1(1, C.JSInt_methods._shrBothPositive$1(8, transform.bits));
      newColorMap = new Uint32Array(finalNumColors);
      data = H.NativeUint8List_NativeUint8List$view(transform.data.buffer, 0, null);
      newData = H.NativeUint8List_NativeUint8List$view(newColorMap.buffer, 0, null);
      t1 = transform.data;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = t1[0];
      if (0 >= finalNumColors)
        return H.ioore(newColorMap, 0);
      newColorMap[0] = t1;
      len = 4 * numColors;
      for (t1 = data.length, t2 = newData.length, i = 4; i < len; ++i) {
        if (i >= t1)
          return H.ioore(data, i);
        t3 = data[i];
        t4 = i - 4;
        if (t4 >= t2)
          return H.ioore(newData, t4);
        t4 = newData[t4];
        if (i >= t2)
          return H.ioore(newData, i);
        newData[i] = t3 + t4 & 255;
      }
      for (len = 4 * finalNumColors; i < len; ++i) {
        if (i >= t2)
          return H.ioore(newData, i);
        newData[i] = 0;
      }
      transform.data = newColorMap;
      return true;
    },
    _getMetaIndex$5: function(image, xsize, bits, x, y) {
      var t1;
      if (bits === 0)
        return 0;
      t1 = xsize * C.JSNumber_methods._shrOtherPositive$1(y, bits) + C.JSNumber_methods._shrOtherPositive$1(x, bits);
      if (t1 >= image.length)
        return H.ioore(image, t1);
      return image[t1];
    },
    _getHtreeGroupForPos$2: function(x, y) {
      var metaIndex, t1, t2;
      metaIndex = this._getMetaIndex$5(this._huffmanImage, this._huffmanXsize, this._huffmanSubsampleBits, x, y);
      t1 = this._htreeGroups;
      if (metaIndex >= t1.length)
        return H.ioore(t1, metaIndex);
      if (t1[metaIndex] == null) {
        t2 = U._HTreeGroup$();
        if (metaIndex >= t1.length)
          return H.ioore(t1, metaIndex);
        t1[metaIndex] = t2;
      }
      t1 = this._htreeGroups;
      if (metaIndex >= t1.length)
        return H.ioore(t1, metaIndex);
      return t1[metaIndex];
    },
    static: {"^": "VP8L___count,VP8L__GREEN,VP8L__RED,VP8L__BLUE,VP8L__ALPHA,VP8L__DIST,VP8L__NUM_ARGB_CACHE_ROWS,VP8L__NUM_CODE_LENGTH_CODES,VP8L__CODE_LENGTH_CODE_ORDER,VP8L__CODE_TO_PLANE_CODES,VP8L__CODE_TO_PLANE,VP8L__CODE_LENGTH_LITERALS,VP8L__CODE_LENGTH_REPEAT_CODE,VP8L__CODE_LENGTH_EXTRA_BITS,VP8L__CODE_LENGTH_REPEAT_OFFSETS,VP8L_ALPHABET_SIZE,VP8L_VP8L_MAGIC_BYTE,VP8L_VP8L_VERSION,VP8L_ARGB_BLACK,VP8L_MAX_CACHE_BITS,VP8L_HUFFMAN_CODES_PER_META_CODE,VP8L_DEFAULT_CODE_LENGTH,VP8L_MAX_ALLOWED_CODE_LENGTH,VP8L_NUM_LITERAL_CODES,VP8L_NUM_LENGTH_CODES,VP8L_NUM_DISTANCE_CODES,VP8L_CODE_LENGTH_CODES", VP8L$: function(input, webp) {
        var t1 = new U.VP8LBitReader(0, input, new Uint32Array(2), null);
        t1.VP8LBitReader$1(input);
        return new U.VP8L(input, t1, webp, null, 0, 0, 0, null, 0, 0, 0, null, 0, [], [], 0, null, null, null, null, null, null);
      }}
  },
  VP8LBitReader: {
    "^": "Object;bitPos,_input,_buffer,_buffer8",
    prefetchBits$0: function() {
      var t1, t2, t3, t4, b2;
      t1 = this.bitPos;
      if (t1 < 32) {
        t2 = this._buffer;
        t3 = C.JSInt_methods._shrReceiverPositive$1(t2[0], t1);
        t2 = t2[1];
        if (t1 >>> 0 !== t1 || t1 >= 33)
          return H.ioore(C.List_DKo, t1);
        t4 = C.List_DKo[t1];
        if (typeof t4 !== "number")
          return H.iae(t4);
        t1 = J.$add$ns(C.List_DKo[32 - t1], 1);
        if (typeof t1 !== "number")
          return H.iae(t1);
        b2 = t3 + ((t2 & t4) >>> 0) * t1;
      } else {
        t2 = this._buffer;
        b2 = t1 === 32 ? t2[1] : C.JSInt_methods._shrReceiverPositive$1(t2[1], t1 - 32);
      }
      return b2;
    },
    readBits$1: function(numBits) {
      var t1, t2;
      t1 = this._input;
      if (!(J.$ge$n(t1.offset, t1.end) && this.bitPos >= 64) && J.$lt$n(numBits, 25)) {
        t1 = this.prefetchBits$0();
        if (numBits >>> 0 !== numBits || numBits >= 33)
          return H.ioore(C.List_DKo, numBits);
        t2 = C.List_DKo[numBits];
        if (typeof t2 !== "number")
          return H.iae(t2);
        this.bitPos += numBits;
        this._shiftBytes$0();
        return (t1 & t2) >>> 0;
      } else
        throw H.wrapException(U.ImageException$("Not enough data in input."));
    },
    _shiftBytes$0: function() {
      var t1, t2, t3, b;
      while (true) {
        if (this.bitPos >= 8) {
          t1 = this._input;
          t1 = !J.$ge$n(t1.offset, t1.end);
        } else
          t1 = false;
        if (!t1)
          break;
        t1 = this._input;
        t2 = t1.buffer;
        t3 = t1.offset;
        t1.offset = J.$add$ns(t3, 1);
        b = J.$index$asx(t2, t3);
        t3 = this._buffer;
        t2 = t3[0];
        t1 = t3[1];
        t3[0] = (t2 >>> 8) + (t1 & 255) * 16777216;
        t3[1] = t1 >>> 8;
        t1 = t3[1];
        t2 = J.$mul$ns(b, 16777216);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3[1] = (t1 | t2) >>> 0;
        this.bitPos -= 8;
      }
    },
    VP8LBitReader$1: function(_input) {
      var t1, t2, t3, t4;
      t1 = H.NativeUint8List_NativeUint8List$view(this._buffer.buffer, 0, null);
      this._buffer8 = t1;
      t2 = this._input;
      t3 = t2.buffer;
      t4 = t2.offset;
      t2.offset = J.$add$ns(t4, 1);
      t4 = J.$index$asx(t3, t4);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1[0] = t4;
      t4 = this._buffer8;
      t1 = this._input;
      t3 = t1.buffer;
      t2 = t1.offset;
      t1.offset = J.$add$ns(t2, 1);
      t2 = J.$index$asx(t3, t2);
      if (1 >= t4.length)
        return H.ioore(t4, 1);
      t4[1] = t2;
      t2 = this._buffer8;
      t4 = this._input;
      t3 = t4.buffer;
      t1 = t4.offset;
      t4.offset = J.$add$ns(t1, 1);
      t1 = J.$index$asx(t3, t1);
      if (2 >= t2.length)
        return H.ioore(t2, 2);
      t2[2] = t1;
      t1 = this._buffer8;
      t2 = this._input;
      t3 = t2.buffer;
      t4 = t2.offset;
      t2.offset = J.$add$ns(t4, 1);
      t4 = J.$index$asx(t3, t4);
      if (3 >= t1.length)
        return H.ioore(t1, 3);
      t1[3] = t4;
      t4 = this._buffer8;
      t1 = this._input;
      t3 = t1.buffer;
      t2 = t1.offset;
      t1.offset = J.$add$ns(t2, 1);
      t2 = J.$index$asx(t3, t2);
      if (4 >= t4.length)
        return H.ioore(t4, 4);
      t4[4] = t2;
      t2 = this._buffer8;
      t4 = this._input;
      t3 = t4.buffer;
      t1 = t4.offset;
      t4.offset = J.$add$ns(t1, 1);
      t1 = J.$index$asx(t3, t1);
      if (5 >= t2.length)
        return H.ioore(t2, 5);
      t2[5] = t1;
      t1 = this._buffer8;
      t2 = this._input;
      t3 = t2.buffer;
      t4 = t2.offset;
      t2.offset = J.$add$ns(t4, 1);
      t4 = J.$index$asx(t3, t4);
      if (6 >= t1.length)
        return H.ioore(t1, 6);
      t1[6] = t4;
      t4 = this._buffer8;
      t1 = this._input;
      t3 = t1.buffer;
      t2 = t1.offset;
      t1.offset = J.$add$ns(t2, 1);
      t2 = J.$index$asx(t3, t2);
      if (7 >= t4.length)
        return H.ioore(t4, 7);
      t4[7] = t2;
    },
    static: {"^": "VP8LBitReader_VALUE_SIZE,VP8LBitReader_MAX_NUM_BIT_READ,VP8LBitReader_LBITS,VP8LBitReader_WBITS,VP8LBitReader_LOG8_WBITS,VP8LBitReader_BIT_MASK"}
  },
  VP8LColorCache: {
    "^": "Object;colors,hashShift",
    insert$1: function(_, argb) {
      var key, t1;
      key = C.JSInt_methods._shrReceiverPositive$1((argb * 506832829 & 4294967295) >>> 0, this.hashShift);
      t1 = this.colors;
      if (key >= t1.length)
        return H.ioore(t1, key);
      t1[key] = argb;
    },
    lookup$1: function(key) {
      var t1 = this.colors;
      if (key >>> 0 !== key || key >= t1.length)
        return H.ioore(t1, key);
      return t1[key];
    },
    static: {"^": "VP8LColorCache__HASH_MUL"}
  },
  VP8LTransform: {
    "^": "Object;type>,xsize,ysize,data>,bits",
    inverseTransform$6: function(rowStart, rowEnd, inData, rowsIn, outData, rowsOut) {
      var width, t1, t2, start, outStride, t3, inStride, src;
      width = this.xsize;
      switch (this.type) {
        case 2:
          this.addGreenToBlueAndRed$3(outData, rowsOut, J.$add$ns(rowsOut, J.$mul$ns(J.$sub$n(rowEnd, rowStart), width)));
          break;
        case 0:
          this.predictorInverseTransform$4(rowStart, rowEnd, outData, rowsOut);
          t1 = J.getInterceptor(rowEnd);
          if (!t1.$eq(rowEnd, this.ysize)) {
            t2 = J.getInterceptor$n(rowsOut);
            start = t2.$sub(rowsOut, width);
            J.setRange$4$ax(outData, start, J.$add$ns(start, width), inData, t2.$add(rowsOut, J.$mul$ns(J.$sub$n(t1.$sub(rowEnd, rowStart), 1), width)));
          }
          break;
        case 1:
          this.colorSpaceInverseTransform$4(rowStart, rowEnd, outData, rowsOut);
          break;
        case 3:
          if (J.$eq(rowsIn, rowsOut) && this.bits > 0) {
            t1 = J.getInterceptor$n(rowEnd);
            outStride = J.$mul$ns(t1.$sub(rowEnd, rowStart), width);
            t1 = t1.$sub(rowEnd, rowStart);
            t2 = this.xsize;
            t3 = this.bits;
            t2 = J.$sub$n(J.$add$ns(t2, C.JSInt_methods._shlPositive$1(1, t3)), 1);
            if (typeof t2 !== "number")
              return t2.$shr();
            inStride = J.$mul$ns(t1, C.JSNumber_methods._shrOtherPositive$1(t2, t3));
            src = J.$sub$n(J.$add$ns(rowsOut, outStride), inStride);
            J.setRange$4$ax(outData, src, J.$add$ns(src, inStride), inData, rowsOut);
            this.colorIndexInverseTransform$6(rowStart, rowEnd, inData, src, outData, rowsOut);
          } else
            this.colorIndexInverseTransform$6(rowStart, rowEnd, inData, rowsIn, outData, rowsOut);
          break;
      }
    },
    colorIndexInverseTransformAlpha$4: function(yStart, yEnd, src, dst) {
      var t1, bitsPerPixel, width, colorMap, countMask, bit_mask, y, packed_pixels, x, t2, index;
      t1 = this.bits;
      bitsPerPixel = C.JSInt_methods._shrBothPositive$1(8, t1);
      width = this.xsize;
      colorMap = this.data;
      if (bitsPerPixel < 8) {
        countMask = C.JSInt_methods._shlPositive$1(1, t1) - 1;
        bit_mask = C.JSInt_methods._shlPositive$1(1, bitsPerPixel) - 1;
        for (y = yStart; t1 = J.getInterceptor$n(y), t1.$lt(y, yEnd); y = t1.$add(y, 1)) {
          if (typeof width !== "number")
            return H.iae(width);
          packed_pixels = 0;
          x = 0;
          for (; x < width; ++x) {
            if ((x & countMask) >>> 0 === 0) {
              packed_pixels = J.$index$asx(src.buffer, J.$add$ns(src.offset, 0));
              src.offset = J.$add$ns(src.offset, 1);
            }
            t2 = J.getInterceptor$n(packed_pixels).$and(packed_pixels, bit_mask);
            if (t2 >>> 0 !== t2 || t2 >= colorMap.length)
              return H.ioore(colorMap, t2);
            t2 = colorMap[t2];
            J.$indexSet$ax(dst.buffer, J.$add$ns(dst.offset, 0), t2 >>> 8 & 255);
            dst.offset = J.$add$ns(dst.offset, 1);
            if (typeof packed_pixels !== "number")
              return packed_pixels.$shr();
            packed_pixels = C.JSNumber_methods._shrOtherPositive$1(packed_pixels, bitsPerPixel);
          }
        }
      } else
        for (y = yStart; t1 = J.getInterceptor$n(y), t1.$lt(y, yEnd); y = t1.$add(y, 1)) {
          if (typeof width !== "number")
            return H.iae(width);
          x = 0;
          for (; x < width; ++x) {
            index = J.$index$asx(src.buffer, J.$add$ns(src.offset, 0));
            src.offset = J.$add$ns(src.offset, 1);
            if (index >>> 0 !== index || index >= colorMap.length)
              return H.ioore(colorMap, index);
            t2 = colorMap[index];
            J.$indexSet$ax(dst.buffer, J.$add$ns(dst.offset, 0), t2 >>> 8 & 255);
            dst.offset = J.$add$ns(dst.offset, 1);
          }
        }
    },
    colorIndexInverseTransform$6: function(yStart, yEnd, inData, src, outData, dst) {
      var t1, bitsPerPixel, width, colorMap, countMask, bit_mask, y, packed_pixels, x, src0, dst0, t2;
      t1 = this.bits;
      bitsPerPixel = C.JSInt_methods._shrBothPositive$1(8, t1);
      width = this.xsize;
      colorMap = this.data;
      if (bitsPerPixel < 8) {
        countMask = C.JSInt_methods._shlPositive$1(1, t1) - 1;
        bit_mask = C.JSInt_methods._shlPositive$1(1, bitsPerPixel) - 1;
        for (y = yStart; t1 = J.getInterceptor$n(y), t1.$lt(y, yEnd); y = t1.$add(y, 1)) {
          if (typeof width !== "number")
            return H.iae(width);
          packed_pixels = 0;
          x = 0;
          for (; x < width; ++x, dst = dst0) {
            if ((x & countMask) >>> 0 === 0) {
              src0 = J.$add$ns(src, 1);
              if (src >>> 0 !== src || src >= inData.length)
                return H.ioore(inData, src);
              packed_pixels = inData[src] >>> 8 & 255;
              src = src0;
            }
            dst0 = J.$add$ns(dst, 1);
            t2 = packed_pixels & bit_mask;
            if (t2 < 0 || t2 >= colorMap.length)
              return H.ioore(colorMap, t2);
            t2 = colorMap[t2];
            if (dst >>> 0 !== dst || dst >= outData.length)
              return H.ioore(outData, dst);
            outData[dst] = t2;
            packed_pixels = C.JSInt_methods._shrBothPositive$1(packed_pixels, bitsPerPixel);
          }
        }
      } else
        for (y = yStart; t1 = J.getInterceptor$n(y), t1.$lt(y, yEnd); y = t1.$add(y, 1)) {
          if (typeof width !== "number")
            return H.iae(width);
          x = 0;
          for (; x < width; ++x, dst = dst0, src = src0) {
            dst0 = J.$add$ns(dst, 1);
            src0 = J.$add$ns(src, 1);
            if (src >>> 0 !== src || src >= inData.length)
              return H.ioore(inData, src);
            t2 = inData[src] >>> 8 & 255;
            if (t2 >= colorMap.length)
              return H.ioore(colorMap, t2);
            t2 = colorMap[t2];
            if (dst >>> 0 !== dst || dst >= outData.length)
              return H.ioore(outData, dst);
            outData[dst] = t2;
          }
        }
    },
    colorSpaceInverseTransform$4: function(yStart, yEnd, outData, data) {
      var width, t1, t2, mask, predRow, y, m, t3, pred, x, t4, pred0, t5, t6, green, newRed, newBlue;
      width = this.xsize;
      t1 = this.bits;
      t2 = C.JSInt_methods._shlPositive$1(1, t1);
      mask = t2 - 1;
      t2 = J.$sub$n(J.$add$ns(width, t2), 1);
      if (typeof t2 !== "number")
        return t2.$shr();
      t1 = C.JSNumber_methods._shrOtherPositive$1(t2, t1);
      t2 = this.bits;
      if (typeof yStart !== "number")
        return yStart.$shr();
      predRow = C.JSNumber_methods._shrOtherPositive$1(yStart, t2) * t1;
      if (typeof yEnd !== "number")
        return H.iae(yEnd);
      y = yStart;
      for (; y < yEnd;) {
        t2 = new Uint8Array(3);
        m = new U._VP8LMultipliers(t2);
        if (typeof width !== "number")
          return H.iae(width);
        t3 = J.getInterceptor$ns(data);
        pred = predRow;
        x = 0;
        for (; x < width; ++x) {
          if ((x & mask) >>> 0 === 0) {
            t4 = this.data;
            pred0 = pred + 1;
            if (pred >= t4.length)
              return H.ioore(t4, pred);
            t4 = t4[pred];
            t2[0] = t4 >>> 0 & 255;
            t2[1] = t4 >>> 8 & 255;
            t2[2] = t4 >>> 16 & 255;
            pred = pred0;
          }
          t4 = t3.$add(data, x);
          t5 = t3.$add(data, x);
          t6 = outData.length;
          if (t5 >>> 0 !== t5 || t5 >= t6)
            return H.ioore(outData, t5);
          t5 = outData[t5];
          green = t5 >>> 8 & 255;
          newRed = (t5 >>> 16 & 255) + m.colorTransformDelta$2(t2[0], green) & 4294967295 & 255;
          newBlue = (((t5 & 255) + m.colorTransformDelta$2(t2[1], green) & 4294967295) >>> 0) + m.colorTransformDelta$2(t2[2], newRed) & 4294967295 & 255;
          if (t4 >>> 0 !== t4 || t4 >= t6)
            return H.ioore(outData, t4);
          outData[t4] = (t5 & 4278255360 | newRed << 16 & 4294967295 | newBlue) >>> 0;
        }
        data = t3.$add(data, width);
        ++y;
        if ((y & mask) >>> 0 === 0)
          predRow += t1;
      }
    },
    predictorInverseTransform$4: function(yStart, yEnd, outData, data) {
      var width, t1, t2, t3, t4, x, pred1, mask, predModeBase, y, predModeSrc, predFunc, predModeSrc0, pred;
      width = this.xsize;
      t1 = J.getInterceptor(yStart);
      if (t1.$eq(yStart, 0)) {
        t2 = J.getInterceptor$n(data);
        t3 = t2.$sub(data, 1);
        t4 = outData.length;
        if (t3 >>> 0 !== t3 || t3 >= t4)
          return H.ioore(outData, t3);
        outData[t3];
        U.VP8LTransform__addPixelsEq(outData, data, 4278190080);
        if (typeof width !== "number")
          return H.iae(width);
        x = 1;
        for (; x < width; ++x) {
          t3 = J.$sub$n(t2.$add(data, x), 1);
          if (t3 >>> 0 !== t3 || t3 >= t4)
            return H.ioore(outData, t3);
          pred1 = outData[t3];
          U.VP8LTransform__addPixelsEq(outData, t2.$add(data, x), pred1);
        }
        data = t2.$add(data, width);
        yStart = t1.$add(yStart, 1);
      }
      t1 = this.bits;
      t2 = C.JSInt_methods._shlPositive$1(1, t1);
      mask = t2 - 1;
      t2 = J.$sub$n(J.$add$ns(width, t2), 1);
      if (typeof t2 !== "number")
        return t2.$shr();
      t1 = C.JSNumber_methods._shrOtherPositive$1(t2, t1);
      t2 = this.bits;
      if (typeof yStart !== "number")
        return yStart.$shr();
      predModeBase = C.JSNumber_methods._shrOtherPositive$1(yStart, t2) * t1;
      if (typeof yEnd !== "number")
        return H.iae(yEnd);
      y = yStart;
      for (; y < yEnd;) {
        t2 = J.getInterceptor$n(data);
        t3 = t2.$sub(data, 1);
        t4 = outData.length;
        if (t3 >>> 0 !== t3 || t3 >= t4)
          return H.ioore(outData, t3);
        outData[t3];
        t3 = t2.$sub(data, width);
        if (t3 >>> 0 !== t3 || t3 >= t4)
          return H.ioore(outData, t3);
        U.VP8LTransform__addPixelsEq(outData, data, outData[t3]);
        t3 = this.data;
        predModeSrc = predModeBase + 1;
        if (predModeBase >= t3.length)
          return H.ioore(t3, predModeBase);
        t3 = t3[predModeBase];
        predFunc = $.get$VP8LTransform_PREDICTORS()[t3 >>> 8 & 15];
        if (typeof width !== "number")
          return H.iae(width);
        x = 1;
        for (; x < width; ++x) {
          if ((x & mask) >>> 0 === 0) {
            t3 = this.data;
            predModeSrc0 = predModeSrc + 1;
            if (predModeSrc >= t3.length)
              return H.ioore(t3, predModeSrc);
            t3 = t3[predModeSrc];
            predFunc = $.get$VP8LTransform_PREDICTORS()[t3 >>> 8 & 15];
            predModeSrc = predModeSrc0;
          }
          t3 = J.$sub$n(t2.$add(data, x), 1);
          if (t3 >>> 0 !== t3 || t3 >= t4)
            return H.ioore(outData, t3);
          pred = predFunc.call$3(outData, outData[t3], J.$sub$n(t2.$add(data, x), width));
          U.VP8LTransform__addPixelsEq(outData, t2.$add(data, x), pred);
        }
        data = t2.$add(data, width);
        ++y;
        if ((y & mask) >>> 0 === 0)
          predModeBase += t1;
      }
    },
    addGreenToBlueAndRed$3: function(pixels, data, dataEnd) {
      var argb, green, data0;
      for (; J.$lt$n(data, dataEnd); data = data0) {
        if (data >>> 0 !== data || data >= pixels.length)
          return H.ioore(pixels, data);
        argb = pixels[data];
        green = argb >>> 8 & 255;
        data0 = data + 1;
        pixels[data] = (argb & 4278255360 | (argb & 16711935) + ((green << 16 | green) >>> 0) & 16711935) >>> 0;
      }
    },
    static: {"^": "VP8LTransform_PREDICTOR_TRANSFORM,VP8LTransform_CROSS_COLOR_TRANSFORM,VP8LTransform_SUBTRACT_GREEN,VP8LTransform_COLOR_INDEXING_TRANSFORM,VP8LTransform_PREDICTORS", VP8LTransform__addPixelsEq: function(pixels, a, b) {
        var pa, t1, t2;
        if (a >>> 0 !== a || a >= pixels.length)
          return H.ioore(pixels, a);
        pa = pixels[a];
        t1 = J.getInterceptor$n(b);
        t2 = t1.$and(b, 4278255360);
        if (typeof t2 !== "number")
          return H.iae(t2);
        pixels[a] = (((pa & 4278255360) >>> 0) + t2 & 4278255360 | (pa & 16711935) + t1.$and(b, 16711935) & 16711935) >>> 0;
      }, VP8LTransform__average2: function(a0, a1) {
        if (typeof a0 !== "number")
          return a0.$xor();
        if (typeof a1 !== "number")
          return H.iae(a1);
        return (((a0 ^ a1) & 4278124286) >>> 1) + ((a0 & a1) >>> 0);
      }, VP8LTransform__clip255: function(a) {
        if (a < 0)
          return 0;
        if (a > 255)
          return 255;
        return a;
      }, VP8LTransform__sub3: function(a, b, c) {
        return Math.abs(b - c) - Math.abs(a - c);
      }, VP8LTransform__predictor0: [function(pixels, left, $top) {
        return 4278190080;
      }, "call$3", "VP8LTransform__predictor0$closure", 6, 0, 25], VP8LTransform__predictor1: [function(pixels, left, $top) {
        return left;
      }, "call$3", "VP8LTransform__predictor1$closure", 6, 0, 25], VP8LTransform__predictor2: [function(pixels, left, $top) {
        return J.$index$asx(pixels, $top);
      }, "call$3", "VP8LTransform__predictor2$closure", 6, 0, 25], VP8LTransform__predictor3: [function(pixels, left, $top) {
        return J.$index$asx(pixels, J.$add$ns($top, 1));
      }, "call$3", "VP8LTransform__predictor3$closure", 6, 0, 25], VP8LTransform__predictor4: [function(pixels, left, $top) {
        return J.$index$asx(pixels, J.$sub$n($top, 1));
      }, "call$3", "VP8LTransform__predictor4$closure", 6, 0, 25], VP8LTransform__predictor5: [function(pixels, left, $top) {
        var t1, t2;
        t1 = J.getInterceptor$asx(pixels);
        t2 = t1.$index(pixels, $top);
        return U.VP8LTransform__average2(U.VP8LTransform__average2(left, t1.$index(pixels, J.$add$ns($top, 1))), t2);
      }, "call$3", "VP8LTransform__predictor5$closure", 6, 0, 25], VP8LTransform__predictor6: [function(pixels, left, $top) {
        return U.VP8LTransform__average2(left, J.$index$asx(pixels, J.$sub$n($top, 1)));
      }, "call$3", "VP8LTransform__predictor6$closure", 6, 0, 25], VP8LTransform__predictor7: [function(pixels, left, $top) {
        return U.VP8LTransform__average2(left, J.$index$asx(pixels, $top));
      }, "call$3", "VP8LTransform__predictor7$closure", 6, 0, 25], VP8LTransform__predictor8: [function(pixels, left, $top) {
        var t1 = J.getInterceptor$asx(pixels);
        return U.VP8LTransform__average2(t1.$index(pixels, J.$sub$n($top, 1)), t1.$index(pixels, $top));
      }, "call$3", "VP8LTransform__predictor8$closure", 6, 0, 25], VP8LTransform__predictor9: [function(pixels, left, $top) {
        var t1 = J.getInterceptor$asx(pixels);
        return U.VP8LTransform__average2(t1.$index(pixels, $top), t1.$index(pixels, J.$add$ns($top, 1)));
      }, "call$3", "VP8LTransform__predictor9$closure", 6, 0, 25], VP8LTransform__predictor10: [function(pixels, left, $top) {
        var t1, t2, t3, t4;
        t1 = J.getInterceptor$n($top);
        t2 = J.getInterceptor$asx(pixels);
        t3 = t2.$index(pixels, t1.$sub($top, 1));
        t4 = t2.$index(pixels, $top);
        t1 = t2.$index(pixels, t1.$add($top, 1));
        return U.VP8LTransform__average2(U.VP8LTransform__average2(left, t3), U.VP8LTransform__average2(t4, t1));
      }, "call$3", "VP8LTransform__predictor10$closure", 6, 0, 25], VP8LTransform__predictor11: [function(pixels, left, $top) {
        var t1, t2, t3, t4;
        t1 = J.getInterceptor$asx(pixels);
        t2 = t1.$index(pixels, $top);
        t1 = t1.$index(pixels, J.$sub$n($top, 1));
        if (typeof t2 !== "number")
          return t2.$shr();
        t3 = C.JSNumber_methods._shrOtherPositive$1(t2, 24);
        if (typeof left !== "number")
          return left.$shr();
        t4 = C.JSNumber_methods._shrOtherPositive$1(left, 24);
        if (typeof t1 !== "number")
          return t1.$shr();
        if (U.VP8LTransform__sub3(t3, t4, C.JSNumber_methods._shrOtherPositive$1(t1, 24)) + U.VP8LTransform__sub3(C.JSNumber_methods._shrOtherPositive$1(t2, 16) & 255, C.JSNumber_methods._shrOtherPositive$1(left, 16) & 255, C.JSNumber_methods._shrOtherPositive$1(t1, 16) & 255) + U.VP8LTransform__sub3(C.JSNumber_methods._shrOtherPositive$1(t2, 8) & 255, C.JSNumber_methods._shrOtherPositive$1(left, 8) & 255, C.JSNumber_methods._shrOtherPositive$1(t1, 8) & 255) + U.VP8LTransform__sub3(t2 & 255, left & 255, t1 & 255) <= 0)
          t1 = t2;
        else
          t1 = left;
        return t1;
      }, "call$3", "VP8LTransform__predictor11$closure", 6, 0, 25], VP8LTransform__predictor12: [function(pixels, left, $top) {
        var t1, t2, t3, t4;
        t1 = J.getInterceptor$asx(pixels);
        t2 = t1.$index(pixels, $top);
        t1 = t1.$index(pixels, J.$sub$n($top, 1));
        if (typeof left !== "number")
          return left.$shr();
        t3 = C.JSNumber_methods._shrOtherPositive$1(left, 24);
        if (typeof t2 !== "number")
          return t2.$shr();
        t4 = C.JSNumber_methods._shrOtherPositive$1(t2, 24);
        if (typeof t1 !== "number")
          return t1.$shr();
        return (U.VP8LTransform__clip255(t3 + t4 - C.JSNumber_methods._shrOtherPositive$1(t1, 24)) << 24 | U.VP8LTransform__clip255((C.JSNumber_methods._shrOtherPositive$1(left, 16) & 255) + (C.JSNumber_methods._shrOtherPositive$1(t2, 16) & 255) - (C.JSNumber_methods._shrOtherPositive$1(t1, 16) & 255)) << 16 | U.VP8LTransform__clip255((C.JSNumber_methods._shrOtherPositive$1(left, 8) & 255) + (C.JSNumber_methods._shrOtherPositive$1(t2, 8) & 255) - (C.JSNumber_methods._shrOtherPositive$1(t1, 8) & 255)) << 8 | U.VP8LTransform__clip255((left & 255) + (t2 & 255) - (t1 & 255))) >>> 0;
      }, "call$3", "VP8LTransform__predictor12$closure", 6, 0, 25], VP8LTransform__predictor13: [function(pixels, left, $top) {
        var t1, t2, avg, t3, t4, t5;
        t1 = J.getInterceptor$asx(pixels);
        t2 = t1.$index(pixels, $top);
        t1 = t1.$index(pixels, J.$sub$n($top, 1));
        avg = U.VP8LTransform__average2(left, t2);
        t2 = avg >>> 24;
        if (typeof t1 !== "number")
          return t1.$shr();
        t3 = avg >>> 16 & 255;
        t4 = avg >>> 8 & 255;
        t5 = avg >>> 0 & 255;
        return (U.VP8LTransform__clip255(t2 + C.JSInt_methods._tdivFast$1(t2 - C.JSNumber_methods._shrOtherPositive$1(t1, 24), 2)) << 24 | U.VP8LTransform__clip255(t3 + C.JSInt_methods._tdivFast$1(t3 - (C.JSNumber_methods._shrOtherPositive$1(t1, 16) & 255), 2)) << 16 | U.VP8LTransform__clip255(t4 + C.JSInt_methods._tdivFast$1(t4 - (C.JSNumber_methods._shrOtherPositive$1(t1, 8) & 255), 2)) << 8 | U.VP8LTransform__clip255(t5 + C.JSInt_methods._tdivFast$1(t5 - (C.JSNumber_methods._shrOtherPositive$1(t1, 0) & 255), 2))) >>> 0;
      }, "call$3", "VP8LTransform__predictor13$closure", 6, 0, 25]}
  },
  _VP8LMultipliers: {
    "^": "Object;data>",
    colorTransformDelta$2: function(colorPred, color) {
      var t1, t2, t3, a, b;
      t1 = $.get$__uint8();
      t1[0] = colorPred;
      t2 = $.get$__uint8ToInt8();
      t3 = t2.length;
      if (0 >= t3)
        return H.ioore(t2, 0);
      a = t2[0];
      t1[0] = color;
      if (0 >= t3)
        return H.ioore(t2, 0);
      b = t2[0];
      $.get$__int32()[0] = a * b;
      t2 = $.get$__int32ToUint32();
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      return t2[0] >>> 5;
    }
  },
  WebPAlpha: {
    "^": "Object;input,width>,height>,method,filter,preProcessing,rsrv,isAlphaDecoded,_vp8l,_use8bDecode",
    get$isValid: function() {
      var t1 = this.method;
      if (typeof t1 !== "number")
        return t1.$lt();
      t1 = t1 > 1 || this.filter >= 4 || this.preProcessing > 1 || this.rsrv !== 0;
      if (t1)
        return false;
      return true;
    },
    decode$3: function(row, numRows, output) {
      var t1, unfilterFunc, offset, numPixels, t2, t3, t4;
      if (!this.get$isValid())
        return false;
      t1 = this.filter;
      if (t1 >= 4)
        return H.ioore(C.List_HHa, t1);
      unfilterFunc = C.List_HHa[t1];
      if (this.method === 0) {
        t1 = this.width;
        if (typeof t1 !== "number")
          return H.iae(t1);
        offset = row * t1;
        numPixels = J.$mul$ns(numRows, t1);
        t1 = this.input;
        J.setRange$4$ax(output, offset, numPixels, t1.buffer, J.$add$ns(J.$sub$n(t1.offset, t1.start), offset));
      } else {
        if (typeof numRows !== "number")
          return H.iae(numRows);
        t1 = row + numRows;
        t2 = this._vp8l;
        t2._opaque = output;
        if (this._use8bDecode) {
          t3 = t2.webp;
          t1 = t2._decodeAlphaData$3(t3.width, t3.height, t1);
        } else {
          t3 = t2._pixels;
          t4 = t2.webp;
          t2 = t2._decodeImageData$5(t3, t4.width, t4.height, t1, t2.get$_extractAlphaRows());
          t1 = t2;
        }
        if (!t1)
          return false;
      }
      if (unfilterFunc != null) {
        t1 = this.width;
        unfilterFunc.call$6(t1, this.height, t1, row, numRows, output);
      }
      if (this.preProcessing === 1)
        if (!this._dequantizeLevels$5(output, this.width, this.height, row, numRows))
          return false;
      if (typeof numRows !== "number")
        return H.iae(numRows);
      if (row + numRows === this.height)
        this.isAlphaDecoded = true;
      return true;
    },
    _dequantizeLevels$5: function(data, width, height, row, num_rows) {
      var t1;
      if (data != null)
        if (!J.$le$n(width, 0))
          if (!J.$le$n(height, 0))
            if (!(row < 0))
              if (!J.$lt$n(num_rows, 0)) {
                if (typeof num_rows !== "number")
                  return H.iae(num_rows);
                if (typeof height !== "number")
                  return H.iae(height);
                t1 = row + num_rows > height;
              } else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return false;
      return true;
    },
    WebPAlpha$3: function(input, width, height) {
      var t1, t2, t3, b, alphaDecodedSize, webp, totalNumPixels, n;
      t1 = this.input;
      t2 = t1.buffer;
      t3 = t1.offset;
      t1.offset = J.$add$ns(t3, 1);
      b = J.$index$asx(t2, t3);
      this.method = J.getInterceptor$n(b).$and(b, 3);
      if (typeof b !== "number")
        return b.$shr();
      this.filter = C.JSNumber_methods._shrOtherPositive$1(b, 2) & 3;
      this.preProcessing = C.JSNumber_methods._shrOtherPositive$1(b, 4) & 3;
      this.rsrv = C.JSNumber_methods._shrOtherPositive$1(b, 6) & 3;
      if (this.get$isValid()) {
        t1 = this.method;
        if (t1 === 0) {
          alphaDecodedSize = J.$mul$ns(this.width, this.height);
          t1 = this.input;
          if (J.$lt$n(J.$sub$n(t1.end, t1.offset), alphaDecodedSize))
            this.rsrv = 1;
        } else if (t1 === 1) {
          webp = new U.WebPInfo(false, false, 0, "", "", "", 0, [], null, null, null, null, null, null, null, 0, 0, 4294967295);
          webp.width = this.width;
          webp.height = this.height;
          t1 = U.VP8L$(this.input, webp);
          this._vp8l = t1;
          t1._ioWidth = this.width;
          t1._ioHeight = this.height;
          t1._decodeImageStream$3(webp.width, webp.height, true);
          t1 = this._vp8l._transforms;
          t2 = t1.length;
          if (t2 === 1) {
            if (0 >= t2)
              return H.ioore(t1, 0);
            t1 = J.$eq(J.get$type$x(t1[0]), 3) && this._vp8l._is8bOptimizable$0();
          } else
            t1 = false;
          if (t1) {
            this._use8bDecode = true;
            t1 = this._vp8l;
            t2 = t1.webp;
            totalNumPixels = J.$mul$ns(t2.width, t2.height);
            t1._argbCache = 0;
            t2 = J.getInterceptor$n(totalNumPixels);
            t3 = t2.$mod(totalNumPixels, 4);
            if (typeof t3 !== "number")
              return H.iae(t3);
            n = t2.$add(totalNumPixels, 4 - t3);
            if (typeof n !== "number" || Math.floor(n) !== n)
              H.throwExpression(P.ArgumentError$("Invalid length " + H.S(n)));
            t2 = new Uint8Array(n);
            t1._pixels8 = t2;
            t1._pixels = H.NativeUint32List_NativeUint32List$view(t2.buffer, 0, null);
          } else {
            this._use8bDecode = false;
            this._vp8l._allocateInternalBuffers32b$0();
          }
        } else
          this.rsrv = 1;
      }
    },
    static: {"^": "WebPAlpha_ALPHA_NO_COMPRESSION,WebPAlpha_ALPHA_LOSSLESS_COMPRESSION,WebPAlpha_ALPHA_PREPROCESSED_LEVELS"}
  },
  WebPFrame: {
    "^": "Object;x*,y*,width>,height>,duration',clearFrame?,_reserved,_framePosition,_frameSize<",
    WebPFrame$2: function(input, size) {
      var t1, t2, b;
      this.x = J.$mul$ns(input.readUint24$0(), 2);
      this.y = J.$mul$ns(input.readUint24$0(), 2);
      this.width = J.$add$ns(input.readUint24$0(), 1);
      this.height = J.$add$ns(input.readUint24$0(), 1);
      this.duration = input.readUint24$0();
      t1 = input.buffer;
      t2 = input.offset;
      input.offset = J.$add$ns(t2, 1);
      b = J.$index$asx(t1, t2);
      t2 = J.getInterceptor$n(b);
      this._reserved = t2.$and(b, 127) >>> 7;
      this.clearFrame = t2.$and(b, 1) !== 0;
      this._framePosition = J.$sub$n(input.offset, input.start);
      this._frameSize = size - 16;
    },
    static: {"^": "WebPFrame__ANIMF_HEADER_SIZE"}
  },
  _HuffmanTree: {
    "^": "Object;lutBits,lutSymbol,lutJump,tree,maxNodes,numNodes<",
    _init$1: function(numLeaves) {
      var t1, t2;
      if (numLeaves === 0)
        return false;
      t1 = (numLeaves << 1 >>> 0) - 1;
      this.maxNodes = t1;
      t1 = t1 << 1 >>> 0;
      t2 = new Int32Array(t1);
      this.tree = t2;
      if (1 >= t1)
        return H.ioore(t2, 1);
      t2[1] = -1;
      this.numNodes = 1;
      C.NativeUint8List_methods.fillRange$3(this.lutBits, 0, 128, 255);
      return true;
    },
    buildImplicit$2: function(codeLengths, codeLengthsSize) {
      var t1, numSymbols, rootSymbol, symbol, codes, t2, t3;
      if (typeof codeLengthsSize !== "number")
        return H.iae(codeLengthsSize);
      t1 = codeLengths.length;
      numSymbols = 0;
      rootSymbol = 0;
      symbol = 0;
      for (; symbol < codeLengthsSize; ++symbol) {
        if (symbol >= t1)
          return H.ioore(codeLengths, symbol);
        if (codeLengths[symbol] > 0) {
          ++numSymbols;
          rootSymbol = symbol;
        }
      }
      if (!this._init$1(numSymbols))
        return false;
      if (numSymbols === 1) {
        if (rootSymbol < 0 || rootSymbol >= codeLengthsSize)
          return false;
        return this._addSymbol$3(rootSymbol, 0, 0);
      }
      if (typeof codeLengthsSize !== "number" || Math.floor(codeLengthsSize) !== codeLengthsSize)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(codeLengthsSize)));
      codes = new Int32Array(codeLengthsSize);
      if (!this._huffmanCodeLengthsToCodes$3(codeLengths, codeLengthsSize, codes))
        return false;
      for (t2 = codes.length, symbol = 0; symbol < codeLengthsSize; ++symbol) {
        if (symbol >= t1)
          return H.ioore(codeLengths, symbol);
        t3 = codeLengths[symbol];
        if (t3 > 0) {
          if (symbol >= t2)
            return H.ioore(codes, symbol);
          if (!this._addSymbol$3(symbol, codes[symbol], t3))
            return false;
        }
      }
      return this.numNodes === this.maxNodes;
    },
    buildExplicit$5: function(codeLengths, codes, symbols, maxSymbol, numSymbols) {
      var i;
      if (!this._init$1(numSymbols))
        return false;
      for (i = 0; i < numSymbols; ++i) {
        if (i >= 2)
          return H.ioore(codes, i);
        if (!J.$eq(codes[i], -1)) {
          if (J.$lt$n(symbols[i], 0) || J.$ge$n(symbols[i], maxSymbol))
            return this.numNodes === this.maxNodes;
          if (!this._addSymbol$3(symbols[i], codes[i], codeLengths[i]))
            return this.numNodes === this.maxNodes;
        }
      }
      return this.numNodes === this.maxNodes;
    },
    readSymbol$1: function(br) {
      var bits, newBitPos, lut_ix, lut_bits, node, t1, t2, t3, t4;
      bits = br.prefetchBits$0();
      newBitPos = br.bitPos;
      lut_ix = bits & 127;
      lut_bits = this.lutBits[lut_ix];
      if (lut_bits <= 7) {
        br.bitPos = newBitPos + lut_bits;
        return this.lutSymbol[lut_ix];
      }
      node = this.lutJump[lut_ix];
      newBitPos += 7;
      bits = C.JSNumber_methods._shrOtherPositive$1(bits, 7);
      t1 = this.tree;
      do {
        t2 = (node << 1 >>> 0) + 1;
        t3 = t1.length;
        if (t2 >= t3)
          return H.ioore(t1, t2);
        node = node + t1[t2] + (bits & 1);
        bits = bits >>> 1;
        ++newBitPos;
        t2 = node << 1 >>> 0;
        t4 = t2 + 1;
        if (t4 >= t3)
          return H.ioore(t1, t4);
      } while (t1[t4] !== 0);
      br.bitPos = newBitPos;
      t1 = this.tree;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    _addSymbol$3: function(symbol, code, codeLength) {
      var t1, baseCode, t2, t3, i, idx, step, node, codeLength0, t4, t5, t6;
      t1 = J.getInterceptor$n(codeLength);
      if (t1.$le(codeLength, 7)) {
        baseCode = this._reverseBitsShort$2(code, codeLength);
        if (typeof codeLength !== "number")
          return H.iae(codeLength);
        t1 = C.JSInt_methods.$shl(1, 7 - codeLength);
        t2 = this.lutSymbol;
        t3 = this.lutBits;
        i = 0;
        for (; i < t1; ++i) {
          idx = (baseCode | C.JSInt_methods.$shl(i, codeLength)) >>> 0;
          if (idx >= 128)
            return H.ioore(t2, idx);
          t2[idx] = symbol;
          t3[idx] = codeLength;
        }
      } else {
        t1 = t1.$sub(codeLength, 7);
        if (typeof code !== "number")
          return code.$shr();
        if (typeof t1 !== "number")
          return H.iae(t1);
        baseCode = this._reverseBitsShort$2(C.JSNumber_methods.$shr(code, t1), 7);
      }
      for (t1 = this.lutJump, step = 7, node = 0; t2 = J.getInterceptor$n(codeLength), codeLength0 = t2.$sub(codeLength, 1), t2.$gt(codeLength, 0); codeLength = codeLength0) {
        t2 = this.maxNodes;
        if (node >= t2)
          return false;
        t3 = this.tree;
        t4 = (node << 1 >>> 0) + 1;
        t5 = t3.length;
        if (t4 >= t5)
          return H.ioore(t3, t4);
        t6 = t3[t4];
        if (t6 < 0) {
          t6 = this.numNodes;
          if (t6 === t2)
            return false;
          t3[t4] = t6 - node;
          this.numNodes = t6 + 2;
          t2 = (t6 << 1 >>> 0) + 1;
          if (t2 >= t5)
            return H.ioore(t3, t2);
          t3[t2] = -1;
          t6 = (t6 + 1 << 1 >>> 0) + 1;
          if (t6 >= t5)
            return H.ioore(t3, t6);
          t3[t6] = -1;
        } else if (t6 === 0)
          return false;
        if (t4 >= t5)
          return H.ioore(t3, t4);
        t2 = t3[t4];
        if (typeof code !== "number")
          return code.$shr();
        if (typeof codeLength0 !== "number")
          return H.iae(codeLength0);
        node += t2 + (C.JSNumber_methods.$shr(code, codeLength0) & 1);
        --step;
        if (step === 0) {
          if (baseCode >= 128)
            return H.ioore(t1, baseCode);
          t1[baseCode] = node;
        }
      }
      t1 = this.tree;
      t2 = node << 1 >>> 0;
      t3 = t2 + 1;
      t4 = t1.length;
      if (t3 >= t4)
        return H.ioore(t1, t3);
      t5 = t1[t3];
      if (t5 < 0)
        t1[t3] = 0;
      else if (t5 !== 0)
        return false;
      if (t2 >= t4)
        return H.ioore(t1, t2);
      t1[t2] = symbol;
      return true;
    },
    _reverseBitsShort$2: function(bits, numBits) {
      var t1, t2;
      t1 = J.getInterceptor$n(bits).$and(bits, 15);
      if (t1 >= 16)
        return H.ioore(C.List_cGl, t1);
      t1 = C.List_cGl[t1];
      if (typeof t1 !== "number")
        return t1.$shl();
      if (typeof bits !== "number")
        return bits.$shr();
      t2 = C.JSNumber_methods._shrOtherPositive$1(bits, 4);
      if (t2 >= 16)
        return H.ioore(C.List_cGl, t2);
      t2 = C.List_cGl[t2];
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof numBits !== "number")
        return H.iae(numBits);
      return C.JSInt_methods._shrReceiverPositive$1((t1 << 4 | t2) >>> 0, 8 - numBits);
    },
    _huffmanCodeLengthsToCodes$3: function(codeLengths, codeLengthsSize, huffCodes) {
      var codeLengthHist, nextCodes, t1, symbol, maxCodeLength, maxCodeLength0, t2, codeLen, currCode, t3, t4;
      codeLengthHist = new Int32Array(16);
      nextCodes = new Int32Array(16);
      if (typeof codeLengthsSize !== "number")
        return H.iae(codeLengthsSize);
      t1 = codeLengths.length;
      symbol = 0;
      maxCodeLength = 0;
      for (; symbol < codeLengthsSize; ++symbol) {
        if (symbol >= t1)
          return H.ioore(codeLengths, symbol);
        maxCodeLength0 = codeLengths[symbol];
        if (maxCodeLength0 > maxCodeLength)
          maxCodeLength = maxCodeLength0;
      }
      if (maxCodeLength > 15)
        return false;
      for (symbol = 0; symbol < codeLengthsSize; ++symbol) {
        if (symbol >= t1)
          return H.ioore(codeLengths, symbol);
        t2 = codeLengths[symbol];
        if (t2 < 0 || t2 >= 16)
          return H.ioore(codeLengthHist, t2);
        codeLengthHist[t2] = codeLengthHist[t2] + 1;
      }
      codeLengthHist[0] = 0;
      nextCodes[0] = -1;
      for (codeLen = 1, currCode = 0; codeLen <= maxCodeLength; ++codeLen) {
        currCode = currCode + codeLengthHist[codeLen - 1] << 1 >>> 0;
        nextCodes[codeLen] = currCode;
      }
      for (t2 = huffCodes.length, symbol = 0; symbol < codeLengthsSize; ++symbol) {
        if (symbol >= t1)
          return H.ioore(codeLengths, symbol);
        t3 = codeLengths[symbol];
        if (t3 > 0) {
          if (t3 >= 16)
            return H.ioore(nextCodes, t3);
          t4 = nextCodes[t3];
          nextCodes[t3] = t4 + 1;
          if (symbol >= t2)
            return H.ioore(huffCodes, symbol);
          huffCodes[symbol] = t4;
        } else {
          if (symbol >= t2)
            return H.ioore(huffCodes, symbol);
          huffCodes[symbol] = -1;
        }
      }
      return true;
    },
    static: {"^": "_HuffmanTree_HUFF_LUT_BITS,_HuffmanTree_HUFF_LUT,_HuffmanTree__REVERSED_BITS"}
  },
  _HTreeGroup: {
    "^": "Object;htrees<",
    $index: function(_, index) {
      var t1, t2, t3;
      t1 = this.htrees;
      if (index >>> 0 !== index || index >= 5)
        return H.ioore(t1, index);
      t2 = t1[index];
      if (t2 == null) {
        t2 = new Uint8Array(128);
        t3 = new Int16Array(128);
        t2 = new U._HuffmanTree(t2, t3, new Int16Array(128), null, 0, 0);
        t2._init$1(0);
        t1[index] = t2;
        t1 = t2;
      } else
        t1 = t2;
      return t1;
    },
    _HTreeGroup$0: function() {
      var t1, i, t2, t3;
      for (t1 = this.htrees, i = 0; i < 5; ++i) {
        t2 = new Uint8Array(128);
        t3 = new Int16Array(128);
        t2 = new U._HuffmanTree(t2, t3, new Int16Array(128), null, 0, 0);
        t2._init$1(0);
        t1[i] = t2;
      }
    },
    static: {_HTreeGroup$: function() {
        var t1 = new U._HTreeGroup(H.setRuntimeTypeInfo(Array(5), [U._HuffmanTree]));
        t1._HTreeGroup$0();
        return t1;
      }}
  },
  WebPInfo: {
    "^": "DecodeInfo;hasAlpha,hasAnimation,format,iccp,exif,xmp,animLoopCount,frames,progressCallback,_frame,_numFrames,_alphaData,_alphaSize,_vp8Position,_vp8Size,width,height,backgroundColor",
    static: {"^": "WebPInfo_FORMAT_UNDEFINED,WebPInfo_FORMAT_LOSSY,WebPInfo_FORMAT_LOSSLESS,WebPInfo_FORMAT_ANIMATED"}
  },
  WebPDecoder: {
    "^": "Decoder;info,_input,progressCallback",
    isValidFile$1: function(bytes) {
      var t1 = U.InputBuffer$(bytes, false, null, 0);
      this._input = t1;
      if (!this._getHeader$1(t1))
        return false;
      return true;
    },
    startDecode$1: function(bytes) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      t1 = U.InputBuffer$(bytes, false, null, 0);
      this._input = t1;
      if (!this._getHeader$1(t1))
        return;
      t1 = new U.WebPInfo(false, false, 0, "", "", "", 0, [], null, null, null, null, null, null, null, 0, 0, 4294967295);
      this.info = t1;
      if (!this._getInfo$2(this._input, t1))
        return;
      t1 = this.info;
      t1.progressCallback = this.progressCallback;
      switch (t1.format) {
        case 3:
          return t1;
        case 2:
          t2 = this._input;
          t2.offset = t1._vp8Position;
          if (!U.VP8L$(t2, t1).decodeHeader$0())
            return;
          return this.info;
        case 1:
          t2 = this._input;
          t2.offset = t1._vp8Position;
          t3 = new Int32Array(4);
          t4 = new Int32Array(4);
          t5 = new Int8Array(4);
          t6 = new Int8Array(4);
          t7 = H.setRuntimeTypeInfo(Array(8), [U.VP8BitReader]);
          t8 = H.setRuntimeTypeInfo(Array(4), [U.VP8QuantMatrix]);
          if (!new U.VP8(t2, t1, null, null, null, new U.VP8FrameHeader(null, null, null, null), new U.VP8PictureHeader(null, null, null, null, null, null), new U.VP8FilterHeader(null, null, null, null, t3, t4), new U.VP8SegmentHeader(false, false, true, t5, t6), null, null, null, null, null, null, null, null, null, null, null, t7, false, null, t8, null, null, null, null, new Uint8Array(4), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null, null, null, null, null, null, null, null, null).decodeHeader$0())
            return;
          return this.info;
      }
      return;
    },
    decodeFrame$1: function(frame) {
      var t1, t2, t3, f, data, t4, t5, t6, t7;
      t1 = this._input;
      if (t1 == null || this.info == null)
        return;
      t2 = this.info;
      if (t2.hasAnimation) {
        t2 = t2.frames;
        t3 = t2.length;
        if (frame >= t3 || false)
          return;
        if (frame >= t3)
          return H.ioore(t2, frame);
        f = t2[frame];
        return this._decodeFrame$2$frame(t1.subset$2$position(f.get$_frameSize(), f._framePosition), frame);
      }
      t3 = t2.format;
      if (t3 === 2)
        return U.VP8L$(t1.subset$2$position(t2._vp8Size, t2._vp8Position), this.info).decode$0();
      else if (t3 === 1) {
        data = t1.subset$2$position(t2._vp8Size, t2._vp8Position);
        t1 = this.info;
        t2 = new Int32Array(4);
        t3 = new Int32Array(4);
        t4 = new Int8Array(4);
        t5 = new Int8Array(4);
        t6 = H.setRuntimeTypeInfo(Array(8), [U.VP8BitReader]);
        t7 = H.setRuntimeTypeInfo(Array(4), [U.VP8QuantMatrix]);
        return new U.VP8(data, t1, null, null, null, new U.VP8FrameHeader(null, null, null, null), new U.VP8PictureHeader(null, null, null, null, null, null), new U.VP8FilterHeader(null, null, null, null, t2, t3), new U.VP8SegmentHeader(false, false, true, t4, t5), null, null, null, null, null, null, null, null, null, null, null, t6, false, null, t7, null, null, null, null, new Uint8Array(4), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null, null, null, null, null, null, null, null, null).decode$0();
      }
      return;
    },
    _decodeFrame$2$frame: function(input, frame) {
      var t1, webp, t2, f, data, t3, t4, t5, t6;
      t1 = [];
      webp = new U.WebPInfo(false, false, 0, "", "", "", 0, t1, null, null, null, null, null, null, null, 0, 0, 4294967295);
      if (!this._getInfo$2(input, webp))
        return;
      if (webp.format === 0)
        return;
      t2 = this.info;
      webp._frame = t2._frame;
      webp._numFrames = t2._numFrames;
      webp.progressCallback = this.progressCallback;
      if (webp.hasAnimation) {
        t2 = t1.length;
        if (frame >= t2 || false)
          return;
        if (frame >= t2)
          return H.ioore(t1, frame);
        f = t1[frame];
        return this._decodeFrame$2$frame(input.subset$2$position(f.get$_frameSize(), f._framePosition), frame);
      } else {
        data = input.subset$2$position(webp._vp8Size, webp._vp8Position);
        t1 = webp.format;
        if (t1 === 2)
          return U.VP8L$(data, webp).decode$0();
        else if (t1 === 1) {
          t1 = new Int32Array(4);
          t2 = new Int32Array(4);
          t3 = new Int8Array(4);
          t4 = new Int8Array(4);
          t5 = H.setRuntimeTypeInfo(Array(8), [U.VP8BitReader]);
          t6 = H.setRuntimeTypeInfo(Array(4), [U.VP8QuantMatrix]);
          return new U.VP8(data, webp, null, null, null, new U.VP8FrameHeader(null, null, null, null), new U.VP8PictureHeader(null, null, null, null, null, null), new U.VP8FilterHeader(null, null, null, null, t1, t2), new U.VP8SegmentHeader(false, false, true, t3, t4), null, null, null, null, null, null, null, null, null, null, null, t5, false, null, t6, null, null, null, null, new Uint8Array(4), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null, null, null, null, null, null, null, null, null).decode$0();
        }
      }
      return;
    },
    _getHeader$1: function(input) {
      if (input.readString$1(4) !== "RIFF")
        return false;
      input.readUint32$0();
      if (input.readString$1(4) !== "WEBP")
        return false;
      return true;
    },
    _getInfo$2: function(input, webp) {
      var found, tag, size, diskSize, t1, t2, p, t3, t4, c, line, remainder;
      found = false;
      while (true) {
        if (!(!J.$ge$n(input.offset, input.end) && !found))
          break;
        tag = input.readString$1(4);
        size = input.readUint32$0();
        diskSize = size + 1 >>> 1 << 1 >>> 0;
        t1 = input.offset;
        t2 = input.start;
        p = J.$sub$n(t1, t2);
        switch (tag) {
          case "VP8X":
            if (!this._getVp8xInfo$2(input, webp))
              return false;
            break;
          case "VP8 ":
            webp._vp8Position = J.$sub$n(input.offset, t2);
            webp._vp8Size = size;
            webp.format = 1;
            found = true;
            break;
          case "VP8L":
            webp._vp8Position = J.$sub$n(input.offset, t2);
            webp._vp8Size = size;
            webp.format = 2;
            found = true;
            break;
          case "ALPH":
            t1 = input.buffer;
            t3 = input.bigEndian;
            t4 = J.get$length$asx(t1);
            t3 = new U.InputBuffer(t1, 0, t4, 0, t3);
            webp._alphaData = t3;
            t3.offset = input.offset;
            webp._alphaSize = size;
            input.offset = J.$add$ns(input.offset, diskSize);
            break;
          case "ANIM":
            webp.format = 3;
            c = input.readUint32$0();
            webp.animLoopCount = input.readUint16$0();
            webp.backgroundColor = (C.JSInt_methods.clamp$2(c & 255, 0, 255) << 24 | C.JSInt_methods.clamp$2(c >>> 24 & 255, 0, 255) << 16 | C.JSInt_methods.clamp$2(c >>> 16 & 255, 0, 255) << 8 | C.JSInt_methods.clamp$2(c >>> 8 & 255, 0, 255)) >>> 0;
            break;
          case "ANMF":
            if (!this._getAnimFrameInfo$3(input, webp, size))
              return false;
            break;
          case "ICCP":
            webp.iccp = input.readString$1(size);
            break;
          case "EXIF":
            webp.exif = input.readString$1(size);
            break;
          case "XMP ":
            webp.xmp = input.readString$1(size);
            break;
          default:
            line = "UNKNOWN WEBP TAG: " + tag;
            H.printString(line);
            input.offset = J.$add$ns(input.offset, diskSize);
            break;
        }
        t1 = J.$sub$n(J.$sub$n(input.offset, t2), p);
        if (typeof t1 !== "number")
          return H.iae(t1);
        remainder = diskSize - t1;
        if (remainder > 0)
          input.offset = J.$add$ns(input.offset, remainder);
      }
      if (!webp.hasAlpha)
        webp.hasAlpha = webp._alphaData != null;
      return webp.format !== 0;
    },
    _getVp8xInfo$2: function(input, webp) {
      var t1, t2, b, w, h;
      t1 = input.buffer;
      t2 = input.offset;
      input.offset = J.$add$ns(t2, 1);
      b = J.$index$asx(t1, t2);
      if (J.getInterceptor$n(b).$and(b, 192) !== 0)
        return false;
      if (typeof b !== "number")
        return b.$shr();
      C.JSNumber_methods._shrOtherPositive$1(b, 5);
      t1 = C.JSNumber_methods._shrOtherPositive$1(b, 4);
      C.JSNumber_methods._shrOtherPositive$1(b, 3);
      C.JSNumber_methods._shrOtherPositive$1(b, 2);
      t2 = C.JSNumber_methods._shrOtherPositive$1(b, 1);
      if ((b & 1) !== 0)
        return false;
      if (input.readUint24$0() !== 0)
        return false;
      w = J.$add$ns(input.readUint24$0(), 1);
      h = J.$add$ns(input.readUint24$0(), 1);
      webp.width = w;
      webp.height = h;
      webp.hasAnimation = (t2 & 1) !== 0;
      webp.hasAlpha = (t1 & 1) !== 0;
      return true;
    },
    _getAnimFrameInfo$3: function(input, webp, size) {
      var frame = new U.WebPFrame(null, null, null, null, null, null, 1, null, null);
      frame.WebPFrame$2(input, size);
      if (frame._reserved !== 0)
        return false;
      webp.frames.push(frame);
      return true;
    }
  },
  HdrImage: {
    "^": "Object;slices,red,green,blue,alpha>,depth",
    get$width: function(_) {
      var t1 = this.slices;
      if (t1.get$isEmpty(t1))
        t1 = 0;
      else {
        t1 = t1.get$values(t1);
        t1 = J.get$width$x(t1._f$1(J.get$first$ax(t1._iterable)));
      }
      return t1;
    },
    get$height: function(_) {
      var t1 = this.slices;
      if (t1.get$isEmpty(t1))
        t1 = 0;
      else {
        t1 = t1.get$values(t1);
        t1 = J.get$height$x(t1._f$1(J.get$first$ax(t1._iterable)));
      }
      return t1;
    },
    $index: function(_, ch) {
      return this.slices.$index(0, ch);
    },
    $indexSet: function(_, ch, sl) {
      this.addSlice$2(ch, sl);
    },
    addSlice$2: function(ch, sl) {
      this.slices.$indexSet(0, ch, sl);
      switch (ch) {
        case "R":
          this.red = sl;
          break;
        case "G":
          this.green = sl;
          break;
        case "B":
          this.blue = sl;
          break;
        case "A":
          this.alpha = sl;
          break;
        case "Z":
          this.depth = sl;
          break;
      }
    },
    static: {"^": "HdrImage_HALF,HdrImage_FLOAT,HdrImage_UINT,HdrImage_R,HdrImage_G,HdrImage_B,HdrImage_A,HdrImage_Z,HdrImage_ID"}
  },
  HdrSlice: {
    "^": "Object;name>,width>,height>,type>,data>",
    getBytes$0: function() {
      return H.NativeUint8List_NativeUint8List$view(this.data, 0, null);
    },
    getFloat$2: function(x, y) {
      var t1, pi, t2, s;
      t1 = this.width;
      if (typeof t1 !== "number")
        return H.iae(t1);
      pi = y * t1 + x;
      t1 = this.data;
      if (J.$eq(this.type, 1)) {
        if (pi >>> 0 !== pi || pi >= t1.length)
          return H.ioore(t1, pi);
        t1 = t1[pi];
        if ($.Half__toFloatFloat32 == null)
          U.Half__initialize();
        t2 = $.Half__toFloatFloat32;
        if (t1 >>> 0 !== t1 || t1 >= t2.length)
          return H.ioore(t2, t1);
        s = t2[t1];
      } else {
        if (pi >>> 0 !== pi || pi >= t1.length)
          return H.ioore(t1, pi);
        s = t1[pi];
      }
      return s;
    }
  },
  hdrToImage__knee: {
    "^": "Closure:118;",
    call$2: function(x, f) {
      return Math.log(x * f + 1) / f;
    }
  },
  hdrToImage__gamma: {
    "^": "Closure:118;_knee_0",
    call$2: function(h, m) {
      var x, t1;
      x = P.max(0, h * m);
      if (x > 1) {
        t1 = this._knee_0.call$2(x - 1, 0.184874);
        if (typeof t1 !== "number")
          return H.iae(t1);
        x = 1 + t1;
      }
      return Math.pow(x, 0.4545) * 84.66;
    }
  },
  Image: {
    "^": "Object;width>,height>,xOffset,yOffset,duration',disposeMethod,blendMethod,data>,_format",
    getBytes$0: function() {
      return H.NativeUint8List_NativeUint8List$view(this.data.buffer, 0, null);
    },
    $add: function(_, other) {
      var t1, t2, h, t3, w, y, x, c1, c2, t4, t5, t6, t7, t8;
      t1 = this.height;
      t2 = J.getInterceptor$x(other);
      h = P.min(t1, t2.get$height(other));
      t3 = this.width;
      w = P.min(t3, t2.get$width(other));
      for (y = 0; y < h; ++y)
        for (x = 0; x < w; ++x) {
          c1 = this.getPixel$2(x, y);
          c2 = other.getPixel$2(x, y);
          if (typeof c2 !== "number")
            return c2.$and();
          t2 = C.JSInt_methods.clamp$2((c1 >>> 24 & 255) + (c2 >>> 24 & 255), 0, 255);
          t4 = C.JSInt_methods.clamp$2((c1 >>> 16 & 255) + (c2 >>> 16 & 255), 0, 255);
          t5 = C.JSInt_methods.clamp$2((c1 >>> 8 & 255) + (c2 >>> 8 & 255), 0, 255);
          t6 = C.JSInt_methods.clamp$2((c1 & 255) + (c2 & 255), 0, 255);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (x < t3) {
            if (typeof t1 !== "number")
              return H.iae(t1);
            t7 = y < t1;
          } else
            t7 = false;
          if (t7) {
            t7 = this.data;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t8 = y * t3 + x;
            if (t8 >>> 0 !== t8 || t8 >= t7.length)
              return H.ioore(t7, t8);
            t7[t8] = (t2 << 24 | t4 << 16 | t5 << 8 | t6) >>> 0;
          }
        }
      return this;
    },
    $sub: function(_, other) {
      var t1, t2, h, t3, w, y, x, c1, c2, t4, t5, t6, t7, t8;
      t1 = this.height;
      t2 = J.getInterceptor$x(other);
      h = P.min(t1, t2.get$height(other));
      t3 = this.width;
      w = P.min(t3, t2.get$width(other));
      for (y = 0; y < h; ++y)
        for (x = 0; x < w; ++x) {
          c1 = this.getPixel$2(x, y);
          c2 = other.getPixel$2(x, y);
          if (typeof c2 !== "number")
            return c2.$and();
          t2 = C.JSInt_methods.clamp$2((c1 >>> 24 & 255) - (c2 >>> 24 & 255), 0, 255);
          t4 = C.JSInt_methods.clamp$2((c1 >>> 16 & 255) - (c2 >>> 16 & 255), 0, 255);
          t5 = C.JSInt_methods.clamp$2((c1 >>> 8 & 255) - (c2 >>> 8 & 255), 0, 255);
          t6 = C.JSInt_methods.clamp$2((c1 & 255) - (c2 & 255), 0, 255);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (x < t3) {
            if (typeof t1 !== "number")
              return H.iae(t1);
            t7 = y < t1;
          } else
            t7 = false;
          if (t7) {
            t7 = this.data;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t8 = y * t3 + x;
            if (t8 >>> 0 !== t8 || t8 >= t7.length)
              return H.ioore(t7, t8);
            t7[t8] = (t2 << 24 | t4 << 16 | t5 << 8 | t6) >>> 0;
          }
        }
      return this;
    },
    $mul: function(_, other) {
      var t1, t2, h, t3, w, y, x, c1, c2, t4, t5, t6, t7, t8;
      t1 = this.height;
      t2 = J.getInterceptor$x(other);
      h = P.min(t1, t2.get$height(other));
      t3 = this.width;
      w = P.min(t3, t2.get$width(other));
      for (y = 0; y < h; ++y)
        for (x = 0; x < w; ++x) {
          c1 = this.getPixel$2(x, y);
          c2 = other.getPixel$2(x, y);
          if (typeof c2 !== "number")
            return c2.$and();
          t2 = C.JSInt_methods.clamp$2((c1 >>> 24 & 255) * (c2 >>> 24 & 255), 0, 255);
          t4 = C.JSInt_methods.clamp$2((c1 >>> 16 & 255) * (c2 >>> 16 & 255), 0, 255);
          t5 = C.JSInt_methods.clamp$2((c1 >>> 8 & 255) * (c2 >>> 8 & 255), 0, 255);
          t6 = C.JSInt_methods.clamp$2((c1 & 255) * (c2 & 255), 0, 255);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (x < t3) {
            if (typeof t1 !== "number")
              return H.iae(t1);
            t7 = y < t1;
          } else
            t7 = false;
          if (t7) {
            t7 = this.data;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t8 = y * t3 + x;
            if (t8 >>> 0 !== t8 || t8 >= t7.length)
              return H.ioore(t7, t8);
            t7[t8] = (t2 << 24 | t4 << 16 | t5 << 8 | t6) >>> 0;
          }
        }
      return this;
    },
    $or: function(_, other) {
      var t1, t2, h, t3, w, y, x, c1, c2, t4, t5, t6, t7, t8;
      t1 = this.height;
      t2 = J.getInterceptor$x(other);
      h = P.min(t1, t2.get$height(other));
      t3 = this.width;
      w = P.min(t3, t2.get$width(other));
      for (y = 0; y < h; ++y)
        for (x = 0; x < w; ++x) {
          c1 = this.getPixel$2(x, y);
          c2 = other.getPixel$2(x, y);
          if (typeof c2 !== "number")
            return c2.$and();
          t2 = C.JSInt_methods.clamp$2(c1 >>> 24 & 255 | c2 >>> 24 & 255, 0, 255);
          t4 = C.JSInt_methods.clamp$2(c1 >>> 16 & 255 | c2 >>> 16 & 255, 0, 255);
          t5 = C.JSInt_methods.clamp$2(c1 >>> 8 & 255 | c2 >>> 8 & 255, 0, 255);
          t6 = C.JSInt_methods.clamp$2((c1 & 255 | c2 & 255) >>> 0, 0, 255);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (x < t3) {
            if (typeof t1 !== "number")
              return H.iae(t1);
            t7 = y < t1;
          } else
            t7 = false;
          if (t7) {
            t7 = this.data;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t8 = y * t3 + x;
            if (t8 >>> 0 !== t8 || t8 >= t7.length)
              return H.ioore(t7, t8);
            t7[t8] = (t2 << 24 | t4 << 16 | t5 << 8 | t6) >>> 0;
          }
        }
      return this;
    },
    $and: function(_, other) {
      var t1, t2, h, t3, w, y, x, c1, c2, t4, t5, t6, t7, t8;
      t1 = this.height;
      t2 = J.getInterceptor$x(other);
      h = P.min(t1, t2.get$height(other));
      t3 = this.width;
      w = P.min(t3, t2.get$width(other));
      for (y = 0; y < h; ++y)
        for (x = 0; x < w; ++x) {
          c1 = this.getPixel$2(x, y);
          c2 = other.getPixel$2(x, y);
          if (typeof c2 !== "number")
            return c2.$and();
          t2 = C.JSInt_methods.clamp$2(c1 >>> 24 & 255 & c2 >>> 24 & 255, 0, 255);
          t4 = C.JSInt_methods.clamp$2(c1 >>> 16 & 255 & c2 >>> 16 & 255, 0, 255);
          t5 = C.JSInt_methods.clamp$2(c1 >>> 8 & 255 & c2 >>> 8 & 255, 0, 255);
          t6 = C.JSInt_methods.clamp$2(c1 & 255 & c2 & 255, 0, 255);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (x < t3) {
            if (typeof t1 !== "number")
              return H.iae(t1);
            t7 = y < t1;
          } else
            t7 = false;
          if (t7) {
            t7 = this.data;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t8 = y * t3 + x;
            if (t8 >>> 0 !== t8 || t8 >= t7.length)
              return H.ioore(t7, t8);
            t7[t8] = (t2 << 24 | t4 << 16 | t5 << 8 | t6) >>> 0;
          }
        }
      return this;
    },
    $mod: function(_, other) {
      var t1, t2, h, t3, w, y, x, c1, c2, t4, t5, t6, t7, t8;
      t1 = this.height;
      t2 = J.getInterceptor$x(other);
      h = P.min(t1, t2.get$height(other));
      t3 = this.width;
      w = P.min(t3, t2.get$width(other));
      for (y = 0; y < h; ++y)
        for (x = 0; x < w; ++x) {
          c1 = this.getPixel$2(x, y);
          c2 = other.getPixel$2(x, y);
          if (typeof c2 !== "number")
            return c2.$and();
          t2 = C.JSInt_methods.$mod(c1 & 255, c2 & 255);
          t4 = C.JSInt_methods.$mod(c1 >>> 8 & 255, c2 >>> 8 & 255);
          t5 = C.JSInt_methods.$mod(c1 >>> 16 & 255, c2 >>> 16 & 255);
          t6 = C.JSInt_methods.clamp$2(C.JSInt_methods.$mod(c1 >>> 24 & 255, c2 >>> 24 & 255), 0, 255);
          t5 = C.JSInt_methods.clamp$2(t5, 0, 255);
          t4 = C.JSInt_methods.clamp$2(t4, 0, 255);
          t2 = C.JSInt_methods.clamp$2(t2, 0, 255);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (x < t3) {
            if (typeof t1 !== "number")
              return H.iae(t1);
            t7 = y < t1;
          } else
            t7 = false;
          if (t7) {
            t7 = this.data;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t8 = y * t3 + x;
            if (t8 >>> 0 !== t8 || t8 >= t7.length)
              return H.ioore(t7, t8);
            t7[t8] = (t6 << 24 | t5 << 16 | t4 << 8 | t2) >>> 0;
          }
        }
      return this;
    },
    get$length: function(_) {
      return this.data.length;
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    $index: function(_, index) {
      var t1 = this.data;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, color) {
      var t1 = this.data;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = color;
    },
    getPixel$2: function(x, y) {
      var t1, t2;
      t1 = this.width;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (x < t1) {
        t1 = this.height;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = y < t1;
      } else
        t1 = false;
      if (t1) {
        t1 = this.data;
        t2 = this.width;
        if (this._format === 4) {
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = y * t2 + x;
          if (t2 >>> 0 !== t2 || t2 >= t1.length)
            return H.ioore(t1, t2);
          t2 = t1[t2];
          t1 = t2;
        } else {
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = y * t2 + x;
          if (t2 >>> 0 !== t2 || t2 >= t1.length)
            return H.ioore(t1, t2);
          t2 = (t1[t2] | 4278190080) >>> 0;
          t1 = t2;
        }
      } else
        t1 = 0;
      return t1;
    },
    static: {"^": "Image_RGB,Image_RGBA,Image_DISPOSE_NONE,Image_DISPOSE_CLEAR,Image_BLEND_SOURCE,Image_BLEND_OVER", Image$: function(width, height, _format) {
        var t1 = J.$mul$ns(width, height);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        return new U.Image(width, height, 0, 0, 0, 1, 1, new Uint32Array(t1), _format);
      }}
  },
  ImageException: {
    "^": "Object;message",
    toString$0: function(_) {
      return "ImageException: " + this.message;
    },
    static: {ImageException$: function(message) {
        return new U.ImageException(message);
      }}
  },
  InputBuffer: {
    "^": "Object;buffer>,start>,end<,offset*,bigEndian<",
    get$length: function(_) {
      return J.$sub$n(this.end, this.offset);
    },
    length$0: function($receiver) {
      return this.get$length(this).call$0();
    },
    $index: function(_, index) {
      return J.$index$asx(this.buffer, J.$add$ns(this.offset, index));
    },
    $indexSet: function(_, index, value) {
      J.$indexSet$ax(this.buffer, J.$add$ns(this.offset, index), value);
      return value;
    },
    memcpy$4: function(start, $length, other, offset) {
      var t1, t2;
      t1 = this.buffer;
      t2 = this.offset;
      if (!!J.getInterceptor(other).$isInputBuffer)
        J.setRange$4$ax(t1, J.$add$ns(t2, start), J.$add$ns(J.$add$ns(this.offset, start), $length), other.buffer, J.$add$ns(other.offset, offset));
      else
        J.setRange$4$ax(t1, J.$add$ns(t2, start), J.$add$ns(J.$add$ns(this.offset, start), $length), other, offset);
    },
    memcpy$3: function(start, length, other) {
      return this.memcpy$4(start, length, other, 0);
    },
    memset$3: function(start, $length, value) {
      J.fillRange$3$ax(this.buffer, J.$add$ns(this.offset, start), J.$add$ns(J.$add$ns(this.offset, start), $length), value);
    },
    subset$3$offset$position: function(count, offset, position) {
      var pos = J.$add$ns(position != null ? J.$add$ns(this.start, position) : this.offset, offset);
      return U.InputBuffer$(this.buffer, this.bigEndian, count, pos);
    },
    subset$1: function(count) {
      return this.subset$3$offset$position(count, 0, null);
    },
    subset$2$position: function(count, position) {
      return this.subset$3$offset$position(count, 0, position);
    },
    skip$1: function(_, count) {
      this.offset = J.$add$ns(this.offset, count);
    },
    readBytes$1: function(count) {
      var bytes = this.subset$1(count);
      this.offset = J.$add$ns(this.offset, J.$sub$n(bytes.end, bytes.offset));
      return bytes;
    },
    readString$1: function(len) {
      var codes, t1, t2, t3, c;
      if (len == null) {
        codes = [];
        for (t1 = this.end; !J.$ge$n(this.offset, t1);) {
          t2 = this.buffer;
          t3 = this.offset;
          this.offset = J.$add$ns(t3, 1);
          c = J.$index$asx(t2, t3);
          if (J.$eq(c, 0))
            return H.Primitives_stringFromCharCodes(codes);
          codes.push(c);
        }
        throw H.wrapException(U.ImageException$("EOF reached without finding string terminator"));
      }
      return P.String_String$fromCharCodes(this.readBytes$1(len).toUint8List$0());
    },
    readString$0: function() {
      return this.readString$1(null);
    },
    readUint16$0: function() {
      var t1, t2, b1, b2;
      t1 = this.buffer;
      t2 = this.offset;
      this.offset = J.$add$ns(t2, 1);
      b1 = J.$and$n(J.$index$asx(t1, t2), 255);
      t2 = this.buffer;
      t1 = this.offset;
      this.offset = J.$add$ns(t1, 1);
      b2 = J.$and$n(J.$index$asx(t2, t1), 255);
      if (this.bigEndian)
        return (b1 << 8 | b2) >>> 0;
      return (b2 << 8 | b1) >>> 0;
    },
    readUint24$0: function() {
      var t1, t2, b1, b2, b3;
      t1 = this.buffer;
      t2 = this.offset;
      this.offset = J.$add$ns(t2, 1);
      b1 = J.$and$n(J.$index$asx(t1, t2), 255);
      t2 = this.buffer;
      t1 = this.offset;
      this.offset = J.$add$ns(t1, 1);
      b2 = J.$and$n(J.$index$asx(t2, t1), 255);
      t1 = this.buffer;
      t2 = this.offset;
      this.offset = J.$add$ns(t2, 1);
      b3 = J.$and$n(J.$index$asx(t1, t2), 255);
      if (this.bigEndian)
        return (b3 | b2 << 8 | b1 << 16) >>> 0;
      return (b1 | b2 << 8 | b3 << 16) >>> 0;
    },
    readUint32$0: function() {
      var t1, t2, b1, b2, b3, b4;
      t1 = this.buffer;
      t2 = this.offset;
      this.offset = J.$add$ns(t2, 1);
      b1 = J.$and$n(J.$index$asx(t1, t2), 255);
      t2 = this.buffer;
      t1 = this.offset;
      this.offset = J.$add$ns(t1, 1);
      b2 = J.$and$n(J.$index$asx(t2, t1), 255);
      t1 = this.buffer;
      t2 = this.offset;
      this.offset = J.$add$ns(t2, 1);
      b3 = J.$and$n(J.$index$asx(t1, t2), 255);
      t2 = this.buffer;
      t1 = this.offset;
      this.offset = J.$add$ns(t1, 1);
      b4 = J.$and$n(J.$index$asx(t2, t1), 255);
      if (this.bigEndian)
        return (b1 << 24 | b2 << 16 | b3 << 8 | b4) >>> 0;
      return (b4 << 24 | b3 << 16 | b2 << 8 | b1) >>> 0;
    },
    readUint64$0: function() {
      var t1, t2, b1, b2, b3, b4, b5, b6, b7, b8;
      t1 = this.buffer;
      t2 = this.offset;
      this.offset = J.$add$ns(t2, 1);
      b1 = J.$and$n(J.$index$asx(t1, t2), 255);
      t2 = this.buffer;
      t1 = this.offset;
      this.offset = J.$add$ns(t1, 1);
      b2 = J.$and$n(J.$index$asx(t2, t1), 255);
      t1 = this.buffer;
      t2 = this.offset;
      this.offset = J.$add$ns(t2, 1);
      b3 = J.$and$n(J.$index$asx(t1, t2), 255);
      t2 = this.buffer;
      t1 = this.offset;
      this.offset = J.$add$ns(t1, 1);
      b4 = J.$and$n(J.$index$asx(t2, t1), 255);
      t1 = this.buffer;
      t2 = this.offset;
      this.offset = J.$add$ns(t2, 1);
      b5 = J.$and$n(J.$index$asx(t1, t2), 255);
      t2 = this.buffer;
      t1 = this.offset;
      this.offset = J.$add$ns(t1, 1);
      b6 = J.$and$n(J.$index$asx(t2, t1), 255);
      t1 = this.buffer;
      t2 = this.offset;
      this.offset = J.$add$ns(t2, 1);
      b7 = J.$and$n(J.$index$asx(t1, t2), 255);
      t2 = this.buffer;
      t1 = this.offset;
      this.offset = J.$add$ns(t1, 1);
      b8 = J.$and$n(J.$index$asx(t2, t1), 255);
      if (this.bigEndian)
        return (C.JSInt_methods._shlPositive$1(b1, 56) | C.JSInt_methods._shlPositive$1(b2, 48) | C.JSInt_methods._shlPositive$1(b3, 40) | C.JSInt_methods._shlPositive$1(b4, 32) | b5 << 24 | b6 << 16 | b7 << 8 | b8) >>> 0;
      return (C.JSInt_methods._shlPositive$1(b8, 56) | C.JSInt_methods._shlPositive$1(b7, 48) | C.JSInt_methods._shlPositive$1(b6, 40) | C.JSInt_methods._shlPositive$1(b5, 32) | b4 << 24 | b3 << 16 | b2 << 8 | b1) >>> 0;
    },
    toList$2: function(_, offset, $length) {
      var s, e;
      if (!!J.getInterceptor(this.buffer).$isUint8List)
        return this.toUint8List$2(offset, $length);
      s = J.$add$ns(J.$add$ns(this.start, this.offset), offset);
      e = J.$le$n($length, 0) ? this.end : J.$add$ns(s, $length);
      return J.sublist$2$ax(this.buffer, s, e);
    },
    toUint8List$2: function(offset, $length) {
      var len, t1, t2, t3;
      len = $length != null ? $length : J.$sub$n(J.$sub$n(this.end, this.offset), offset);
      t1 = this.buffer;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isUint8List) {
        t3 = t2.get$buffer(t1);
        t1 = t2.get$offsetInBytes(t1);
        t2 = this.offset;
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return H.NativeUint8List_NativeUint8List$view(t3, t1 + t2 + offset, len);
      }
      return new Uint8Array(H._ensureNativeList(t2.sublist$2(t1, J.$add$ns(this.offset, offset), J.$add$ns(J.$add$ns(this.offset, offset), len))));
    },
    toUint8List$0: function() {
      return this.toUint8List$2(0, null);
    },
    toUint32List$1: function(offset) {
      var t1, t2, t3;
      t1 = this.buffer;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isUint8List) {
        t3 = t2.get$buffer(t1);
        t1 = t2.get$offsetInBytes(t1);
        t2 = this.offset;
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return H.NativeUint32List_NativeUint32List$view(t3, t1 + t2 + offset, null);
      }
      return H.NativeUint32List_NativeUint32List$view(this.toUint8List$0().buffer, 0, null);
    },
    toUint32List$0: function() {
      return this.toUint32List$1(0);
    },
    $isInputBuffer: true,
    static: {InputBuffer$: function(buffer, bigEndian, $length, offset) {
        var t1 = $length == null ? J.get$length$asx(buffer) : J.$add$ns(offset, $length);
        return new U.InputBuffer(buffer, offset, t1, offset, bigEndian);
      }, InputBuffer$from: function(other, $length, offset) {
        var t1, t2, t3, t4;
        t1 = J.getInterceptor$x(other);
        t2 = t1.get$buffer(other);
        t3 = J.$add$ns(t1.get$offset(other), offset);
        t4 = t1.get$start(other);
        t1 = $length == null ? other.get$end() : J.$add$ns(J.$add$ns(t1.get$offset(other), offset), $length);
        return new U.InputBuffer(t2, t4, t1, t3, other.get$bigEndian());
      }}
  },
  OutputBuffer: {
    "^": "Object;length*,bigEndian,_buffer",
    length$0: function($receiver) {
      return this.length.call$0();
    },
    getBytes$0: function() {
      return H.NativeUint8List_NativeUint8List$view(this._buffer.buffer, 0, this.length);
    },
    writeByte$1: function(value) {
      var t1, t2, t3;
      if (J.$eq(this.length, this._buffer.length))
        this._expandBuffer$0();
      t1 = this._buffer;
      t2 = this.length;
      this.length = J.$add$ns(t2, 1);
      t3 = J.$and$n(value, 255);
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = t3;
    },
    writeUint16$1: function(value) {
      if (this.bigEndian) {
        this.writeByte$1(value >>> 8 & 255);
        this.writeByte$1(value & 255);
        return;
      }
      this.writeByte$1(value & 255);
      this.writeByte$1(value >>> 8 & 255);
    },
    _expandBuffer$1: function(required) {
      var blockSize, t1, newBuffer;
      blockSize = required != null ? J.$gt$n(required, 32768) ? required : 32768 : 32768;
      t1 = this._buffer;
      if (typeof blockSize !== "number")
        return H.iae(blockSize);
      t1 = t1.length + blockSize;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      newBuffer = new Uint8Array(t1);
      t1 = this._buffer;
      C.NativeUint8List_methods.setRange$3(newBuffer, 0, t1.length, t1);
      this._buffer = newBuffer;
    },
    _expandBuffer$0: function() {
      return this._expandBuffer$1(null);
    },
    static: {"^": "OutputBuffer__BLOCK_SIZE", OutputBuffer$: function(bigEndian, size) {
        var t1 = size == null ? 32768 : size;
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        return new U.OutputBuffer(0, bigEndian, new Uint8Array(t1));
      }}
  }
}],
["image_samplers", "package:dartray/image_samplers/image_samplers.dart", , Y, {
  "^": "",
  RandomImageSampler: {
    "^": "ImageSampler;_numSamples,_samples,xPixelStart,xPixelEnd,yPixelStart,yPixelEnd",
    getPixel$2: function(index, pixel) {
      var t1;
      index *= 2;
      t1 = this._samples;
      if (index >= t1.length - 1)
        return;
      J.$indexSet$ax(pixel, 0, t1[index]);
      t1 = t1[index + 1];
      if (1 >= pixel.length)
        return H.ioore(pixel, 1);
      pixel[1] = t1;
    },
    RandomImageSampler$4: function(xPixelStart, xPixelEnd, yPixelStart, yPixelEnd) {
      var t1, t2, y, si, t3, x, t4, si0, rng, i, r, l, t, t5;
      for (t1 = this._samples, t2 = t1.length, y = yPixelStart, si = 0; t3 = J.getInterceptor$n(y), t3.$lt(y, yPixelEnd); y = t3.$add(y, 1))
        for (x = xPixelStart; t4 = J.getInterceptor$n(x), t4.$lt(x, xPixelEnd); x = t4.$add(x, 1)) {
          si0 = si + 1;
          if (si < 0 || si >= t2)
            return H.ioore(t1, si);
          t1[si] = x;
          si = si0 + 1;
          if (si0 < 0 || si0 >= t2)
            return H.ioore(t1, si0);
          t1[si0] = y;
        }
      rng = new G.RNG(null, new Uint32Array(624), null);
      rng.mti = 625;
      rng.seed$1(0, 5489);
      t3 = C.JSInt_methods._tdivFast$1(t2, 2);
      this._numSamples = t3;
      i = 0;
      r = 0;
      while (true) {
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        t3 = rng.randomUInt$0();
        t4 = this._numSamples;
        if (typeof t4 !== "number")
          return H.iae(t4);
        l = C.JSInt_methods.$mod(t3, t4) * 2;
        if (r >= t2)
          return H.ioore(t1, r);
        t = t1[r];
        if (l >= t2)
          return H.ioore(t1, l);
        t1[r] = t1[l];
        t1[l] = t;
        t3 = r + 1;
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t = t1[t3];
        t5 = l + 1;
        if (t5 >= t2)
          return H.ioore(t1, t5);
        t1[t3] = t1[t5];
        t1[t5] = t;
        ++i;
        r += 2;
        t3 = t4;
      }
    },
    static: {RandomImageSampler$: function(xPixelStart, xPixelEnd, yPixelStart, yPixelEnd) {
        var t1 = J.$mul$ns(J.$mul$ns(J.$sub$n(xPixelEnd, xPixelStart), J.$sub$n(yPixelEnd, yPixelStart)), 2);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        t1 = new Y.RandomImageSampler(null, new Int32Array(t1), xPixelStart, xPixelEnd, yPixelStart, yPixelEnd);
        t1.RandomImageSampler$4(xPixelStart, xPixelEnd, yPixelStart, yPixelEnd);
        return t1;
      }}
  },
  TileImageSampler: {
    "^": "ImageSampler;tileSize,_numSamples,_samples,xPixelStart,xPixelEnd,yPixelStart,yPixelEnd",
    getPixel$2: function(index, pixel) {
      var t1;
      index *= 2;
      t1 = this._samples;
      if (index >= t1.length - 1)
        return;
      J.$indexSet$ax(pixel, 0, t1[index]);
      t1 = t1[index + 1];
      if (1 >= pixel.length)
        return H.ioore(pixel, 1);
      pixel[1] = t1;
    },
    TileImageSampler$6$randomize$tileSize: function(xPixelStart, xPixelEnd, yPixelStart, yPixelEnd, randomize, tileSize) {
      var width, height, t1, t2, numXTiles, numYTiles, tiles, yi, ti, xi, ti0, numTiles, rng, lx, ly, rx, ry, t, t3, t4, t5, t6, si, i, tx, ty, sx, sy, t7, t8, y, x, si0;
      width = J.$sub$n(xPixelEnd, xPixelStart);
      height = J.$sub$n(yPixelEnd, yPixelStart);
      t1 = this.tileSize;
      t2 = J.getInterceptor$n(width).$tdiv(width, t1);
      if (typeof width !== "number")
        return width.$mod();
      numXTiles = J.$add$ns(t2, C.JSNumber_methods.$mod(width, t1) === 0 ? 0 : 1);
      t2 = J.getInterceptor$n(height).$tdiv(height, t1);
      if (typeof height !== "number")
        return height.$mod();
      numYTiles = J.$add$ns(t2, C.JSNumber_methods.$mod(height, t1) === 0 ? 0 : 1);
      t2 = J.$mul$ns(J.$mul$ns(numXTiles, numYTiles), 2);
      if (typeof t2 !== "number" || Math.floor(t2) !== t2)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
      tiles = new Int32Array(t2);
      if (typeof numYTiles !== "number")
        return H.iae(numYTiles);
      t2 = tiles.length;
      yi = 0;
      ti = 0;
      for (; yi < numYTiles; ++yi) {
        if (typeof numXTiles !== "number")
          return H.iae(numXTiles);
        xi = 0;
        for (; xi < numXTiles; ++xi) {
          ti0 = ti + 1;
          if (ti < 0 || ti >= t2)
            return H.ioore(tiles, ti);
          tiles[ti] = xi;
          ti = ti0 + 1;
          if (ti0 < 0 || ti0 >= t2)
            return H.ioore(tiles, ti0);
          tiles[ti0] = yi;
        }
      }
      numTiles = C.JSInt_methods._tdivFast$1(t2, 2);
      if (randomize) {
        rng = new G.RNG(null, new Uint32Array(624), null);
        rng.mti = 625;
        rng.seed$1(0, 5489);
        for (ti = 1; ti < numTiles; ++ti) {
          lx = ti * 2;
          ly = lx + 1;
          rx = C.JSInt_methods.$mod(rng.randomUInt$0(), numTiles) * 2;
          ry = rx + 1;
          if (lx >= t2)
            return H.ioore(tiles, lx);
          t = tiles[lx];
          if (rx >= t2)
            return H.ioore(tiles, rx);
          tiles[lx] = tiles[rx];
          tiles[rx] = t;
          if (ly >= t2)
            return H.ioore(tiles, ly);
          t = tiles[ly];
          if (ry >= t2)
            return H.ioore(tiles, ry);
          tiles[ly] = tiles[ry];
          tiles[ry] = t;
        }
      }
      for (t3 = this._samples, t4 = t3.length, t5 = J.getInterceptor$ns(xPixelStart), t6 = J.getInterceptor$ns(yPixelStart), si = 0, i = 0, ti = 0; i < numTiles; ++i) {
        ti0 = ti + 1;
        if (ti >= t2)
          return H.ioore(tiles, ti);
        tx = tiles[ti];
        ti = ti0 + 1;
        if (ti0 >= t2)
          return H.ioore(tiles, ti0);
        ty = tiles[ti0];
        sx = t5.$add(xPixelStart, tx * t1);
        sy = t6.$add(yPixelStart, ty * t1);
        for (t7 = J.getInterceptor$ns(sx), t8 = J.getInterceptor$ns(sy), yi = 0; yi < t1; ++yi) {
          y = t8.$add(sy, yi);
          if (J.$ge$n(y, yPixelEnd))
            break;
          for (xi = 0; xi < t1; ++xi) {
            x = t7.$add(sx, xi);
            if (J.$ge$n(x, xPixelEnd))
              break;
            si0 = si + 1;
            if (si < 0 || si >= t4)
              return H.ioore(t3, si);
            t3[si] = x;
            si = si0 + 1;
            if (si0 < 0 || si0 >= t4)
              return H.ioore(t3, si0);
            t3[si0] = y;
          }
        }
      }
    },
    static: {TileImageSampler$: function(xPixelStart, xPixelEnd, yPixelStart, yPixelEnd, randomize, tileSize) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(xPixelEnd);
        t2 = J.getInterceptor$n(yPixelEnd);
        t3 = J.$mul$ns(t1.$sub(xPixelEnd, xPixelStart), t2.$sub(yPixelEnd, yPixelStart));
        t2 = J.$mul$ns(J.$mul$ns(t1.$sub(xPixelEnd, xPixelStart), t2.$sub(yPixelEnd, yPixelStart)), 2);
        if (typeof t2 !== "number" || Math.floor(t2) !== t2)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
        t1 = new Y.TileImageSampler(tileSize, t3, new Int32Array(t2), xPixelStart, xPixelEnd, yPixelStart, yPixelEnd);
        t1.TileImageSampler$6$randomize$tileSize(xPixelStart, xPixelEnd, yPixelStart, yPixelEnd, randomize, tileSize);
        return t1;
      }}
  }
}],
["lights", "package:dartray/lights/lights.dart", , O, {
  "^": "",
  DiffuseAreaLight: {
    "^": "AreaLight;Lemit,shapeSet,area,nSamples,lightToWorld,worldToLight",
    L$3: function(p, n, w) {
      return J.$gt$n(G.Vector_Dot(n, w), 0) ? this.Lemit : G.Spectrum_Spectrum(0);
    },
    power$1: function(scene) {
      return this.Lemit.$mul(0, this.area).$mul(0, 3.141592653589793);
    },
    isDeltaLight$0: function() {
      return false;
    },
    pdf$2: function(p, w) {
      return this.shapeSet.pdf$2(p, w);
    },
    sampleLAtPoint$7: function(p, pEpsilon, ls, time, wo, pdf, visibility) {
      var ns, t1, ps, t2, t3, t4, dist;
      ns = new G.Normal(0, 0, 0);
      t1 = this.shapeSet;
      ps = t1.sample$3(ls, ns, p);
      t2 = J.getInterceptor$n(ps);
      t3 = t2.$sub(ps, p);
      t4 = J.getInterceptor$asx(t3);
      t3 = t4.$div(t3, t4.length$0(t3));
      t4 = J.getInterceptor$x(t3);
      wo.x = t4.get$x(t3);
      wo.y = t4.get$y(t3);
      wo.z = t4.get$z(t3);
      pdf[0] = t1.pdf$2(p, wo);
      dist = J.length$0$asx(t2.$sub(ps, p));
      t2 = J.$div$n(t2.$sub(ps, p), dist);
      t1 = J.$mul$ns(dist, 0.999);
      t3 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
      if (t2 == null)
        t2 = new G.Vector(0, 0, 0);
      else {
        t4 = J.getInterceptor$x(t2);
        t2 = new G.Vector(t4.get$x(t2), t4.get$y(t2), t4.get$z(t2));
      }
      visibility.r = new G.Ray(t3, t2, pEpsilon, t1, time, 0);
      t1 = J.$negate$n(wo.x);
      t2 = J.$negate$n(wo.y);
      t3 = J.$negate$n(wo.z);
      return J.$gt$n(J.$add$ns(J.$add$ns(J.$mul$ns(ns.x, t1), J.$mul$ns(ns.y, t2)), J.$mul$ns(ns.z, t3)), 0) ? this.Lemit : G.Spectrum_Spectrum(0);
    },
    sampleL$8: function(scene, ls, u1, u2, time, ray, Ns, pdf) {
      var t1, org, dir;
      t1 = this.shapeSet;
      org = t1.sample$2(ls, Ns);
      dir = G.UniformSampleSphere(u1, u2);
      if (J.$lt$n(G.Vector_Dot(dir, Ns), 0))
        dir = dir.$mul(0, -1);
      ray.origin = org;
      ray.direction = dir;
      ray.minDistance = 0.001;
      ray.maxDistance = 1 / 0;
      ray.time = time;
      t1 = t1.pdf$1(org);
      if (0 >= pdf.length)
        return H.ioore(pdf, 0);
      pdf[0] = t1 * 0.15915494309189535;
      return J.$gt$n(G.Vector_Dot(Ns, dir), 0) ? this.Lemit : G.Spectrum_Spectrum(0);
    },
    area$0: function() {
      return this.area.call$0();
    },
    DiffuseAreaLight$4: function(light2world, Le, ns, shape) {
      this.area = this.shapeSet.area;
    },
    static: {DiffuseAreaLight_Create: [function(light2world, paramSet, shape) {
        var $L, sc, nSamples, t1, t2, t3, t4;
        $L = paramSet.findOneSpectrum$2("L", G.Spectrum_Spectrum(1));
        sc = paramSet.findOneSpectrum$2("scale", G.Spectrum_Spectrum(1));
        nSamples = paramSet.findOneInt$2("nsamples", 1);
        t1 = J.$mul$ns($L, sc);
        t2 = P.max(1, nSamples);
        t3 = G.Transform$from(light2world);
        t4 = G.Transform$from(G.Transform$(light2world.get$mInv(), light2world.m));
        t4 = new O.DiffuseAreaLight(G.Spectrum_Spectrum$from(t1, 0), G.ShapeSet$(shape), null, t2, t3, t4);
        t4.Light$2(light2world, nSamples);
        t4.DiffuseAreaLight$4(light2world, t1, nSamples, shape);
        return t4;
      }, "call$3", "DiffuseAreaLight_Create$closure", 6, 0, 27]}
  },
  DistantLight: {
    "^": "Light;lightDir,L,nSamples,lightToWorld,worldToLight",
    isDeltaLight$0: function() {
      return true;
    },
    power$1: function(scene) {
      var worldRadius = scene.worldBound.boundingSphere$1(new G.Point(0, 0, 0));
      return J.$mul$ns(J.$mul$ns(J.$mul$ns(this.L, 3.141592653589793), worldRadius), worldRadius);
    },
    sampleLAtPoint$7: function(p, pEpsilon, ls, time, wi, pdf, vis) {
      var t1, t2;
      t1 = this.lightDir;
      t2 = J.getInterceptor$x(t1);
      wi.x = t2.get$x(t1);
      wi.y = t2.get$y(t1);
      wi.z = t2.get$z(t1);
      pdf[0] = 1;
      t1 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
      t2 = new G.Vector(wi.x, wi.y, wi.z);
      vis.r = new G.Ray(t1, t2, pEpsilon, 1 / 0, time, 0);
      return this.L;
    },
    sampleL$8: function(scene, ls, u1, u2, time, ray, Ns, pdf) {
      var worldCenter, worldRadius, v1, v2, d1, d2, t1;
      worldCenter = new G.Point(0, 0, 0);
      worldRadius = scene.worldBound.boundingSphere$1(worldCenter);
      v1 = new G.Vector(0, 0, 0);
      v2 = new G.Vector(0, 0, 0);
      G.Vector_CoordinateSystem(this.lightDir, v1, v2);
      d1 = [0];
      d2 = [0];
      t1 = ls.uPos;
      G.ConcentricSampleDisk(t1[0], t1[1], d1, d2);
      ray.set$5(worldCenter.$add(0, v1.$mul(0, d1[0]).$add(0, v2.$mul(0, d2[0])).$mul(0, worldRadius)).$add(0, J.$mul$ns(this.lightDir, worldRadius)), J.$negate$n(this.lightDir), 0, 1 / 0, time);
      Ns.copy$1(ray.direction);
      if (typeof worldRadius !== "number")
        return H.iae(worldRadius);
      if (0 >= pdf.length)
        return H.ioore(pdf, 0);
      pdf[0] = 1 / (3.141592653589793 * worldRadius * worldRadius);
      return this.L;
    },
    pdf$2: function(p, w) {
      return 0;
    },
    L$3: function(arg0, arg1, arg2) {
      return this.L.call$3(arg0, arg1, arg2);
    },
    DistantLight$3: function(light2world, radiance, dir) {
      var t1 = this.lightToWorld.transformVector$1(dir);
      this.lightDir = t1.$div(t1, t1.length$0(0));
      this.L = radiance;
    },
    static: {DistantLight_Create: [function(light2world, paramSet) {
        var $L, sc, dir, t1, t2;
        $L = paramSet.findOneSpectrum$2("L", G.Spectrum_Spectrum(1));
        sc = paramSet.findOneSpectrum$2("scale", G.Spectrum_Spectrum(1));
        dir = J.$sub$n(paramSet.findOnePoint$2("from", new G.Point(0, 0, 0)), paramSet.findOnePoint$2("to", new G.Point(0, 0, 1)));
        t1 = J.$mul$ns($L, sc);
        t2 = new O.DistantLight(null, null, P.max(1, 1), G.Transform$from(light2world), G.Transform$from(G.Transform$(light2world.get$mInv(), light2world.m)));
        t2.Light$2(light2world, 1);
        t2.DistantLight$3(light2world, t1, dir);
        return t2;
      }, "call$2", "DistantLight_Create$closure", 4, 0, 28]}
  },
  GoniometricLight: {
    "^": "Light;lightPos,intensity,mipmap,nSamples,lightToWorld,worldToLight",
    sampleLAtPoint$7: function(p, pEpsilon, ls, time, wi, pdf, visibility) {
      var t1, dist, t2;
      t1 = this.lightPos.$sub(0, p);
      t1 = t1.$div(t1, t1.length$0(0));
      wi.x = t1.x;
      wi.y = t1.y;
      wi.z = t1.z;
      pdf[0] = 1;
      t1 = this.lightPos;
      dist = t1.$sub(0, p).length$0(0);
      t1 = t1.$sub(0, p).$div(0, dist);
      t2 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
      t1 = new G.Vector(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1));
      visibility.r = new G.Ray(t2, t1, pEpsilon, dist, time, 0);
      return J.$div$n(J.$mul$ns(this.intensity, this.scale$1(0, new G.Vector(J.$negate$n(wi.x), J.$negate$n(wi.y), J.$negate$n(wi.z)))), p.$sub(0, this.lightPos).lengthSquared$0());
    },
    isDeltaLight$0: function() {
      return true;
    },
    scale$1: function(_, w) {
      var t1, wp, tmp, theta, phi;
      t1 = this.worldToLight.transformVector$1(w);
      wp = t1.$div(t1, t1.length$0(0));
      tmp = wp.y;
      wp.y = wp.z;
      wp.z = tmp;
      t1 = J.clamp$2$n(tmp, -1, 1);
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      theta = Math.acos(t1);
      phi = G.Vector_SphericalPhi(wp);
      t1 = this.mipmap;
      return t1 == null ? 1 : G.Spectrum_Spectrum$from(t1.lookup$2(phi * 0.15915494309189535, theta * 0.3183098861837907), 1);
    },
    power$1: function(scene) {
      var t1, t2;
      t1 = J.$mul$ns(this.intensity, 12.566370614359172);
      t2 = this.mipmap;
      return J.$mul$ns(t1, G.Spectrum_Spectrum$from(t2 != null ? t2.lookup$3(0.5, 0.5, 0.5) : G.Spectrum_Spectrum(1), 1));
    },
    sampleL$8: function(scene, ls, u1, u2, time, ray, Ns, pdf) {
      var t1 = ls.uPos;
      ray.set$5(this.lightPos, G.UniformSampleSphere(t1[0], t1[1]), 0, 1 / 0, time);
      Ns.copy$1(ray.direction);
      if (0 >= pdf.length)
        return H.ioore(pdf, 0);
      pdf[0] = 0.07957747154594767;
      return J.$mul$ns(this.intensity, this.scale$1(0, ray.direction));
    },
    pdf$2: function(p, w) {
      return 0;
    },
    GoniometricLight$3: function(light2world, intensity, texname) {
      var completer;
      this.lightPos = this.lightToWorld.transformPoint$1(new G.Point(0, 0, 0));
      if (J.get$isNotEmpty$asx(texname)) {
        completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        $.ResourceManager_global.requestImage$2(texname, completer.future).then$1(new O.GoniometricLight_closure(this, completer));
      }
    },
    static: {GoniometricLight_Create: [function(light2world, paramSet) {
        var I, sc, texname;
        I = paramSet.findOneSpectrum$2("I", G.Spectrum_Spectrum(1));
        sc = paramSet.findOneSpectrum$2("scale", G.Spectrum_Spectrum(1));
        texname = paramSet.findOneFilename$2("mapname", "");
        return O.GoniometricLight$(light2world, J.$mul$ns(I, sc), texname);
      }, "call$2", "GoniometricLight_Create$closure", 4, 0, 29], GoniometricLight$: function(light2world, intensity, texname) {
        var t1 = new O.GoniometricLight(null, intensity, null, P.max(1, 1), G.Transform$from(light2world), G.Transform$from(G.Transform$(light2world.get$mInv(), light2world.m)));
        t1.Light$2(light2world, 1);
        t1.GoniometricLight$3(light2world, intensity, texname);
        return t1;
      }}
  },
  GoniometricLight_closure: {
    "^": "Closure:119;this_0,completer_1",
    call$1: function(img) {
      var t1;
      this.this_0.mipmap = G.MIPMap$texture(img, false, 8, 0);
      t1 = this.completer_1.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  InfiniteAreaLight: {
    "^": "Light;radianceMap,distribution,nSamples,lightToWorld,worldToLight",
    power$1: function(scene) {
      var worldRadius, t1;
      worldRadius = scene.worldBound.boundingSphere$1(new G.Point(0, 0, 0));
      t1 = G.Spectrum_Spectrum$from(this.radianceMap.lookup$3(0.5, 0.5, 0.5), 1);
      if (typeof worldRadius !== "number")
        return H.iae(worldRadius);
      return t1.$mul(0, 3.141592653589793 * worldRadius * worldRadius);
    },
    isDeltaLight$0: function() {
      return false;
    },
    Le$1: function(r) {
      var t1, wh, t2;
      t1 = this.worldToLight.transformVector$1(r.get$direction());
      wh = t1.$div(t1, t1.length$0(0));
      t1 = G.Vector_SphericalPhi(wh);
      t2 = J.clamp$2$n(wh.z, -1, 1);
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      t2 = Math.acos(t2);
      return G.Spectrum_Spectrum$from(this.radianceMap.lookup$2(t1 * 0.15915494309189535, t2 * 0.3183098861837907), 1);
    },
    sampleLAtPoint$7: function(p, pEpsilon, ls, time, wi, pdf, visibility) {
      var uv, mapPdf, t1, theta, phi, costheta, sintheta, sinphi, t2;
      uv = [0, 0];
      mapPdf = [0];
      t1 = ls.uPos;
      this.distribution.sampleContinuous$4(t1[0], t1[1], uv, mapPdf);
      if (J.$eq(mapPdf[0], 0))
        return G.Spectrum_Spectrum(0);
      theta = J.$mul$ns(uv[1], 3.141592653589793);
      phi = J.$mul$ns(J.$mul$ns(uv[0], 2), 3.141592653589793);
      t1 = typeof theta !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(theta));
      costheta = Math.cos(theta);
      if (t1)
        H.throwExpression(P.ArgumentError$(theta));
      sintheta = Math.sin(theta);
      t1 = typeof phi !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(phi));
      sinphi = Math.sin(phi);
      if (t1)
        H.throwExpression(P.ArgumentError$(phi));
      t1 = this.lightToWorld.transformVector$1(new G.Vector(sintheta * Math.cos(phi), sintheta * sinphi, costheta));
      wi.x = t1.get$x(t1);
      wi.y = t1.get$y(t1);
      wi.z = t1.get$z(t1);
      if (sintheta === 0)
        pdf[0] = 0;
      else
        pdf[0] = J.$div$n(mapPdf[0], 19.739208802178716 * sintheta);
      t1 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
      t2 = new G.Vector(wi.x, wi.y, wi.z);
      visibility.r = new G.Ray(t1, t2, pEpsilon, 1 / 0, time, 0);
      return G.Spectrum_Spectrum$from(this.radianceMap.lookup$2(uv[0], uv[1]), 1);
    },
    sampleL$8: function(scene, ls, u1, u2, time, ray, Ns, pdf) {
      var uv, mapPdf, t1, theta, phi, costheta, sintheta, sinphi, d, worldCenter, worldRadius, v1, v2, d1, d2, directionPdf;
      uv = [0, 0];
      mapPdf = [0];
      t1 = ls.uPos;
      this.distribution.sampleContinuous$4(t1[0], t1[1], uv, mapPdf);
      if (J.$eq(mapPdf[0], 0))
        return G.Spectrum_Spectrum(0);
      theta = J.$mul$ns(uv[1], 3.141592653589793);
      phi = J.$mul$ns(J.$mul$ns(uv[0], 2), 3.141592653589793);
      t1 = typeof theta !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(theta));
      costheta = Math.cos(theta);
      if (t1)
        H.throwExpression(P.ArgumentError$(theta));
      sintheta = Math.sin(theta);
      t1 = typeof phi !== "number";
      if (t1)
        H.throwExpression(P.ArgumentError$(phi));
      sinphi = Math.sin(phi);
      if (t1)
        H.throwExpression(P.ArgumentError$(phi));
      d = this.lightToWorld.transformVector$1(new G.Vector(sintheta * Math.cos(phi), sintheta * sinphi, costheta)).$negate(0);
      Ns.copy$1(d);
      worldCenter = new G.Point(0, 0, 0);
      worldRadius = scene.worldBound.boundingSphere$1(worldCenter);
      v1 = new G.Vector(0, 0, 0);
      v2 = new G.Vector(0, 0, 0);
      G.Vector_CoordinateSystem(d.$negate(0), v1, v2);
      d1 = [0];
      d2 = [0];
      G.ConcentricSampleDisk(u1, u2, d1, d2);
      ray.set$5(worldCenter.$add(0, v1.$mul(0, d1[0]).$add(0, v2.$mul(0, d2[0])).$mul(0, worldRadius)).$add(0, d.$negate(d).$mul(0, worldRadius)), d, 0, 1 / 0, time);
      if (sintheta === 0) {
        if (0 >= pdf.length)
          return H.ioore(pdf, 0);
        pdf[0] = 0;
      } else {
        directionPdf = J.$div$n(mapPdf[0], 19.739208802178716 * sintheta);
        if (typeof worldRadius !== "number")
          return H.iae(worldRadius);
        t1 = J.$mul$ns(directionPdf, 1 / (3.141592653589793 * worldRadius * worldRadius));
        if (0 >= pdf.length)
          return H.ioore(pdf, 0);
        pdf[0] = t1;
      }
      return G.Spectrum_Spectrum$from(this.radianceMap.lookup$2(uv[0], uv[1]), 1);
    },
    pdf$2: function(p, w) {
      var wi, t1, theta, phi, sintheta;
      wi = this.worldToLight.transformVector$1(w);
      t1 = J.clamp$2$n(wi.get$z(wi), -1, 1);
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      theta = Math.acos(t1);
      phi = G.Vector_SphericalPhi(wi);
      sintheta = Math.sin(theta);
      if (sintheta === 0)
        return 0;
      return this.distribution.pdf$2(phi * 0.15915494309189535, theta * 0.3183098861837907) / (19.739208802178716 * sintheta);
    },
    shProject$8: function(p, pEpsilon, lmax, scene, computeLightVis, time, rng, coeffs) {
      var t1, t2, i, t3, ntheta, nphi, buf, bufp, bufp0, bufp1, theta, t4, t5, phi, t6, Ylm, t7, t8, t9, t10, t11, w, Le;
      if (computeLightVis) {
        G.Light.prototype.shProject$8.call(this, p, pEpsilon, lmax, scene, true, time, rng, coeffs);
        return;
      }
      t1 = J.getInterceptor$ns(lmax);
      t2 = coeffs.length;
      i = 0;
      while (true) {
        t3 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        t3 = G.Spectrum_Spectrum(0);
        if (i >= t2)
          return H.ioore(coeffs, i);
        coeffs[i] = t3;
        ++i;
      }
      t3 = this.radianceMap;
      ntheta = t3.height;
      nphi = t3.width;
      if (P.min(ntheta, nphi) > 50) {
        if (typeof ntheta !== "number")
          return H.iae(ntheta);
        if (typeof nphi !== "number")
          return H.iae(nphi);
        t3 = 2 * ntheta + 2 * nphi;
        if (typeof t3 !== "number" || Math.floor(t3) !== t3)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t3)));
        buf = new Float32Array(t3);
        bufp = 0 + ntheta;
        bufp0 = bufp + ntheta;
        bufp1 = bufp0 + nphi;
        for (t3 = buf.length, theta = 0; theta < ntheta; ++theta) {
          t4 = (theta + 0.5) / ntheta * 3.141592653589793;
          t5 = Math.sin(t4);
          if (theta >= t3)
            return H.ioore(buf, theta);
          buf[theta] = t5;
          t5 = bufp + theta;
          t4 = Math.cos(t4);
          if (t5 >>> 0 !== t5 || t5 >= t3)
            return H.ioore(buf, t5);
          buf[t5] = t4;
        }
        for (phi = 0; phi < nphi; ++phi) {
          t4 = bufp0 + phi;
          t5 = (phi + 0.5) / nphi * 2 * 3.141592653589793;
          t6 = Math.sin(t5);
          if (t4 >>> 0 !== t4 || t4 >= t3)
            return H.ioore(buf, t4);
          buf[t4] = t6;
          t6 = bufp1 + phi;
          t4 = Math.cos(t5);
          if (t6 >>> 0 !== t6 || t6 >= t3)
            return H.ioore(buf, t6);
          buf[t6] = t4;
        }
        t4 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
        if (typeof t4 !== "number" || Math.floor(t4) !== t4)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t4)));
        Ylm = new Float32Array(t4);
        for (t4 = Ylm.length, t5 = 3.141592653589793 / ntheta, t6 = 6.283185307179586 / nphi, t7 = this.lightToWorld, theta = 0; theta < ntheta; ++theta)
          for (t8 = bufp + theta, phi = 0; phi < nphi; ++phi) {
            if (theta >= t3)
              return H.ioore(buf, theta);
            t9 = buf[theta];
            t10 = bufp1 + phi;
            if (t10 >>> 0 !== t10 || t10 >= t3)
              return H.ioore(buf, t10);
            t10 = buf[t10];
            t11 = bufp0 + phi;
            if (t11 >>> 0 !== t11 || t11 >= t3)
              return H.ioore(buf, t11);
            t11 = buf[t11];
            if (t8 >>> 0 !== t8 || t8 >= t3)
              return H.ioore(buf, t8);
            t11 = t7.transformVector$1(new G.Vector(t9 * t10, t9 * t11, buf[t8]));
            w = t11.$div(t11, t11.length$0(0));
            Le = G.Spectrum_Spectrum$from(this.radianceMap.texel$3(0, phi, theta), 1);
            G.SphericalHarmonics_Evaluate(w, lmax, Ylm, 0);
            i = 0;
            while (true) {
              t9 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
              if (typeof t9 !== "number")
                return H.iae(t9);
              if (!(i < t9))
                break;
              if (i >= t2)
                return H.ioore(coeffs, i);
              t9 = coeffs[i];
              if (i >= t4)
                return H.ioore(Ylm, i);
              coeffs[i] = J.$add$ns(t9, Le.$mul(0, Ylm[i]).$mul(0, buf[theta]).$mul(0, t5).$mul(0, t6));
              ++i;
            }
          }
      } else
        G.SphericalHarmonics_ProjectCube(new O._InfiniteAreaCube(this, scene, time, pEpsilon, false), p, 200, lmax, coeffs);
    },
    _setRadianceMap$1: function(texels) {
      var width, height, filter, t1, img, v, vw, vp, sinTheta, u, t2, t3;
      width = texels.width;
      height = texels.height;
      this.radianceMap = G.MIPMap$texture(texels, false, 8, 0);
      filter = 1 / P.max(width, height);
      t1 = J.$mul$ns(width, height);
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      img = new Float32Array(t1);
      if (typeof height !== "number")
        return H.iae(height);
      t1 = img.length;
      v = 0;
      for (; v < height; ++v) {
        if (typeof width !== "number")
          return H.iae(width);
        vw = v * width;
        vp = v / height;
        sinTheta = Math.sin(3.141592653589793 * (v + 0.5) / height);
        for (u = 0; u < width; ++u) {
          t2 = u + vw;
          t3 = J.get$y$x(this.radianceMap.lookup$3(u / width, vp, filter));
          if (t2 >>> 0 !== t2 || t2 >= t1)
            return H.ioore(img, t2);
          img[t2] = t3;
          img[t2] = img[t2] * sinTheta;
        }
      }
      this.distribution = G.Distribution2D$(img, width, height);
    },
    InfiniteAreaLight$4: function(light2world, $L, ns, texmap) {
      var completer, texels;
      if (J.get$isNotEmpty$asx(texmap)) {
        completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        $.ResourceManager_global.requestImage$2(texmap, completer.future).then$1(new O.InfiniteAreaLight_closure(this, $L, completer));
      }
      texels = G.SpectrumImage$(1, 1, 3);
      texels.$indexSet(0, 0, $L.toRGB$0());
      this._setRadianceMap$1(texels);
    },
    static: {InfiniteAreaLight_Create: [function(light2world, paramSet) {
        var $L, sc, texmap, nSamples;
        $L = paramSet.findOneSpectrum$2("L", G.Spectrum_Spectrum(1));
        sc = paramSet.findOneSpectrum$2("scale", G.Spectrum_Spectrum(1));
        texmap = paramSet.findOneFilename$2("mapname", "");
        nSamples = paramSet.findOneInt$2("nsamples", 1);
        return O.InfiniteAreaLight$(light2world, J.$mul$ns($L, sc), nSamples, texmap);
      }, "call$2", "InfiniteAreaLight_Create$closure", 4, 0, 30], InfiniteAreaLight$: function(light2world, $L, ns, texmap) {
        var t1 = new O.InfiniteAreaLight(null, null, P.max(1, ns), G.Transform$from(light2world), G.Transform$from(G.Transform$(light2world.get$mInv(), light2world.m)));
        t1.Light$2(light2world, ns);
        t1.InfiniteAreaLight$4(light2world, $L, ns, texmap);
        return t1;
      }}
  },
  InfiniteAreaLight_closure: {
    "^": "Closure:119;this_0,L_1,completer_2",
    call$1: function(img) {
      var texels, width, height, t1, t2, i, t3;
      texels = G.SpectrumImage$from(img);
      width = texels.width;
      height = texels.height;
      t1 = J.getInterceptor$ns(width);
      t2 = this.L_1;
      i = 0;
      while (true) {
        t3 = t1.$mul(width, height);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        texels.$indexSet(0, i, J.$mul$ns(texels.$index(0, i), t2.toRGB$0()));
        ++i;
      }
      this.this_0._setRadianceMap$1(texels);
      t1 = this.completer_2.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  _InfiniteAreaCube: {
    "^": "Object:120;light,scene,time@,pEpsilon,computeVis",
    call$2: function(p, w) {
      var ray = G.Ray$(p, w, this.pEpsilon, 1 / 0, this.time, 0);
      if (!this.computeVis || !this.scene.intersectP$1(ray))
        return this.light.Le$1(G.RayDifferential$fromRay(ray));
      return G.Spectrum_Spectrum(0);
    }
  },
  PointLight: {
    "^": "Light;lightPos,intensity,nSamples,lightToWorld,worldToLight",
    sampleLAtPoint$7: function(p, pEpsilon, ls, time, wi, pdf, vis) {
      var t1, dist, t2;
      t1 = this.lightPos.$sub(0, p);
      t1 = t1.$div(t1, t1.length$0(0));
      wi.x = t1.x;
      wi.y = t1.y;
      wi.z = t1.z;
      pdf[0] = 1;
      t1 = this.lightPos;
      dist = t1.$sub(0, p).length$0(0);
      t1 = t1.$sub(0, p).$div(0, dist);
      t2 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
      t1 = new G.Vector(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1));
      vis.r = new G.Ray(t2, t1, pEpsilon, dist, time, 0);
      return J.$div$n(this.intensity, p.$sub(0, this.lightPos).lengthSquared$0());
    },
    power$1: function(scene) {
      return J.$mul$ns(this.intensity, 12.566370614359172);
    },
    isDeltaLight$0: function() {
      return true;
    },
    sampleL$8: function(scene, ls, u1, u2, time, ray, Ns, pdf) {
      var t1 = this.lightPos;
      ray.origin = new G.Point(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1));
      t1 = ls.uPos;
      t1 = G.UniformSampleSphere(t1[0], t1[1]);
      ray.direction = t1;
      ray.minDistance = 0;
      ray.maxDistance = 1 / 0;
      ray.time = time;
      Ns.copy$1(t1);
      if (0 >= pdf.length)
        return H.ioore(pdf, 0);
      pdf[0] = 0.07957747154594767;
      return G.Spectrum_Spectrum$from(this.intensity, 0);
    },
    pdf$2: function(p, w) {
      return 0;
    },
    shProject$8: function(p, pEpsilon, lmax, scene, computeLightVisibility, time, rng, coeffs) {
      var t1, t2, i, t3, Ylm, Li, t4, t5;
      t1 = J.getInterceptor$ns(lmax);
      t2 = coeffs.length;
      i = 0;
      while (true) {
        t3 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        t3 = G.Spectrum_Spectrum(0);
        if (i >= t2)
          return H.ioore(coeffs, i);
        coeffs[i] = t3;
        ++i;
      }
      if (computeLightVisibility) {
        t3 = this.lightPos.$sub(0, p);
        t3 = scene.intersectP$1(G.Ray$(p, t3.$div(t3, t3.length$0(0)), pEpsilon, p.$sub(0, this.lightPos).length$0(0), time, 0));
      } else
        t3 = false;
      if (t3)
        return;
      t3 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
      if (typeof t3 !== "number")
        return H.iae(t3);
      Ylm = H.setRuntimeTypeInfo(Array(t3), [J.JSDouble]);
      t3 = this.lightPos.$sub(0, p);
      G.SphericalHarmonics_Evaluate(t3.$div(t3, t3.length$0(0)), lmax, Ylm, 0);
      Li = J.$div$n(this.intensity, p.$sub(0, this.lightPos).lengthSquared$0());
      t3 = Ylm.length;
      t4 = J.getInterceptor$ns(Li);
      i = 0;
      while (true) {
        t5 = J.$mul$ns(t1.$add(lmax, 1), t1.$add(lmax, 1));
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(i < t5))
          break;
        if (i >= t3)
          return H.ioore(Ylm, i);
        t5 = t4.$mul(Li, Ylm[i]);
        if (i >= t2)
          return H.ioore(coeffs, i);
        coeffs[i] = t5;
        ++i;
      }
    },
    static: {PointLight_Create: [function(light2world, paramSet) {
        var I, sc, l2w, t1;
        I = paramSet.findOneSpectrum$2("I", G.Spectrum_Spectrum(1));
        sc = paramSet.findOneSpectrum$2("scale", G.Spectrum_Spectrum(1));
        l2w = G.Transform_Translate(paramSet.findOnePoint$2("from", new G.Point(0, 0, 0))).$mul(0, light2world);
        t1 = new O.PointLight(null, J.$mul$ns(I, sc), P.max(1, 1), G.Transform$from(l2w), G.Transform$from(G.Transform$(l2w.mInv, l2w.m)));
        t1.Light$2(l2w, 1);
        t1.lightPos = l2w.transformPoint$1(new G.Point(0, 0, 0));
        return t1;
      }, "call$2", "PointLight_Create$closure", 4, 0, 31]}
  },
  ProjectionLight: {
    "^": "Light;projectionMap,lightPos,intensity,lightProjection,hither,yon,screenX0,screenX1,screenY0,screenY1,cosTotalWidth,nSamples,lightToWorld,worldToLight",
    sampleLAtPoint$7: function(p, pEpsilon, ls, time, wi, pdf, visibility) {
      var t1, dist, t2;
      t1 = this.lightPos.$sub(0, p);
      t1 = t1.$div(t1, t1.length$0(0));
      wi.x = t1.x;
      wi.y = t1.y;
      wi.z = t1.z;
      pdf[0] = 1;
      t1 = this.lightPos;
      dist = t1.$sub(0, p).length$0(0);
      t1 = t1.$sub(0, p).$div(0, dist);
      t2 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
      t1 = new G.Vector(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1));
      visibility.r = new G.Ray(t2, t1, pEpsilon, dist, time, 0);
      return J.$div$n(J.$mul$ns(this.intensity, this.projection$1(new G.Vector(J.$negate$n(wi.x), J.$negate$n(wi.y), J.$negate$n(wi.z)))), p.$sub(0, this.lightPos).lengthSquared$0());
    },
    isDeltaLight$0: function() {
      return true;
    },
    projection$1: function(w) {
      var wl, Pl, s, t;
      wl = this.worldToLight.transformVector$1(w);
      if (J.$lt$n(wl.get$z(wl), this.hither))
        return G.Spectrum_Spectrum(0);
      Pl = this.lightProjection.transformPoint$1(new G.Point(wl.get$x(wl), wl.get$y(wl), wl.get$z(wl)));
      if (J.$lt$n(Pl.get$x(Pl), this.screenX0) || J.$gt$n(Pl.get$x(Pl), this.screenX1) || J.$lt$n(Pl.get$y(Pl), this.screenY0) || J.$gt$n(Pl.get$y(Pl), this.screenY1))
        return G.Spectrum_Spectrum(0);
      if (this.projectionMap == null)
        return G.Spectrum_Spectrum(1);
      s = J.$div$n(J.$sub$n(Pl.get$x(Pl), this.screenX0), this.screenX1 - this.screenX0);
      t = J.$div$n(J.$sub$n(Pl.get$y(Pl), this.screenY0), this.screenY1 - this.screenY0);
      return G.Spectrum_Spectrum$from(this.projectionMap.lookup$2(s, t), 1);
    },
    power$1: function(scene) {
      var t1 = this.projectionMap;
      t1 = t1 != null ? G.Spectrum_Spectrum$from(t1.lookup$3(0.5, 0.5, 0.5), 1) : G.Spectrum_Spectrum(1);
      return t1.$mul(0, this.intensity).$mul(0, 6.283185307179586 * (1 - this.cosTotalWidth));
    },
    sampleL$8: function(scene, ls, u1, u2, time, ray, Ns, pdf) {
      var t1, v;
      t1 = ls.uPos;
      v = G.UniformSampleCone(t1[0], t1[1], this.cosTotalWidth);
      ray.set$5(this.lightPos, this.lightToWorld.transformVector$1(v), 0, 1 / 0, time);
      Ns.copy$1(ray.direction);
      t1 = G.UniformConePdf(this.cosTotalWidth);
      if (0 >= pdf.length)
        return H.ioore(pdf, 0);
      pdf[0] = t1;
      return J.$mul$ns(this.intensity, this.projection$1(ray.direction));
    },
    pdf$2: function(p, w) {
      return 0;
    },
    ProjectionLight$4: function(light2world, intensity, texname, fov) {
      var completer, opposite, t1;
      this.lightPos = this.lightToWorld.transformPoint$1(new G.Point(0, 0, 0));
      if (J.get$isNotEmpty$asx(texname)) {
        completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        $.ResourceManager_global.requestImage$2(texname, completer.future).then$1(new O.ProjectionLight_closure(this, fov, completer));
      }
      this.screenX0 = -1;
      this.screenX1 = 1;
      this.screenY0 = -1;
      this.screenY1 = 1;
      this.hither = 0.001;
      this.yon = 1000000000000000019884624838656;
      this.lightProjection = G.Transform_Perspective(fov, 0.001, 1000000000000000019884624838656);
      if (typeof fov !== "number")
        return H.iae(fov);
      opposite = Math.tan(0.017453292519943295 * fov / 2);
      t1 = Math.sqrt(2);
      t1 = Math.atan(opposite * t1);
      this.cosTotalWidth = Math.cos(t1);
    },
    static: {ProjectionLight_Create: [function(light2world, paramSet) {
        var I, sc, fov, texname;
        I = paramSet.findOneSpectrum$2("I", G.Spectrum_Spectrum(1));
        sc = paramSet.findOneSpectrum$2("scale", G.Spectrum_Spectrum(1));
        fov = paramSet.findOneFloat$2("fov", 45);
        texname = paramSet.findOneFilename$2("mapname", "");
        return O.ProjectionLight$(light2world, J.$mul$ns(I, sc), texname, fov);
      }, "call$2", "ProjectionLight_Create$closure", 4, 0, 32], ProjectionLight$: function(light2world, intensity, texname, fov) {
        var t1 = new O.ProjectionLight(null, null, intensity, null, null, null, null, null, null, null, null, P.max(1, 1), G.Transform$from(light2world), G.Transform$from(G.Transform$(light2world.get$mInv(), light2world.m)));
        t1.Light$2(light2world, 1);
        t1.ProjectionLight$4(light2world, intensity, texname, fov);
        return t1;
      }}
  },
  ProjectionLight_closure: {
    "^": "Closure:119;this_0,fov_1,completer_2",
    call$1: function(img) {
      var t1, t2, aspect, t3, opposite;
      t1 = this.this_0;
      t1.projectionMap = G.MIPMap$texture(img, false, 8, 0);
      t2 = J.getInterceptor$x(img);
      aspect = J.$div$n(t2.get$width(img), t2.get$height(img));
      t2 = J.getInterceptor$n(aspect);
      if (t2.$gt(aspect, 1)) {
        if (typeof aspect !== "number")
          return aspect.$negate();
        t1.screenX0 = -aspect;
        t1.screenX1 = aspect;
        t1.screenY0 = -1;
        t1.screenY1 = 1;
      } else {
        t1.screenX0 = -1;
        t1.screenX1 = 1;
        if (typeof aspect !== "number")
          return H.iae(aspect);
        t1.screenY0 = -1 / aspect;
        t1.screenY1 = 1 / aspect;
      }
      t3 = this.fov_1;
      if (typeof t3 !== "number")
        return H.iae(t3);
      opposite = Math.tan(0.017453292519943295 * t3 / 2);
      t2 = t2.$mul(aspect, aspect);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = Math.sqrt(1 + 1 / t2);
      t2 = Math.atan(opposite * t2);
      t1.cosTotalWidth = Math.cos(t2);
      t1 = this.completer_2.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  SpotLight: {
    "^": "Light;lightPos,intensity,cosTotalWidth,cosFalloffStart,nSamples,lightToWorld,worldToLight",
    isDeltaLight$0: function() {
      return true;
    },
    falloff$1: function(w) {
      var t1, costheta, t2, t3, delta;
      t1 = this.worldToLight.transformVector$1(w);
      costheta = t1.$div(t1, t1.length$0(0)).z;
      t1 = J.getInterceptor$n(costheta);
      if (t1.$lt(costheta, this.cosTotalWidth))
        return 0;
      if (t1.$gt(costheta, this.cosFalloffStart))
        return 1;
      t1 = t1.$sub(costheta, this.cosTotalWidth);
      t2 = this.cosFalloffStart;
      t3 = this.cosTotalWidth;
      if (typeof t1 !== "number")
        return t1.$div();
      delta = t1 / (t2 - t3);
      return delta * delta * delta * delta;
    },
    power$1: function(s) {
      return J.$mul$ns(J.$mul$ns(J.$mul$ns(this.intensity, 2), 3.141592653589793), 1 - 0.5 * (this.cosFalloffStart + this.cosTotalWidth));
    },
    sampleLAtPoint$7: function(p, pEpsilon, ls, time, wi, pdf, vis) {
      var t1, dist, t2;
      t1 = this.lightPos.$sub(0, p);
      t1 = t1.$div(t1, t1.length$0(0));
      wi.x = t1.x;
      wi.y = t1.y;
      wi.z = t1.z;
      pdf[0] = 1;
      t1 = this.lightPos;
      dist = t1.$sub(0, p).length$0(0);
      t1 = t1.$sub(0, p).$div(0, dist);
      t2 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
      t1 = new G.Vector(t1.get$x(t1), t1.get$y(t1), t1.get$z(t1));
      vis.r = new G.Ray(t2, t1, pEpsilon, dist, time, 0);
      return J.$div$n(J.$mul$ns(this.intensity, this.falloff$1(new G.Vector(J.$negate$n(wi.x), J.$negate$n(wi.y), J.$negate$n(wi.z)))), p.$sub(0, this.lightPos).lengthSquared$0());
    },
    sampleL$8: function(scene, ls, u1, u2, time, ray, Ns, pdf) {
      var t1, v;
      t1 = ls.uPos;
      v = G.UniformSampleCone(t1[0], t1[1], this.cosTotalWidth);
      ray.set$5(this.lightPos, this.lightToWorld.transformVector$1(v), 0, 1 / 0, time);
      Ns.copy$1(ray.direction);
      t1 = G.UniformConePdf(this.cosTotalWidth);
      if (0 >= pdf.length)
        return H.ioore(pdf, 0);
      pdf[0] = t1;
      return J.$mul$ns(this.intensity, this.falloff$1(ray.direction));
    },
    pdf$2: function(p, w) {
      return 0;
    },
    SpotLight$4: function(light2world, I, width, fall) {
      this.lightPos = this.lightToWorld.transformPoint$1(new G.Point(0, 0, 0));
      this.intensity = I;
      if (typeof width !== "number")
        return H.iae(width);
      this.cosTotalWidth = Math.cos(0.017453292519943295 * width);
      if (typeof fall !== "number")
        return H.iae(fall);
      this.cosFalloffStart = Math.cos(0.017453292519943295 * fall);
    },
    static: {SpotLight_Create: [function(l2w, paramSet) {
        var I, sc, coneangle, conedelta, from, t1, t2, dir, du, dv, dirToZ, light2world, t3;
        I = paramSet.findOneSpectrum$2("I", G.Spectrum_Spectrum(1));
        sc = paramSet.findOneSpectrum$2("scale", G.Spectrum_Spectrum(1));
        coneangle = paramSet.findOneFloat$2("coneangle", 30);
        conedelta = paramSet.findOneFloat$2("conedeltaangle", 5);
        from = paramSet.findOnePoint$2("from", new G.Point(0, 0, 0));
        t1 = J.$sub$n(paramSet.findOnePoint$2("to", new G.Point(0, 0, 1)), from);
        t2 = J.getInterceptor$asx(t1);
        dir = t2.$div(t1, t2.length$0(t1));
        du = new G.Vector(0, 0, 0);
        dv = new G.Vector(0, 0, 0);
        G.Vector_CoordinateSystem(dir, du, dv);
        t1 = J.getInterceptor$x(dir);
        dirToZ = G.Transform$(G.Matrix4x4$values(du.x, du.y, du.z, 0, dv.x, dv.y, dv.z, 0, t1.get$x(dir), t1.get$y(dir), t1.get$z(dir), 0, 0, 0, 0, 1), null);
        t1 = J.getInterceptor$x(from);
        light2world = J.$mul$ns(J.$mul$ns(l2w, G.Transform_Translate(new G.Vector(t1.get$x(from), t1.get$y(from), t1.get$z(from)))), G.Transform$(dirToZ.mInv, dirToZ.m));
        t1 = J.$mul$ns(I, sc);
        t2 = J.$sub$n(coneangle, conedelta);
        t3 = new O.SpotLight(null, null, null, null, P.max(1, 1), G.Transform$from(light2world), G.Transform$from(G.Transform$(light2world.get$mInv(), light2world.m)));
        t3.Light$2(light2world, 1);
        t3.SpotLight$4(light2world, t1, coneangle, t2);
        return t3;
      }, "call$2", "SpotLight_Create$closure", 4, 0, 33]}
  }
}],
["materials", "package:dartray/materials/materials.dart", , D, {
  "^": "",
  GlassMaterial: {
    "^": "Material;Kr,Kt,index,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var t1, dgs, ior, bsdf, $R, $T, t2, t3;
      t1 = this.bumpMap;
      if (t1 != null) {
        dgs = G.DifferentialGeometry$();
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      } else
        dgs = dgShading;
      ior = this.index.evaluate$1(dgs);
      bsdf = G.BSDF$(dgs, dgGeom.nn, ior);
      $R = J.clamp$0$n(this.Kr.evaluate$1(dgs));
      $T = J.clamp$0$n(this.Kt.evaluate$1(dgs));
      if (!$R.isBlack$0()) {
        t1 = G.SpecularReflection$($R, new G.FresnelDielectric(1, ior));
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = t1;
      }
      if (!$T.isBlack$0()) {
        t1 = G.SpecularTransmission$($T, 1, ior);
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = t1;
      }
      return bsdf;
    },
    static: {GlassMaterial_Create: [function(xform, mp) {
        return new D.GlassMaterial(mp.getSpectrumTexture$2("Kr", G.Spectrum_Spectrum(1)), mp.getSpectrumTexture$2("Kt", G.Spectrum_Spectrum(1)), mp.getFloatTexture$2("index", 1.5), mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "GlassMaterial_Create$closure", 4, 0, 34]}
  },
  KdSubsurfaceMaterial: {
    "^": "Material;Kd,Kr,meanfreepath,eta,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var dgs, t1, bsdf, $R, e, t2, t3;
      dgs = G.DifferentialGeometry$();
      t1 = this.bumpMap;
      if (t1 != null)
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      $R = J.clamp$0$n(this.Kr.evaluate$1(dgs));
      e = this.eta.evaluate$1(dgs);
      if (!$R.isBlack$0()) {
        t1 = G.SpecularReflection$($R, new G.FresnelDielectric(1, e));
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = t1;
      }
      return bsdf;
    },
    static: {KdSubsurfaceMaterial_Create: [function(xform, mp) {
        var kd, mfp, ior;
        kd = mp.getSpectrumTexture$2("Kd", G.Spectrum_Spectrum(0.5));
        mfp = mp.getFloatTexture$2("meanfreepath", 1);
        ior = mp.getFloatTexture$2("index", 1.3);
        return new D.KdSubsurfaceMaterial(kd, mp.getSpectrumTexture$2("Kr", G.Spectrum_Spectrum(1)), mfp, ior, mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "KdSubsurfaceMaterial_Create$closure", 4, 0, 35]}
  },
  MatteMaterial: {
    "^": "Material;Kd,sigma,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var t1, dgs, bsdf, r, sig, t2, t3;
      t1 = this.bumpMap;
      if (t1 != null) {
        dgs = G.DifferentialGeometry$();
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      } else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      r = J.clamp$0$n(this.Kd.evaluate$1(dgs));
      sig = J.clamp$2$n(this.sigma.evaluate$1(dgs), 0, 90);
      if (!r.isBlack$0()) {
        t1 = bsdf.bxdfs;
        if (sig === 0) {
          t2 = G.Lambertian$(r);
          t3 = bsdf.nBxDFs++;
          if (t3 >= 8)
            return H.ioore(t1, t3);
          t1[t3] = t2;
        } else {
          t2 = new G.OrenNayar(G.Spectrum_Spectrum$from(r, 0), null, null, 5);
          t2.OrenNayar$2(r, sig);
          t3 = bsdf.nBxDFs++;
          if (t3 >= 8)
            return H.ioore(t1, t3);
          t1[t3] = t2;
        }
      }
      return bsdf;
    },
    static: {MatteMaterial_Create: [function(xform, mp) {
        return new D.MatteMaterial(mp.getSpectrumTexture$2("Kd", G.Spectrum_Spectrum(0.5)), mp.getFloatTexture$2("sigma", 0), mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "MatteMaterial_Create$closure", 4, 0, 36]}
  },
  MeasuredMaterial: {
    "^": "Material;thetaPhiData,regularHalfangleData,nThetaH,nThetaD,nPhiD,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var dgs, t1, bsdf, t2, t3, t4, t5, t6;
      dgs = G.DifferentialGeometry$();
      t1 = this.bumpMap;
      if (t1 != null)
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      t1 = this.regularHalfangleData;
      if (t1 != null) {
        t2 = this.nThetaH;
        t3 = this.nThetaD;
        t4 = this.nPhiD;
        t5 = bsdf.bxdfs;
        t6 = bsdf.nBxDFs++;
        if (t6 >= 8)
          return H.ioore(t5, t6);
        t5[t6] = new G.RegularHalfangleBRDF(t1, t2, t3, t4, 9);
      } else {
        t1 = this.thetaPhiData;
        if (t1 != null) {
          t2 = bsdf.bxdfs;
          t3 = bsdf.nBxDFs++;
          if (t3 >= 8)
            return H.ioore(t2, t3);
          t2[t3] = new G.IrregularIsotropicBRDF(t1, 9);
        }
      }
      return bsdf;
    },
    MeasuredMaterial$2: function(filename, bumpMap) {
      var t1, suffix, c;
      t1 = J.getInterceptor$asx(filename);
      suffix = t1.substring$1(filename, t1.lastIndexOf$1(filename, ".")).toLowerCase();
      if (suffix.length === 0) {
        t1 = "No suffix in measured BRDF filename \"" + filename + "\". Can't determine file type (.brdf / .merl)";
        $.Log.call$2(2, t1);
        return;
      }
      if (suffix === ".brdf") {
        if ($.get$MeasuredMaterial_loadedThetaPhi().containsKey$1(filename)) {
          this.thetaPhiData = $.get$MeasuredMaterial_loadedThetaPhi().$index(0, filename);
          return;
        }
        c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        $.ResourceManager_global.requestFile$2(filename, c.future).then$1(new D.MeasuredMaterial_closure(this, filename, c));
      } else {
        this.nThetaH = 90;
        this.nThetaD = 90;
        this.nPhiD = 180;
        if ($.get$MeasuredMaterial_loadedRegularHalfangle().containsKey$1(filename)) {
          this.regularHalfangleData = $.get$MeasuredMaterial_loadedRegularHalfangle().$index(0, filename);
          return;
        }
        c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        $.ResourceManager_global.requestFile$2(filename, c.future).then$1(new D.MeasuredMaterial_closure0(this, filename, c));
      }
    },
    static: {"^": "MeasuredMaterial_loadedRegularHalfangle,MeasuredMaterial_loadedThetaPhi", MeasuredMaterial_Create: [function(xform, mp) {
        var bumpMap = mp.getFloatTextureOrNull$1("bumpmap");
        return D.MeasuredMaterial$(mp.geomParams.findOneFilename$2("filename", mp.materialParams.findOneFilename$2("filename", "")), bumpMap);
      }, "call$2", "MeasuredMaterial_Create$closure", 4, 0, 37], MeasuredMaterial$: function(filename, bumpMap) {
        var t1 = new D.MeasuredMaterial(null, null, null, null, null, bumpMap);
        t1.MeasuredMaterial$2(filename, bumpMap);
        return t1;
      }}
  },
  MeasuredMaterial_closure: {
    "^": "Closure:88;this_0,filename_1,c_2",
    call$1: function(bytes) {
      var values, t1, numWls, wls, pos, i, pos0, bbox, samples, thetai, phii, thetao, phio, t2, t3, t4, t5, t6, t7, t8, t9, s, p;
      values = H.NativeFloat32List_NativeFloat32List$view(new Uint8Array(H._ensureNativeList(bytes)).buffer, 0, null);
      t1 = values.length;
      if (0 >= t1)
        return H.ioore(values, 0);
      numWls = C.JSNumber_methods.toInt$0(values[0]);
      if (C.JSInt_methods.$mod(t1 - 1 - numWls, 4 + numWls) !== 0) {
        t1 = "Excess or insufficient data in theta, phi BRDF file \"" + this.filename_1 + "\"";
        $.Log.call$2(2, t1);
        t1 = this.c_2.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(null);
        return;
      }
      wls = new Float32Array(numWls);
      for (pos = 1, i = 0; i < numWls; ++i, pos = pos0) {
        pos0 = pos + 1;
        if (pos >= t1)
          return H.ioore(values, pos);
        wls[i] = values[pos];
      }
      bbox = G.BBox$(null, null);
      samples = [];
      for (; pos < t1;) {
        pos0 = pos + 1;
        if (pos < 0)
          return H.ioore(values, pos);
        thetai = values[pos];
        pos = pos0 + 1;
        if (pos0 < 0 || pos0 >= t1)
          return H.ioore(values, pos0);
        phii = values[pos0];
        pos0 = pos + 1;
        if (pos < 0 || pos >= t1)
          return H.ioore(values, pos);
        thetao = values[pos];
        pos = pos0 + 1;
        if (pos0 < 0 || pos0 >= t1)
          return H.ioore(values, pos0);
        phio = values[pos0];
        t2 = Math.sin(thetao);
        t3 = Math.cos(thetao);
        t4 = Math.cos(phio);
        t5 = Math.sin(phio);
        t6 = Math.sin(thetai);
        t7 = Math.cos(thetai);
        t8 = Math.cos(phii);
        t9 = Math.sin(phii);
        s = G.Spectrum_Spectrum(0);
        s.setSampled$3(wls, values, pos);
        pos += numWls;
        p = G.BRDFRemap(new G.Vector(t2 * t4, t2 * t5, t3), new G.Vector(t6 * t8, t6 * t9, t7));
        samples.push(new G.IrregIsotropicBRDFSample(new G.Point(p.x, p.y, p.z), G.Spectrum_Spectrum$from(s, 0)));
        t7 = bbox.pMin;
        t9 = t7.x;
        t6 = t7.y;
        t7 = t7.z;
        t8 = bbox.pMax;
        bbox = new G.BBox(new G.Point(t9, t6, t7), new G.Point(t8.x, t8.y, t8.z)).unionPoint$1(p);
      }
      t1 = $.get$MeasuredMaterial_loadedThetaPhi();
      t2 = G.KdTree$(samples);
      this.this_0.thetaPhiData = t2;
      t1.$indexSet(0, this.filename_1, t2);
      t1 = this.c_2.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  MeasuredMaterial_closure0: {
    "^": "Closure:88;this_3,filename_4,c_5",
    call$1: function(bytes) {
      var fp, t1, t2, dims0, dims1, n, t3, t4, chunkSize;
      fp = U.InputBuffer$(bytes, false, null, 0);
      t1 = fp.readUint32$0();
      t2 = $.get$__uint32();
      t2[0] = t1;
      t1 = $.get$__uint32ToInt32();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      dims0 = t1[0];
      t2[0] = fp.readUint32$0();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      dims1 = t1[0];
      t2[0] = fp.readUint32$0();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      n = dims0 * dims1 * t1[0];
      t1 = this.this_3;
      t2 = t1.nThetaH;
      t3 = t1.nThetaD;
      if (typeof t2 !== "number")
        return t2.$mul();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = t1.nPhiD;
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (n !== t2 * t3 * t4) {
        $.Log.call$2(2, "Dimensions don't match");
        t1 = this.c_5.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(null);
        return;
      }
      t1.regularHalfangleData = new Float32Array(3 * n);
      t1 = t1.nPhiD;
      if (typeof t1 !== "number")
        return H.iae(t1);
      chunkSize = 2 * t1;
      new Float32Array(chunkSize);
      C.JSInt_methods.$tdiv(n, chunkSize);
      P.Uint64List_Uint64List(1);
    }
  },
  MetalMaterial: {
    "^": "Material;eta,k,roughness,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var t1, dgs, bsdf, rough, md, frMf, t2, t3;
      t1 = this.bumpMap;
      if (t1 != null) {
        dgs = G.DifferentialGeometry$();
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      } else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      rough = this.roughness.evaluate$1(dgs);
      if (typeof rough !== "number")
        return H.iae(rough);
      md = G.Blinn$(1 / rough);
      frMf = G.FresnelConductor$(this.eta.evaluate$1(dgs), this.k.evaluate$1(dgs));
      t1 = G.Spectrum_Spectrum(1);
      t2 = bsdf.bxdfs;
      t3 = bsdf.nBxDFs++;
      if (t3 >= 8)
        return H.ioore(t2, t3);
      t2[t3] = new G.Microfacet(t1, md, frMf, 9);
      return bsdf;
    },
    static: {"^": "MetalMaterial__copperN,MetalMaterial__copperK,MetalMaterial__COPPER_SAMPLES,MetalMaterial__COPPER_WAVELENGTHS,MetalMaterial__COPPER_N,MetalMaterial__COPPER_K", MetalMaterial_Create: [function(xform, mp) {
        return new D.MetalMaterial(mp.getSpectrumTexture$2("eta", $.get$MetalMaterial__copperN()), mp.getSpectrumTexture$2("k", $.get$MetalMaterial__copperK()), mp.getFloatTexture$2("roughness", 0.01), mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "MetalMaterial_Create$closure", 4, 0, 38]}
  },
  MirrorMaterial: {
    "^": "Material;Kr,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var dgs, t1, bsdf, $R, t2, t3;
      dgs = G.DifferentialGeometry$();
      t1 = this.bumpMap;
      if (t1 != null)
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      $R = J.clamp$0$n(this.Kr.evaluate$1(dgs));
      if (!$R.isBlack$0()) {
        t1 = G.SpecularReflection$($R, new G.FresnelNoOp());
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = t1;
      }
      return bsdf;
    },
    static: {MirrorMaterial_Create: [function(xform, mp) {
        return new D.MirrorMaterial(mp.getSpectrumTexture$2("Kr", G.Spectrum_Spectrum(0.9)), mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "MirrorMaterial_Create$closure", 4, 0, 39]}
  },
  MixMaterial: {
    "^": "Material;m1,m2,scale",
    getBSDF$2: function(dgGeom, dgShading) {
      var b1, b2, s1, s2, n1, n2, t1, i, t2, t3, t4, t5, t6;
      b1 = this.m1.getBSDF$2(dgGeom, dgShading);
      b2 = this.m2.getBSDF$2(dgGeom, dgShading);
      s1 = J.clamp$0$n(this.scale.evaluate$1(dgShading));
      s2 = G.Spectrum_Spectrum(1).$sub(0, s1).clamp$0(0);
      n1 = b1.numComponents$0();
      n2 = b2.numComponents$0();
      for (t1 = b1.bxdfs, i = 0; i < n1; ++i) {
        if (i >= 8)
          return H.ioore(t1, i);
        t2 = t1[i];
        t3 = J.get$type$x(t2);
        t1[i] = new G.ScaledBxDF(t2, G.Spectrum_Spectrum$from(s1, 0), t3);
      }
      for (t2 = b2.bxdfs, i = 0; i < n2; ++i) {
        if (i >= 8)
          return H.ioore(t2, i);
        t3 = t2[i];
        t4 = J.get$type$x(t3);
        t5 = G.Spectrum_Spectrum$from(s2, 0);
        t6 = b1.nBxDFs++;
        if (t6 >= 8)
          return H.ioore(t1, t6);
        t1[t6] = new G.ScaledBxDF(t3, t5, t4);
      }
      return b1;
    },
    scale$1: function($receiver, arg0) {
      return this.scale.call$1(arg0);
    }
  },
  PlasticMaterial: {
    "^": "Material;Kd,Ks,roughness,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var dgs, t1, bsdf, kd, diff, t2, ks, rough, t3;
      dgs = G.DifferentialGeometry$();
      t1 = this.bumpMap;
      if (t1 != null)
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      kd = J.clamp$0$n(this.Kd.evaluate$1(dgs));
      if (!kd.isBlack$0()) {
        diff = G.Lambertian$(kd);
        t1 = bsdf.bxdfs;
        t2 = bsdf.nBxDFs++;
        if (t2 >= 8)
          return H.ioore(t1, t2);
        t1[t2] = diff;
      }
      ks = J.clamp$0$n(this.Ks.evaluate$1(dgs));
      if (!ks.isBlack$0()) {
        rough = this.roughness.evaluate$1(dgs);
        if (typeof rough !== "number")
          return H.iae(rough);
        t1 = G.Blinn$(1 / rough);
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = new G.Microfacet(ks, t1, new G.FresnelDielectric(1.5, 1), 9);
      }
      return bsdf;
    },
    static: {PlasticMaterial_Create: [function(xform, mp) {
        return new D.PlasticMaterial(mp.getSpectrumTexture$2("Kd", G.Spectrum_Spectrum(0.25)), mp.getSpectrumTexture$2("Ks", G.Spectrum_Spectrum(0.25)), mp.getFloatTexture$2("roughness", 0.1), mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "PlasticMaterial_Create$closure", 4, 0, 40]}
  },
  ShinyMetalMaterial: {
    "^": "Material;Ks,Kr,roughness,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var t1, dgs, bsdf, spec, rough, $R, md, k, frMf, t2, t3, frSr;
      t1 = this.bumpMap;
      if (t1 != null) {
        dgs = G.DifferentialGeometry$();
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      } else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      spec = J.clamp$0$n(this.Ks.evaluate$1(dgs));
      rough = this.roughness.evaluate$1(dgs);
      $R = J.clamp$0$n(this.Kr.evaluate$1(dgs));
      if (typeof rough !== "number")
        return H.iae(rough);
      md = G.Blinn$(1 / rough);
      k = G.Spectrum_Spectrum(0);
      if (!spec.isBlack$0()) {
        frMf = G.FresnelConductor$(D.ShinyMetalMaterial_FresnelApproxEta(spec), k);
        t1 = G.Spectrum_Spectrum(1);
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = new G.Microfacet(t1, md, frMf, 9);
      }
      if (!$R.isBlack$0()) {
        frSr = G.FresnelConductor$(D.ShinyMetalMaterial_FresnelApproxEta($R), k);
        t1 = G.SpecularReflection$(G.Spectrum_Spectrum(1), frSr);
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = t1;
      }
      return bsdf;
    },
    static: {ShinyMetalMaterial_Create: [function(xform, mp) {
        var Kr = mp.getSpectrumTexture$2("Kr", G.Spectrum_Spectrum(1));
        return new D.ShinyMetalMaterial(mp.getSpectrumTexture$2("Ks", G.Spectrum_Spectrum(1)), Kr, mp.getFloatTexture$2("roughness", 0.1), mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "ShinyMetalMaterial_Create$closure", 4, 0, 41], ShinyMetalMaterial_FresnelApproxEta: function(Fr) {
        var sqrtRefl, one;
        sqrtRefl = Fr.clamp$2(0, 0, 0.999).sqrt$0();
        one = G.Spectrum_Spectrum(1);
        return one.$add(0, sqrtRefl).$div(0, one.$sub(one, sqrtRefl));
      }}
  },
  SubstrateMaterial: {
    "^": "Material;Kd,Ks,nu,nv,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var dgs, t1, bsdf, d, s, u, v, t2, t3, t4, t5;
      dgs = G.DifferentialGeometry$();
      t1 = this.bumpMap;
      if (t1 != null)
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      d = J.clamp$0$n(this.Kd.evaluate$1(dgs));
      s = J.clamp$0$n(this.Ks.evaluate$1(dgs));
      u = this.nu.evaluate$1(dgs);
      v = this.nv.evaluate$1(dgs);
      if (!d.isBlack$0() || !s.isBlack$0()) {
        if (typeof u !== "number")
          return H.iae(u);
        t1 = 1 / u;
        if (typeof v !== "number")
          return H.iae(v);
        t2 = 1 / v;
        t3 = new G.Anisotropic(t1, t2);
        t3.Anisotropic$2(t1, t2);
        t2 = G.Spectrum_Spectrum$from(d, 0);
        t1 = G.Spectrum_Spectrum$from(s, 0);
        t4 = bsdf.bxdfs;
        t5 = bsdf.nBxDFs++;
        if (t5 >= 8)
          return H.ioore(t4, t5);
        t4[t5] = new G.FresnelBlend(t2, t1, t3, 9);
      }
      return bsdf;
    },
    static: {SubstrateMaterial_Create: [function(xform, mp) {
        return new D.SubstrateMaterial(mp.getSpectrumTexture$2("Kd", G.Spectrum_Spectrum(0.5)), mp.getSpectrumTexture$2("Ks", G.Spectrum_Spectrum(0.5)), mp.getFloatTexture$2("uroughness", 0.1), mp.getFloatTexture$2("vroughness", 0.1), mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "SubstrateMaterial_Create$closure", 4, 0, 42]}
  },
  SubsurfaceMaterial: {
    "^": "Material;scale,Kr,sigma_a,sigma_prime_s,eta,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var dgs, t1, bsdf, $R, e, t2, t3;
      dgs = G.DifferentialGeometry$();
      t1 = this.bumpMap;
      if (t1 != null)
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      $R = J.clamp$0$n(this.Kr.evaluate$1(dgs));
      e = this.eta.evaluate$1(dgs);
      if (!$R.isBlack$0()) {
        t1 = G.SpecularReflection$($R, new G.FresnelDielectric(1, e));
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = t1;
      }
      return bsdf;
    },
    scale$1: function($receiver, arg0) {
      return this.scale.call$1(arg0);
    },
    static: {SubsurfaceMaterial_Create: [function(xform, mp) {
        var sa_rgb, sps_rgb, sa, sps, $name, found, t1, scale, sigma_a, sigma_prime_s, ior;
        sa_rgb = [0.0011, 0.0024, 0.014];
        sps_rgb = [2.55, 3.21, 3.77];
        sa = G.Spectrum_Spectrum$rgb(sa_rgb[0], sa_rgb[1], sa_rgb[2]);
        sps = G.Spectrum_Spectrum$rgb(sps_rgb[0], sps_rgb[1], sps_rgb[2]);
        $name = mp.findString$1("name");
        found = G.GetVolumeScatteringProperties($name, sa, sps);
        if (!J.$eq($name, "") && !found) {
          t1 = "Named material \"" + H.S($name) + "\" not found.  Using defaults.";
          $.Log.call$2(1, t1);
        }
        scale = mp.findFloat$2("scale", 1);
        sigma_a = mp.getSpectrumTexture$2("sigma_a", sa);
        sigma_prime_s = mp.getSpectrumTexture$2("sigma_prime_s", sps);
        ior = mp.getFloatTexture$2("index", 1.3);
        return new D.SubsurfaceMaterial(scale, mp.getSpectrumTexture$2("Kr", G.Spectrum_Spectrum(1)), sigma_a, sigma_prime_s, ior, mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "SubsurfaceMaterial_Create$closure", 4, 0, 43]}
  },
  TranslucentMaterial: {
    "^": "Material;Kd,Ks,roughness,reflect,transmit,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var dgs, t1, bsdf, r, t, kd, t2, t3, ks, rough, t4;
      dgs = G.DifferentialGeometry$();
      t1 = this.bumpMap;
      if (t1 != null)
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1.5);
      r = J.clamp$0$n(this.reflect.evaluate$1(dgs));
      t = J.clamp$0$n(this.transmit.evaluate$1(dgs));
      if (r.isBlack$0() && t.isBlack$0())
        return bsdf;
      kd = J.clamp$0$n(this.Kd.evaluate$1(dgs));
      if (!kd.isBlack$0()) {
        if (!r.isBlack$0()) {
          t1 = G.Lambertian$(r.$mul(0, kd));
          t2 = bsdf.bxdfs;
          t3 = bsdf.nBxDFs++;
          if (t3 >= 8)
            return H.ioore(t2, t3);
          t2[t3] = t1;
        }
        if (!t.isBlack$0()) {
          t1 = G.BRDFToBTDF$(G.Lambertian$(t.$mul(0, kd)));
          t2 = bsdf.bxdfs;
          t3 = bsdf.nBxDFs++;
          if (t3 >= 8)
            return H.ioore(t2, t3);
          t2[t3] = t1;
        }
      }
      ks = J.clamp$0$n(this.Ks.evaluate$1(dgs));
      if (!ks.isBlack$0()) {
        rough = this.roughness.evaluate$1(dgs);
        if (!r.isBlack$0()) {
          t1 = r.$mul(0, ks);
          if (typeof rough !== "number")
            return H.iae(rough);
          t2 = G.Blinn$(1 / rough);
          t3 = bsdf.bxdfs;
          t4 = bsdf.nBxDFs++;
          if (t4 >= 8)
            return H.ioore(t3, t4);
          t3[t4] = new G.Microfacet(t1, t2, new G.FresnelDielectric(1.5, 1), 9);
        }
        if (!t.isBlack$0()) {
          t1 = t.$mul(0, ks);
          if (typeof rough !== "number")
            return H.iae(rough);
          t1 = G.BRDFToBTDF$(new G.Microfacet(t1, G.Blinn$(1 / rough), new G.FresnelDielectric(1.5, 1), 9));
          t2 = bsdf.bxdfs;
          t3 = bsdf.nBxDFs++;
          if (t3 >= 8)
            return H.ioore(t2, t3);
          t2[t3] = t1;
        }
      }
      return bsdf;
    },
    static: {TranslucentMaterial_Create: [function(xform, mp) {
        var Kd, Ks, reflect, transmit;
        Kd = mp.getSpectrumTexture$2("Kd", G.Spectrum_Spectrum(0.25));
        Ks = mp.getSpectrumTexture$2("Ks", G.Spectrum_Spectrum(0.25));
        reflect = mp.getSpectrumTexture$2("reflect", G.Spectrum_Spectrum(0.5));
        transmit = mp.getSpectrumTexture$2("transmit", G.Spectrum_Spectrum(0.5));
        return new D.TranslucentMaterial(Kd, Ks, mp.getFloatTexture$2("roughness", 0.1), reflect, transmit, mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "TranslucentMaterial_Create$closure", 4, 0, 44]}
  },
  UberMaterial: {
    "^": "Material;Kd,Ks,Kr,Kt,opacity,roughness,eta,bumpMap",
    getBSDF$2: function(dgGeom, dgShading) {
      var t1, dgs, bsdf, op, tr, t2, kd, diff, e, ks, rough, t3, kr, kt;
      t1 = this.bumpMap;
      if (t1 != null) {
        dgs = G.DifferentialGeometry$();
        G.Material_Bump(t1, dgGeom, dgShading, dgs);
      } else
        dgs = dgShading;
      bsdf = G.BSDF$(dgs, dgGeom.nn, 1);
      op = J.clamp$0$n(this.opacity.evaluate$1(dgs));
      if (!op.isValue$1(1)) {
        tr = G.SpecularTransmission$(op.$negate(0).$add(0, G.Spectrum_Spectrum(1)), 1, 1);
        t1 = bsdf.bxdfs;
        t2 = bsdf.nBxDFs++;
        if (t2 >= 8)
          return H.ioore(t1, t2);
        t1[t2] = tr;
      }
      kd = op.$mul(0, J.clamp$0$n(this.Kd.evaluate$1(dgs)));
      if (!kd.isBlack$0()) {
        diff = G.Lambertian$(kd);
        t1 = bsdf.bxdfs;
        t2 = bsdf.nBxDFs++;
        if (t2 >= 8)
          return H.ioore(t1, t2);
        t1[t2] = diff;
      }
      e = this.eta.evaluate$1(dgs);
      ks = op.$mul(0, J.clamp$0$n(this.Ks.evaluate$1(dgs)));
      if (!ks.isBlack$0()) {
        rough = this.roughness.evaluate$1(dgs);
        if (typeof rough !== "number")
          return H.iae(rough);
        t1 = G.Blinn$(1 / rough);
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = new G.Microfacet(ks, t1, new G.FresnelDielectric(e, 1), 9);
      }
      kr = op.$mul(0, J.clamp$0$n(this.Kr.evaluate$1(dgs)));
      if (!kr.isBlack$0()) {
        t1 = G.SpecularReflection$(kr, new G.FresnelDielectric(e, 1));
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = t1;
      }
      kt = op.$mul(0, J.clamp$0$n(this.Kt.evaluate$1(dgs)));
      if (!kt.isBlack$0()) {
        t1 = G.SpecularTransmission$(kt, e, 1);
        t2 = bsdf.bxdfs;
        t3 = bsdf.nBxDFs++;
        if (t3 >= 8)
          return H.ioore(t2, t3);
        t2[t3] = t1;
      }
      return bsdf;
    },
    static: {UberMaterial_Create: [function(xform, mp) {
        var Kd, Ks, Kr, Kt, roughness, eta;
        Kd = mp.getSpectrumTexture$2("Kd", G.Spectrum_Spectrum(0.25));
        Ks = mp.getSpectrumTexture$2("Ks", G.Spectrum_Spectrum(0.25));
        Kr = mp.getSpectrumTexture$2("Kr", G.Spectrum_Spectrum(0));
        Kt = mp.getSpectrumTexture$2("Kt", G.Spectrum_Spectrum(0));
        roughness = mp.getFloatTexture$2("roughness", 0.1);
        eta = mp.getFloatTexture$2("index", 1.5);
        return new D.UberMaterial(Kd, Ks, Kr, Kt, mp.getSpectrumTexture$2("opacity", G.Spectrum_Spectrum(1)), roughness, eta, mp.getFloatTextureOrNull$1("bumpmap"));
      }, "call$2", "UberMaterial_Create$closure", 4, 0, 45]}
  }
}],
["pbrt", "package:dartray/pbrt/pbrt.dart", , U, {
  "^": "",
  GraphicsState: {
    "^": "Object;doubleTextures<,spectrumTextures<,materialParams@,material@,namedMaterials<,currentNamedMaterial?,areaLightParams@,areaLight@,reverseOrientation@",
    static: {GraphicsState$from: function(other) {
        var t1, t2, t3, t4, t5, t6;
        P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t1 = other.get$doubleTextures();
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
        t2.addAll$1(0, t1);
        t1 = other.spectrumTextures;
        t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
        t3.addAll$1(0, t1);
        t1 = G.ParamSet$from(other.materialParams);
        t4 = other.material;
        t5 = other.namedMaterials;
        t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
        t6.addAll$1(0, t5);
        return new U.GraphicsState(t2, t3, t1, t4, t6, other.currentNamedMaterial, G.ParamSet$from(other.areaLightParams), other.areaLight, other.reverseOrientation);
      }}
  },
  Pbrt: {
    "^": "Object;resourceManager,_currentApiState,_curTransform,_activeTransformBits,_namedCoordinateSystems,_renderOptions<,_graphicsState,_pushedGraphicsStates,_pushedTransforms,_pushedActiveTransformBits,_renderer,_scene",
    renderScene$2: function(scene, output) {
      var t, t1, c;
      t = new P.Stopwatch(1000000, null, null);
      t.start$0(0);
      this._renderOptions.outputImage = output;
      t1 = G.OutputImage;
      c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t1)), [t1]);
      new U.PbrtParser(this, this.resourceManager).parse$1(scene).then$1(new U.Pbrt_renderScene_closure(this, t, c));
      return c.future;
    },
    identity$0: function() {
      for (var i = 0; i < 2; ++i)
        if (J.$and$n(this._activeTransformBits, C.JSInt_methods._shlPositive$1(1, i)) !== 0)
          J.$indexSet$ax(this._curTransform, i, G.Transform$(null, null));
    },
    translate$3: function(_, dx, dy, dz) {
      var i, t1, t2;
      for (i = 0; i < 2; ++i)
        if (J.$and$n(this._activeTransformBits, C.JSInt_methods._shlPositive$1(1, i)) !== 0) {
          t1 = this._curTransform;
          t2 = J.getInterceptor$asx(t1);
          t2.$indexSet(t1, i, J.$mul$ns(t2.$index(t1, i), G.Transform_Translate(new G.Vector(dx, dy, dz))));
        }
    },
    transform$1: function(_, tr) {
      var i;
      for (i = 0; i < 2; ++i)
        if (J.$and$n(this._activeTransformBits, C.JSInt_methods._shlPositive$1(1, i)) !== 0)
          J.$indexSet$ax(this._curTransform, i, G.Transform$(tr, null));
    },
    concatTransform$1: function(tr) {
      var i, t1, t2;
      for (i = 0; i < 2; ++i)
        if (J.$and$n(this._activeTransformBits, C.JSInt_methods._shlPositive$1(1, i)) !== 0) {
          t1 = this._curTransform;
          t2 = J.getInterceptor$asx(t1);
          t2.$indexSet(t1, i, J.$mul$ns(t2.$index(t1, i), G.Transform$(tr, null)));
        }
    },
    rotate$4: function(_, angle, dx, dy, dz) {
      var i, t1, t2, t3, t4, a, s, c, m, t5, t6, t7, t8;
      for (i = 0; i < 2; ++i)
        if (J.$and$n(this._activeTransformBits, C.JSInt_methods._shlPositive$1(1, i)) !== 0) {
          t1 = this._curTransform;
          t2 = J.getInterceptor$asx(t1);
          t3 = t2.$index(t1, i);
          t4 = new G.Vector(dx, dy, dz);
          a = t4.$div(0, t4.length$0(0));
          if (typeof angle !== "number")
            return H.iae(angle);
          t4 = 0.017453292519943295 * angle;
          s = Math.sin(t4);
          c = Math.cos(t4);
          m = G.Matrix4x4$();
          t4 = a.x;
          t4 = J.$mul$ns(t4, t4);
          t5 = a.x;
          t5 = J.$mul$ns(t5, t5);
          if (typeof t5 !== "number")
            return H.iae(t5);
          t5 = J.$add$ns(t4, (1 - t5) * c);
          t4 = m.m;
          t6 = t4.length;
          if (0 >= t6)
            return H.ioore(t4, 0);
          t4[0] = t5;
          t5 = 1 - c;
          t7 = J.$sub$n(J.$mul$ns(J.$mul$ns(a.x, a.y), t5), J.$mul$ns(a.z, s));
          if (1 >= t6)
            return H.ioore(t4, 1);
          t4[1] = t7;
          t7 = J.$add$ns(J.$mul$ns(J.$mul$ns(a.x, a.z), t5), J.$mul$ns(a.y, s));
          if (2 >= t6)
            return H.ioore(t4, 2);
          t4[2] = t7;
          if (3 >= t6)
            return H.ioore(t4, 3);
          t4[3] = 0;
          t7 = J.$add$ns(J.$mul$ns(J.$mul$ns(a.x, a.y), t5), J.$mul$ns(a.z, s));
          if (4 >= t6)
            return H.ioore(t4, 4);
          t4[4] = t7;
          t7 = a.y;
          t7 = J.$mul$ns(t7, t7);
          t8 = a.y;
          t8 = J.$mul$ns(t8, t8);
          if (typeof t8 !== "number")
            return H.iae(t8);
          t8 = J.$add$ns(t7, (1 - t8) * c);
          if (5 >= t6)
            return H.ioore(t4, 5);
          t4[5] = t8;
          t8 = J.$sub$n(J.$mul$ns(J.$mul$ns(a.y, a.z), t5), J.$mul$ns(a.x, s));
          if (6 >= t6)
            return H.ioore(t4, 6);
          t4[6] = t8;
          if (7 >= t6)
            return H.ioore(t4, 7);
          t4[7] = 0;
          t8 = J.$sub$n(J.$mul$ns(J.$mul$ns(a.x, a.z), t5), J.$mul$ns(a.y, s));
          if (8 >= t6)
            return H.ioore(t4, 8);
          t4[8] = t8;
          t5 = J.$add$ns(J.$mul$ns(J.$mul$ns(a.y, a.z), t5), J.$mul$ns(a.x, s));
          if (9 >= t6)
            return H.ioore(t4, 9);
          t4[9] = t5;
          t5 = a.z;
          t5 = J.$mul$ns(t5, t5);
          t8 = a.z;
          t8 = J.$mul$ns(t8, t8);
          if (typeof t8 !== "number")
            return H.iae(t8);
          t8 = J.$add$ns(t5, (1 - t8) * c);
          if (10 >= t6)
            return H.ioore(t4, 10);
          t4[10] = t8;
          if (11 >= t6)
            return H.ioore(t4, 11);
          t4[11] = 0;
          if (12 >= t6)
            return H.ioore(t4, 12);
          t4[12] = 0;
          if (13 >= t6)
            return H.ioore(t4, 13);
          t4[13] = 0;
          if (14 >= t6)
            return H.ioore(t4, 14);
          t4[14] = 0;
          if (15 >= t6)
            return H.ioore(t4, 15);
          t4[15] = 1;
          t2.$indexSet(t1, i, J.$mul$ns(t3, G.Transform$(m, G.Matrix4x4_Transpose(m))));
        }
    },
    scale$3: function(_, sx, sy, sz) {
      var i, t1, t2;
      for (i = 0; i < 2; ++i)
        if (J.$and$n(this._activeTransformBits, C.JSInt_methods._shlPositive$1(1, i)) !== 0) {
          t1 = this._curTransform;
          t2 = J.getInterceptor$asx(t1);
          t2.$indexSet(t1, i, J.$mul$ns(t2.$index(t1, i), G.Transform_Scale(sx, sy, sz)));
        }
    },
    lookAt$9: function(ex, ey, ez, lx, ly, lz, ux, uy, uz) {
      var i, t1, t2, t3, t4, m, t5, t6, dir, left, newUp;
      for (i = 0; i < 2; ++i)
        if (J.$and$n(this._activeTransformBits, C.JSInt_methods._shlPositive$1(1, i)) !== 0) {
          t1 = this._curTransform;
          t2 = J.getInterceptor$asx(t1);
          t3 = t2.$index(t1, i);
          t4 = new G.Vector(ux, uy, uz);
          m = G.Matrix4x4$();
          t5 = m.m;
          t6 = t5.length;
          if (3 >= t6)
            return H.ioore(t5, 3);
          t5[3] = ex;
          if (7 >= t6)
            return H.ioore(t5, 7);
          t5[7] = ey;
          if (11 >= t6)
            return H.ioore(t5, 11);
          t5[11] = ez;
          if (15 >= t6)
            return H.ioore(t5, 15);
          t5[15] = 1;
          t6 = new G.Point(J.$sub$n(lx, ex), J.$sub$n(ly, ey), J.$sub$n(lz, ez));
          dir = t6.$div(0, t6.length$0(0));
          t4 = G.Vector_Cross(t4.$div(0, t4.length$0(0)), dir);
          left = t4.$div(0, t4.length$0(0));
          newUp = G.Vector_Cross(dir, left);
          t5[0] = left.x;
          t5[4] = left.y;
          t5[8] = left.z;
          t5[12] = 0;
          t5[1] = newUp.x;
          t5[5] = newUp.y;
          t5[9] = newUp.z;
          t5[13] = 0;
          t5[2] = dir.x;
          t5[6] = dir.y;
          t5[10] = dir.z;
          t5[14] = 0;
          t2.$indexSet(t1, i, J.$mul$ns(t3, G.Transform$(new G.Matrix4x4(new Float32Array(H._ensureNativeList(t5))).invert$0(), m)));
        }
    },
    film$2: [function(type, params) {
      var t1 = this._renderOptions;
      t1.filmParams = params;
      t1.filmName = type;
    }, "call$2", "get$film", 4, 0, 121],
    worldBegin$0: function() {
      this._currentApiState = 2;
      for (var i = 0; i < 2; ++i)
        J.$indexSet$ax(this._curTransform, i, G.Transform$(null, null));
      this._activeTransformBits = 3;
      this._namedCoordinateSystems.$indexSet(0, "world", this._curTransform);
    },
    attributeEnd$0: function() {
      var t1, t2;
      t1 = this._pushedGraphicsStates;
      t2 = t1.length;
      if (t2 === 0) {
        $.Log.call$2(1, "Unmatched attributeEnd() encountered. Ignoring it.");
        return;
      }
      if (0 >= t2)
        return H.ioore(t1, 0);
      this._graphicsState = t1.pop();
      t1 = this._pushedTransforms;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this._curTransform = t1.pop();
      t1 = this._pushedActiveTransformBits;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this._activeTransformBits = t1.pop();
    },
    transformEnd$0: function() {
      var t1, t2;
      t1 = this._pushedTransforms;
      t2 = t1.length;
      if (t2 === 0) {
        $.Log.call$2(1, "Unmatched pbrtTransformEnd() encountered. Ignoring it.");
        return;
      }
      if (0 >= t2)
        return H.ioore(t1, 0);
      this._curTransform = t1.pop();
      t1 = this._pushedActiveTransformBits;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this._activeTransformBits = t1.pop();
    },
    material$2: [function($name, params) {
      this._graphicsState.set$material($name);
      this._graphicsState.set$materialParams(params);
      this._graphicsState.set$currentNamedMaterial("");
    }, "call$2", "get$material", 4, 0, 121],
    shape$2: function(_, $name, params) {
      var obj2world, shape, mtl, area, t1, prim, identity, world2obj0, world2obj1, animatedWorldToObject, baseprim, refinedPrimitives, t2;
      if (this._curTransform.isAnimated$0() !== true) {
        obj2world = G.Transform$from(J.$index$asx(this._curTransform, 0));
        shape = this._makeShape$5($name, obj2world, G.Transform$(obj2world.mInv, obj2world.m), this._graphicsState.get$reverseOrientation(), params);
        if (shape == null)
          return;
        mtl = this._createMaterial$1(params);
        params.reportUnused$0();
        area = !J.$eq(this._graphicsState.get$areaLight(), "") ? this._makeAreaLight$4(this._graphicsState.get$areaLight(), J.$index$asx(this._curTransform, 0), this._graphicsState.get$areaLightParams(), shape) : null;
        t1 = $.Primitive__nextprimitiveId;
        $.Primitive__nextprimitiveId = t1 + 1;
        prim = new G.GeometricPrimitive(shape, mtl, area, t1);
      } else {
        if (!J.$eq(this._graphicsState.get$areaLight(), ""))
          $.Log.call$2(1, "Ignoring currently set area light when creating animated shape");
        identity = G.Transform$(null, null);
        shape = this._makeShape$5($name, identity, identity, this._graphicsState.get$reverseOrientation(), params);
        if (shape == null)
          return;
        mtl = this._createMaterial$1(params);
        params.reportUnused$0();
        t1 = J.$index$asx(this._curTransform, 0);
        world2obj0 = G.Transform$(t1.get$mInv(), t1.m);
        t1 = J.$index$asx(this._curTransform, 1);
        world2obj1 = G.Transform$(t1.get$mInv(), t1.m);
        t1 = this._renderOptions;
        animatedWorldToObject = G.AnimatedTransform$(world2obj0, t1.transformStartTime, world2obj1, t1.transformEndTime);
        t1 = $.Primitive__nextprimitiveId;
        $.Primitive__nextprimitiveId = t1 + 1;
        baseprim = new G.GeometricPrimitive(shape, mtl, null, t1);
        if (!shape.canIntersect$0()) {
          refinedPrimitives = [];
          baseprim.fullyRefine$1(refinedPrimitives);
          t1 = refinedPrimitives.length;
          if (t1 === 0)
            return;
          baseprim = t1 > 1 ? E.BVHAccel$(refinedPrimitives, 1, 2) : refinedPrimitives[0];
        }
        t1 = G.AnimatedTransform$from(animatedWorldToObject);
        t2 = $.Primitive__nextprimitiveId;
        $.Primitive__nextprimitiveId = t2 + 1;
        prim = new G.TransformedPrimitive(baseprim, t1, t2);
        area = null;
      }
      t1 = this._renderOptions;
      if (t1.currentInstance != null) {
        if (area != null)
          $.Log.call$2(1, "Area lights not supported with object instancing");
        t1.currentInstance.push(prim);
      } else {
        t1.primitives.push(prim);
        if (area != null)
          t1.lights.push(area);
      }
    },
    reverseOrientation$0: [function() {
      var t1 = this._graphicsState;
      t1.set$reverseOrientation(t1.get$reverseOrientation() !== true);
    }, "call$0", "get$reverseOrientation", 0, 0, 10],
    objectInstance$1: function($name) {
      var t1, t2, inst, accel, world2instance0, world2instance1, animatedWorldToInstance, t3, t4;
      t1 = this._renderOptions;
      if (t1.currentInstance != null) {
        $.Log.call$2(1, "ObjectInstance can't be called inside instance definition");
        return;
      }
      t2 = t1.instances;
      if (!t2.containsKey$1($name)) {
        t1 = "Unable to find instance named '" + H.S($name) + "'";
        $.Log.call$2(1, t1);
        return;
      }
      inst = t2.$index(0, $name);
      t2 = inst.length;
      if (t2 === 0)
        return;
      if (t2 <= 1) {
        if (0 >= t2)
          return H.ioore(inst, 0);
        t2 = !inst[0].canIntersect$0();
      } else
        t2 = true;
      if (t2) {
        accel = this._makeAccelerator$3(t1.acceleratorName, inst, t1.acceleratorParams);
        if (accel == null)
          accel = this._makeAccelerator$3("bvh", inst, new G.ParamSet([], [], [], [], [], [], [], [], []));
        if (accel == null)
          $.Log.call$2(3, "Unable to create 'bvh' accelerator");
        J.set$length$asx(inst, 0);
        inst.push(accel);
      }
      t2 = J.$index$asx(this._curTransform, 0);
      world2instance0 = G.Transform$(t2.get$mInv(), t2.m);
      t2 = J.$index$asx(this._curTransform, 1);
      world2instance1 = G.Transform$(t2.get$mInv(), t2.m);
      animatedWorldToInstance = G.AnimatedTransform$(world2instance0, t1.transformStartTime, world2instance1, t1.transformEndTime);
      if (0 >= inst.length)
        return H.ioore(inst, 0);
      t2 = inst[0];
      t3 = G.AnimatedTransform$from(animatedWorldToInstance);
      t4 = $.Primitive__nextprimitiveId;
      $.Primitive__nextprimitiveId = t4 + 1;
      t1.primitives.push(new G.TransformedPrimitive(t2, t3, t4));
    },
    worldEnd$0: function() {
      var t1, t2, filter, film, camera, t3, renderer, largeStepProb, perPixelSamples, nBootstrap, nDirectPixelSamples, doDirectSeparately, mr, md, doBidirectional, sampler, surfaceIntegrator, volumeIntegrator, volumeRegion, accelerator, scene, i;
      for (t1 = this._pushedGraphicsStates, t2 = this._pushedTransforms; t1.length !== 0;) {
        $.Log.call$2(1, "Missing end to pbrtAttributeBegin()");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2.pop();
      }
      for (; t2.length !== 0;) {
        $.Log.call$2(1, "Missing end to pbrtTransformBegin()");
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2.pop();
      }
      t1 = this._renderOptions;
      filter = this._makeFilter$2(t1.filterName, t1.filterParams);
      film = this._makeFilm$5(t1.filmName, t1.filmParams, filter, t1.outputImage, t1.previewCallback);
      if (film == null)
        $.Log.call$2(3, "Unable to create film.");
      camera = this._makeCamera$6(t1.cameraName, t1.cameraParams, t1.cameraToWorld, t1.transformStartTime, t1.transformEndTime, film);
      if (camera == null)
        $.Log.call$2(3, "Unable to create camera.");
      t2 = t1.rendererName;
      if (t2 === "aggregatetest") {
        t2 = t1.rendererParams;
        t3 = t1.primitives;
        renderer = Y.AggregateTestRenderer$(t2.findOneInt$2("niters", 100000), t3);
        t1.rendererParams.reportUnused$0();
      } else if (t2 === "metropolis") {
        t2 = t1.rendererParams;
        largeStepProb = t2.findOneFloat$2("largestepprobability", 0.25);
        perPixelSamples = t2.findOneInt$2("samplesperpixel", 100);
        nBootstrap = t2.findOneInt$2("bootstrapsamples", 100000);
        nDirectPixelSamples = t2.findOneInt$2("directsamples", 4);
        doDirectSeparately = t2.findOneBool$2("dodirectseparately", true);
        mr = t2.findOneInt$2("maxconsecutiverejects", 512);
        md = t2.findOneInt$2("maxdepth", 7);
        doBidirectional = t2.findOneBool$2("bidirectional", true);
        renderer = new Y.MetropolisRenderer(0, 1, camera, doBidirectional, nDirectPixelSamples, perPixelSamples, md, null, nBootstrap, mr, null);
        renderer.MetropolisRenderer$11(perPixelSamples, nBootstrap, nDirectPixelSamples, largeStepProb, doDirectSeparately, mr, md, camera, doBidirectional, 0, 1);
        t1.rendererParams.reportUnused$0();
        if (t1.lights.length === 0)
          $.Log.call$2(1, "No light sources defined in scene; possibly rendering a black image.");
      } else {
        if (t2 !== "sampler") {
          t2 = "Renderer type '" + H.S(t2) + "' unknown. Using 'sampler'.";
          $.Log.call$2(1, t2);
        }
        t1.rendererParams.reportUnused$0();
        sampler = this._makeSampler$4(t1.samplerName, t1.samplerParams, camera.get$film(), camera);
        if (sampler == null)
          $.Log.call$2(3, "Unable to create sampler.");
        surfaceIntegrator = this._makeSurfaceIntegrator$2(t1.surfIntegratorName, t1.surfIntegratorParams);
        if (surfaceIntegrator == null)
          $.Log.call$2(3, "Unable to create surface integrator.");
        volumeIntegrator = this._makeVolumeIntegrator$2(t1.volIntegratorName, t1.volIntegratorParams);
        if (volumeIntegrator == null)
          $.Log.call$2(3, "Unable to create volume integrator.");
        renderer = new Y.SamplerRenderer(t1.taskNum, t1.taskCount, sampler, camera, surfaceIntegrator, volumeIntegrator);
        if (t1.lights.length === 0)
          $.Log.call$2(1, "No light sources defined in scene; possibly rendering a black image.");
      }
      this._renderer = renderer;
      t2 = t1.volumeRegions;
      t3 = t2.length;
      if (t3 === 0)
        volumeRegion = null;
      else if (t3 === 1) {
        if (0 >= t3)
          return H.ioore(t2, 0);
        volumeRegion = t2[0];
      } else
        volumeRegion = G.AggregateVolume$(t2);
      accelerator = this._makeAccelerator$3(t1.acceleratorName, t1.primitives, t1.acceleratorParams);
      if (accelerator == null)
        accelerator = this._makeAccelerator$3("bvh", t1.primitives, new G.ParamSet([], [], [], [], [], [], [], [], []));
      if (accelerator == null)
        $.Log.call$2(3, "Unable to create 'bvh' accelerator.");
      t3 = t1.lights;
      scene = new G.Scene(accelerator, P.List_List$from(t3, true, G.Light), volumeRegion, null);
      scene.Scene$3(accelerator, t3, volumeRegion);
      C.JSArray_methods.set$length(t1.primitives, 0);
      C.JSArray_methods.set$length(t3, 0);
      C.JSArray_methods.set$length(t2, 0);
      this._scene = scene;
      t2 = new U.GraphicsState(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), new G.ParamSet([], [], [], [], [], [], [], [], []), null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, new G.ParamSet([], [], [], [], [], [], [], [], []), "", null);
      t2.material = "matte";
      t2.reverseOrientation = false;
      this._graphicsState = t2;
      this._currentApiState = 1;
      for (i = 0; i < 2; ++i)
        J.$indexSet$ax(this._curTransform.get$t(), i, G.Transform$(null, null));
      this._activeTransformBits = 3;
      this._namedCoordinateSystems.clear$0(0);
    },
    _makeShape$5: function($name, object2world, world2object, reverseOrientation, paramSet) {
      var t1, s;
      if (!$.get$Pbrt__shapes().containsKey$1($name)) {
        t1 = "Shape '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      s = $.get$Pbrt__shapes().$index(0, $name).call$4(object2world, world2object, reverseOrientation, paramSet);
      paramSet.reportUnused$0();
      return s;
    },
    _createMaterial$1: function(params) {
      var t1, t2, mp, mtl;
      t1 = this._graphicsState;
      t2 = t1.get$materialParams();
      mp = new G.TextureParams(t1.get$doubleTextures(), t1.spectrumTextures, params, t2);
      t2 = t1.currentNamedMaterial;
      if (t2 !== "" && t1.namedMaterials.containsKey$1(t2)) {
        t1 = this._graphicsState;
        mtl = t1.get$namedMaterials().$index(0, t1.currentNamedMaterial);
      } else
        mtl = null;
      if (mtl == null)
        mtl = this._makeMaterial$3(this._graphicsState.get$material(), J.$index$asx(this._curTransform, 0), mp);
      if (mtl == null)
        mtl = this._makeMaterial$3("matte", J.$index$asx(this._curTransform, 0), mp);
      if (mtl == null)
        $.Log.call$2(3, "Unable to create 'matte' material?!");
      return mtl;
    },
    _makeMaterial$3: function($name, mtl2world, mp) {
      var t1, m1, m2, mat1, mat2, t2, scale, material;
      if (J.$eq($name, "mix")) {
        t1 = mp.geomParams;
        m1 = t1.findOneString$2("namedmaterial1", mp.materialParams.findOneString$2("namedmaterial1", ""));
        m2 = t1.findOneString$2("namedmaterial2", mp.materialParams.findOneString$2("namedmaterial2", ""));
        mat1 = this._graphicsState.get$namedMaterials().$index(0, m1);
        mat2 = this._graphicsState.get$namedMaterials().$index(0, m2);
        if (mat1 == null) {
          t2 = "Named material '" + H.S(m1) + "' undefined.  Using 'matte'";
          $.Log.call$2(1, t2);
          mat1 = this._makeMaterial$3("matte", J.$index$asx(this._curTransform, 0), mp);
        }
        if (mat2 == null) {
          t2 = "Named material '" + H.S(m2) + "' undefined.  Using 'matte'";
          $.Log.call$2(1, t2);
          mat2 = this._makeMaterial$3("matte", J.$index$asx(this._curTransform, 0), mp);
        }
        scale = mp.getSpectrumTexture$2("amount", G.Spectrum_Spectrum(0.5));
        t1.reportUnused$0();
        mp.materialParams.reportUnused$0();
        return new D.MixMaterial(mat1, mat2, scale);
      }
      if (!$.get$Pbrt__materials().containsKey$1($name)) {
        t1 = "Material '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      material = $.get$Pbrt__materials().$index(0, $name).call$2(mtl2world, mp);
      mp.geomParams.reportUnused$0();
      mp.materialParams.reportUnused$0();
      return material;
    },
    _makeFloatTexture$3: function($name, tex2world, tp) {
      var t1, t;
      if (!$.get$Pbrt__floatTextures().containsKey$1($name)) {
        t1 = "Texture '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return new G.ConstantTexture(tp.geomParams.findOneFloat$2("value", tp.materialParams.findOneFloat$2("value", 1)));
      }
      t = $.get$Pbrt__floatTextures().$index(0, $name).call$2(tex2world, tp);
      tp.geomParams.reportUnused$0();
      tp.materialParams.reportUnused$0();
      return t;
    },
    _makeSpectrumTexture$3: function($name, tex2world, tp) {
      var t1, t;
      if (!$.get$Pbrt__spectrumTextures().containsKey$1($name)) {
        t1 = "Texture '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        t1 = G.Spectrum_Spectrum(1);
        return new G.ConstantTexture(tp.geomParams.findOneSpectrum$2("value", tp.materialParams.findOneSpectrum$2("value", t1)));
      }
      t = $.get$Pbrt__spectrumTextures().$index(0, $name).call$2(tex2world, tp);
      tp.geomParams.reportUnused$0();
      tp.materialParams.reportUnused$0();
      return t;
    },
    _makeLight$3: function($name, light2world, paramSet) {
      var t1, l;
      if (!$.get$Pbrt__lights().containsKey$1($name)) {
        t1 = "Light '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      l = $.get$Pbrt__lights().$index(0, $name).call$2(light2world, paramSet);
      paramSet.reportUnused$0();
      return l;
    },
    _makeAreaLight$4: function($name, light2world, paramSet, shape) {
      var t1, l;
      if (!$.get$Pbrt__areaLights().containsKey$1($name)) {
        t1 = "Area Light '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      l = $.get$Pbrt__areaLights().$index(0, $name).call$3(light2world, paramSet, shape);
      paramSet.reportUnused$0();
      return l;
    },
    _makeVolumeRegion$3: function($name, volume2world, paramSet) {
      var t1, v;
      if (!$.get$Pbrt__volumeRegions().containsKey$1($name)) {
        t1 = "Volume Region '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      v = $.get$Pbrt__volumeRegions().$index(0, $name).call$2(volume2world, paramSet);
      paramSet.reportUnused$0();
      return v;
    },
    _makeSurfaceIntegrator$2: function($name, paramSet) {
      var t1, si;
      if (!$.get$Pbrt__surfaceIntegrators().containsKey$1($name)) {
        t1 = "Surface Integrator '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      si = $.get$Pbrt__surfaceIntegrators().$index(0, $name).call$1(paramSet);
      paramSet.reportUnused$0();
      return si;
    },
    _makeVolumeIntegrator$2: function($name, paramSet) {
      var t1, vi;
      if (!$.get$Pbrt__volumeIntegrators().containsKey$1($name)) {
        t1 = "Volume Integrator '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      vi = $.get$Pbrt__volumeIntegrators().$index(0, $name).call$1(paramSet);
      paramSet.reportUnused$0();
      return vi;
    },
    _makeAccelerator$3: function($name, prims, paramSet) {
      var t1, a;
      if (!$.get$Pbrt__accelerators().containsKey$1($name)) {
        t1 = "Accelerator '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      a = $.get$Pbrt__accelerators().$index(0, $name).call$2(prims, paramSet);
      paramSet.reportUnused$0();
      return a;
    },
    _makeCamera$6: function($name, paramSet, cam2worldSet, transformStart, transformEnd, film) {
      var t1, animatedCam2World, c;
      if (!$.get$Pbrt__cameras().containsKey$1($name)) {
        t1 = "Camera '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      animatedCam2World = G.AnimatedTransform$(G.Transform$from(cam2worldSet.$index(0, 0)), transformStart, G.Transform$from(cam2worldSet.$index(cam2worldSet, 1)), transformEnd);
      c = $.get$Pbrt__cameras().$index(0, $name).call$3(paramSet, animatedCam2World, film);
      paramSet.reportUnused$0();
      return c;
    },
    _makeSampler$4: function($name, paramSet, film, camera) {
      var t1, s;
      if (!$.get$Pbrt__samplers().containsKey$1($name)) {
        t1 = "Sampler '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      s = $.get$Pbrt__samplers().$index(0, $name).call$3(paramSet, film, camera);
      paramSet.reportUnused$0();
      return s;
    },
    _makeFilter$2: function($name, paramSet) {
      var t1, f;
      if (!$.get$Pbrt__filters().containsKey$1($name)) {
        t1 = "Filter '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      f = $.get$Pbrt__filters().$index(0, $name).call$1(paramSet);
      paramSet.reportUnused$0();
      return f;
    },
    _makeFilm$5: function($name, paramSet, filter, outputImage, previewCallback) {
      var t1, f;
      if (!$.get$Pbrt__films().containsKey$1($name)) {
        t1 = "Film '" + H.S($name) + "' unknown.";
        $.Log.call$2(1, t1);
        return;
      }
      f = $.get$Pbrt__films().$index(0, $name).call$4(paramSet, filter, outputImage, previewCallback);
      paramSet.reportUnused$0();
      return f;
    },
    static: {"^": "Pbrt__accelerators,Pbrt__cameras,Pbrt__films,Pbrt__filters,Pbrt__surfaceIntegrators,Pbrt__volumeIntegrators,Pbrt__lights,Pbrt__areaLights,Pbrt__materials,Pbrt__samplers,Pbrt__shapes,Pbrt__floatTextures,Pbrt__spectrumTextures,Pbrt__volumeRegions,Pbrt__renderers,Pbrt__MAX_TRANSFORMS,Pbrt__START_TRANSFORM_BITS,Pbrt__END_TRANSFORM_BITS,Pbrt__ALL_TRANSFORMS_BITS,Pbrt_STATE_UNINITIALIZED,Pbrt_STATE_OPTIONS_BLOCK,Pbrt_STATE_WORLD_BLOCK", Pbrt__registerStandardNodes: function() {
        if ($.get$Pbrt__shapes().containsKey$1("sphere"))
          return;
        $.get$Pbrt__accelerators().$indexSet(0, "bvh", E.BVHAccel_Create$closure());
        $.get$Pbrt__accelerators().$indexSet(0, "grid", E.GridAccel_Create$closure());
        $.get$Pbrt__accelerators().$indexSet(0, "kdtree", E.KdTreeAccel_Create$closure());
        $.get$Pbrt__accelerators().$indexSet(0, "bruteforce", E.BruteForceAccel_Create$closure());
        $.get$Pbrt__cameras().$indexSet(0, "environment", K.EnvironmentCamera_Create$closure());
        $.get$Pbrt__cameras().$indexSet(0, "orthographic", K.OrthographicCamera_Create$closure());
        $.get$Pbrt__cameras().$indexSet(0, "perspective", K.PerspectiveCamera_Create$closure());
        $.get$Pbrt__films().$indexSet(0, "image", R.ImageFilm_Create$closure());
        $.get$Pbrt__filters().$indexSet(0, "box", S.BoxFilter_Create$closure());
        $.get$Pbrt__filters().$indexSet(0, "gaussian", S.GaussianFilter_Create$closure());
        $.get$Pbrt__filters().$indexSet(0, "sinc", S.LanczosSincFilter_Create$closure());
        $.get$Pbrt__filters().$indexSet(0, "mitchell", S.MitchellFilter_Create$closure());
        $.get$Pbrt__filters().$indexSet(0, "triangle", S.TriangleFilter_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "ambientocclusion", U.AmbientOcclusionIntegrator_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "diffuseprt", U.DiffusePRTIntegrator_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "directlighting", U.DirectLightingIntegrator_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "glossyprt", U.GlossyPRTIntegrator_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "igi", U.IGIIntegrator_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "irradiancecache", U.IrradianceCacheIntegrator_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "path", U.PathIntegrator_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "photonmap", U.PhotonMapIntegrator_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "exphotonmap", U.PhotonMapIntegrator_Create$closure());
        $.get$Pbrt__surfaceIntegrators().$indexSet(0, "whitted", U.WhittedIntegrator_Create$closure());
        $.get$Pbrt__lights().$indexSet(0, "distant", O.DistantLight_Create$closure());
        $.get$Pbrt__lights().$indexSet(0, "point", O.PointLight_Create$closure());
        $.get$Pbrt__lights().$indexSet(0, "spot", O.SpotLight_Create$closure());
        $.get$Pbrt__lights().$indexSet(0, "infinite", O.InfiniteAreaLight_Create$closure());
        $.get$Pbrt__lights().$indexSet(0, "goniometric", O.GoniometricLight_Create$closure());
        $.get$Pbrt__lights().$indexSet(0, "projection", O.ProjectionLight_Create$closure());
        $.get$Pbrt__areaLights().$indexSet(0, "diffuse", O.DiffuseAreaLight_Create$closure());
        $.get$Pbrt__areaLights().$indexSet(0, "area", O.DiffuseAreaLight_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "glass", D.GlassMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "kdsubsurface", D.KdSubsurfaceMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "matte", D.MatteMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "measured", D.MeasuredMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "metal", D.MetalMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "mirror", D.MirrorMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "plastic", D.PlasticMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "shinymetal", D.ShinyMetalMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "substrate", D.SubstrateMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "subsurface", D.SubsurfaceMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "translucent", D.TranslucentMaterial_Create$closure());
        $.get$Pbrt__materials().$indexSet(0, "uber", D.UberMaterial_Create$closure());
        $.get$Pbrt__samplers().$indexSet(0, "adaptive", U.AdaptiveSampler_Create$closure());
        $.get$Pbrt__samplers().$indexSet(0, "bestcandidate", U.BestCandidateSampler_Create$closure());
        $.get$Pbrt__samplers().$indexSet(0, "halton", U.HaltonSampler_Create$closure());
        $.get$Pbrt__samplers().$indexSet(0, "lowdiscrepancy", U.LowDiscrepancySampler_Create$closure());
        $.get$Pbrt__samplers().$indexSet(0, "random", U.RandomSampler_Create$closure());
        $.get$Pbrt__samplers().$indexSet(0, "stratified", U.StratifiedSampler_Create$closure());
        $.get$Pbrt__shapes().$indexSet(0, "cone", M.ConeShape_Create$closure());
        $.get$Pbrt__shapes().$indexSet(0, "cylinder", M.CylinderShape_Create$closure());
        $.get$Pbrt__shapes().$indexSet(0, "disk", M.DiskShape_Create$closure());
        $.get$Pbrt__shapes().$indexSet(0, "hyperboloid", M.HyperboloidShape_Create$closure());
        $.get$Pbrt__shapes().$indexSet(0, "loopsubdiv", M.LoopSubdivisionShape_Create$closure());
        $.get$Pbrt__shapes().$indexSet(0, "paraboloid", M.ParaboloidShape_Create$closure());
        $.get$Pbrt__shapes().$indexSet(0, "sphere", M.SphereShape_Create$closure());
        $.get$Pbrt__shapes().$indexSet(0, "trianglemesh", M.TriangleMeshShape_Create$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "bilerp", G.BilerpTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "bilerp", G.BilerpTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "checkerboard", G.CheckerboardTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "checkerboard", G.CheckerboardTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "dots", G.DotsTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "dots", G.DotsTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "fbm", G.FBmTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "fbm", G.FBmTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "imagemap", G.ImageTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "imagemap", G.ImageTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "marble", G.MarbleTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "marble", G.MarbleTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "mix", G.MixTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "mix", G.MixTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "scale", G.ScaleTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "scale", G.ScaleTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "uv", G.UVTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "uv", G.UVTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "windy", G.WindyTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "windy", G.WindyTexture_CreateSpectrum$closure());
        $.get$Pbrt__floatTextures().$indexSet(0, "wrinkled", G.WrinkledTexture_CreateFloat$closure());
        $.get$Pbrt__spectrumTextures().$indexSet(0, "wrinkled", G.WrinkledTexture_CreateSpectrum$closure());
        $.get$Pbrt__volumeIntegrators().$indexSet(0, "emission", S.EmissionIntegrator_Create$closure());
        $.get$Pbrt__volumeIntegrators().$indexSet(0, "single", S.SingleScatteringIntegrator_Create$closure());
        $.get$Pbrt__volumeRegions().$indexSet(0, "exponential", B.ExponentialDensityRegion_Create$closure());
        $.get$Pbrt__volumeRegions().$indexSet(0, "homogeneous", B.HomogeneousVolumeRegion_Create$closure());
        $.get$Pbrt__volumeRegions().$indexSet(0, "volumegrid", B.VolumeGridDensity_Create$closure());
      }}
  },
  Pbrt_renderScene_closure: {
    "^": "Closure:88;this_0,t_1,c_2",
    call$1: function(x) {
      var t1, t2;
      t1 = this.this_0;
      if (t1._scene == null) {
        t2 = this.c_2.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(null);
      }
      t1.resourceManager.waitUntilReady$0().then$1(new U.Pbrt_renderScene__closure(t1, this.t_1, this.c_2));
    }
  },
  Pbrt_renderScene__closure: {
    "^": "Closure:88;this_3,t_4,c_5",
    call$1: function(_) {
      var t1, output;
      t1 = this.t_4;
      t1 = "FINISHED Preparing Scene: " + P.Duration$(0, 0, C.JSNumber_methods.$tdiv(t1.get$elapsedTicks() * 1000000, t1.frequency), 0, 0, 0).toString$0(0);
      $.Log.call$2(0, t1);
      t1 = this.this_3;
      output = t1._renderer.render$1(t1._scene);
      t1 = this.c_5.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(output);
    }
  },
  PbrtLexer: {
    "^": "Object;_inputStack,_identifierStr,_numValue,_lastChar,_curToken,_curTokenStr",
    get$path: function(_) {
      return J.get$path$x(C.JSArray_methods.get$last(this._inputStack));
    },
    get$line: function() {
      return C.JSArray_methods.get$last(this._inputStack).get$line();
    },
    nextToken$0: function() {
      var t1, t2, t3, numStr, thisChar;
      this._identifierStr = "";
      this._curTokenStr = "";
      t1 = this._inputStack;
      while (true) {
        t2 = this._lastChar;
        t3 = J.getInterceptor(t2);
        if (!(t3.$eq(t2, 32) || t3.$eq(t2, 9) || t3.$eq(t2, 10) || t3.$eq(t2, 13)))
          break;
        if (J.$eq(this._lastChar, 10)) {
          t2 = C.JSArray_methods.get$last(t1);
          t2.set$line(t2.get$line() + 1);
        }
        this._lastChar = this._nextChar$0();
      }
      if (J.$eq(this._lastChar, 0)) {
        this._curToken = -1;
        return -1;
      }
      if (J.$eq(this._lastChar, 34)) {
        t1 = this._nextChar$0();
        this._lastChar = t1;
        while (true) {
          t1 = !J.$eq(t1, 34) && !J.$eq(this._lastChar, 0);
          t2 = this._identifierStr;
          if (!t1)
            break;
          t1 = H.Primitives_stringFromCharCode(this._lastChar);
          if (typeof t2 !== "string")
            return t2.$add();
          this._identifierStr = t2 + t1;
          t1 = this._nextChar$0();
          this._lastChar = t1;
        }
        this._curTokenStr = t2;
        this._curToken = -10;
        this._lastChar = this._nextChar$0();
        return this._curToken;
      }
      if (J.$eq(this._lastChar, 39)) {
        t1 = this._nextChar$0();
        this._lastChar = t1;
        while (true) {
          t1 = !J.$eq(t1, 39) && !J.$eq(this._lastChar, 0);
          t2 = this._identifierStr;
          if (!t1)
            break;
          t1 = H.Primitives_stringFromCharCode(this._lastChar);
          if (typeof t2 !== "string")
            return t2.$add();
          this._identifierStr = t2 + t1;
          t1 = this._nextChar$0();
          this._lastChar = t1;
        }
        this._curTokenStr = t2;
        this._curToken = -10;
        this._lastChar = this._nextChar$0();
        return this._curToken;
      }
      if (this._isAlpha$1(this._lastChar)) {
        this._identifierStr = H.Primitives_stringFromCharCode(this._lastChar);
        t1 = this._nextChar$0();
        this._lastChar = t1;
        while (true) {
          if (!J.$eq(t1, 0)) {
            t1 = this._lastChar;
            t2 = J.getInterceptor$n(t1);
            if (!(t2.$ge(t1, 97) && t2.$le(t1, 122)))
              t3 = t2.$ge(t1, 65) && t2.$le(t1, 90);
            else
              t3 = true;
            if (!t3)
              t1 = t2.$ge(t1, 48) && t2.$le(t1, 57);
            else
              t1 = true;
          } else
            t1 = false;
          t1 = t1 || J.$eq(this._lastChar, 46) || J.$eq(this._lastChar, 95);
          t2 = this._identifierStr;
          if (!t1)
            break;
          t1 = H.Primitives_stringFromCharCode(this._lastChar);
          if (typeof t2 !== "string")
            return t2.$add();
          this._identifierStr = t2 + t1;
          t1 = this._nextChar$0();
          this._lastChar = t1;
        }
        this._curTokenStr = t2;
        this._curToken = -4;
        return -4;
      }
      if (J.$eq(this._lastChar, 45)) {
        t1 = this._peekNext$0();
        t2 = J.getInterceptor$n(t1);
        t1 = !(t2.$ge(t1, 48) && t2.$le(t1, 57)) && !J.$eq(this._peekNext$0(), 46);
      } else
        t1 = false;
      if (t1) {
        this._curToken = 45;
        this._curTokenStr = H.Primitives_stringFromCharCode(this._lastChar);
        return this._curToken;
      }
      if (!J.$eq(this._lastChar, 45)) {
        t1 = this._lastChar;
        t2 = J.getInterceptor$n(t1);
        t1 = t2.$ge(t1, 48) && t2.$le(t1, 57) || J.$eq(this._lastChar, 46);
      } else
        t1 = true;
      if (t1) {
        numStr = "";
        do {
          numStr += H.Primitives_stringFromCharCode(this._lastChar);
          t1 = this._nextChar$0();
          this._lastChar = t1;
          if (J.$eq(t1, 101) || J.$eq(this._lastChar, 96)) {
            numStr += H.Primitives_stringFromCharCode(this._lastChar);
            t1 = this._nextChar$0();
            this._lastChar = t1;
            if (J.$eq(t1, 43) || J.$eq(this._lastChar, 45)) {
              numStr += H.Primitives_stringFromCharCode(this._lastChar);
              this._lastChar = this._nextChar$0();
            }
          }
          if (!J.$eq(this._lastChar, 0)) {
            t1 = this._lastChar;
            t2 = J.getInterceptor$n(t1);
            t1 = t2.$ge(t1, 48) && t2.$le(t1, 57) || J.$eq(this._lastChar, 46);
          } else
            t1 = false;
        } while (t1);
        this._curTokenStr = numStr;
        this._numValue = H.Primitives_parseDouble(numStr, null);
        this._curToken = -5;
        return -5;
      }
      if (J.$eq(this._lastChar, 35)) {
        do {
          t1 = this._nextChar$0();
          this._lastChar = t1;
        } while (!J.$eq(t1, 0) && !J.$eq(this._lastChar, 10) && !J.$eq(this._lastChar, 13));
        if (!J.$eq(this._lastChar, 0)) {
          t1 = this.nextToken$0();
          this._curToken = t1;
          return t1;
        }
      }
      if (J.$eq(this._lastChar, 0)) {
        this._curToken = -1;
        return -1;
      }
      thisChar = this._lastChar;
      this._curTokenStr = H.Primitives_stringFromCharCode(thisChar);
      this._lastChar = this._nextChar$0();
      t1 = J.getInterceptor(thisChar);
      if (t1.$eq(thisChar, 61) && J.$eq(this._lastChar, 61)) {
        this._lastChar = this._nextChar$0();
        this._curTokenStr = "==";
        this._curToken = -6;
        return -6;
      } else if (t1.$eq(thisChar, 33) && J.$eq(this._lastChar, 61)) {
        this._lastChar = this._nextChar$0();
        this._curTokenStr = "!=";
        this._curToken = -7;
        return -7;
      } else if (t1.$eq(thisChar, 124) && J.$eq(this._lastChar, 124)) {
        this._lastChar = this._nextChar$0();
        this._curTokenStr = "||";
        this._curToken = -8;
        return -8;
      } else if (t1.$eq(thisChar, 38) && J.$eq(this._lastChar, 38)) {
        this._lastChar = this._nextChar$0();
        this._curTokenStr = "&&";
        this._curToken = -9;
        return -9;
      }
      this._curToken = thisChar;
      return thisChar;
    },
    _nextChar$0: function() {
      var t1, t2;
      t1 = this._inputStack;
      if (C.JSArray_methods.get$last(t1).get$isEOF()) {
        t2 = t1.length;
        if (t2 === 1)
          return 0;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t1.pop();
      }
      return C.JSArray_methods.get$last(t1).nextChar$0();
    },
    _peekNext$0: function() {
      var t1, len, t2, t3;
      t1 = this._inputStack;
      len = t1.length;
      for (t2 = len > 0, t3 = len - 1; t2;) {
        if (t3 < 0 || t3 >= t1.length)
          return H.ioore(t1, t3);
        if (!t1[t3].get$isEOF()) {
          if (t3 >= t1.length)
            return H.ioore(t1, t3);
          return t1[t3].peekNext$0();
        }
      }
      return 0;
    },
    _isAlpha$1: function(c) {
      var t1 = J.getInterceptor$n(c);
      if (!(t1.$ge(c, 97) && t1.$le(c, 122)))
        t1 = t1.$ge(c, 65) && t1.$le(c, 90);
      else
        t1 = true;
      return t1;
    },
    static: {"^": "PbrtLexer_TOKEN_EOF,PbrtLexer_TOKEN_IDENTIFIER,PbrtLexer_TOKEN_NUMBER,PbrtLexer_TOKEN_DOUBLE_EQUAL,PbrtLexer_TOKEN_NOT_EQUAL,PbrtLexer_TOKEN_DOUBLE_OR,PbrtLexer_TOKEN_DOUBLE_AND,PbrtLexer_TOKEN_STRING,PbrtLexer_TOKEN_SPACE,PbrtLexer_TOKEN_TAB,PbrtLexer_TOKEN_LINEFEED,PbrtLexer_TOKEN_NEWLINE,PbrtLexer_TOKEN_GREATER,PbrtLexer_TOKEN_LESS,PbrtLexer_TOKEN_LEFT_PAREN,PbrtLexer_TOKEN_RIGHT_PAREN,PbrtLexer_TOKEN_COMMA,PbrtLexer_TOKEN_SEMICOLON,PbrtLexer_TOKEN_PLUS,PbrtLexer_TOKEN_MINUS,PbrtLexer_TOKEN_MULTIPLY,PbrtLexer_TOKEN_DIVIDE,PbrtLexer_TOKEN_CARROT,PbrtLexer_TOKEN_PERCENT,PbrtLexer_TOKEN_HASH,PbrtLexer_TOKEN_NOT,PbrtLexer_TOKEN_OR,PbrtLexer_TOKEN_AND,PbrtLexer_TOKEN_QUESTION,PbrtLexer_TOKEN_COLON,PbrtLexer_TOKEN_DOT,PbrtLexer_TOKEN_DOUBLE_QUOTE,PbrtLexer_TOKEN_SINGLE_QUOTE,PbrtLexer_TOKEN_LEFT_BRACKET,PbrtLexer_TOKEN_RIGHT_BRACKET,PbrtLexer_TOKEN_UNDERSCORE,PbrtLexer_TOKEN_EQUAL,PbrtLexer_TOKEN_0,PbrtLexer_TOKEN_9,PbrtLexer_TOKEN_a,PbrtLexer_TOKEN_e,PbrtLexer_TOKEN_z,PbrtLexer_TOKEN_A,PbrtLexer_TOKEN_E,PbrtLexer_TOKEN_Z,PbrtLexer__EOF"}
  },
  _PbrtLexerInput: {
    "^": "Object;input,path>,line@,position",
    get$isEOF: function() {
      var t1, t2;
      t1 = this.position;
      t2 = J.get$length$asx(this.input);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 >= t2;
    },
    nextChar$0: function() {
      return J.$index$asx(this.input, this.position++);
    },
    peekNext$0: function() {
      return J.$index$asx(this.input, this.position);
    }
  },
  PbrtParser: {
    "^": "Object;pbrt,resourceManager",
    parse$1: function(file) {
      var t, t1, c;
      t = new P.Stopwatch(1000000, null, null);
      t.start$0(0);
      t1 = "LOADING Scene " + H.S(file);
      $.Log.call$2(0, t1);
      c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      this.resourceManager.requestFile$1(file).then$1(new U.PbrtParser_parse_closure(this, file, t, c));
      return c.future;
    },
    _loadIncludes$2: function(input, path) {
      var t1, _lexer, futures, paths, c, cmd, f, t2, result, result0;
      t1 = [];
      _lexer = new U.PbrtLexer(t1, null, null, 32, null, null);
      t1.push(new U._PbrtLexerInput(input, path, 0, 0));
      futures = [];
      paths = [];
      t1 = new P._Future(0, $.Zone__current, null, null, null, null, null, null);
      t1.$builtinTypeInfo = [null];
      c = new P._AsyncCompleter(t1);
      c.$builtinTypeInfo = [null];
      _lexer.nextToken$0();
      for (; !J.$eq(_lexer._curToken, -1);) {
        cmd = this._parseCommand$2(_lexer, futures);
        if (cmd == null) {
          _lexer.nextToken$0();
          continue;
        }
        t1 = cmd.$index(0, "name");
        t1.toString;
        if (t1.toLowerCase() === "include")
          if (!this.pbrt.resourceManager.resources.containsKey$1(cmd.$index(0, "value"))) {
            t1 = "LOADING INCLUDE " + H.S(cmd.$index(0, "value"));
            $.Log.call$2(4, t1);
            f = this.pbrt.resourceManager.requestFile$1(cmd.$index(0, "value"));
            futures.push(f);
            paths.push(cmd.$index(0, "value"));
            f.then$1(new U.PbrtParser__loadIncludes_closure(cmd));
          }
      }
      t1 = P.Future_wait(futures, false);
      t2 = $.Zone__current;
      t2.toString;
      result = new P._Future(0, t2, null, null, new U.PbrtParser__loadIncludes_closure0(this, c), null, P._registerErrorHandler(null, t2), null);
      result.$builtinTypeInfo = [null];
      t1._addListener$1(result);
      t1 = $.Zone__current;
      t2 = P._registerErrorHandler(new U.PbrtParser__loadIncludes_closure1(c), t1);
      t1.toString;
      result0 = new P._Future(0, t1, null, null, null, null, t2, null);
      result0.$builtinTypeInfo = [null];
      result._addListener$1(result0);
      return c.future;
    },
    _parse$2: function(input, path) {
      var t1, c, _lexer, cmd, t2, t3, t4, t5, m, lt, v, t6, t7, t8, t9, t10, t11, matName, mtl, tp, ft, st, vr, inc;
      t1 = "PARSING INPUT " + H.S(path);
      $.Log.call$2(4, t1);
      c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      t1 = [];
      _lexer = new U.PbrtLexer(t1, null, null, 32, null, null);
      t1.push(new U._PbrtLexerInput(input, path, 0, 0));
      _lexer.nextToken$0();
      for (; !J.$eq(_lexer._curToken, -1);) {
        cmd = this._parseCommand$2(_lexer, null);
        if (cmd == null) {
          _lexer.nextToken$0();
          continue;
        }
        t2 = cmd.$index(0, "name");
        t2.toString;
        switch (t2.toLowerCase()) {
          case "accelerator":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            t2 = t2._renderOptions;
            t2.acceleratorName = t3;
            t2.acceleratorParams = t4;
            break;
          case "activetransform":
            if (cmd.$index(0, "type") === "StartTime")
              this.pbrt._activeTransformBits = 1;
            else if (cmd.$index(0, "type") === "EndTime")
              this.pbrt._activeTransformBits = 2;
            else if (cmd.$index(0, "type") === "All")
              this.pbrt._activeTransformBits = 3;
            break;
          case "arealightsource":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            t2._graphicsState.set$areaLight(t3);
            t2._graphicsState.set$areaLightParams(t4);
            break;
          case "attributebegin":
            t2 = this.pbrt;
            t2._pushedGraphicsStates.push(U.GraphicsState$from(t2._graphicsState));
            t3 = t2._curTransform;
            t4 = Array(2);
            t4.fixed$length = init;
            t4.$builtinTypeInfo = [G.Transform];
            t5 = J.$index$asx(t3.get$t(), 0);
            t4[0] = new G.Transform(new G.Matrix4x4(new Float32Array(H._ensureNativeList(t5.get$m().get$m()))), new G.Matrix4x4(new Float32Array(H._ensureNativeList(t5.get$mInv().m))));
            t3 = J.$index$asx(t3.get$t(), 1);
            t4[1] = new G.Transform(new G.Matrix4x4(new Float32Array(H._ensureNativeList(t3.get$m().get$m()))), new G.Matrix4x4(new Float32Array(H._ensureNativeList(t3.get$mInv().m))));
            t2._pushedTransforms.push(new U.TransformSet(t4));
            t2._pushedActiveTransformBits.push(t2._activeTransformBits);
            break;
          case "attributeend":
            this.pbrt.attributeEnd$0();
            break;
          case "camera":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            t5 = t2._renderOptions;
            t5.cameraName = t3;
            t5.cameraParams = t4;
            t4 = U.TransformSet_Inverse(t2._curTransform);
            t5.cameraToWorld = t4;
            t2._namedCoordinateSystems.$indexSet(0, "camera", t4);
            break;
          case "coordinatesystem":
            t2 = this.pbrt;
            t2._namedCoordinateSystems.$indexSet(0, cmd.$index(0, "type"), t2._curTransform);
            break;
          case "coordsystransform":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = t2._namedCoordinateSystems;
            if (t4.containsKey$1(t3))
              t2._curTransform = t4.$index(0, t3);
            else {
              t2 = "Couldn't find named coordinate system '" + H.S(t3) + "'";
              $.Log.call$2(1, t2);
            }
            break;
          case "concattransform":
            if (!cmd.containsKey$1("values") || J.get$length$asx(cmd.$index(0, "values")) !== 16) {
              t2 = "ConcatTransform requires 16 values, " + J.get$length$asx(cmd.$index(0, "values")) + " found.";
              $.Log.call$2(1, t2);
            } else {
              m = G.Matrix4x4_Transpose(new G.Matrix4x4(new Float32Array(H._ensureNativeList(cmd.$index(0, "values")))));
              this.pbrt.concatTransform$1(m);
            }
            break;
          case "film":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t2 = t2._renderOptions;
            t2.filmParams = cmd.$index(0, "params");
            t2.filmName = t3;
            break;
          case "ident":
          case "identity":
            this.pbrt.identity$0();
            break;
          case "lightsource":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            lt = t2._makeLight$3(t3, J.$index$asx(t2._curTransform, 0), t4);
            if (lt == null) {
              t2 = "pbrtLightSource: light type '" + H.S(t3) + "' unknown.";
              $.Log.call$2(1, t2);
            } else
              t2._renderOptions.lights.push(lt);
            break;
          case "lookat":
            if (!cmd.containsKey$1("values") || J.get$length$asx(cmd.$index(0, "values")) !== 9)
              $.Log.call$2(1, "LookAt requires 9 values");
            else {
              v = cmd.$index(0, "values");
              t2 = this.pbrt;
              t3 = J.$index$asx(v, 0);
              t4 = v.length;
              if (1 >= t4)
                return H.ioore(v, 1);
              t5 = v[1];
              if (2 >= t4)
                return H.ioore(v, 2);
              t6 = v[2];
              if (3 >= t4)
                return H.ioore(v, 3);
              t7 = v[3];
              if (4 >= t4)
                return H.ioore(v, 4);
              t8 = v[4];
              if (5 >= t4)
                return H.ioore(v, 5);
              t9 = v[5];
              if (6 >= t4)
                return H.ioore(v, 6);
              t10 = v[6];
              if (7 >= t4)
                return H.ioore(v, 7);
              t11 = v[7];
              if (8 >= t4)
                return H.ioore(v, 8);
              t2.lookAt$9(t3, t5, t6, t7, t8, t9, t10, t11, v[8]);
            }
            break;
          case "makenamedmaterial":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "id");
            t4 = cmd.$index(0, "params");
            t5 = t2._graphicsState;
            t6 = t5.get$materialParams();
            t7 = t5.get$doubleTextures();
            t5 = t5.spectrumTextures;
            matName = t4.findOneString$2("type", t6.findOneString$2("type", ""));
            if (J.get$isEmpty$asx(matName) === true)
              $.Log.call$2(1, "No parameter string 'type' found in MakeNamedMaterial");
            else {
              mtl = t2._makeMaterial$3(matName, J.$index$asx(t2._curTransform, 0), new G.TextureParams(t7, t5, t4, t6));
              if (mtl != null)
                t2._graphicsState.get$namedMaterials().$indexSet(0, t3, mtl);
            }
            break;
          case "material":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            t2._graphicsState.set$material(t3);
            t2._graphicsState.set$materialParams(t4);
            t2._graphicsState.set$currentNamedMaterial("");
            break;
          case "namedmaterial":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t2._graphicsState.set$currentNamedMaterial(t3);
            break;
          case "objectbegin":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t2._pushedGraphicsStates.push(U.GraphicsState$from(t2._graphicsState));
            t4 = t2._curTransform;
            t5 = Array(2);
            t5.fixed$length = init;
            t5.$builtinTypeInfo = [G.Transform];
            t6 = J.$index$asx(t4.get$t(), 0);
            t5[0] = new G.Transform(new G.Matrix4x4(new Float32Array(H._ensureNativeList(t6.get$m().get$m()))), new G.Matrix4x4(new Float32Array(H._ensureNativeList(t6.get$mInv().m))));
            t4 = J.$index$asx(t4.get$t(), 1);
            t5[1] = new G.Transform(new G.Matrix4x4(new Float32Array(H._ensureNativeList(t4.get$m().get$m()))), new G.Matrix4x4(new Float32Array(H._ensureNativeList(t4.get$mInv().m))));
            t2._pushedTransforms.push(new U.TransformSet(t5));
            t2._pushedActiveTransformBits.push(t2._activeTransformBits);
            t2 = t2._renderOptions;
            if (t2.currentInstance != null)
              $.Log.call$2(1, "ObjectBegin called inside of instance definition");
            t4 = t2.instances;
            t5 = [];
            t5.$builtinTypeInfo = [G.Primitive];
            t4.$indexSet(0, t3, t5);
            t2.currentInstance = t4.$index(0, t3);
            break;
          case "objectend":
            t2 = this.pbrt;
            t3 = t2._renderOptions;
            if (t3.currentInstance == null)
              $.Log.call$2(1, "ObjectEnd called outside of instance definition");
            t3.currentInstance = null;
            t2.attributeEnd$0();
            break;
          case "objectinstance":
            this.pbrt.objectInstance$1(cmd.$index(0, "type"));
            break;
          case "pixelfilter":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            t2 = t2._renderOptions;
            t2.filterName = t3;
            t2.filterParams = t4;
            break;
          case "renderer":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            t2 = t2._renderOptions;
            t2.rendererName = t3;
            t2.rendererParams = t4;
            break;
          case "reverseorientation":
            t2 = this.pbrt._graphicsState;
            t2.set$reverseOrientation(t2.get$reverseOrientation() !== true);
            break;
          case "rotate":
            if (!cmd.containsKey$1("values") || J.get$length$asx(cmd.$index(0, "values")) !== 4)
              $.Log.call$2(1, "Rotate requires 4 values");
            else {
              v = cmd.$index(0, "values");
              t2 = this.pbrt;
              t3 = J.$index$asx(v, 0);
              t4 = v.length;
              if (1 >= t4)
                return H.ioore(v, 1);
              t5 = v[1];
              if (2 >= t4)
                return H.ioore(v, 2);
              t6 = v[2];
              if (3 >= t4)
                return H.ioore(v, 3);
              t2.rotate$4(0, t3, t5, t6, v[3]);
            }
            break;
          case "sampler":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            t2 = t2._renderOptions;
            t2.samplerName = t3;
            t2.samplerParams = t4;
            break;
          case "scale":
            if (!cmd.containsKey$1("values") || J.get$length$asx(cmd.$index(0, "values")) !== 3)
              $.Log.call$2(1, "Scale requires 3 values");
            else {
              v = cmd.$index(0, "values");
              t2 = this.pbrt;
              t3 = J.$index$asx(v, 0);
              t4 = v.length;
              if (1 >= t4)
                return H.ioore(v, 1);
              t5 = v[1];
              if (2 >= t4)
                return H.ioore(v, 2);
              t2.scale$3(0, t3, t5, v[2]);
            }
            break;
          case "shape":
            this.pbrt.shape$2(0, cmd.$index(0, "type"), cmd.$index(0, "params"));
            break;
          case "surfaceintegrator":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            t2 = t2._renderOptions;
            t2.surfIntegratorName = t3;
            t2.surfIntegratorParams = t4;
            break;
          case "texture":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "id");
            t4 = cmd.$index(0, "type");
            t5 = cmd.$index(0, "class");
            t6 = cmd.$index(0, "params");
            t7 = t2._graphicsState;
            t8 = t7.get$doubleTextures();
            t7 = t7.spectrumTextures;
            tp = new G.TextureParams(t8, t7, t6, t6);
            if (t4 === "float") {
              if (t8.containsKey$1(t3)) {
                t4 = "Texture '" + H.S(t3) + "' being redefined";
                $.Log.call$2(1, t4);
              }
              ft = t2._makeFloatTexture$3(t5, J.$index$asx(t2._curTransform, 0), tp);
              if (ft != null)
                t2._graphicsState.get$doubleTextures().$indexSet(0, t3, ft);
            } else if (t4 === "color" || t4 === "spectrum") {
              if (t7.containsKey$1(t3)) {
                t4 = "Texture '" + H.S(t3) + "' being redefined";
                $.Log.call$2(1, t4);
              }
              st = t2._makeSpectrumTexture$3(t5, J.$index$asx(t2._curTransform, 0), tp);
              if (st != null)
                t2._graphicsState.get$spectrumTextures().$indexSet(0, t3, st);
            } else {
              t2 = "Texture type '" + H.S(t4) + "' unknown.";
              $.Log.call$2(1, t2);
            }
            break;
          case "translate":
            if (!cmd.containsKey$1("values") || J.get$length$asx(cmd.$index(0, "values")) !== 3)
              $.Log.call$2(1, "Translate requires 3 values");
            else {
              v = cmd.$index(0, "values");
              t2 = this.pbrt;
              t3 = J.$index$asx(v, 0);
              t4 = v.length;
              if (1 >= t4)
                return H.ioore(v, 1);
              t5 = v[1];
              if (2 >= t4)
                return H.ioore(v, 2);
              t2.translate$3(0, t3, t5, v[2]);
            }
            break;
          case "transform":
            if (!cmd.containsKey$1("values") || J.get$length$asx(cmd.$index(0, "values")) !== 16)
              $.Log.call$2(1, "Transform requires 16 values");
            else {
              t2 = new Float32Array(H._ensureNativeList(cmd.$index(0, "values")));
              this.pbrt.transform$1(0, new G.Matrix4x4(t2));
            }
            break;
          case "transformbegin":
            t2 = this.pbrt;
            t2._pushedTransforms.push(t2._curTransform);
            t2._pushedActiveTransformBits.push(t2._activeTransformBits);
            break;
          case "transformend":
            this.pbrt.transformEnd$0();
            break;
          case "transformtimes":
            if (!cmd.containsKey$1("values") || J.get$length$asx(cmd.$index(0, "values")) !== 2)
              $.Log.call$2(1, "TransformTimes requires 2 values");
            else {
              v = cmd.$index(0, "values");
              t2 = this.pbrt;
              t3 = J.$index$asx(v, 0);
              if (1 >= v.length)
                return H.ioore(v, 1);
              t4 = v[1];
              t2 = t2._renderOptions;
              t2.transformStartTime = t3;
              t2.transformEndTime = t4;
            }
            break;
          case "volume":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            vr = t2._makeVolumeRegion$3(t3, J.$index$asx(t2._curTransform, 0), t4);
            if (vr != null)
              t2._renderOptions.volumeRegions.push(vr);
            break;
          case "volumeintegrator":
            t2 = this.pbrt;
            t3 = cmd.$index(0, "type");
            t4 = cmd.$index(0, "params");
            t2 = t2._renderOptions;
            t2.volIntegratorName = t3;
            t2.volIntegratorParams = t4;
            break;
          case "worldbegin":
            this.pbrt.worldBegin$0();
            break;
          case "worldend":
            this.pbrt.worldEnd$0();
            break;
          case "include":
            inc = this.pbrt.resourceManager.getResource$1(cmd.$index(0, "value"));
            t2 = H.checkSubtype(inc, "$isList", [J.JSInt], "$asList");
            if (t2)
              t1.push(new U._PbrtLexerInput(inc, cmd.$index(0, "value"), 0, 0));
            else {
              t2 = "MISSING include: " + H.S(cmd.$index(0, "value"));
              $.Log.call$2(1, t2);
            }
            break;
          default:
            t2 = "UNHANDLED command " + H.S(cmd.$index(0, "name"));
            $.Log.call$2(1, t2);
            break;
        }
      }
      P.Future_wait([], false).then$1(new U.PbrtParser__parse_closure(c));
      return c.future;
    },
    _parseCommand$2: function(_lexer, futures) {
      var cmd, t1, $name, params, tk, values, paramTypeName, array, paramValue, paramTk, t2;
      if (!J.$eq(_lexer._curToken, -4))
        return;
      cmd = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      cmd.$indexSet(0, "name", _lexer._curTokenStr);
      t1 = cmd.$index(0, "name");
      t1.toString;
      $name = t1.toLowerCase();
      if ($name === "include") {
        _lexer.nextToken$0();
        cmd.$indexSet(0, "value", _lexer._curTokenStr);
        return cmd;
      }
      if ($name === "activetransform") {
        _lexer.nextToken$0();
        cmd.$indexSet(0, "type", _lexer._curTokenStr);
        _lexer.nextToken$0();
        return cmd;
      }
      params = [];
      if ($name === "texture") {
        _lexer.nextToken$0();
        cmd.$indexSet(0, "id", _lexer._curTokenStr);
        _lexer.nextToken$0();
        cmd.$indexSet(0, "type", _lexer._curTokenStr);
        _lexer.nextToken$0();
        cmd.$indexSet(0, "class", _lexer._curTokenStr);
        tk = _lexer.nextToken$0();
      } else if ($name === "makenamedmaterial") {
        _lexer.nextToken$0();
        cmd.$indexSet(0, "id", _lexer._curTokenStr);
        tk = _lexer.nextToken$0();
      } else {
        tk = _lexer.nextToken$0();
        t1 = J.getInterceptor(tk);
        if (t1.$eq(tk, -4))
          return cmd;
        if (t1.$eq(tk, -10)) {
          cmd.$indexSet(0, "type", _lexer._curTokenStr);
          tk = _lexer.nextToken$0();
        } else if (t1.$eq(tk, 91)) {
          values = [];
          tk = _lexer.nextToken$0();
          while (true) {
            if (!(!J.$eq(tk, 93) && !J.$eq(_lexer._curToken, -1)))
              break;
            t1 = _lexer._numValue;
            if (t1 != null)
              values.push(t1);
            else
              values.push(_lexer._curTokenStr);
            tk = _lexer.nextToken$0();
          }
          cmd.$indexSet(0, "values", values);
        } else if (t1.$eq(tk, -5)) {
          values = [_lexer._numValue];
          tk = _lexer.nextToken$0();
          while (true) {
            if (!(J.$eq(tk, -5) && !J.$eq(_lexer._curToken, -1)))
              break;
            values.push(_lexer._numValue);
            tk = _lexer.nextToken$0();
          }
          cmd.$indexSet(0, "values", values);
        }
      }
      while (true) {
        if (!(J.$eq(tk, -10) && !J.$eq(_lexer._curToken, -1)))
          break;
        paramTypeName = _lexer._curTokenStr;
        if (J.$eq(_lexer.nextToken$0(), 91)) {
          array = [];
          tk = _lexer.nextToken$0();
          while (true) {
            if (!(!J.$eq(tk, 93) && !J.$eq(_lexer._curToken, -1)))
              break;
            array.push(_lexer._curTokenStr);
            tk = _lexer.nextToken$0();
          }
          paramValue = array;
        } else
          paramValue = [_lexer._curTokenStr];
        paramTk = paramTypeName.split(" ");
        H.IterableMixinWorkaround_removeWhereList(paramTk, new U.PbrtParser__parseCommand_closure());
        t1 = paramTk.length;
        if (t1 !== 2) {
          t1 = _lexer._inputStack;
          t1 = H.S(J.get$path$x(C.JSArray_methods.get$last(t1))) + " [" + C.JSArray_methods.get$last(t1).get$line() + "]: Expected Parameter \"Type Name\", found: \"" + paramTypeName + "\"";
          $.Log.call$2(1, t1);
          return cmd;
        }
        if (0 >= t1)
          return H.ioore(paramTk, 0);
        t2 = paramTk[0];
        if (1 >= t1)
          return H.ioore(paramTk, 1);
        params.push(P.LinkedHashMap_LinkedHashMap$_literal(["type", t2, "name", paramTk[1], "value", paramValue], null, null));
        tk = _lexer.nextToken$0();
      }
      if (params.length !== 0)
        cmd.$indexSet(0, "params", this._parseParameters$2(params, futures));
      else
        cmd.$indexSet(0, "params", new G.ParamSet([], [], [], [], [], [], [], [], []));
      return cmd;
    },
    _parseParameters$2: function(params, futures) {
      var t1, t2, t3, t4, t5, ps, t6, p, t7, v, t8, l, i, $name, t9;
      t1 = [];
      t2 = [];
      t3 = [];
      t4 = [];
      t5 = [];
      ps = new G.ParamSet(t1, t2, t3, [], [], [], [], t4, t5);
      for (t6 = new H.ListIterator(params, params.length, 0, null); t6.moveNext$0();) {
        p = t6._current;
        t7 = J.getInterceptor$asx(p);
        switch (t7.$index(p, "type")) {
          case "float":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            l = t8.get$length(v);
            if (typeof l !== "number")
              return H.iae(l);
            i = 0;
            for (; i < l; ++i)
              t8.$indexSet(v, i, H.Primitives_parseDouble(t8.$index(v, i), null));
            $name = J.toLowerCase$0$s(t7.$index(p, "name"));
            ps.eraseFloat$1($name);
            t3.push(new G.ParamSetItem($name, v, false));
            break;
          case "integer":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            l = t8.get$length(v);
            if (typeof l !== "number")
              return H.iae(l);
            i = 0;
            for (; i < l; ++i)
              t8.$indexSet(v, i, H.Primitives_parseInt(t8.$index(v, i), null, null));
            $name = J.toLowerCase$0$s(t7.$index(p, "name"));
            ps.eraseInt$1($name);
            t2.push(new G.ParamSetItem($name, v, false));
            break;
          case "rgb":
          case "color":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            l = t8.get$length(v);
            if (typeof l !== "number")
              return H.iae(l);
            i = 0;
            for (; i < l; ++i)
              t8.$indexSet(v, i, H.Primitives_parseDouble(t8.$index(v, i), null));
            ps.addRGBSpectrum$2(t7.$index(p, "name"), v);
            break;
          case "point":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            l = t8.get$length(v);
            if (typeof l !== "number")
              return H.iae(l);
            i = 0;
            for (; i < l; ++i)
              t8.$indexSet(v, i, H.Primitives_parseDouble(t8.$index(v, i), null));
            ps.addPoint$2(t7.$index(p, "name"), v);
            break;
          case "normal":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            l = t8.get$length(v);
            if (typeof l !== "number")
              return H.iae(l);
            i = 0;
            for (; i < l; ++i)
              t8.$indexSet(v, i, H.Primitives_parseDouble(t8.$index(v, i), null));
            ps.addNormal$2(t7.$index(p, "name"), v);
            break;
          case "vector":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            l = t8.get$length(v);
            if (typeof l !== "number")
              return H.iae(l);
            i = 0;
            for (; i < l; ++i)
              t8.$indexSet(v, i, H.Primitives_parseDouble(t8.$index(v, i), null));
            ps.addVector$2(t7.$index(p, "name"), v);
            break;
          case "string":
            t8 = t7.$index(p, "name");
            t7 = t7.$index(p, "value");
            $name = J.toLowerCase$0$s(t8);
            ps.eraseString$1($name);
            t4.push(new G.ParamSetItem($name, t7, false));
            break;
          case "texture":
            t8 = t7.$index(p, "name");
            t7 = t7.$index(p, "value");
            $name = J.toLowerCase$0$s(t8);
            ps.eraseTexture$1($name);
            t5.push(new G.ParamSetItem($name, t7, false));
            break;
          case "spectrum":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            if (t8.get$isNotEmpty(v)) {
              t9 = t8.$index(v, 0);
              if (typeof t9 === "string")
                ps.addSpectrumFiles$3(t7.$index(p, "name"), v, futures);
              else {
                if (J.$mod$n(t8.get$length(v), 2) !== 0) {
                  t9 = "Non-even number of values given with sampled spectrum parameter \"" + H.S(t7.$index(p, "name")) + "\". Ignoring extra.";
                  $.Log.call$2(1, t9);
                }
                l = t8.get$length(v);
                if (typeof l !== "number")
                  return H.iae(l);
                i = 0;
                for (; i < l; ++i)
                  t8.$indexSet(v, i, H.Primitives_parseDouble(t8.$index(v, i), null));
                ps.addSampledSpectrum$2(t7.$index(p, "name"), v);
              }
            }
            break;
          case "xyz":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            l = t8.get$length(v);
            if (typeof l !== "number")
              return H.iae(l);
            i = 0;
            for (; i < l; ++i)
              t8.$indexSet(v, i, H.Primitives_parseDouble(t8.$index(v, i), null));
            ps.addXYZSpectrum$2(t7.$index(p, "name"), v);
            break;
          case "blackbody":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            if (t8.get$isNotEmpty(v)) {
              l = t8.get$length(v);
              if (typeof l !== "number")
                return H.iae(l);
              i = 0;
              for (; i < l; ++i)
                t8.$indexSet(v, i, H.Primitives_parseDouble(t8.$index(v, i), null));
              ps.addBlackbodySpectrum$2(t7.$index(p, "name"), v);
            }
            break;
          case "bool":
            v = t7.$index(p, "value");
            t8 = J.getInterceptor$asx(v);
            l = t8.get$length(v);
            if (typeof l !== "number")
              return H.iae(l);
            i = 0;
            for (; i < l; ++i)
              if (J.toLowerCase$0$s(t8.$index(v, i)) === "false")
                t8.$indexSet(v, i, false);
              else if (J.toLowerCase$0$s(t8.$index(v, i)) === "true")
                t8.$indexSet(v, i, true);
              else {
                t9 = "Invalid boolean value \"" + H.S(t8.$index(v, i)) + "\".";
                $.Log.call$2(1, t9);
                t8.$indexSet(v, i, false);
              }
            $name = J.toLowerCase$0$s(t7.$index(p, "name"));
            ps.eraseBool$1($name);
            t1.push(new G.ParamSetItem($name, v, false));
            break;
          default:
            t7 = "Unhandled parameter type " + H.S(t7.$index(p, "type"));
            $.Log.call$2(1, t7);
            break;
        }
      }
      return ps;
    }
  },
  PbrtParser_parse_closure: {
    "^": "Closure:122;this_0,file_1,t_2,c_3",
    call$1: function(input) {
      var t1, t2;
      t1 = this.file_1;
      t2 = "FINISHED " + H.S(t1) + ". Scanning for includes.";
      $.Log.call$2(4, t2);
      t2 = this.this_0;
      t2._loadIncludes$2(input, t1).then$1(new U.PbrtParser_parse__closure(t2, t1, this.t_2, this.c_3, input));
    }
  },
  PbrtParser_parse__closure: {
    "^": "Closure:88;this_4,file_5,t_6,c_7,input_8",
    call$1: function(_) {
      $.Log.call$2(4, "FINISHED Includes. Parsing.");
      this.this_4._parse$2(this.input_8, this.file_5).then$1(new U.PbrtParser_parse___closure(this.t_6, this.c_7));
    }
  },
  PbrtParser_parse___closure: {
    "^": "Closure:88;t_9,c_10",
    call$1: function(_) {
      var t1 = this.t_9;
      t1.stop$0(0);
      t1 = "FINISHED Parsing Scene: " + P.Duration$(0, 0, C.JSNumber_methods.$tdiv(t1.get$elapsedTicks() * 1000000, t1.frequency), 0, 0, 0).toString$0(0);
      $.Log.call$2(0, t1);
      t1 = this.c_10.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  PbrtParser__loadIncludes_closure: {
    "^": "Closure:88;cmd_0",
    call$1: function(_) {
      var t1 = "FINISHED INCLUDE " + H.S(this.cmd_0.$index(0, "value"));
      $.Log.call$2(4, t1);
    }
  },
  PbrtParser__loadIncludes_closure0: {
    "^": "Closure:123;this_1,c_2",
    call$1: function(responses) {
      var subFutures, t1, t2, i, t3, inc;
      $.Log.call$2(4, "LOADING SUB-INCLUDES");
      subFutures = [];
      t1 = J.getInterceptor$asx(responses);
      if (t1.get$isNotEmpty(responses)) {
        t2 = this.this_1;
        i = 0;
        while (true) {
          t3 = t1.get$length(responses);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          inc = t1.$index(responses, i);
          if (inc != null && J.get$isNotEmpty$asx(inc))
            subFutures.push(t2._loadIncludes$2(inc, "@"));
          ++i;
        }
        t1 = this.c_2;
        P.Future_wait(subFutures, false).then$1(new U.PbrtParser__loadIncludes__closure(t1)).catchError$1(new U.PbrtParser__loadIncludes__closure0(t1));
      } else {
        t1 = this.c_2.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(null);
      }
    }
  },
  PbrtParser__loadIncludes__closure: {
    "^": "Closure:123;c_3",
    call$1: function(subResponses) {
      var t1;
      $.Log.call$2(4, "FINISHED SUB-INCLUDES");
      t1 = this.c_3.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  PbrtParser__loadIncludes__closure0: {
    "^": "Closure:88;c_4",
    call$1: function(e) {
      $.Log.call$2(2, e);
      this.c_4.completeError$1(e);
    }
  },
  PbrtParser__loadIncludes_closure1: {
    "^": "Closure:88;c_5",
    call$1: function(e) {
      var t1 = J.toString$0(e);
      $.Log.call$2(2, t1);
      this.c_5.completeError$1(e);
    }
  },
  PbrtParser__parse_closure: {
    "^": "Closure:88;c_0",
    call$1: function(e) {
      var t1 = this.c_0.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  PbrtParser__parseCommand_closure: {
    "^": "Closure:88;",
    call$1: function(e) {
      return J.get$isEmpty$asx(e);
    }
  },
  RenderIsolate: {
    "^": "Object;CONNECTING,CONNECTED,STOPPED,status,taskNum,taskCount,receivePort,sendPort,manager,rng,requests",
    start$1: [function(_, port) {
      var t1;
      $.Log = this.get$_log();
      this.status = this.CONNECTING;
      t1 = P.ReceivePort_ReceivePort();
      this.receivePort = t1;
      this.sendPort = port;
      J.send$1$x(port, new H._NativeJsSendPort(t1._rawPort, init.globalState.currentContext.id));
      t1 = this.receivePort._controller;
      t1.toString;
      H.setRuntimeTypeInfo(new P._ControllerStream(t1), [null]).listen$4$cancelOnError$onDone$onError(new U.RenderIsolate_start_closure(this), null, null, null);
    }, "call$1", "get$start", 2, 0, 124],
    _log$2: [function(type, msg) {
      var t1, timestamp;
      t1 = new P.DateTime(Date.now(), false);
      t1.DateTime$_now$0();
      timestamp = C.JSString_methods.substring$1(t1.toString$0(0), 11);
      t1 = this.sendPort;
      if (type >>> 0 !== type || type >= 5)
        return H.ioore(C.List_UgT, type);
      J.send$1$x(t1, H.S(C.List_UgT[type]) + " [THREAD " + H.S(this.taskNum) + "/" + H.S(this.taskCount) + "]: " + timestamp + " : " + H.S(msg));
    }, "call$2", "get$_log", 4, 0, 9],
    _render$6: function(w, h, scene, taskNum, taskCount, doPreview) {
      var timer, img, pbrt, e, timer0, t1, t2, t3, t4, exception;
      this._log$2(0, "RENDER " + H.S(w) + "x" + H.S(h));
      timer0 = new P.Stopwatch(1000000, null, null);
      timer0.start$0(0);
      timer = timer0;
      img = U.Image$(w, h, 4);
      t1 = img;
      t2 = J.getInterceptor$x(t1);
      J.fillRange$3$ax(t2.get$data(t1), 0, t2.get$data(t1).length, 4278190080);
      t1 = U.TransformSet$();
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t3 = U.RenderOptions$();
      t4 = new U.GraphicsState(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), new G.ParamSet([], [], [], [], [], [], [], [], []), null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, new G.ParamSet([], [], [], [], [], [], [], [], []), "", null);
      t4.material = "matte";
      t4.reverseOrientation = false;
      U.Pbrt__registerStandardNodes();
      pbrt = new U.Pbrt(this.manager, 1, t1, 3, t2, t3, t4, [], [], [], null, null);
      if (doPreview === true)
        pbrt.get$_renderOptions().previewCallback = new U.RenderIsolate__render_closure(this);
      try {
        t1 = pbrt;
        t1.get$_renderOptions().taskNum = taskNum;
        t1._renderOptions.taskCount = taskCount;
        pbrt.renderScene$2(scene, img).then$1(new U.RenderIsolate__render_closure0(this, taskNum, timer));
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        J.send$1$x(this.sendPort, P.LinkedHashMap_LinkedHashMap$_literal(["cmd", "error", "msg", J.toString$0(e)], null, null));
        return false;
      }

      return true;
    }
  },
  RenderIsolate_start_closure: {
    "^": "Closure:88;this_0",
    call$1: function(msg) {
      var t1, t2, cmd, t3, id, c, w, h, scene, doPreview;
      t1 = this.this_0;
      t2 = t1.status;
      if (t2 === t1.CONNECTING) {
        if (J.$eq(msg, "ping")) {
          J.send$1$x(t1.sendPort, "pong");
          t1.status = t1.CONNECTED;
        }
      } else if (t2 === t1.CONNECTED) {
        t2 = J.getInterceptor(msg);
        if (!!t2.$isMap) {
          if (msg.containsKey$1("cmd") === true) {
            cmd = t2.$index(msg, "cmd");
            t3 = J.getInterceptor(cmd);
            if (t3.$eq(cmd, "request")) {
              id = t2.$index(msg, "id");
              t1 = t1.requests;
              if (t1.containsKey$1(id)) {
                c = t1.$index(0, id);
                t1.remove$1(0, id);
                t1 = t2.$index(msg, "data");
                t2 = c.future;
                if (t2._state !== 0)
                  H.throwExpression(P.StateError$("Future already completed"));
                t2._asyncComplete$1(t1);
              }
            } else if (t3.$eq(cmd, "render")) {
              t1.taskNum = msg.containsKey$1("taskNum") === true ? t2.$index(msg, "taskNum") : 0;
              t1.taskCount = msg.containsKey$1("taskCount") === true ? t2.$index(msg, "taskCount") : 1;
              w = msg.containsKey$1("width") === true ? t2.$index(msg, "width") : 256;
              h = msg.containsKey$1("height") === true ? t2.$index(msg, "height") : 256;
              scene = msg.containsKey$1("scene") === true ? t2.$index(msg, "scene") : "";
              doPreview = msg.containsKey$1("preview") === true && t2.$index(msg, "preview");
              t1._render$6(w, h, scene, t1.taskNum, t1.taskCount, doPreview);
            }
          }
        } else if (t2.$eq(msg, "quit")) {
          t1.status = t1.STOPPED;
          t1 = t1.receivePort;
          t1._rawPort.close$0(0);
          t1._controller.close$0(0);
        }
      }
    }
  },
  RenderIsolate__render_closure: {
    "^": "Closure:125;this_0",
    call$1: function(img) {
      J.send$1$x(this.this_0.sendPort, P.LinkedHashMap_LinkedHashMap$_literal(["cmd", "preview", "image", img.getBytes$0()], null, null));
    }
  },
  RenderIsolate__render_closure0: {
    "^": "Closure:88;this_1,taskNum_2,timer_3",
    call$1: function(output) {
      var t1, t2;
      t1 = this.this_1;
      t2 = this.timer_3;
      t1._log$2(0, "FINISHED: " + P.Duration$(0, 0, C.JSNumber_methods.$tdiv(t2.get$elapsedTicks() * 1000000, t2.frequency), 0, 0, 0).toString$0(0));
      t2 = "[" + H.S(this.taskNum_2) + "] STATS:\n" + G.Stats_getString();
      $.Log.call$2(0, t2);
      J.send$1$x(t1.sendPort, P.LinkedHashMap_LinkedHashMap$_literal(["cmd", "final", "output", output.get$rgb()], null, null));
    }
  },
  RenderManagerInterface: {
    "^": "ResourceManager;"
  },
  RenderOptions: {
    "^": "Object;transformStartTime,transformEndTime,filterName,filterParams,filmName,filmParams,outputImage,previewCallback,samplerName,samplerParams,acceleratorName,acceleratorParams,rendererName,surfIntegratorName,volIntegratorName,rendererParams,surfIntegratorParams,volIntegratorParams,cameraName,cameraParams,cameraToWorld,lights,primitives,volumeRegions,instances,currentInstance,taskNum,taskCount",
    RenderOptions$0: function() {
      this.transformStartTime = 0;
      this.transformEndTime = 1;
      this.filterName = "box";
      this.filmName = "image";
      this.samplerName = "lowdiscrepancy";
      this.acceleratorName = "bvh";
      this.rendererName = "sampler";
      this.surfIntegratorName = "directlighting";
      this.volIntegratorName = "emission";
      this.cameraName = "perspective";
      this.currentInstance = null;
      this.taskNum = 0;
      this.taskCount = 1;
    },
    static: {RenderOptions$: function() {
        var t1 = new U.RenderOptions(null, null, null, new G.ParamSet([], [], [], [], [], [], [], [], []), null, new G.ParamSet([], [], [], [], [], [], [], [], []), null, null, null, new G.ParamSet([], [], [], [], [], [], [], [], []), null, new G.ParamSet([], [], [], [], [], [], [], [], []), null, null, null, new G.ParamSet([], [], [], [], [], [], [], [], []), new G.ParamSet([], [], [], [], [], [], [], [], []), new G.ParamSet([], [], [], [], [], [], [], [], []), null, new G.ParamSet([], [], [], [], [], [], [], [], []), null, [], [], [], P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null);
        t1.RenderOptions$0();
        return t1;
      }}
  },
  TransformSet: {
    "^": "Object;t<",
    $index: function(_, i) {
      var t1 = this.t;
      if (i >>> 0 !== i || i >= 2)
        return H.ioore(t1, i);
      return t1[i];
    },
    $indexSet: function(_, i, transform) {
      var t1 = this.t;
      if (i >>> 0 !== i || i >= 2)
        return H.ioore(t1, i);
      t1[i] = transform;
    },
    isAnimated$0: function() {
      var i, t1, i0;
      for (i = 0; i < 1; i = i0) {
        t1 = this.t;
        i0 = i + 1;
        if (!J.$eq(t1[i], t1[i0]))
          return true;
      }
      return false;
    },
    TransformSet$0: function() {
      for (var i = 0; i < 2; ++i)
        this.t[i] = G.Transform$(null, null);
    },
    static: {TransformSet$: function() {
        var t1 = Array(2);
        t1.fixed$length = init;
        t1 = new U.TransformSet(H.setRuntimeTypeInfo(t1, [G.Transform]));
        t1.TransformSet$0();
        return t1;
      }, TransformSet_Inverse: function(ts) {
        var t2, i, t1, t3;
        t2 = U.TransformSet$();
        for (i = 0; i < 2; ++i) {
          t1 = t2.t;
          t3 = J.$index$asx(ts.get$t(), i);
          t1[i] = G.Transform$(t3.get$mInv(), t3.m);
        }
        return t2;
      }}
  }
}],
["renderers", "package:dartray/renderers/renderers.dart", , Y, {
  "^": "",
  AggregateTestRenderer: {
    "^": "Renderer;nIterations,primitives,bboxes",
    render$1: function(scene) {
      var rng, bbox, t1, t2, lastHit, lastEps, i, v, t3, t4, v0, t5, t6, v1, t7, t8, org, dir, eps, rayAccel, rayAll, isectAccel, isectAll, hit, hitAll, inconsistentBounds, j;
      rng = new G.RNG(null, new Uint32Array(624), null);
      rng.mti = 625;
      rng.seed$1(0, 5489);
      bbox = G.BBox$from(scene.worldBound);
      bbox.expand$1(0, J.$sub$n(bbox.pMax.$index(0, bbox.maximumExtent$0()), bbox.pMin.$index(0, bbox.maximumExtent$0())));
      t1 = this.nIterations;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.bboxes;
      lastHit = null;
      lastEps = 0;
      i = 0;
      for (; i < t1; ++i) {
        v = (rng.randomUInt$0() & 16777215) / 16777216;
        t3 = bbox.pMin.x;
        t4 = bbox.pMax.x;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof t4 !== "number")
          return H.iae(t4);
        v0 = (rng.randomUInt$0() & 16777215) / 16777216;
        t5 = bbox.pMin.y;
        t6 = bbox.pMax.y;
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof t6 !== "number")
          return H.iae(t6);
        v1 = (rng.randomUInt$0() & 16777215) / 16777216;
        t7 = bbox.pMin.z;
        t8 = bbox.pMax.z;
        if (typeof t7 !== "number")
          return H.iae(t7);
        if (typeof t8 !== "number")
          return H.iae(t8);
        org = new G.Point((1 - v) * t3 + v * t4, (1 - v0) * t5 + v0 * t6, (1 - v1) * t7 + v1 * t8);
        if (C.JSInt_methods.$mod(rng.randomUInt$0(), 4) === 0)
          org = lastHit;
        dir = G.UniformSampleSphere((rng.randomUInt$0() & 16777215) / 16777216, (rng.randomUInt$0() & 16777215) / 16777216);
        if (C.JSInt_methods.$mod(rng.randomUInt$0(), 32) === 0) {
          dir.y = 0;
          dir.x = 0;
        } else if (C.JSInt_methods.$mod(rng.randomUInt$0(), 32) === 0) {
          dir.z = 0;
          dir.x = 0;
        } else if (C.JSInt_methods.$mod(rng.randomUInt$0(), 32) === 0) {
          dir.z = 0;
          dir.y = 0;
        }
        if ((rng.randomUInt$0() & 16777215) / 16777216 < 0.25)
          eps = lastEps;
        else
          eps = (rng.randomUInt$0() & 16777215) / 16777216 < 0.25 ? 0.001 : 0;
        t3 = org == null ? new G.Point(0, 0, 0) : new G.Point(org.x, org.y, org.z);
        t4 = new G.Vector(dir.x, dir.y, dir.z);
        rayAccel = new G.Ray(t3, t4, eps, 1 / 0, 0, 0);
        rayAll = new G.Ray(new G.Point(t3.x, t3.y, t3.z), new G.Vector(t4.x, t4.y, t4.z), eps, 1 / 0, 0, 0);
        isectAccel = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
        isectAccel.primitive = null;
        isectAccel.shapeId = 0;
        isectAccel.primitiveId = 0;
        isectAccel.rayEpsilon = 0;
        isectAll = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
        isectAll.primitive = null;
        isectAll.shapeId = 0;
        isectAll.primitiveId = 0;
        isectAll.rayEpsilon = 0;
        hit = scene.aggregate.intersect$2(rayAccel, isectAccel);
        t4 = $.get$Stats_nonShadowRays();
        t4.count = J.$add$ns(t4.count, 1);
        $.Stats_nonShadowRays = t4;
        for (hitAll = false, inconsistentBounds = false, j = 0; j < this.primitives.length; ++j) {
          if (j >= t2.length)
            return H.ioore(t2, j);
          if (t2[j].intersectP$1(rayAll)) {
            t3 = this.primitives;
            if (j >= t3.length)
              return H.ioore(t3, j);
            hitAll = t3[j].intersect$2(rayAll, isectAll) || hitAll;
          } else {
            t3 = this.primitives;
            if (j >= t3.length)
              return H.ioore(t3, j);
            if (t3[j].intersect$2(rayAll, isectAll))
              inconsistentBounds = true;
          }
        }
        if (!inconsistentBounds)
          t3 = hit !== hitAll || !J.$eq(rayAccel.maxDistance, rayAll.maxDistance);
        else
          t3 = false;
        if (t3)
          ;
        if (hitAll) {
          t3 = rayAll.maxDistance;
          t3 = J.$add$ns(rayAll.origin, J.$mul$ns(rayAll.direction, t3));
          t4 = J.getInterceptor$x(t3);
          lastHit = new G.Point(t4.get$x(t3), t4.get$y(t3), t4.get$z(t3));
          lastEps = isectAll.rayEpsilon;
        }
      }
      return;
    },
    Li$6: function(scene, ray, sample, rng, isect, $T) {
      return G.Spectrum_Spectrum(0);
    },
    AggregateTestRenderer$2: function(nIterations, p) {
      var i, t1, t2;
      for (i = 0; i < p.length; ++i)
        p[i].fullyRefine$1(this.primitives);
      for (t1 = this.bboxes, i = 0; t2 = this.primitives, i < t2.length; ++i)
        t1.push(t2[i].worldBound$0());
    },
    static: {AggregateTestRenderer$: function(nIterations, p) {
        var t1 = new Y.AggregateTestRenderer(nIterations, [], []);
        t1.AggregateTestRenderer$2(nIterations, p);
        return t1;
      }}
  },
  MetropolisRenderer: {
    "^": "Renderer;taskNum,taskCount,camera,bidirectional,nDirectPixelSamples,nPixelSamples,maxDepth,largeStepsPerPixel,nBootstrap,maxConsecutiveRejects,directLighting",
    render$1: function(scene) {
      var extent, t1, t00, t10, lightDistribution, t, t2, sampler, t3, rng, cameraPath, lightPath, t4, i, t5, t6, bootstrapI, sample, sumI, v, v0, t7, t8, $L, I, b, contribOffset, initialSample, nTasks, largeStepRate, scramble, d, task;
      if (scene.lights.length > 0) {
        extent = [0, 0, 0, 0];
        t1 = this.camera;
        t1.get$film().getPixelExtent$1(extent);
        t00 = t1.get$shutterOpen();
        t10 = t1.shutterClose;
        lightDistribution = G.Integrator_ComputeLightSamplingCDF(scene);
        if (this.directLighting != null) {
          t = new P.Stopwatch(1000000, null, null);
          t.start$0(0);
          $.Log.call$2(0, "Metropolis: Starting Direct Lighting Render");
          t2 = this.nDirectPixelSamples;
          if (J.$gt$n(t2, 0)) {
            sampler = U.LowDiscrepancySampler$(extent[0], extent[1], extent[2], extent[3], t2, t00, t10);
            new Y._SamplerRendererTask(scene, this, t1, sampler, G.Sample$(sampler, this.directLighting, null, scene), this.taskNum, this.taskCount).run$0();
          }
          t1.film.writeImage$0();
          t2 = "Metropolis:Finished Direct Lighting Render: " + P.Duration$(0, 0, C.JSNumber_methods._tdivFast$1(t.get$elapsedTicks() * 1000000, 1000000), 0, 0, 0).toString$0(0);
          $.Log.call$2(0, t2);
        }
        t = new P.Stopwatch(1000000, null, null);
        t.start$0(0);
        t2 = this.nBootstrap;
        t3 = "Metropolis: Starting Bootstrap: " + H.S(t2);
        $.Log.call$2(0, t3);
        rng = new G.RNG(null, new Uint32Array(624), null);
        rng.mti = 625;
        rng.seed$1(0, 0);
        t3 = this.maxDepth;
        if (typeof t3 !== "number")
          return H.iae(t3);
        cameraPath = H.setRuntimeTypeInfo(Array(t3), [Y._PathVertex]);
        t3 = this.maxDepth;
        if (typeof t3 !== "number")
          return H.iae(t3);
        lightPath = H.setRuntimeTypeInfo(Array(t3), [Y._PathVertex]);
        t3 = cameraPath.length;
        t4 = lightPath.length;
        i = 0;
        while (true) {
          t5 = this.maxDepth;
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(i < t5))
            break;
          t5 = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
          t5.primitive = null;
          t5.shapeId = 0;
          t5.primitiveId = 0;
          t5.rayEpsilon = 0;
          t6 = G.Spectrum_Spectrum(0);
          if (i >= t3)
            return H.ioore(cameraPath, i);
          cameraPath[i] = new Y._PathVertex(t5, new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), null, null, null, t6);
          t6 = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
          t6.primitive = null;
          t6.shapeId = 0;
          t6.primitiveId = 0;
          t6.rayEpsilon = 0;
          t5 = G.Spectrum_Spectrum(0);
          if (i >= t4)
            return H.ioore(lightPath, i);
          lightPath[i] = new Y._PathVertex(t6, new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), null, null, null, t5);
          ++i;
        }
        if (typeof t2 !== "number" || Math.floor(t2) !== t2)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t2)));
        bootstrapI = new Float32Array(t2);
        sample = Y._MLTSample$(this.maxDepth);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = this.bidirectional;
        t4 = bootstrapI.length;
        sumI = 0;
        i = 0;
        for (; i < t2; ++i) {
          v = (rng.randomUInt$0() & 16777215) / 16777216;
          t5 = extent[0];
          t6 = extent[1];
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (typeof t6 !== "number")
            return H.iae(t6);
          v0 = (rng.randomUInt$0() & 16777215) / 16777216;
          t7 = extent[2];
          t8 = extent[3];
          if (typeof t7 !== "number")
            return H.iae(t7);
          if (typeof t8 !== "number")
            return H.iae(t8);
          Y.MetropolisRenderer_LargeStep(rng, sample, this.maxDepth, (1 - v) * t5 + v * t6, (1 - v0) * t7 + v0 * t8, t00, t10, t3);
          $L = this.pathL$7(sample, scene, t1, lightDistribution, cameraPath, lightPath, rng);
          I = $L.get$y($L);
          if (typeof I !== "number")
            return H.iae(I);
          sumI += I;
          if (i >= t4)
            return H.ioore(bootstrapI, i);
          bootstrapI[i] = I;
        }
        b = sumI / t2;
        t5 = "Metropolis: Finished Bootstrap: " + P.Duration$(0, 0, C.JSNumber_methods.$tdiv(t.get$elapsedTicks() * 1000000, t.frequency), 0, 0, 0).toString$0(0);
        $.Log.call$2(0, t5);
        t5 = "MLT computed b = " + H.S(b);
        $.Log.call$2(0, t5);
        contribOffset = rng.randomFloat$0() * sumI;
        rng.seed$1(0, 0);
        initialSample = Y._MLTSample$(this.maxDepth);
        for (sumI = 0, i = 0; i < t2; ++i) {
          v = (rng.randomUInt$0() & 16777215) / 16777216;
          t5 = extent[0];
          t6 = extent[1];
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (typeof t6 !== "number")
            return H.iae(t6);
          v0 = (rng.randomUInt$0() & 16777215) / 16777216;
          t7 = extent[2];
          t8 = extent[3];
          if (typeof t7 !== "number")
            return H.iae(t7);
          if (typeof t8 !== "number")
            return H.iae(t8);
          Y.MetropolisRenderer_LargeStep(rng, initialSample, this.maxDepth, (1 - v) * t5 + v * t6, (1 - v0) * t7 + v0 * t8, t00, t10, t3);
          if (i >= t4)
            return H.ioore(bootstrapI, i);
          sumI += bootstrapI[i];
          if (sumI > contribOffset)
            break;
        }
        nTasks = this.largeStepsPerPixel;
        largeStepRate = J.$tdiv$n(this.nPixelSamples, nTasks);
        t2 = "MLT running " + H.S(nTasks) + " tasks, large step rate " + H.S(largeStepRate);
        $.Log.call$2(0, t2);
        scramble = [rng.randomUInt$0(), rng.randomUInt$0()];
        if (typeof nTasks !== "number")
          return H.iae(nTasks);
        i = 0;
        for (; i < nTasks; ++i) {
          t = new P.Stopwatch(1000000, null, null);
          t.start$0(0);
          t2 = "Metropolis: Task " + i;
          $.Log.call$2(0, t2);
          d = [0, 0];
          d[0] = G.VanDerCorput(0, scramble[0]);
          t2 = G.Sobol2(0, scramble[1]);
          d[1] = t2;
          task = new Y._MLTTask(i, d[0], t2, null, extent[0], extent[1], extent[2], extent[3], t00, t10, b, initialSample, scene, t1, this, lightDistribution);
          task.currentPixelSample = 0;
          task.run$0();
          t2 = "Metropolis: Finished Task " + i + ": " + new P.Duration(0 + C.JSNumber_methods._tdivFast$1(t.get$elapsedTicks() * 1000000, 1000000)).toString$0(0);
          $.Log.call$2(0, t2);
        }
      }
      return this.camera.get$film().writeImage$0();
    },
    Li$6: function(scene, ray, sample, rng, isect, $T) {
      var localIsect, Lo, t1, i;
      localIsect = G.Intersection$();
      if (isect == null)
        isect = localIsect;
      Lo = G.Spectrum_Spectrum(0);
      if (scene.intersect$2(ray, isect))
        Lo = this.directLighting.Li$6(scene, this, ray, isect, sample, rng);
      else
        for (t1 = scene.lights, i = 0; i < t1.length; ++i)
          Lo = Lo.$add(0, t1[i].Le$1(ray));
      return Lo;
    },
    Li$4: function(scene, ray, sample, rng) {
      return this.Li$6(scene, ray, sample, rng, null, null);
    },
    transmittance$4: function(scene, ray, sample, rng) {
      return G.Spectrum_Spectrum(1);
    },
    pathL$7: function(sample, scene, camera, lightDistribution, cameraPath, lightPath, rng) {
      var t1, t2, cameraRay, cameraWt, t3, escapedRay, escapedAlpha, cameraLength, lightPdf, lightRayPdf, lightNum, light, lightRay, Nl, t4, t5, t6, lrs, lightWt, t7, t8, t9, t10, t11;
      sample.get$cameraSample();
      t1 = $.get$Stats_cameraRays();
      t1.count = J.$add$ns(t1.count, 1);
      $.Stats_cameraRays = t1;
      t1 = new G.Point(0, 0, 0);
      t2 = new G.Vector(0, 0, 0);
      cameraRay = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t1, t2, 0, 1 / 0, 0, 0);
      t2 = sample.cameraSample;
      cameraWt = camera.generateRayDifferential$2(t2, cameraRay);
      t1 = this.nPixelSamples;
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      cameraRay.scaleDifferentials$1(1 / Math.sqrt(t1));
      t1 = new G.Point(0, 0, 0);
      t3 = new G.Vector(0, 0, 0);
      escapedRay = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t1, t3, 0, 1 / 0, 0, 0);
      escapedAlpha = G.Spectrum_Spectrum(0);
      cameraLength = Y.MetropolisRenderer_GeneratePath(cameraRay, G.Spectrum_Spectrum(cameraWt), scene, sample.cameraPathSamples, cameraPath, escapedRay, escapedAlpha);
      if (this.bidirectional !== true)
        return this.Lpath$9(scene, cameraPath, cameraLength, sample.lightingSamples, rng, t2.time, lightDistribution, escapedRay, escapedAlpha);
      else {
        lightPdf = [0];
        lightRayPdf = [0];
        lightNum = lightDistribution.sampleDiscrete$2(sample.lightNumSample, lightPdf);
        t1 = scene.lights;
        if (lightNum >>> 0 !== lightNum || lightNum >= t1.length)
          return H.ioore(t1, lightNum);
        light = t1[lightNum];
        t1 = new G.Point(0, 0, 0);
        t3 = new G.Vector(0, 0, 0);
        lightRay = new G.Ray(t1, t3, 0, 1 / 0, 0, 0);
        Nl = new G.Normal(0, 0, 0);
        t3 = sample.lightRaySamples;
        t1 = t3[0];
        t4 = t3[1];
        t5 = t3[2];
        t6 = Array(2);
        t6.$builtinTypeInfo = [J.JSDouble];
        lrs = new G.LightSample(t6, 0);
        t6[0] = t1;
        t6[1] = t4;
        lrs.uComponent = t5;
        lightWt = light.sampleL$8(scene, lrs, t3[3], t3[4], t2.time, lightRay, Nl, lightRayPdf);
        if (lightWt.isBlack$0() || J.$eq(lightRayPdf[0], 0))
          return this.Lpath$9(scene, cameraPath, cameraLength, sample.lightingSamples, rng, t2.time, lightDistribution, escapedRay, escapedAlpha);
        else {
          t1 = Nl.x;
          t3 = Nl.y;
          t4 = Nl.z;
          t5 = new G.Normal(t1, t3, t4);
          t6 = J.$add$ns(J.$add$ns(J.$mul$ns(t1, t1), J.$mul$ns(t3, t3)), J.$mul$ns(t4, t4));
          if (typeof t6 !== "number")
            H.throwExpression(P.ArgumentError$(t6));
          t6 = Math.sqrt(t6);
          t1 = J.$div$n(t1, t6);
          t5.x = t1;
          t3 = J.$div$n(t3, t6);
          t5.y = t3;
          t6 = J.$div$n(t4, t6);
          t5.z = t6;
          t5 = lightRay.direction;
          t4 = J.getInterceptor$x(t5);
          t5 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(t1, t4.get$x(t5)), J.$mul$ns(t3, t4.get$y(t5))), J.$mul$ns(t6, t4.get$z(t5))));
          t4 = J.$mul$ns(lightPdf[0], lightRayPdf[0]);
          if (typeof t4 !== "number")
            return H.iae(t4);
          lightWt = lightWt.$mul(0, t5 / t4);
          t4 = lightRay.origin;
          t5 = J.getInterceptor$x(t4);
          t6 = t5.get$x(t4);
          t3 = t5.get$y(t4);
          t4 = t5.get$z(t4);
          t5 = lightRay.direction;
          t1 = J.getInterceptor$x(t5);
          t7 = t1.get$x(t5);
          t8 = t1.get$y(t5);
          t5 = t1.get$z(t5);
          t1 = lightRay.minDistance;
          t9 = lightRay.maxDistance;
          t10 = lightRay.time;
          t11 = lightRay.depth;
          t3 = new G.Point(t6, t3, t4);
          t4 = new G.Vector(t7, t8, t5);
          return this.Lbidir$11(scene, cameraPath, cameraLength, lightPath, Y.MetropolisRenderer_GeneratePath(new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t3, t4, t1, t9, t10, t11), lightWt, scene, sample.lightPathSamples, lightPath, null, null), sample.lightingSamples, rng, t2.time, lightDistribution, escapedRay, escapedAlpha);
        }
      }
    },
    Lpath$9: function(scene, cameraPath, cameraPathLength, samples, rng, time, lightDistribution, escapedRay, escapedAlpha) {
      var $L, t1, t2, previousSpecular, allSpecular, i, vc, pc, nc, t3, t4, t5, area, Ld, ls, lightPdf, lightNum, light;
      $L = G.Spectrum_Spectrum(0);
      for (t1 = cameraPath.length, t2 = scene.lights, previousSpecular = true, allSpecular = true, i = 0; i < cameraPathLength; ++i) {
        if (i >= t1)
          return H.ioore(cameraPath, i);
        vc = cameraPath[i];
        pc = vc.get$bsdf().dgShading.p;
        nc = vc.bsdf.dgShading.nn;
        if (previousSpecular === true)
          t3 = this.directLighting == null || !allSpecular;
        else
          t3 = false;
        if (t3) {
          t3 = vc.alpha;
          t4 = vc.isect;
          t5 = vc.wPrev;
          area = t4.primitive.areaLight;
          if (area != null) {
            t4 = t4.dg;
            t5 = area.L$3(t4.p, t4.nn, t5);
            t4 = t5;
          } else
            t4 = G.Spectrum_Spectrum(0);
          $L = $L.$add(0, t3.$mul(0, t4));
        }
        Ld = G.Spectrum_Spectrum(0);
        if (this.directLighting == null || !allSpecular) {
          if (i >= samples.length)
            return H.ioore(samples, i);
          ls = samples[i];
          lightPdf = [0];
          lightNum = lightDistribution.sampleDiscrete$2(ls.get$lightNum(), lightPdf);
          if (lightNum >>> 0 !== lightNum || lightNum >= t2.length)
            return H.ioore(t2, lightNum);
          light = t2[lightNum];
          Ld = vc.alpha.$mul(0, G.Integrator_EstimateDirect(scene, this, light, pc, nc, vc.wPrev, vc.isect.rayEpsilon, time, vc.bsdf, rng, ls.lightSample, ls.bsdfSample, 15)).$div(0, lightPdf[0]);
        }
        previousSpecular = vc.specularBounce;
        allSpecular = allSpecular && previousSpecular === true;
        $L = $L.$add(0, Ld);
      }
      if (!escapedAlpha.isBlack$0())
        if (previousSpecular === true)
          t1 = this.directLighting == null || !allSpecular;
        else
          t1 = false;
      else
        t1 = false;
      if (t1)
        for (i = 0; i < t2.length; ++i)
          $L = $L.$add(0, escapedAlpha.$mul(0, t2[i].Le$1(escapedRay)));
      return $L;
    },
    Lbidir$11: function(scene, cameraPath, cameraPathLength, lightPath, lightPathLength, samples, rng, time, lightDistribution, escapedRay, escapedAlpha) {
      var $L, nVerts, nSpecularVertices, t1, t2, i, j, t3, t4, previousSpecular, allSpecular, vc, pc, nc, t5, t6, t7, area, Ld, ls, lightPdf, lightNum, light, i0, vl, pl, nl, w, fc, fl, hit, t8, t9, t10;
      $L = G.Spectrum_Spectrum(0);
      nVerts = cameraPathLength + lightPathLength + 2;
      nSpecularVertices = new Uint32Array(nVerts);
      for (t1 = cameraPath.length, t2 = lightPath.length, i = 0; i < cameraPathLength; ++i)
        for (j = 0; j < lightPathLength; ++j) {
          if (i >= t1)
            return H.ioore(cameraPath, i);
          if (cameraPath[i].get$specularBounce() !== true) {
            if (j >= t2)
              return H.ioore(lightPath, j);
            t3 = lightPath[j].get$specularBounce() === true;
          } else
            t3 = true;
          if (t3) {
            t3 = i + j + 2;
            if (t3 >= nVerts)
              return H.ioore(nSpecularVertices, t3);
            nSpecularVertices[t3] = nSpecularVertices[t3] + 1;
          }
        }
      for (t3 = scene.lights, t4 = scene.aggregate, previousSpecular = true, allSpecular = true, i = 0; i < cameraPathLength; i = i0) {
        if (i >= t1)
          return H.ioore(cameraPath, i);
        vc = cameraPath[i];
        pc = vc.get$bsdf().dgShading.p;
        nc = vc.bsdf.dgShading.nn;
        if (previousSpecular === true)
          t5 = this.directLighting == null || !allSpecular;
        else
          t5 = false;
        if (t5) {
          t5 = vc.alpha;
          t6 = vc.isect;
          t7 = vc.wPrev;
          area = t6.primitive.areaLight;
          if (area != null) {
            t6 = t6.dg;
            t7 = area.L$3(t6.p, t6.nn, t7);
            t6 = t7;
          } else
            t6 = G.Spectrum_Spectrum(0);
          $L = $L.$add(0, t5.$mul(0, t6));
        }
        Ld = G.Spectrum_Spectrum(0);
        if (this.directLighting == null || !allSpecular) {
          if (i >= samples.length)
            return H.ioore(samples, i);
          ls = samples[i];
          lightPdf = [0];
          lightNum = lightDistribution.sampleDiscrete$2(ls.get$lightNum(), lightPdf);
          if (lightNum >>> 0 !== lightNum || lightNum >= t3.length)
            return H.ioore(t3, lightNum);
          light = t3[lightNum];
          Ld = vc.alpha.$mul(0, G.Integrator_EstimateDirect(scene, this, light, pc, nc, vc.wPrev, vc.isect.rayEpsilon, time, vc.bsdf, rng, ls.lightSample, ls.bsdfSample, 15)).$div(0, lightPdf[0]);
        }
        previousSpecular = vc.specularBounce;
        allSpecular = allSpecular && previousSpecular === true;
        i0 = i + 1;
        if (i0 >= nVerts)
          return H.ioore(nSpecularVertices, i0);
        $L = $L.$add(0, Ld.$div(0, i0 - nSpecularVertices[i0]));
        if (vc.specularBounce !== true)
          for (t5 = J.getInterceptor$x(nc), j = 0; j < lightPathLength; ++j) {
            if (j >= t2)
              return H.ioore(lightPath, j);
            vl = lightPath[j];
            pl = vl.get$bsdf().dgShading.p;
            nl = vl.bsdf.dgShading.nn;
            if (vl.specularBounce !== true) {
              t6 = pl.$sub(0, pc);
              w = t6.$div(t6, t6.length$0(0));
              t6 = vc.bsdf.f$2(vc.wPrev, w);
              t7 = vc.nSpecularComponents;
              if (typeof t7 !== "number")
                return H.iae(t7);
              fc = t6.$mul(0, 1 + t7);
              t7 = vl.bsdf.f$2(w.$negate(0), vl.wPrev);
              t6 = vl.nSpecularComponents;
              if (typeof t6 !== "number")
                return H.iae(t6);
              fl = t7.$mul(0, 1 + t6);
              if (fc.isBlack$0() || fl.isBlack$0())
                continue;
              t6 = pl.$sub(0, pc);
              t7 = new G.Point(pc.get$x(pc), pc.get$y(pc), pc.get$z(pc));
              t6 = new G.Vector(t6.get$x(t6), t6.get$y(t6), t6.get$z(t6));
              hit = t4.intersectP$1(new G.Ray(t7, t6, 0.001, 0.999, time, 0));
              t6 = $.get$Stats_shadowRays();
              t6.count = J.$add$ns(t6.count, 1);
              $.Stats_shadowRays = t6;
              if (!hit) {
                t6 = i + j + 2;
                if (t6 >= nVerts)
                  return H.ioore(nSpecularVertices, t6);
                t7 = nSpecularVertices[t6];
                t8 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(t5.get$x(nc), w.x), J.$mul$ns(t5.get$y(nc), w.y)), J.$mul$ns(t5.get$z(nc), w.z)));
                t9 = J.getInterceptor$x(nl);
                t9 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(t9.get$x(nl), w.x), J.$mul$ns(t9.get$y(nl), w.y)), J.$mul$ns(t9.get$z(nl), w.z)));
                t10 = pc.$sub(0, pl).lengthSquared$0();
                if (typeof t10 !== "number")
                  return H.iae(t10);
                $L = $L.$add(0, vc.alpha.$mul(0, fc).$mul(0, t8 * t9 / t10).$mul(0, fl).$mul(0, vl.alpha).$mul(0, 1 / (t6 - t7)));
              }
            }
          }
      }
      if (!escapedAlpha.isBlack$0())
        if (previousSpecular === true)
          t1 = this.directLighting == null || !allSpecular;
        else
          t1 = false;
      else
        t1 = false;
      if (t1)
        for (i = 0; i < t3.length; ++i)
          $L = $L.$add(0, escapedAlpha.$mul(0, t3[i].Le$1(escapedRay)));
      return $L;
    },
    MetropolisRenderer$11: function(nPixelSamples, nBootstrap, nDirectPixelSamples, lsp, doDirectSeparately, maxConsecutiveRejects, maxDepth, camera, bidirectional, taskNum, taskCount) {
      var t1, t2, origPixelSamples, t3;
      t1 = P.max(1, G.RoundUpPow2(J.toInt$0$n(J.$mul$ns(lsp, this.nPixelSamples))));
      this.largeStepsPerPixel = t1;
      t2 = this.nPixelSamples;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 >= t2) {
        t1 = C.JSNumber_methods._tdivFast$1(t1, 2);
        this.largeStepsPerPixel = t1;
      }
      if (C.JSNumber_methods.$mod(t2, t1) !== 0) {
        origPixelSamples = this.nPixelSamples;
        t1 = this.largeStepsPerPixel;
        t2 = J.getInterceptor$n(origPixelSamples);
        t3 = t2.$mod(origPixelSamples, t1);
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t3 = t2.$add(origPixelSamples, t1 - t3);
        this.nPixelSamples = t3;
        t3 = "Rounding up to " + H.S(t3) + " Metropolis samples per pixel (from " + H.S(origPixelSamples) + ")";
        $.Log.call$2(1, t3);
      }
      this.directLighting = doDirectSeparately === true ? new U.DirectLightingIntegrator(0, this.maxDepth, null, null, null) : null;
    },
    static: {MetropolisRenderer_LargeStep: function(rng, sample, maxDepth, x, y, t00, t1, bidirectional) {
        var t2, v, i, cps, t3, ls, lps;
        sample.get$cameraSample().imageX = x;
        t2 = sample.cameraSample;
        t2.imageY = y;
        v = (rng.randomUInt$0() & 16777215) / 16777216;
        if (typeof t00 !== "number")
          return H.iae(t00);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2.time = (1 - v) * t00 + v * t1;
        t2.lensU = (rng.randomUInt$0() & 16777215) / 16777216;
        t2.lensV = (rng.randomUInt$0() & 16777215) / 16777216;
        if (typeof maxDepth !== "number")
          return H.iae(maxDepth);
        t1 = sample.cameraPathSamples;
        t2 = sample.lightingSamples;
        i = 0;
        for (; i < maxDepth; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          cps = t1[i];
          t3 = cps.get$bsdfSample();
          t3.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
          t3 = t3.uDir;
          t3[0] = (rng.randomUInt$0() & 16777215) / 16777216;
          t3[1] = (rng.randomUInt$0() & 16777215) / 16777216;
          cps.set$rrSample((rng.randomUInt$0() & 16777215) / 16777216);
          if (i >= t2.length)
            return H.ioore(t2, i);
          ls = t2[i];
          t3 = ls.get$bsdfSample();
          t3.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
          t3 = t3.uDir;
          t3[0] = (rng.randomUInt$0() & 16777215) / 16777216;
          t3[1] = (rng.randomUInt$0() & 16777215) / 16777216;
          ls.set$lightNum((rng.randomUInt$0() & 16777215) / 16777216);
          t3 = ls.lightSample;
          t3.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
          t3 = t3.uPos;
          t3[0] = (rng.randomUInt$0() & 16777215) / 16777216;
          t3[1] = (rng.randomUInt$0() & 16777215) / 16777216;
        }
        if (bidirectional === true) {
          sample.lightNumSample = (rng.randomUInt$0() & 16777215) / 16777216;
          for (t1 = sample.lightRaySamples, i = 0; i < 5; ++i)
            t1[i] = (rng.randomUInt$0() & 16777215) / 16777216;
          for (t1 = sample.lightPathSamples, i = 0; i < maxDepth; ++i) {
            if (i >= t1.length)
              return H.ioore(t1, i);
            lps = t1[i];
            t2 = lps.get$bsdfSample();
            t2.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
            t2 = t2.uDir;
            t2[0] = (rng.randomUInt$0() & 16777215) / 16777216;
            t2[1] = (rng.randomUInt$0() & 16777215) / 16777216;
            lps.set$rrSample((rng.randomUInt$0() & 16777215) / 16777216);
          }
        }
      }, MetropolisRenderer_Mutate: function(rng, v, min, max) {
        var t1, t2, t3, t4, t5, delta;
        t1 = J.getInterceptor(min);
        if (t1.$eq(min, max))
          return min;
        t2 = Math.log(16);
        t3 = J.getInterceptor$n(max);
        t4 = J.$mul$ns(t3.$sub(max, min), 0.015625);
        t5 = rng.randomUInt$0();
        delta = J.$mul$ns(t4, Math.exp(-t2 * ((t5 & 16777215) / 16777216)));
        t2 = J.getInterceptor$ns(v);
        if ((rng.randomUInt$0() & 16777215) / 16777216 < 0.5) {
          v = t2.$add(v, delta);
          t2 = J.getInterceptor$n(v);
          if (t2.$ge(v, max))
            v = t1.$add(min, t2.$sub(v, max));
        } else {
          v = t2.$sub(v, delta);
          if (J.$lt$n(v, min))
            v = t3.$sub(max, t1.$sub(min, v));
        }
        t1 = J.getInterceptor$n(v);
        return t1.$lt(v, min) || t1.$ge(v, max) ? min : v;
      }, MetropolisRenderer_SmallStep: function(rng, sample, maxDepth, x0, x1, y0, y1, t00, t1, bidirectional) {
        var t2, t3, i, eps, ls, lps;
        t2 = sample.get$cameraSample();
        t3 = sample.cameraSample;
        t2.imageX = Y.MetropolisRenderer_Mutate(rng, t3.imageX, x0, x1);
        t3.imageY = Y.MetropolisRenderer_Mutate(rng, t3.imageY, y0, y1);
        t3.time = Y.MetropolisRenderer_Mutate(rng, t3.time, t00, t1);
        t3.lensU = Y.MetropolisRenderer_Mutate(rng, t3.lensU, 0, 1);
        t3.lensV = Y.MetropolisRenderer_Mutate(rng, t3.lensV, 0, 1);
        if (typeof maxDepth !== "number")
          return H.iae(maxDepth);
        t1 = sample.cameraPathSamples;
        t2 = sample.lightingSamples;
        i = 0;
        for (; i < maxDepth; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          eps = t1[i];
          t3 = eps.get$bsdfSample();
          t3.uComponent = Y.MetropolisRenderer_Mutate(rng, t3.uComponent, 0, 1);
          t3 = t3.uDir;
          t3[0] = Y.MetropolisRenderer_Mutate(rng, t3[0], 0, 1);
          t3[1] = Y.MetropolisRenderer_Mutate(rng, t3[1], 0, 1);
          eps.rrSample = Y.MetropolisRenderer_Mutate(rng, eps.get$rrSample(), 0, 1);
          if (i >= t2.length)
            return H.ioore(t2, i);
          ls = t2[i];
          t3 = ls.get$bsdfSample();
          t3.uComponent = Y.MetropolisRenderer_Mutate(rng, t3.uComponent, 0, 1);
          t3 = t3.uDir;
          t3[0] = Y.MetropolisRenderer_Mutate(rng, t3[0], 0, 1);
          t3[1] = Y.MetropolisRenderer_Mutate(rng, t3[1], 0, 1);
          ls.lightNum = Y.MetropolisRenderer_Mutate(rng, ls.get$lightNum(), 0, 1);
          t3 = ls.lightSample;
          t3.uComponent = Y.MetropolisRenderer_Mutate(rng, t3.uComponent, 0, 1);
          t3 = t3.uPos;
          t3[0] = Y.MetropolisRenderer_Mutate(rng, t3[0], 0, 1);
          t3[1] = Y.MetropolisRenderer_Mutate(rng, t3[1], 0, 1);
        }
        if (bidirectional === true) {
          sample.lightNumSample = Y.MetropolisRenderer_Mutate(rng, sample.lightNumSample, 0, 1);
          for (t1 = sample.lightRaySamples, i = 0; i < 5; ++i)
            t1[i] = Y.MetropolisRenderer_Mutate(rng, t1[i], 0, 1);
          for (t1 = sample.lightPathSamples, i = 0; i < maxDepth; ++i) {
            if (i >= t1.length)
              return H.ioore(t1, i);
            lps = t1[i];
            t2 = lps.get$bsdfSample();
            t2.uComponent = Y.MetropolisRenderer_Mutate(rng, t2.uComponent, 0, 1);
            t2 = t2.uDir;
            t2[0] = Y.MetropolisRenderer_Mutate(rng, t2[0], 0, 1);
            t2[1] = Y.MetropolisRenderer_Mutate(rng, t2[1], 0, 1);
            lps.rrSample = Y.MetropolisRenderer_Mutate(rng, lps.get$rrSample(), 0, 1);
          }
        }
      }, MetropolisRenderer_GeneratePath: function(r, a, scene, samples, path, escapedRay, escapedAlpha) {
        var t1, t2, t3, t4, alpha, ray, $length, v, hit, t5, bsdf, pdf, flags, t6, t7, f, p, n, pathScale, rrSurviveProb;
        t1 = escapedAlpha != null;
        if (t1)
          escapedAlpha.set$1(0);
        for (t2 = samples.length, t3 = scene.aggregate, t4 = path.length, alpha = a, ray = r, $length = 0; $length < t2; ++$length) {
          if ($length >= t4)
            return H.ioore(path, $length);
          v = path[$length];
          hit = t3.intersect$2(ray, v.get$isect());
          t5 = $.get$Stats_nonShadowRays();
          t5.count = J.$add$ns(t5.count, 1);
          $.Stats_nonShadowRays = t5;
          if (!hit) {
            if (t1)
              escapedAlpha.copy$1(alpha);
            if (escapedRay != null)
              escapedRay.copy$1(ray);
            break;
          }
          v.alpha = alpha;
          t5 = v.isect;
          bsdf = t5.getBSDF$1(ray);
          v.bsdf = bsdf;
          v.wPrev = J.$negate$n(ray.direction);
          pdf = [0];
          flags = [0];
          t6 = J.$negate$n(ray.direction);
          t7 = v.wNext;
          f = bsdf.sample_f$6(t6, t7, samples[$length].get$bsdfSample(), pdf, 31, flags);
          v.specularBounce = J.$and$n(flags[0], 16) !== 0;
          v.nSpecularComponents = bsdf.numComponents$1(19);
          if (!f.isBlack$0()) {
            if (0 >= pdf.length)
              return H.ioore(pdf, 0);
            t6 = J.$eq(pdf[0], 0);
          } else
            t6 = true;
          if (t6)
            return $length + 1;
          t6 = bsdf.dgShading;
          p = t6.p;
          n = t6.nn;
          t6 = J.getInterceptor$x(n);
          t6 = f.$mul(0, J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(t7.x, t6.get$x(n)), J.$mul$ns(t7.y, t6.get$y(n))), J.$mul$ns(t7.z, t6.get$z(n)))));
          if (0 >= pdf.length)
            return H.ioore(pdf, 0);
          pathScale = t6.$div(0, pdf[0]);
          rrSurviveProb = P.min(1, pathScale.get$y(pathScale));
          if (J.$gt$n(samples[$length].get$rrSample(), rrSurviveProb))
            return $length + 1;
          alpha = alpha.$mul(0, pathScale.$div(0, rrSurviveProb));
          t5 = t5.rayEpsilon;
          ray = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(p.get$x(p), p.get$y(p), p.get$z(p)), new G.Vector(t7.x, t7.y, t7.z), t5, 1 / 0, ray.time, ray.depth + 1);
        }
        return $length;
      }}
  },
  _PathSample: {
    "^": "Object;bsdfSample<,rrSample@"
  },
  _LightingSample: {
    "^": "Object;bsdfSample<,lightNum@,lightSample"
  },
  _PathVertex: {
    "^": "Object;isect<,wPrev,wNext,bsdf<,specularBounce<,nSpecularComponents,alpha>"
  },
  _MLTSample: {
    "^": "Object;cameraSample<,lightNumSample,lightRaySamples,cameraPathSamples,lightPathSamples,lightingSamples",
    _MLTSample$1: function(maxLength) {
      var t1, t2, t3, i, t4, t5;
      if (typeof maxLength !== "number")
        return H.iae(maxLength);
      t1 = this.lightingSamples;
      t2 = this.lightPathSamples;
      t3 = this.cameraPathSamples;
      i = 0;
      for (; i < maxLength; ++i) {
        t4 = Array(2);
        t4.$builtinTypeInfo = [J.JSDouble];
        t4[0] = 0;
        t4[1] = 0;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3[i] = new Y._PathSample(new G.BSDFSample(t4, 0), 0);
        t4 = Array(2);
        t4.$builtinTypeInfo = [J.JSDouble];
        t4[0] = 0;
        t4[1] = 0;
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = new Y._PathSample(new G.BSDFSample(t4, 0), 0);
        t4 = Array(2);
        t4.$builtinTypeInfo = [J.JSDouble];
        t4[0] = 0;
        t4[1] = 0;
        t5 = Array(2);
        t5.$builtinTypeInfo = [J.JSDouble];
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = new Y._LightingSample(new G.BSDFSample(t4, 0), 0, new G.LightSample(t5, 0));
      }
    },
    static: {_MLTSample$: function(maxLength) {
        var t1 = new Float32Array(5);
        if (typeof maxLength !== "number")
          return H.iae(maxLength);
        t1 = new Y._MLTSample(new G.CameraSample(0, 0, 0, 0, 0), 0, t1, H.setRuntimeTypeInfo(Array(maxLength), [Y._PathSample]), H.setRuntimeTypeInfo(Array(maxLength), [Y._PathSample]), H.setRuntimeTypeInfo(Array(maxLength), [Y._LightingSample]));
        t1._MLTSample$1(maxLength);
        return t1;
      }}
  },
  _MLTTask: {
    "^": "Object;taskNum,dx,dy,currentPixelSample,x0,x1,y0,y1,t0,t1,b,initialSample,scene,camera,renderer,lightDistribution",
    run$0: function() {
      var t1, t2, t3, t4, t5, nPixels, t6, nPixelSamples, largeStepRate, nTaskSamples, t7, rng, cameraPath, lightPath, t8, i, t9, t10, samples, $L, I, largeStepPixelNum, t11, t12, t13, t14, t15, t16, t17, t18, consecutiveRejects, current, proposed, pixelNumOffset, s, t19, t20, x, y, a, contrib, splatScale;
      t1 = this.x1;
      t2 = this.x0;
      t3 = J.getInterceptor$n(t1);
      t4 = this.y1;
      t5 = this.y0;
      nPixels = J.$mul$ns(t3.$sub(t1, t2), J.$sub$n(t4, t5));
      t6 = this.renderer;
      nPixelSamples = t6.nPixelSamples;
      largeStepRate = J.$tdiv$n(nPixelSamples, t6.largeStepsPerPixel);
      nTaskSamples = J.$mul$ns(nPixels, largeStepRate);
      t7 = this.taskNum;
      rng = new G.RNG(null, new Uint32Array(624), null);
      rng.mti = 625;
      rng.seed$1(0, t7);
      t7 = t6.maxDepth;
      if (typeof t7 !== "number")
        return H.iae(t7);
      cameraPath = H.setRuntimeTypeInfo(Array(t7), [Y._PathVertex]);
      t7 = t6.maxDepth;
      if (typeof t7 !== "number")
        return H.iae(t7);
      lightPath = H.setRuntimeTypeInfo(Array(t7), [Y._PathVertex]);
      t7 = cameraPath.length;
      t8 = lightPath.length;
      i = 0;
      while (true) {
        t9 = t6.maxDepth;
        if (typeof t9 !== "number")
          return H.iae(t9);
        if (!(i < t9))
          break;
        t9 = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
        t9.primitive = null;
        t9.shapeId = 0;
        t9.primitiveId = 0;
        t9.rayEpsilon = 0;
        t10 = G.Spectrum_Spectrum(0);
        if (i >= t7)
          return H.ioore(cameraPath, i);
        cameraPath[i] = new Y._PathVertex(t9, new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), null, null, null, t10);
        t10 = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
        t10.primitive = null;
        t10.shapeId = 0;
        t10.primitiveId = 0;
        t10.rayEpsilon = 0;
        t9 = G.Spectrum_Spectrum(0);
        if (i >= t8)
          return H.ioore(lightPath, i);
        lightPath[i] = new Y._PathVertex(t10, new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), null, null, null, t9);
        ++i;
      }
      samples = H.setRuntimeTypeInfo(Array(2), [Y._MLTSample]);
      $L = H.setRuntimeTypeInfo(Array(2), [G.Spectrum]);
      I = new Float32Array(2);
      for (i = 0; i < 2; ++i)
        samples[i] = Y._MLTSample$(t6.maxDepth);
      t7 = this.initialSample;
      samples[0] = t7;
      t8 = this.scene;
      t9 = this.camera;
      t10 = this.lightDistribution;
      t7 = t6.pathL$7(t7, t8, t9, t10, cameraPath, lightPath, rng);
      $L[0] = t7;
      I[0] = t7.get$y(t7);
      if (typeof nPixels !== "number" || Math.floor(nPixels) !== nPixels)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(nPixels)));
      largeStepPixelNum = new Uint32Array(nPixels);
      if (typeof nPixels !== "number")
        return H.iae(nPixels);
      t7 = largeStepPixelNum.length;
      i = 0;
      for (; i < nPixels; ++i) {
        if (i >= t7)
          return H.ioore(largeStepPixelNum, i);
        largeStepPixelNum[i] = i;
      }
      G.Shuffle(largeStepPixelNum, 0, nPixels, 1, rng);
      if (typeof nTaskSamples !== "number")
        return H.iae(nTaskSamples);
      t11 = t6.maxConsecutiveRejects;
      t12 = this.t0;
      t13 = this.t1;
      t14 = t6.bidirectional;
      t15 = J.getInterceptor$ns(t2);
      t16 = J.getInterceptor$ns(t5);
      t17 = this.dx;
      t18 = this.dy;
      consecutiveRejects = 0;
      current = 0;
      proposed = 1;
      pixelNumOffset = 0;
      s = 0;
      for (; s < nTaskSamples; ++s) {
        if (current < 0 || current >= 2)
          return H.ioore(samples, current);
        t19 = samples[current];
        if (proposed < 0 || proposed >= 2)
          return H.ioore(samples, proposed);
        samples[proposed] = t19;
        if (typeof largeStepRate !== "number")
          return H.iae(largeStepRate);
        if (C.JSInt_methods.$mod(s, largeStepRate) === 0) {
          if (pixelNumOffset >= t7)
            return H.ioore(largeStepPixelNum, pixelNumOffset);
          t19 = largeStepPixelNum[pixelNumOffset];
          t20 = t3.$sub(t1, t2);
          if (typeof t20 !== "number")
            return H.iae(t20);
          x = t15.$add(t2, C.JSInt_methods.$mod(t19, t20));
          t20 = largeStepPixelNum[pixelNumOffset];
          t19 = t3.$sub(t1, t2);
          if (typeof t19 !== "number")
            return H.iae(t19);
          y = t16.$add(t5, C.JSInt_methods.$tdiv(t20, t19));
          Y.MetropolisRenderer_LargeStep(rng, samples[proposed], t6.maxDepth, J.$add$ns(x, t17), J.$add$ns(y, t18), t12, t13, t14);
          ++pixelNumOffset;
        } else
          Y.MetropolisRenderer_SmallStep(rng, t19, t6.maxDepth, t2, t1, t5, t4, t12, t13, t14);
        t19 = t6.pathL$7(samples[proposed], t8, t9, t10, cameraPath, lightPath, rng);
        $L[proposed] = t19;
        I[proposed] = t19.get$y(t19);
        a = P.min(1, I[proposed] / I[current]);
        t19 = I[current];
        if (t19 > 0)
          if (isFinite(1 / t19)) {
            t19 = $L[current];
            t20 = this.b;
            if (typeof nPixelSamples !== "number")
              return H.iae(nPixelSamples);
            contrib = J.$div$n(J.$mul$ns(t19, t20 / nPixelSamples), I[current]);
            t9.get$film().splat$2(samples[current].get$cameraSample(), J.$mul$ns(contrib, 1 - a));
          }
        t19 = I[proposed];
        if (t19 > 0)
          if (isFinite(1 / t19)) {
            t19 = $L[proposed];
            t20 = this.b;
            if (typeof nPixelSamples !== "number")
              return H.iae(nPixelSamples);
            contrib = J.$div$n(J.$mul$ns(t19, t20 / nPixelSamples), I[proposed]);
            t9.get$film().splat$2(samples[proposed].get$cameraSample(), J.$mul$ns(contrib, a));
          }
        if (typeof t11 !== "number")
          return H.iae(t11);
        if (consecutiveRejects >= t11 || (rng.randomUInt$0() & 16777215) / 16777216 < a) {
          current ^= 1;
          proposed ^= 1;
          consecutiveRejects = 0;
        } else
          ++consecutiveRejects;
      }
      t3 = this.taskNum;
      if (typeof nPixelSamples !== "number")
        return H.iae(nPixelSamples);
      splatScale = nPixels * nPixelSamples / ((t3 + 1) * nTaskSamples);
      t9.get$film().updateDisplay$5(t2, t5, t1, t4, splatScale);
      t9.get$film().writeImage$1(splatScale);
    }
  },
  SamplerRenderer: {
    "^": "Renderer;taskNum,taskCount,sampler,camera,surfaceIntegrator,volumeIntegrator",
    render$1: function(scene) {
      var t1, t2, t3, t4;
      $.Log.call$2(0, "Starting Render");
      t1 = this.surfaceIntegrator;
      t2 = this.camera;
      t1.preprocess$3(scene, t2, this);
      t3 = this.volumeIntegrator;
      t3.preprocess$3(scene, t2, this);
      t4 = this.sampler;
      new Y._SamplerRendererTask(scene, this, t2, t4, G.Sample$(t4, t1, t3, scene), this.taskNum, this.taskCount).run$0();
      return t2.get$film().writeImage$0();
    },
    Li$6: function(scene, ray, sample, rng, isect, $T) {
      var t1, t2, Li, t3, i, Lvi;
      if ($T == null)
        $T = G.Spectrum_Spectrum(0);
      t1 = this.volumeIntegrator;
      t2 = t1 == null;
      if (t2)
        $T.set$1(1);
      if (isect == null)
        isect = G.Intersection$();
      Li = G.Spectrum_Spectrum(0);
      if (scene.intersect$2(ray, isect))
        Li = this.surfaceIntegrator.Li$6(scene, this, ray, isect, sample, rng);
      else
        for (t3 = scene.lights, i = 0; i < t3.length; ++i)
          Li = Li.$add(0, t3[i].Le$1(ray));
      Lvi = t2 ? G.Spectrum_Spectrum(0) : t1.Li$6(scene, this, ray, sample, rng, $T);
      return J.$add$ns(J.$mul$ns($T, Li), Lvi);
    },
    Li$4: function(scene, ray, sample, rng) {
      return this.Li$6(scene, ray, sample, rng, null, null);
    },
    Li$5: function(scene, ray, sample, rng, isect) {
      return this.Li$6(scene, ray, sample, rng, isect, null);
    },
    transmittance$4: function(scene, ray, sample, rng) {
      return this.volumeIntegrator.transmittance$5(scene, this, ray, sample, rng);
    }
  },
  _SamplerRendererTask: {
    "^": "Object;scene,renderer,camera,mainSampler,origSample,taskNum,taskCount",
    run$0: function() {
      var sampler, t1, rng, maxSamples, samples, rays, Ls, Ts, isects, t2, t3, t4, i, t5, t6, t7, t8, sampleCount, t9, rayWeight, t10, t11;
      sampler = this.mainSampler.getSubSampler$2(this.taskNum, this.taskCount);
      if (sampler == null)
        return;
      t1 = this.taskNum;
      rng = new G.RNG(null, new Uint32Array(624), null);
      rng.mti = 625;
      rng.seed$1(0, t1);
      maxSamples = sampler.maximumSampleCount$0();
      samples = this.origSample.duplicate$1(maxSamples);
      if (typeof maxSamples !== "number")
        return H.iae(maxSamples);
      rays = H.setRuntimeTypeInfo(Array(maxSamples), [G.RayDifferential]);
      Ls = H.setRuntimeTypeInfo(Array(maxSamples), [G.Spectrum]);
      Ts = H.setRuntimeTypeInfo(Array(maxSamples), [G.Spectrum]);
      isects = H.setRuntimeTypeInfo(Array(maxSamples), [G.Intersection]);
      for (t1 = rays.length, t2 = Ls.length, t3 = Ts.length, t4 = isects.length, i = 0; i < maxSamples; ++i) {
        t5 = new G.Point(0, 0, 0);
        t6 = new G.Vector(0, 0, 0);
        if (i >= t1)
          return H.ioore(rays, i);
        rays[i] = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t5, t6, 0, 1 / 0, 0, 0);
        t6 = G.Spectrum_Spectrum(0);
        if (i >= t2)
          return H.ioore(Ls, i);
        Ls[i] = t6;
        t6 = G.Spectrum_Spectrum(0);
        if (i >= t3)
          return H.ioore(Ts, i);
        Ts[i] = t6;
        t6 = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
        t6.primitive = null;
        t6.shapeId = 0;
        t6.primitiveId = 0;
        t6.rayEpsilon = 0;
        if (i >= t4)
          return H.ioore(isects, i);
        isects[i] = t6;
      }
      for (t5 = samples.length, t6 = this.camera, t7 = this.renderer, t8 = this.scene; true;) {
        sampleCount = sampler.getMoreSamples$2(samples, rng);
        if (J.$eq(sampleCount, 0))
          break;
        if (typeof sampleCount !== "number")
          return H.iae(sampleCount);
        i = 0;
        for (; i < sampleCount; ++i) {
          if (i >= t5)
            return H.ioore(samples, i);
          t9 = $.get$Stats_cameraRays();
          t9.count = J.$add$ns(t9.count, 1);
          $.Stats_cameraRays = t9;
          t9 = samples[i];
          if (i >= t1)
            return H.ioore(rays, i);
          rayWeight = t6.generateRayDifferential$2(t9, rays[i]);
          t9 = rays[i];
          t10 = sampler.samplesPerPixel;
          if (typeof t10 !== "number")
            H.throwExpression(P.ArgumentError$(t10));
          t9.scaleDifferentials$1(1 / Math.sqrt(t10));
          if (rayWeight > 0) {
            t9 = rays[i];
            t10 = samples[i];
            if (i >= t4)
              return H.ioore(isects, i);
            t11 = isects[i];
            if (i >= t3)
              return H.ioore(Ts, i);
            t11 = J.$mul$ns(t7.Li$6(t8, t9, t10, rng, t11, Ts[i]), rayWeight);
            if (i >= t2)
              return H.ioore(Ls, i);
            Ls[i] = t11;
          } else {
            t9 = G.Spectrum_Spectrum(0);
            if (i >= t2)
              return H.ioore(Ls, i);
            Ls[i] = t9;
            t9 = G.Spectrum_Spectrum(1);
            if (i >= t3)
              return H.ioore(Ts, i);
            Ts[i] = t9;
          }
          if (i >= t2)
            return H.ioore(Ls, i);
          if (Ls[i].hasNaNs$0()) {
            $.Log.call$2(1, "Not-a-number radiance value returned for image sample. Setting to black.");
            Ls[i] = G.Spectrum_Spectrum(0);
          } else if (J.$lt$n(J.get$y$x(Ls[i]), -0.00001)) {
            t9 = "Negative luminance value, " + H.S(J.get$y$x(Ls[i])) + ", returnedfor image sample. Setting to black.";
            $.Log.call$2(1, t9);
            Ls[i] = G.Spectrum_Spectrum(0);
          } else if (J.get$isInfinite$n(J.get$y$x(Ls[i]))) {
            $.Log.call$2(1, "Infinite luminance value returnedfor image sample. Setting to black.");
            Ls[i] = G.Spectrum_Spectrum(0);
          }
        }
        if (sampler.reportResults$5(samples, rays, Ls, isects, sampleCount))
          for (i = 0; i < sampleCount; ++i) {
            if (i >= t5)
              return H.ioore(samples, i);
            if (i >= t1)
              return H.ioore(rays, i);
            if (i >= t2)
              return H.ioore(Ls, i);
            if (i >= t3)
              return H.ioore(Ts, i);
            t6.get$film().addSample$2(samples[i], Ls[i]);
          }
      }
      t6.get$film().updateDisplay$4(sampler.xPixelStart, sampler.yPixelStart, J.$add$ns(sampler.xPixelEnd, 1), J.$add$ns(sampler.yPixelEnd, 1));
    }
  }
}],
["samplers", "package:dartray/samplers/samplers.dart", , U, {
  "^": "",
  AdaptiveSampler: {
    "^": "Sampler;pixels,pixel,pixelIndex,minSamples,maxSamples,sampleBuf,method,supersamplePixel,xPixelStart,xPixelEnd,yPixelStart,yPixelEnd,samplesPerPixel,shutterOpen,shutterClose",
    getSubSampler$2: function(num, count) {
      var extent = [0, 0, 0, 0];
      G.Sampler_ComputeSubWindow(J.$sub$n(this.xPixelEnd, this.xPixelStart), J.$sub$n(this.yPixelEnd, this.yPixelStart), num, count, extent);
      if (J.$eq(extent[0], extent[1]) || J.$eq(extent[2], extent[3]))
        return;
      return U.AdaptiveSampler$(extent[0], extent[1], extent[2], extent[3], this.minSamples, this.maxSamples, this.method, this.shutterOpen, this.shutterClose);
    },
    roundSize$1: function(size) {
      return G.RoundUpPow2(size);
    },
    maximumSampleCount$0: function() {
      return this.maxSamples;
    },
    getMoreSamples$2: function(samples, rng) {
      var t1, t2, t3;
      t1 = this.sampleBuf;
      if (t1 == null) {
        if (0 >= samples.length)
          return H.ioore(samples, 0);
        t1 = G.LDPixelSampleFloatsNeeded(samples[0], this.maxSamples);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        t1 = new Float32Array(t1);
        this.sampleBuf = t1;
      }
      if (this.supersamplePixel) {
        t2 = this.pixel;
        G.LDPixelSample(t2[0], t2[1], this.shutterOpen, this.shutterClose, this.maxSamples, samples, t1, rng);
        return this.maxSamples;
      } else {
        t2 = this.pixelIndex;
        t3 = this.pixels._numSamples;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t2 >= t3)
          return 0;
        t2 = this.pixel;
        G.LDPixelSample(t2[0], t2[1], this.shutterOpen, this.shutterClose, this.minSamples, samples, t1, rng);
        return this.minSamples;
      }
    },
    reportResults$5: function(samples, rays, Ls, isects, count) {
      var t1, t2, t3;
      if (this.supersamplePixel) {
        this.supersamplePixel = false;
        t1 = this.pixelIndex;
        t2 = this.pixels;
        t3 = t2._numSamples;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t1 < t3) {
          ++t1;
          this.pixelIndex = t1;
          t2.getPixel$2(t1, this.pixel);
        }
        return true;
      } else if (this.needsSupersampling$5(samples, rays, Ls, isects, count)) {
        this.supersamplePixel = true;
        return false;
      } else {
        t1 = this.pixelIndex;
        t2 = this.pixels;
        t3 = t2._numSamples;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t1 < t3) {
          ++t1;
          this.pixelIndex = t1;
          t2.getPixel$2(t1, this.pixel);
        }
        return true;
      }
    },
    needsSupersampling$5: function(samples, rays, Ls, isects, count) {
      var t1, t2, i, t3, t4, t5, Lavg;
      switch (this.method) {
        case 0:
          t1 = J.getInterceptor$n(count);
          t2 = isects.length;
          i = 0;
          while (true) {
            t3 = t1.$sub(count, 1);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            if (i >= t2)
              return H.ioore(isects, i);
            t3 = isects[i];
            t4 = t3.get$shapeId();
            ++i;
            if (i >= t2)
              return H.ioore(isects, i);
            t5 = isects[i];
            if (t4 !== t5.get$shapeId() || t3.get$primitiveId() !== t5.get$primitiveId())
              return true;
          }
          return false;
        case 1:
          if (typeof count !== "number")
            return H.iae(count);
          t1 = Ls.length;
          Lavg = 0;
          i = 0;
          for (; i < count; ++i) {
            if (i >= t1)
              return H.ioore(Ls, i);
            t2 = J.get$y$x(Ls[i]);
            if (typeof t2 !== "number")
              return H.iae(t2);
            Lavg += t2;
          }
          Lavg /= count;
          for (i = 0; i < count; ++i) {
            if (i >= t1)
              return H.ioore(Ls, i);
            if (J.abs$0$n(J.$sub$n(J.get$y$x(Ls[i]), Lavg)) / Lavg > 0.5)
              return true;
          }
          return false;
      }
      return false;
    },
    AdaptiveSampler$9: function(xstart, xend, ystart, yend, mins, maxs, method, sopen, sclose) {
      var t1, t0;
      t1 = Y.TileImageSampler$(xstart, xend, ystart, yend, true, 32);
      this.pixels = t1;
      this.pixelIndex = 0;
      this.supersamplePixel = false;
      t1.getPixel$2(0, this.pixel);
      if (J.$gt$n(mins, maxs)) {
        t0 = maxs;
        maxs = mins;
        mins = t0;
      }
      t1 = J.getInterceptor$n(mins);
      if (t1.$and(mins, t1.$sub(mins, 1)) !== 0) {
        $.Log.call$2(1, "Minimum pixel samples being rounded up to power of 2");
        this.minSamples = G.RoundUpPow2(mins);
      } else
        this.minSamples = mins;
      t1 = J.getInterceptor$n(maxs);
      if (t1.$and(maxs, t1.$sub(maxs, 1)) !== 0) {
        $.Log.call$2(1, "Maximum pixel samples being rounded up to power of 2");
        this.maxSamples = G.RoundUpPow2(maxs);
      } else
        this.maxSamples = maxs;
      if (J.$lt$n(this.minSamples, 2)) {
        $.Log.call$2(1, "Adaptive sampler needs at least two initial pixel samples. Using two.");
        this.minSamples = 2;
      }
      if (J.$eq(this.minSamples, this.maxSamples)) {
        this.maxSamples = J.$mul$ns(this.maxSamples, 2);
        t1 = "Adaptive sampler must have more maximum samples than minimum. Using " + H.S(this.minSamples) + " - " + H.S(this.maxSamples);
        $.Log.call$2(1, t1);
      }
    },
    static: {"^": "AdaptiveSampler_ADAPTIVE_COMPARE_SHAPE_ID,AdaptiveSampler_ADAPTIVE_CONTRAST_THRESHOLD", AdaptiveSampler_Create: [function(params, film, camera) {
        var extent, minsamp, maxsamp, m, t1, method;
        extent = [0, 0, 0, 0];
        film.getSampleExtent$1(extent);
        minsamp = params.findOneInt$2("minsamples", 4);
        maxsamp = params.findOneInt$2("maxsamples", 32);
        m = params.findOneString$2("method", "contrast");
        t1 = J.getInterceptor(m);
        if (t1.$eq(m, "contrast"))
          method = 1;
        else
          method = t1.$eq(m, "shapeid") ? 0 : -1;
        if (method === -1) {
          t1 = "Adaptive sampling metric '" + H.S(m) + "' unknown. Using 'contrast'.";
          $.Log.call$2(1, t1);
          method = 1;
        }
        return U.AdaptiveSampler$(extent[0], extent[1], extent[2], extent[3], minsamp, maxsamp, method, camera.get$shutterOpen(), camera.get$shutterClose());
      }, "call$3", "AdaptiveSampler_Create$closure", 6, 0, 46], AdaptiveSampler$: function(xstart, xend, ystart, yend, mins, maxs, method, sopen, sclose) {
        var t1 = new U.AdaptiveSampler(null, new Int32Array(2), null, null, null, null, null, null, xstart, xend, ystart, yend, G.RoundUpPow2(P.max(mins, maxs)), sopen, sclose);
        t1.AdaptiveSampler$9(xstart, xend, ystart, yend, mins, maxs, method, sopen, sclose);
        return t1;
      }}
  },
  BestCandidateSampler: {
    "^": "Sampler;tableWidth,tableOffset,xTileStart,xTileEnd,yTileStart,yTileEnd,xTile,yTile,sampleOffsets,xPixelStart,xPixelEnd,yPixelStart,yPixelEnd,samplesPerPixel,shutterOpen,shutterClose",
    getSubSampler$2: function(num, count) {
      var extent = [0, 0, 0, 0];
      G.Sampler_ComputeSubWindow(J.$sub$n(this.xPixelEnd, this.xPixelStart), J.$sub$n(this.yPixelEnd, this.yPixelStart), num, count, extent);
      if (J.$eq(extent[0], extent[1]) || J.$eq(extent[2], extent[3]))
        return;
      return U.BestCandidateSampler$(extent[0], extent[1], extent[2], extent[3], this.samplesPerPixel, this.shutterOpen, this.shutterClose);
    },
    roundSize$1: function(size) {
      return G.RoundUpPow2(size);
    },
    maximumSampleCount$0: function() {
      return 1;
    },
    getMoreSamples$2: function(samples, rng) {
      var sample, t1, t2, t3, t4, t5, again, t6, t7, tileRng, i, to, t8;
      if (0 >= samples.length)
        return H.ioore(samples, 0);
      sample = samples[0];
      for (t1 = this.sampleOffsets, t2 = this.shutterOpen, t3 = this.shutterClose, t4 = this.xPixelEnd, t5 = this.yPixelEnd, again = true; again;) {
        if (this.tableOffset === 4096) {
          this.tableOffset = 0;
          t6 = ++this.xTile;
          if (t6 > this.xTileEnd) {
            t6 = this.xTileStart;
            this.xTile = t6;
            if (++this.yTile > this.yTileEnd)
              return 0;
          }
          t7 = this.yTile;
          tileRng = new G.RNG(null, new Uint32Array(624), null);
          tileRng.mti = 625;
          tileRng.seed$1(0, t6 + (t7 << 8 >>> 0));
          for (i = 0; i < 3; ++i)
            t1[i] = (tileRng.randomUInt$0() & 16777215) / 16777216;
        }
        t6 = new U.BestCandidateSampler_getMoreSamples_WRAP();
        to = this.tableOffset * 5;
        t7 = this.xTile;
        if (to >= 20480)
          return H.ioore(C.List_qtg, to);
        t8 = C.List_qtg[to];
        if (typeof t8 !== "number")
          return H.iae(t8);
        sample.set$imageX((t7 + t8) * this.tableWidth);
        t8 = this.yTile;
        t7 = to + 1;
        if (t7 >= 20480)
          return H.ioore(C.List_qtg, t7);
        t7 = C.List_qtg[t7];
        if (typeof t7 !== "number")
          return H.iae(t7);
        sample.imageY = (t8 + t7) * this.tableWidth;
        t7 = t1[0];
        t8 = to + 2;
        if (t8 >= 20480)
          return H.ioore(C.List_qtg, t8);
        t8 = t6.call$1(J.$add$ns(t7, C.List_qtg[t8]));
        if (typeof t8 !== "number")
          return H.iae(t8);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (typeof t3 !== "number")
          return H.iae(t3);
        sample.time = (1 - t8) * t2 + t8 * t3;
        t8 = t1[1];
        t7 = to + 3;
        if (t7 >= 20480)
          return H.ioore(C.List_qtg, t7);
        sample.lensU = t6.call$1(J.$add$ns(t8, C.List_qtg[t7]));
        t7 = t1[2];
        t8 = to + 4;
        if (t8 >= 20480)
          return H.ioore(C.List_qtg, t8);
        sample.lensV = t6.call$1(J.$add$ns(t7, C.List_qtg[t8]));
        if (J.$lt$n(sample.imageX, this.xPixelStart) || J.$ge$n(sample.imageX, t4) || J.$lt$n(sample.imageY, this.yPixelStart) || J.$ge$n(sample.imageY, t5)) {
          ++this.tableOffset;
          again = true;
          continue;
        }
        again = false;
      }
      for (i = 0; i < sample.get$n1D().length; ++i) {
        t1 = sample.n1D;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1 = t1[i];
        t2 = sample.oneD;
        if (i >= t2.length)
          return H.ioore(t2, i);
        G.LDShuffleScrambled1D(t1, 1, t2[i], rng);
      }
      for (i = 0; t1 = sample.n2D, i < t1.length; ++i) {
        t1 = t1[i];
        t2 = sample.twoD;
        if (i >= t2.length)
          return H.ioore(t2, i);
        G.LDShuffleScrambled2D(t1, 1, t2[i], rng);
      }
      ++this.tableOffset;
      return 1;
    },
    BestCandidateSampler$7: function(xstart, xend, ystart, yend, nPixelSamples, sopen, sclose) {
      var t1, t2, tileRng, i;
      if (typeof nPixelSamples !== "number")
        H.throwExpression(P.ArgumentError$(nPixelSamples));
      t1 = 64 / Math.sqrt(nPixelSamples);
      this.tableWidth = t1;
      this.xTileStart = J.floor$0$n(J.$div$n(xstart, t1));
      this.xTileEnd = J.floor$0$n(J.$div$n(xend, this.tableWidth));
      this.yTileStart = J.floor$0$n(J.$div$n(ystart, this.tableWidth));
      this.yTileEnd = J.floor$0$n(J.$div$n(yend, this.tableWidth));
      t1 = this.xTileStart;
      this.xTile = t1;
      t2 = this.yTileStart;
      this.yTile = t2;
      this.tableOffset = 0;
      tileRng = new G.RNG(null, new Uint32Array(624), null);
      tileRng.mti = 625;
      tileRng.seed$1(0, t1 + (t2 << 8 >>> 0));
      for (t1 = this.sampleOffsets, i = 0; i < 3; ++i)
        t1[i] = (tileRng.randomUInt$0() & 16777215) / 16777216;
    },
    static: {"^": "BestCandidateSampler_SQRT_SAMPLE_TABLE_SIZE,BestCandidateSampler_SAMPLE_TABLE_SIZE", BestCandidateSampler_Create: [function(params, film, camera) {
        var extent, nsamp;
        extent = [0, 0, 0, 0];
        film.getSampleExtent$1(extent);
        nsamp = params.findOneInt$2("pixelsamples", 4);
        return U.BestCandidateSampler$(extent[0], extent[1], extent[2], extent[3], nsamp, camera.get$shutterOpen(), camera.get$shutterClose());
      }, "call$3", "BestCandidateSampler_Create$closure", 6, 0, 47], BestCandidateSampler$: function(xstart, xend, ystart, yend, nPixelSamples, sopen, sclose) {
        var t1 = new U.BestCandidateSampler(null, null, null, null, null, null, null, null, [0, 0, 0], xstart, xend, ystart, yend, nPixelSamples, sopen, sclose);
        t1.BestCandidateSampler$7(xstart, xend, ystart, yend, nPixelSamples, sopen, sclose);
        return t1;
      }}
  },
  BestCandidateSampler_getMoreSamples_WRAP: {
    "^": "Closure:88;",
    call$1: function(x) {
      var t1 = J.getInterceptor$n(x);
      return t1.$gt(x, 1) ? t1.$sub(x, 1) : x;
    }
  },
  HaltonSampler: {
    "^": "Sampler;wantedSamples,currentSample,xPixelStart,xPixelEnd,yPixelStart,yPixelEnd,samplesPerPixel,shutterOpen,shutterClose",
    maximumSampleCount$0: function() {
      return 1;
    },
    getMoreSamples$2: function(samples, rng) {
      var t1, t2, t3, t4, t5, t6, t7, u, v, lerpDelta, t8, i;
      for (t1 = samples.length, t2 = this.xPixelEnd, t3 = J.getInterceptor$n(t2), t4 = this.yPixelEnd, t5 = J.getInterceptor$n(t4); true;) {
        t6 = this.currentSample;
        t7 = this.wantedSamples;
        if (typeof t7 !== "number")
          return H.iae(t7);
        if (t6 >= t7)
          return 0;
        u = G.RadicalInverse(t6, 3);
        v = G.RadicalInverse(this.currentSample, 2);
        lerpDelta = C.JSNumber_methods.toDouble$0(P.max(t3.$sub(t2, this.xPixelStart), t5.$sub(t4, this.yPixelStart)));
        if (0 >= t1)
          return H.ioore(samples, 0);
        t6 = samples[0];
        t7 = this.xPixelStart;
        t8 = J.$add$ns(t7, lerpDelta);
        if (typeof t7 !== "number")
          return H.iae(t7);
        if (typeof t8 !== "number")
          return H.iae(t8);
        t6.set$imageX((1 - u) * t7 + u * t8);
        t8 = samples[0];
        t7 = this.yPixelStart;
        t6 = J.$add$ns(t7, lerpDelta);
        if (typeof t7 !== "number")
          return H.iae(t7);
        if (typeof t6 !== "number")
          return H.iae(t6);
        t8.set$imageY((1 - v) * t7 + v * t6);
        ++this.currentSample;
        if (J.$ge$n(samples[0].get$imageX(), t2) || J.$ge$n(samples[0].get$imageY(), t4))
          continue;
        break;
      }
      if (0 >= t1)
        return H.ioore(samples, 0);
      samples[0].set$lensU(G.RadicalInverse(this.currentSample, 5));
      samples[0].set$lensV(G.RadicalInverse(this.currentSample, 7));
      t1 = samples[0];
      t2 = G.RadicalInverse(this.currentSample, 11);
      t3 = this.shutterOpen;
      t4 = this.shutterClose;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (typeof t4 !== "number")
        return H.iae(t4);
      t1.set$time((1 - t2) * t3 + t2 * t4);
      for (i = 0; t1 = samples[0], i < t1.get$n1D().length; ++i) {
        t1 = t1.oneD;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        t1 = t1[i];
        t2 = samples[0].get$n1D();
        if (i >= t2.length)
          return H.ioore(t2, i);
        G.LatinHypercube(t1, t2[i], 1, rng);
      }
      for (i = 0; t1 = samples[0], t2 = t1.get$n2D(), i < t2.length; ++i) {
        t1 = t1.twoD;
        if (i >= t1.length)
          return H.ioore(t1, i);
        G.LatinHypercube(t1[i], t2[i], 2, rng);
      }
      return 1;
    },
    getSubSampler$2: function(num, count) {
      var range = [0, 0, 0, 0];
      G.Sampler_ComputeSubWindow(J.$sub$n(this.xPixelEnd, this.xPixelStart), J.$sub$n(this.yPixelEnd, this.yPixelStart), num, count, range);
      if (J.$eq(range[0], range[1]) || J.$eq(range[2], range[3]))
        return;
      return U.HaltonSampler$(range[0], range[1], range[2], range[3], this.samplesPerPixel, this.shutterOpen, this.shutterClose);
    },
    roundSize$1: function(size) {
      return size;
    },
    HaltonSampler$7: function(xs, xe, ys, ye, ps, sopen, sclose) {
      var delta = P.max(J.$sub$n(this.xPixelEnd, this.xPixelStart), J.$sub$n(this.yPixelEnd, this.yPixelStart));
      this.wantedSamples = J.$mul$ns(J.$mul$ns(this.samplesPerPixel, delta), delta);
      this.currentSample = 0;
    },
    static: {HaltonSampler$: function(xs, xe, ys, ye, ps, sopen, sclose) {
        var t1 = new U.HaltonSampler(null, null, xs, xe, ys, ye, ps, sopen, sclose);
        t1.HaltonSampler$7(xs, xe, ys, ye, ps, sopen, sclose);
        return t1;
      }, HaltonSampler_Create: [function(params, film, camera) {
        var range, nsamp;
        range = [0, 0, 0, 0];
        film.getSampleExtent$1(range);
        nsamp = params.findOneInt$2("pixelsamples", 4);
        return U.HaltonSampler$(range[0], range[1], range[2], range[3], nsamp, camera.get$shutterOpen(), camera.get$shutterClose());
      }, "call$3", "HaltonSampler_Create$closure", 6, 0, 48]}
  },
  LowDiscrepancySampler: {
    "^": "Sampler;pixels,pixel,pixelIndex,nPixelSamples,sampleBuf,xPixelStart,xPixelEnd,yPixelStart,yPixelEnd,samplesPerPixel,shutterOpen,shutterClose",
    getSubSampler$2: function(num, count) {
      var extents = [0, 0, 0, 0];
      G.Sampler_ComputeSubWindow(J.$sub$n(this.xPixelEnd, this.xPixelStart), J.$sub$n(this.yPixelEnd, this.yPixelStart), num, count, extents);
      if (J.$eq(extents[0], extents[1]) || J.$eq(extents[2], extents[3]))
        return;
      return U.LowDiscrepancySampler$(extents[0], extents[1], extents[2], extents[3], this.nPixelSamples, this.shutterOpen, this.shutterClose);
    },
    roundSize$1: function(size) {
      return G.RoundUpPow2(size);
    },
    getMoreSamples$2: function(samples, rng) {
      var t1, t2;
      t1 = this.pixelIndex;
      t2 = this.pixels._numSamples;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 >= t2)
        return 0;
      if (this.sampleBuf == null) {
        if (0 >= samples.length)
          return H.ioore(samples, 0);
        t1 = G.LDPixelSampleFloatsNeeded(samples[0], this.nPixelSamples);
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
        this.sampleBuf = new Float32Array(t1);
      }
      t1 = this.pixel;
      this.pixels.getPixel$2(this.pixelIndex++, t1);
      G.LDPixelSample(t1[0], t1[1], this.shutterOpen, this.shutterClose, this.nPixelSamples, samples, this.sampleBuf, rng);
      return this.nPixelSamples;
    },
    maximumSampleCount$0: function() {
      return this.nPixelSamples;
    },
    LowDiscrepancySampler$7: function(xstart, xend, ystart, yend, nsamp, sopen, sclose) {
      var t1;
      this.pixels = Y.RandomImageSampler$(xstart, xend, ystart, yend);
      this.pixelIndex = 0;
      t1 = J.getInterceptor$n(nsamp);
      if (t1.$and(nsamp, t1.$sub(nsamp, 1)) !== 0) {
        $.Log.call$2(1, "Pixel samples being rounded up to power of 2");
        this.nPixelSamples = G.RoundUpPow2(nsamp);
      } else
        this.nPixelSamples = nsamp;
      this.sampleBuf = null;
    },
    static: {LowDiscrepancySampler$: function(xstart, xend, ystart, yend, nsamp, sopen, sclose) {
        var t1 = new U.LowDiscrepancySampler(null, new Int32Array(2), null, null, null, xstart, xend, ystart, yend, G.RoundUpPow2(nsamp), sopen, sclose);
        t1.LowDiscrepancySampler$7(xstart, xend, ystart, yend, nsamp, sopen, sclose);
        return t1;
      }, LowDiscrepancySampler_Create: [function(params, film, camera) {
        var extents, nsamp;
        extents = [0, 0, 0, 0];
        film.getSampleExtent$1(extents);
        nsamp = params.findOneInt$2("pixelsamples", 4);
        return U.LowDiscrepancySampler$(extents[0], extents[1], extents[2], extents[3], nsamp, camera.get$shutterOpen(), camera.get$shutterClose());
      }, "call$3", "LowDiscrepancySampler_Create$closure", 6, 0, 49]}
  },
  RandomSampler: {
    "^": "Sampler;continuous,pixels,pixel,pixelIndex,imageSamples,lensSamples,timeSamples,samplePos,xPixelStart,xPixelEnd,yPixelStart,yPixelEnd,samplesPerPixel,shutterOpen,shutterClose",
    maximumSampleCount$0: function() {
      return 1;
    },
    getMoreSamples$2: function(sample, rng) {
      var t1, t2, i, t3, t4, o, t5, j;
      t1 = this.pixelIndex;
      t2 = this.pixels._numSamples;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 >= t2) {
        if (this.continuous !== true)
          return 0;
        this.pixelIndex = 0;
      }
      if (J.$eq(this.samplePos, this.samplesPerPixel)) {
        t1 = this.pixel;
        this.pixels.getPixel$2(this.pixelIndex++, t1);
        i = 0;
        while (true) {
          t2 = this.samplesPerPixel;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t2 = this.timeSamples;
          t3 = rng.randomUInt$0();
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2[i] = (t3 & 16777215) / 16777216;
          t3 = this.imageSamples;
          t2 = rng.randomUInt$0();
          if (i >= t3.length)
            return H.ioore(t3, i);
          t3[i] = (t2 & 16777215) / 16777216;
          t2 = this.lensSamples;
          t3 = rng.randomUInt$0();
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2[i] = (t3 & 16777215) / 16777216;
          ++i;
        }
        while (true) {
          t2 = this.samplesPerPixel;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = 2 * t2;
          if (!(i < t2))
            break;
          t2 = this.imageSamples;
          t3 = rng.randomUInt$0();
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2[i] = (t3 & 16777215) / 16777216;
          t3 = this.lensSamples;
          t2 = rng.randomUInt$0();
          if (i >= t3.length)
            return H.ioore(t3, i);
          t3[i] = (t2 & 16777215) / 16777216;
          ++i;
        }
        for (t3 = this.imageSamples, t4 = t3.length, o = 0; o < t2; o += 2) {
          if (o >= t4)
            return H.ioore(t3, o);
          t3[o] = t3[o] + t1[0];
          t5 = o + 1;
          if (t5 >= t4)
            return H.ioore(t3, t5);
          t3[t5] = t3[t5] + t1[1];
        }
        this.samplePos = 0;
      }
      if (0 >= sample.length)
        return H.ioore(sample, 0);
      t1 = sample[0];
      t2 = this.imageSamples;
      t3 = this.samplePos;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = 2 * t3;
      if (t3 >>> 0 !== t3 || t3 >= t2.length)
        return H.ioore(t2, t3);
      t1.set$imageX(t2[t3]);
      t3 = this.imageSamples;
      t2 = this.samplePos;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = 2 * t2 + 1;
      if (t2 >>> 0 !== t2 || t2 >= t3.length)
        return H.ioore(t3, t2);
      t1.imageY = t3[t2];
      t2 = this.lensSamples;
      t3 = this.samplePos;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = 2 * t3;
      if (t3 >>> 0 !== t3 || t3 >= t2.length)
        return H.ioore(t2, t3);
      t1.lensU = t2[t3];
      t3 = this.lensSamples;
      t2 = this.samplePos;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = 2 * t2 + 1;
      if (t2 >>> 0 !== t2 || t2 >= t3.length)
        return H.ioore(t3, t2);
      t1.lensV = t3[t2];
      t2 = this.timeSamples;
      t3 = this.samplePos;
      if (t3 >>> 0 !== t3 || t3 >= t2.length)
        return H.ioore(t2, t3);
      t3 = t2[t3];
      t2 = this.shutterOpen;
      t4 = this.shutterClose;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t4 !== "number")
        return H.iae(t4);
      t1.time = (1 - t3) * t2 + t3 * t4;
      for (i = 0; i < t1.get$n1D().length; ++i) {
        j = 0;
        while (true) {
          t1 = sample[0];
          t2 = t1.get$n1D();
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2 = t2[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j < t2))
            break;
          t1 = t1.oneD;
          if (i < 0 || i >= t1.length)
            return H.ioore(t1, i);
          J.$indexSet$ax(t1[i], j, (rng.randomUInt$0() & 16777215) / 16777216);
          ++j;
        }
      }
      for (i = 0; i < t1.get$n2D().length; ++i) {
        j = 0;
        while (true) {
          t1 = sample[0];
          t2 = t1.get$n2D();
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2 = t2[i];
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j < 2 * t2))
            break;
          t1 = t1.twoD;
          if (i >= t1.length)
            return H.ioore(t1, i);
          J.$indexSet$ax(t1[i], j, (rng.randomUInt$0() & 16777215) / 16777216);
          ++j;
        }
      }
      this.samplePos = J.$add$ns(this.samplePos, 1);
      return 1;
    },
    roundSize$1: function(sz) {
      return sz;
    },
    getSubSampler$2: function(num, count) {
      var extents = [0, 0, 0, 0];
      G.Sampler_ComputeSubWindow(J.$sub$n(this.xPixelEnd, this.xPixelStart), J.$sub$n(this.yPixelEnd, this.yPixelStart), num, count, extents);
      if (J.$eq(extents[0], extents[1]) || J.$eq(extents[2], extents[3]))
        return;
      return U.RandomSampler$(extents[0], extents[1], extents[2], extents[3], this.samplesPerPixel, this.continuous, this.shutterOpen, this.shutterClose);
    },
    RandomSampler$8: function(xstart, xend, ystart, yend, ns, continuous, sopen, sclose) {
      var t1;
      this.pixels = Y.TileImageSampler$(xstart, xend, ystart, yend, true, 32);
      this.pixelIndex = 0;
      t1 = this.samplesPerPixel;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = 2 * t1;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.imageSamples = new Float32Array(t1);
      t1 = this.samplesPerPixel;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = 2 * t1;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.lensSamples = new Float32Array(t1);
      t1 = this.samplesPerPixel;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.timeSamples = new Float32Array(t1);
      this.samplePos = this.samplesPerPixel;
    },
    static: {RandomSampler_Create: [function(params, film, camera) {
        var ns, continuous, extents;
        ns = params.findOneInt$2("pixelsamples", 1);
        continuous = params.findOneBool$2("continuous", true);
        extents = [0, 0, 0, 0];
        film.getSampleExtent$1(extents);
        return U.RandomSampler$(extents[0], extents[1], extents[2], extents[3], ns, continuous, camera.get$shutterOpen(), camera.get$shutterClose());
      }, "call$3", "RandomSampler_Create$closure", 6, 0, 50], RandomSampler$: function(xstart, xend, ystart, yend, ns, continuous, sopen, sclose) {
        var t1 = new U.RandomSampler(continuous, null, new Int32Array(2), null, null, null, null, null, xstart, xend, ystart, yend, ns, sopen, sclose);
        t1.RandomSampler$8(xstart, xend, ystart, yend, ns, continuous, sopen, sclose);
        return t1;
      }}
  },
  StratifiedSampler: {
    "^": "Sampler;xPixelSamples,yPixelSamples,nPixelSamples,jitterSamples,pixels,pixel,pixelIndex,imageSamples,lensSamples,timeSamples,xPixelStart,xPixelEnd,yPixelStart,yPixelEnd,samplesPerPixel,shutterOpen,shutterClose",
    roundSize$1: function(size) {
      return size;
    },
    getSubSampler$2: function(num, count) {
      var range = [0, 0, 0, 0];
      G.Sampler_ComputeSubWindow(J.$sub$n(this.xPixelEnd, this.xPixelStart), J.$sub$n(this.yPixelEnd, this.yPixelStart), num, count, range);
      if (J.$eq(range[0], range[1]) || J.$eq(range[2], range[3]))
        return;
      return U.StratifiedSampler$(range[0], range[1], range[2], range[3], this.xPixelSamples, this.yPixelSamples, this.jitterSamples, this.shutterOpen, this.shutterClose);
    },
    getMoreSamples$2: function(samples, rng) {
      var t1, t2, t3, t4, t5, t6, o, t7, i, j;
      t1 = this.pixelIndex;
      t2 = this.pixels._numSamples;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 >= t2)
        return 0;
      t1 = this.nPixelSamples;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = this.jitterSamples;
      G.StratifiedSample2D(this.imageSamples, this.xPixelSamples, this.yPixelSamples, rng, t1);
      G.StratifiedSample2D(this.lensSamples, this.xPixelSamples, this.yPixelSamples, rng, t1);
      G.StratifiedSample1D(this.timeSamples, J.$mul$ns(this.xPixelSamples, this.yPixelSamples), rng, t1);
      t1 = this.pixel;
      this.pixels.getPixel$2(this.pixelIndex++, t1);
      t2 = this.xPixelSamples;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.yPixelSamples;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = 2 * t2 * t3;
      t5 = this.imageSamples;
      t6 = t5.length;
      o = 0;
      for (; o < t4; o += 2) {
        if (o >= t6)
          return H.ioore(t5, o);
        t5[o] = t5[o] + t1[0];
        t7 = o + 1;
        if (t7 >= t6)
          return H.ioore(t5, t7);
        t5[t7] = t5[t7] + t1[1];
      }
      G.Shuffle(this.lensSamples, 0, t2 * t3, 2, rng);
      G.Shuffle(this.timeSamples, 0, J.$mul$ns(this.xPixelSamples, this.yPixelSamples), 1, rng);
      t1 = samples.length;
      t2 = this.shutterOpen;
      t3 = this.shutterClose;
      i = 0;
      while (true) {
        t4 = this.nPixelSamples;
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(i < t4))
          break;
        if (i >= t1)
          return H.ioore(samples, i);
        t4 = samples[i];
        t5 = this.imageSamples;
        t6 = 2 * i;
        if (t6 >= t5.length)
          return H.ioore(t5, t6);
        t4.set$imageX(t5[t6]);
        t5 = this.imageSamples;
        t7 = t6 + 1;
        if (t7 >= t5.length)
          return H.ioore(t5, t7);
        t4.imageY = t5[t7];
        t5 = this.lensSamples;
        if (t6 >= t5.length)
          return H.ioore(t5, t6);
        t4.lensU = t5[t6];
        t6 = this.lensSamples;
        if (t7 >= t6.length)
          return H.ioore(t6, t7);
        t4.lensV = t6[t7];
        t7 = this.timeSamples;
        if (i >= t7.length)
          return H.ioore(t7, i);
        t7 = t7[i];
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4.time = (1 - t7) * t2 + t7 * t3;
        for (j = 0; t4 = samples[i], j < t4.get$n1D().length; ++j) {
          t4 = t4.oneD;
          if (j < 0 || j >= t4.length)
            return H.ioore(t4, j);
          t4 = t4[j];
          t5 = samples[i].get$n1D();
          if (j >= t5.length)
            return H.ioore(t5, j);
          G.LatinHypercube(t4, t5[j], 1, rng);
        }
        for (j = 0; t4 = samples[i], t5 = t4.get$n2D(), j < t5.length; ++j) {
          t4 = t4.twoD;
          if (j >= t4.length)
            return H.ioore(t4, j);
          G.LatinHypercube(t4[j], t5[j], 2, rng);
        }
        ++i;
      }
      return t4;
    },
    maximumSampleCount$0: function() {
      return this.nPixelSamples;
    },
    StratifiedSampler$9: function(xstart, xend, ystart, yend, xs, ys, jitterSamples, sopen, sclose) {
      var t1;
      this.pixels = Y.RandomImageSampler$(xstart, xend, ystart, yend);
      this.pixelIndex = 0;
      this.xPixelSamples = xs;
      this.yPixelSamples = ys;
      t1 = J.$mul$ns(xs, ys);
      this.nPixelSamples = t1;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = 2 * t1;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.imageSamples = new Float32Array(t1);
      t1 = this.nPixelSamples;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = 2 * t1;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.lensSamples = new Float32Array(t1);
      t1 = J.$mul$ns(this.xPixelSamples, this.yPixelSamples);
      if (typeof t1 !== "number" || Math.floor(t1) !== t1)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
      this.timeSamples = new Float32Array(t1);
    },
    static: {StratifiedSampler$: function(xstart, xend, ystart, yend, xs, ys, jitterSamples, sopen, sclose) {
        var t1 = new U.StratifiedSampler(null, null, null, jitterSamples, null, new Int32Array(2), null, null, null, null, xstart, xend, ystart, yend, J.$mul$ns(xs, ys), sopen, sclose);
        t1.StratifiedSampler$9(xstart, xend, ystart, yend, xs, ys, jitterSamples, sopen, sclose);
        return t1;
      }, StratifiedSampler_Create: [function(params, film, camera) {
        var jitter, extents, pixelsamples, ysamp, xsamp;
        jitter = params.findOneBool$2("jitter", true);
        extents = [0, 0, 0, 0];
        film.getSampleExtent$1(extents);
        pixelsamples = params.findOneInt$2("pixelsamples", null);
        if (pixelsamples != null) {
          ysamp = pixelsamples;
          xsamp = ysamp;
        } else {
          xsamp = params.findOneInt$2("xsamples", 2);
          ysamp = params.findOneInt$2("ysamples", 2);
        }
        return U.StratifiedSampler$(extents[0], extents[1], extents[2], extents[3], xsamp, ysamp, jitter, camera.get$shutterOpen(), camera.get$shutterClose());
      }, "call$3", "StratifiedSampler_Create$closure", 6, 0, 51]}
  }
}],
["shapes", "package:dartray/shapes/shapes.dart", , M, {
  "^": "",
  ConeShape: {
    "^": "Shape;radius,height>,phiMax,objectToWorld,worldToObject,reverseOrientation,transformSwapsHandedness,shapeId",
    objectBound$0: function() {
      var t1, t2;
      t1 = this.radius;
      t2 = J.getInterceptor$n(t1);
      return G.BBox$(new G.Point(t2.$negate(t1), t2.$negate(t1), 0), new G.Point(t1, t1, this.height));
    },
    intersect$4: function(r, tHit, rayEpsilon, dg) {
      var ray, k, t1, $A, t2, t00, t10, thit, t3, t4, phit, phi, v, dpdu, dpdv, t5, d2Pduu, d2Pduv, $E, $F, $G, $N, e, f, g, invEGF2, t6, t7, o2w;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      k = J.$div$n(this.radius, this.height);
      k = J.$mul$ns(k, k);
      t1 = J.getInterceptor$ns(k);
      $A = J.$sub$n(J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.direction)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.direction))), J.$mul$ns(t1.$mul(k, J.get$z$x(ray.direction)), J.get$z$x(ray.direction)));
      t2 = J.$sub$n(J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.origin))), J.$mul$ns(t1.$mul(k, J.get$z$x(ray.direction)), J.$sub$n(J.get$z$x(ray.origin), this.height)));
      if (typeof t2 !== "number")
        return H.iae(t2);
      t00 = [0];
      t10 = [0];
      if (!G.Quadratic($A, 2 * t2, J.$sub$n(J.$add$ns(J.$mul$ns(J.get$x$x(ray.origin), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.origin), J.get$y$x(ray.origin))), J.$mul$ns(t1.$mul(k, J.$sub$n(J.get$z$x(ray.origin), this.height)), J.$sub$n(J.get$z$x(ray.origin), this.height))), t00, t10))
        return false;
      if (J.$gt$n(t00[0], ray.maxDistance) || J.$lt$n(t10[0], ray.minDistance))
        return false;
      thit = t00[0];
      if (J.$lt$n(thit, ray.minDistance)) {
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
      }
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t2 = J.getInterceptor$x(t1);
      t3 = t2.get$x(t1);
      t4 = t2.get$y(t1);
      t1 = t2.get$z(t1);
      phit = new G.Point(t3, t4, t1);
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      phi = Math.atan2(t4, t3);
      if (phi < 0)
        phi += 6.283185307179586;
      if (J.$lt$n(t1, 0) || J.$gt$n(t1, this.height) || phi > this.phiMax) {
        if (J.$eq(thit, t10[0]))
          return false;
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        phit = new G.Point(t3, t4, t1);
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        phi = Math.atan2(t4, t3);
        if (phi < 0)
          phi += 6.283185307179586;
        if (J.$lt$n(t1, 0) || J.$gt$n(t1, this.height) || phi > this.phiMax)
          return false;
      }
      t1 = this.phiMax;
      v = J.$div$n(phit.z, this.height);
      t2 = this.phiMax;
      t3 = phit.y;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = phit.x;
      if (typeof t4 !== "number")
        return H.iae(t4);
      dpdu = new G.Vector(-t2 * t3, t2 * t4, 0);
      if (typeof v !== "number")
        return H.iae(v);
      t2 = 1 - v;
      dpdv = new G.Vector(-t4 / t2, J.$div$n(J.$negate$n(phit.y), t2), this.height);
      t4 = phit.x;
      t3 = phit.y;
      t5 = this.phiMax;
      d2Pduu = new G.Vector(t4, t3, 0).$mul(0, -t5 * t5);
      d2Pduv = new G.Vector(phit.y, J.$negate$n(phit.x), 0).$mul(0, this.phiMax / t2);
      $E = G.Vector_Dot(dpdu, dpdu);
      $F = G.Vector_Dot(dpdu, dpdv);
      $G = G.Vector_Dot(dpdv, dpdv);
      t2 = G.Vector_Cross(dpdu, dpdv);
      $N = t2.$div(0, t2.length$0(0));
      e = G.Vector_Dot($N, d2Pduu);
      f = G.Vector_Dot($N, d2Pduv);
      g = G.Vector_Dot($N, new G.Vector(0, 0, 0));
      t2 = J.$sub$n(J.$mul$ns($E, $G), J.$mul$ns($F, $F));
      if (typeof t2 !== "number")
        return H.iae(t2);
      invEGF2 = 1 / t2;
      t2 = J.getInterceptor$ns(f);
      t5 = J.getInterceptor$ns(e);
      t5 = dpdu.$mul(0, J.$mul$ns(J.$sub$n(t2.$mul(f, $F), t5.$mul(e, $G)), invEGF2)).$add(0, dpdv.$mul(0, J.$mul$ns(J.$sub$n(t5.$mul(e, $F), t2.$mul(f, $E)), invEGF2)));
      t3 = t5.x;
      t4 = t5.y;
      t5 = t5.z;
      t6 = J.getInterceptor$ns(g);
      t6 = dpdu.$mul(0, J.$mul$ns(J.$sub$n(t6.$mul(g, $F), t2.$mul(f, $G)), invEGF2)).$add(0, dpdv.$mul(0, J.$mul$ns(J.$sub$n(t2.$mul(f, $F), t6.$mul(g, $E)), invEGF2)));
      t2 = t6.x;
      t7 = t6.y;
      t6 = t6.z;
      o2w = this.objectToWorld;
      dg.set$8(o2w.transformPoint$1(phit), o2w.transformVector$1(dpdu), o2w.transformVector$1(dpdv), o2w.transformNormal$1(new G.Normal(t3, t4, t5)), o2w.transformNormal$1(new G.Normal(t2, t7, t6)), phi / t1, v, this);
      tHit[0] = thit;
      if (typeof thit !== "number")
        return H.iae(thit);
      rayEpsilon[0] = 0.0005 * thit;
      return true;
    },
    intersectP$1: function(r) {
      var ray, k, t1, $A, t2, t00, t10, thit, t3, t4, phi;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      k = J.$div$n(this.radius, this.height);
      k = J.$mul$ns(k, k);
      t1 = J.getInterceptor$ns(k);
      $A = J.$sub$n(J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.direction)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.direction))), J.$mul$ns(t1.$mul(k, J.get$z$x(ray.direction)), J.get$z$x(ray.direction)));
      t2 = J.$sub$n(J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.origin))), J.$mul$ns(t1.$mul(k, J.get$z$x(ray.direction)), J.$sub$n(J.get$z$x(ray.origin), this.height)));
      if (typeof t2 !== "number")
        return H.iae(t2);
      t00 = [0];
      t10 = [0];
      if (!G.Quadratic($A, 2 * t2, J.$sub$n(J.$add$ns(J.$mul$ns(J.get$x$x(ray.origin), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.origin), J.get$y$x(ray.origin))), J.$mul$ns(t1.$mul(k, J.$sub$n(J.get$z$x(ray.origin), this.height)), J.$sub$n(J.get$z$x(ray.origin), this.height))), t00, t10))
        return false;
      if (J.$gt$n(t00[0], ray.maxDistance) || J.$lt$n(t10[0], ray.minDistance))
        return false;
      thit = t00[0];
      if (J.$lt$n(thit, ray.minDistance)) {
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
      }
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t2 = J.getInterceptor$x(t1);
      t3 = t2.get$x(t1);
      t4 = t2.get$y(t1);
      t1 = t2.get$z(t1);
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      phi = Math.atan2(t4, t3);
      if (phi < 0)
        phi += 6.283185307179586;
      if (J.$lt$n(t1, 0) || J.$gt$n(t1, this.height) || phi > this.phiMax) {
        if (J.$eq(thit, t10[0]))
          return false;
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        phi = Math.atan2(t4, t3);
        if (phi < 0)
          phi += 6.283185307179586;
        if (J.$lt$n(t1, 0) || J.$gt$n(t1, this.height) || phi > this.phiMax)
          return false;
      }
      return true;
    },
    area$0: function() {
      var t1, t2, t3;
      t1 = this.radius;
      t2 = this.height;
      t3 = J.getInterceptor$ns(t1);
      t2 = J.$add$ns(J.$mul$ns(t2, t2), t3.$mul(t1, t1));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      return J.$div$n(J.$mul$ns(t3.$mul(t1, Math.sqrt(t2)), this.phiMax), 2);
    },
    static: {ConeShape_Create: [function(o2w, w2o, reverseOrientation, params) {
        var radius, height, phimax, t1, t2;
        radius = params.findOneFloat$2("radius", 1);
        height = params.findOneFloat$2("height", 1);
        phimax = params.findOneFloat$2("phimax", 360);
        t1 = $.Shape__nextShapeId;
        $.Shape__nextShapeId = t1 + 1;
        t1 = new M.ConeShape(radius, height, null, o2w, w2o, reverseOrientation, false, t1);
        t2 = J.clamp$2$n(phimax, 0, 360);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1.phiMax = 0.017453292519943295 * t2;
        return t1;
      }, "call$4", "ConeShape_Create$closure", 8, 0, 52]}
  },
  CylinderShape: {
    "^": "Shape;radius,zmin,zmax,phiMax,objectToWorld,worldToObject,reverseOrientation,transformSwapsHandedness,shapeId",
    objectBound$0: function() {
      var t1, t2;
      t1 = this.radius;
      t2 = J.getInterceptor$n(t1);
      return G.BBox$(new G.Point(t2.$negate(t1), t2.$negate(t1), this.zmin), new G.Point(t1, t1, this.zmax));
    },
    intersect$4: function(r, tHit, rayEpsilon, dg) {
      var ray, $A, t1, t2, _t0, _t1, t00, thit, t3, t4, t5, phit, phi, v, dpdu, dpdv, d2Pduu, $E, $F, $G, $N, e, f, g, invEGF2, t6, t7, o2w;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      $A = J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.direction)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.direction)));
      t1 = J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.origin)));
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.radius;
      _t0 = [0];
      _t1 = [0];
      if (!G.Quadratic($A, 2 * t1, J.$sub$n(J.$add$ns(J.$mul$ns(J.get$x$x(ray.origin), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.origin), J.get$y$x(ray.origin))), J.$mul$ns(t2, t2)), _t0, _t1))
        return false;
      t00 = _t0[0];
      t1 = _t1[0];
      t2 = J.getInterceptor$n(t00);
      if (t2.$gt(t00, ray.maxDistance) || J.$lt$n(t1, ray.minDistance))
        return false;
      if (t2.$lt(t00, ray.minDistance)) {
        if (J.$gt$n(t1, ray.maxDistance))
          return false;
        thit = t1;
      } else
        thit = t00;
      t2 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t3 = J.getInterceptor$x(t2);
      t4 = t3.get$x(t2);
      t5 = t3.get$y(t2);
      t2 = t3.get$z(t2);
      phit = new G.Point(t4, t5, t2);
      if (typeof t5 !== "number")
        H.throwExpression(P.ArgumentError$(t5));
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      phi = Math.atan2(t5, t4);
      if (phi < 0)
        phi += 6.283185307179586;
      if (J.$lt$n(t2, this.zmin) || J.$gt$n(t2, this.zmax) || phi > this.phiMax) {
        if (J.$eq(thit, t1))
          return false;
        if (J.$gt$n(t1, ray.maxDistance))
          return false;
        t2 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t1));
        t3 = J.getInterceptor$x(t2);
        t4 = t3.get$x(t2);
        t5 = t3.get$y(t2);
        t2 = t3.get$z(t2);
        phit = new G.Point(t4, t5, t2);
        if (typeof t5 !== "number")
          H.throwExpression(P.ArgumentError$(t5));
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        phi = Math.atan2(t5, t4);
        if (phi < 0)
          phi += 6.283185307179586;
        if (J.$lt$n(t2, this.zmin) || J.$gt$n(t2, this.zmax) || phi > this.phiMax)
          return false;
        thit = t1;
      }
      t1 = this.phiMax;
      v = J.$div$n(J.$sub$n(phit.z, this.zmin), this.zmax - this.zmin);
      t2 = this.phiMax;
      t3 = -t2;
      t4 = phit.y;
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = phit.x;
      if (typeof t5 !== "number")
        return H.iae(t5);
      dpdu = new G.Vector(t3 * t4, t2 * t5, 0);
      dpdv = new G.Vector(0, 0, this.zmax - this.zmin);
      d2Pduu = new G.Vector(t5, t4, 0).$mul(0, t3 * t2);
      $E = G.Vector_Dot(dpdu, dpdu);
      $F = G.Vector_Dot(dpdu, dpdv);
      $G = G.Vector_Dot(dpdv, dpdv);
      t2 = G.Vector_Cross(dpdu, dpdv);
      $N = t2.$div(0, t2.length$0(0));
      e = G.Vector_Dot($N, d2Pduu);
      f = G.Vector_Dot($N, new G.Vector(0, 0, 0));
      g = G.Vector_Dot($N, new G.Vector(0, 0, 0));
      t2 = J.$sub$n(J.$mul$ns($E, $G), J.$mul$ns($F, $F));
      if (typeof t2 !== "number")
        return H.iae(t2);
      invEGF2 = 1 / t2;
      t2 = J.getInterceptor$ns(f);
      t3 = J.getInterceptor$ns(e);
      t3 = dpdu.$mul(0, J.$mul$ns(J.$sub$n(t2.$mul(f, $F), t3.$mul(e, $G)), invEGF2)).$add(0, dpdv.$mul(0, J.$mul$ns(J.$sub$n(t3.$mul(e, $F), t2.$mul(f, $E)), invEGF2)));
      t4 = t3.x;
      t5 = t3.y;
      t3 = t3.z;
      t6 = J.getInterceptor$ns(g);
      t6 = dpdu.$mul(0, J.$mul$ns(J.$sub$n(t6.$mul(g, $F), t2.$mul(f, $G)), invEGF2)).$add(0, dpdv.$mul(0, J.$mul$ns(J.$sub$n(t2.$mul(f, $F), t6.$mul(g, $E)), invEGF2)));
      t2 = t6.x;
      t7 = t6.y;
      t6 = t6.z;
      o2w = this.objectToWorld;
      dg.set$8(o2w.transformPoint$1(phit), o2w.transformVector$1(dpdu), o2w.transformVector$1(dpdv), o2w.transformNormal$1(new G.Normal(t4, t5, t3)), o2w.transformNormal$1(new G.Normal(t2, t7, t6)), phi / t1, v, this);
      tHit[0] = thit;
      if (typeof thit !== "number")
        return H.iae(thit);
      rayEpsilon[0] = 0.0005 * thit;
      return true;
    },
    intersectP$1: function(r) {
      var ray, $A, t1, t2, _t0, _t1, t00, thit, t3, t4, t5, phi;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      $A = J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.direction)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.direction)));
      t1 = J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.origin)));
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.radius;
      _t0 = [0];
      _t1 = [0];
      if (!G.Quadratic($A, 2 * t1, J.$sub$n(J.$add$ns(J.$mul$ns(J.get$x$x(ray.origin), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.origin), J.get$y$x(ray.origin))), J.$mul$ns(t2, t2)), _t0, _t1))
        return false;
      t00 = _t0[0];
      t1 = _t1[0];
      t2 = J.getInterceptor$n(t00);
      if (t2.$gt(t00, ray.maxDistance) || J.$lt$n(t1, ray.minDistance))
        return false;
      if (t2.$lt(t00, ray.minDistance)) {
        if (J.$gt$n(t1, ray.maxDistance))
          return false;
        thit = t1;
      } else
        thit = t00;
      t2 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t3 = J.getInterceptor$x(t2);
      t4 = t3.get$x(t2);
      t5 = t3.get$y(t2);
      t2 = t3.get$z(t2);
      if (typeof t5 !== "number")
        H.throwExpression(P.ArgumentError$(t5));
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      phi = Math.atan2(t5, t4);
      if (phi < 0)
        phi += 6.283185307179586;
      if (J.$lt$n(t2, this.zmin) || J.$gt$n(t2, this.zmax) || phi > this.phiMax) {
        if (J.$eq(thit, t1))
          return false;
        if (J.$gt$n(t1, ray.maxDistance))
          return false;
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t1));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        phi = Math.atan2(t4, t3);
        if (phi < 0)
          phi += 6.283185307179586;
        if (J.$lt$n(t1, this.zmin) || J.$gt$n(t1, this.zmax) || phi > this.phiMax)
          return false;
      }
      return true;
    },
    area$0: function() {
      var t1, t2, t3, t4;
      t1 = this.zmax;
      t2 = this.zmin;
      t3 = this.phiMax;
      t4 = this.radius;
      if (typeof t4 !== "number")
        return H.iae(t4);
      return (t1 - t2) * t3 * t4;
    },
    sample$3: function(u1, u2, Ns) {
      var t1, t2, t, t3, t4, t5, t6;
      t1 = this.zmin;
      t2 = this.zmax;
      if (typeof u1 !== "number")
        return H.iae(u1);
      t = J.$mul$ns(u2, this.phiMax);
      t3 = this.radius;
      t4 = typeof t !== "number";
      if (t4)
        H.throwExpression(P.ArgumentError$(t));
      t5 = J.getInterceptor$ns(t3);
      t6 = t5.$mul(t3, Math.cos(t));
      if (t4)
        H.throwExpression(P.ArgumentError$(t));
      t3 = t5.$mul(t3, Math.sin(t));
      t4 = this.objectToWorld;
      t5 = t4.transformNormal$1(new G.Normal(t6, t3, 0));
      Ns.copy$1(t5.$div(0, t5.length$0(0)));
      if (this.reverseOrientation === true)
        J.scale$1$x(Ns, -1);
      return t4.transformPoint$1(new G.Point(t6, t3, (1 - u1) * t1 + u1 * t2));
    },
    CylinderShape$7: function(o2w, w2o, ro, radius, z0, z1, phimax) {
      var t1;
      this.zmin = P.min(z0, z1);
      this.zmax = P.max(z0, z1);
      t1 = J.clamp$2$n(phimax, 0, 360);
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.phiMax = 0.017453292519943295 * t1;
    },
    static: {CylinderShape_Create: [function(o2w, w2o, reverseOrientation, params) {
        var radius, zmin, zmax, phimax, t1;
        radius = params.findOneFloat$2("radius", 1);
        zmin = params.findOneFloat$2("zmin", -1);
        zmax = params.findOneFloat$2("zmax", 1);
        phimax = params.findOneFloat$2("phimax", 360);
        t1 = $.Shape__nextShapeId;
        $.Shape__nextShapeId = t1 + 1;
        t1 = new M.CylinderShape(radius, null, null, null, o2w, w2o, reverseOrientation, false, t1);
        t1.CylinderShape$7(o2w, w2o, reverseOrientation, radius, zmin, zmax, phimax);
        return t1;
      }, "call$4", "CylinderShape_Create$closure", 8, 0, 53]}
  },
  DiskShape: {
    "^": "Shape;height>,radius,innerRadius,phiMax,objectToWorld,worldToObject,reverseOrientation,transformSwapsHandedness,shapeId",
    objectBound$0: function() {
      var t1, t2, t3, t4;
      t1 = this.radius;
      t2 = J.getInterceptor$n(t1);
      t3 = t2.$negate(t1);
      t2 = t2.$negate(t1);
      t4 = this.height;
      return G.BBox$(new G.Point(t3, t2, t4), new G.Point(t1, t1, t4));
    },
    intersect$4: function(r, tHit, rayEpsilon, dg) {
      var ray, thit, t1, t2, t3, t4, dist2, t5, t6, t7, phi, t8, t9, oneMinusV, invOneMinusV, t10, t11, dpdu, dpdv, o2w;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      if (J.abs$0$n(J.get$z$x(ray.direction)) < 1e-7)
        return false;
      thit = J.$div$n(J.$sub$n(this.height, J.get$z$x(ray.origin)), J.get$z$x(ray.direction));
      t1 = J.getInterceptor$n(thit);
      if (t1.$lt(thit, ray.minDistance) || t1.$gt(thit, ray.maxDistance))
        return false;
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t2 = J.getInterceptor$x(t1);
      t3 = t2.get$x(t1);
      t4 = t2.get$y(t1);
      t1 = t2.get$z(t1);
      dist2 = J.$add$ns(J.$mul$ns(t3, t3), J.$mul$ns(t4, t4));
      t2 = this.radius;
      t5 = J.getInterceptor$ns(t2);
      t6 = J.getInterceptor$n(dist2);
      if (!t6.$gt(dist2, t5.$mul(t2, t2))) {
        t7 = this.innerRadius;
        t7 = t6.$lt(dist2, J.$mul$ns(t7, t7));
        t6 = t7;
      } else
        t6 = true;
      if (t6)
        return false;
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      phi = Math.atan2(t4, t3);
      if (phi < 0)
        phi += 6.283185307179586;
      t6 = this.phiMax;
      if (typeof t6 !== "number")
        return H.iae(t6);
      if (phi > t6)
        return false;
      if (typeof dist2 !== "number")
        H.throwExpression(P.ArgumentError$(dist2));
      t7 = Math.sqrt(dist2);
      t8 = this.innerRadius;
      if (typeof t8 !== "number")
        return H.iae(t8);
      t9 = t5.$sub(t2, t8);
      if (typeof t9 !== "number")
        return H.iae(t9);
      oneMinusV = (t7 - t8) / t9;
      invOneMinusV = oneMinusV > 0 ? 1 / oneMinusV : 0;
      t7 = J.$mul$ns(J.$negate$n(this.phiMax), t4);
      t9 = J.$mul$ns(this.phiMax, t3);
      t10 = J.$mul$ns(J.$negate$n(t3), invOneMinusV);
      t11 = J.$mul$ns(J.$negate$n(t4), invOneMinusV);
      dpdu = new G.Vector(t7, t9, 0).$mul(0, J.$mul$ns(this.phiMax, 0.15915494309189535));
      dpdv = new G.Vector(t10, t11, 0).$mul(0, J.$div$n(t5.$sub(t2, t8), t2));
      o2w = this.objectToWorld;
      dg.set$8(o2w.transformPoint$1(new G.Point(t3, t4, t1)), o2w.transformVector$1(dpdu), o2w.transformVector$1(dpdv), o2w.transformNormal$1(new G.Normal(0, 0, 0)), o2w.transformNormal$1(new G.Normal(0, 0, 0)), phi / t6, 1 - oneMinusV, this);
      tHit[0] = thit;
      if (typeof thit !== "number")
        return H.iae(thit);
      rayEpsilon[0] = 0.0005 * thit;
      return true;
    },
    intersectP$1: function(r) {
      var ray, thit, t1, t2, t3, t4, dist2, phi;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      if (J.abs$0$n(J.get$z$x(ray.direction)) < 1e-7)
        return false;
      thit = J.$div$n(J.$sub$n(this.height, J.get$z$x(ray.origin)), J.get$z$x(ray.direction));
      t1 = J.getInterceptor$n(thit);
      if (t1.$lt(thit, ray.minDistance) || t1.$gt(thit, ray.maxDistance))
        return false;
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t2 = J.getInterceptor$x(t1);
      t3 = t2.get$x(t1);
      t4 = t2.get$y(t1);
      t2.get$z(t1);
      dist2 = J.$add$ns(J.$mul$ns(t3, t3), J.$mul$ns(t4, t4));
      t1 = this.radius;
      t2 = J.getInterceptor$n(dist2);
      if (!t2.$gt(dist2, J.$mul$ns(t1, t1))) {
        t1 = this.innerRadius;
        t1 = t2.$lt(dist2, J.$mul$ns(t1, t1));
      } else
        t1 = true;
      if (t1)
        return false;
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      phi = Math.atan2(t4, t3);
      if (phi < 0)
        phi += 6.283185307179586;
      t1 = this.phiMax;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (phi > t1)
        return false;
      return true;
    },
    area$0: function() {
      var t1, t2;
      t1 = this.radius;
      t2 = this.innerRadius;
      return J.$mul$ns(J.$mul$ns(this.phiMax, 0.5), J.$sub$n(J.$mul$ns(t1, t1), J.$mul$ns(t2, t2)));
    },
    sample$3: function(u1, u2, Ns) {
      var t00, t1, t2, t3;
      t00 = [0];
      t1 = [0];
      G.ConcentricSampleDisk(u1, u2, t00, t1);
      t2 = this.radius;
      t00 = J.$mul$ns(t00[0], t2);
      t2 = J.$mul$ns(t1[0], t2);
      t1 = this.height;
      t3 = this.objectToWorld;
      Ns.copy$1(t3.transformNormal$1(new G.Normal(0, 0, 1)));
      Ns.normalize$0();
      if (this.reverseOrientation === true)
        Ns.scale$1(0, -1);
      return t3.transformPoint$1(new G.Point(t00, t2, t1));
    },
    static: {DiskShape_Create: [function(o2w, w2o, reverseOrientation, params) {
        var height, radius, inner_radius, phimax, t1, t2;
        height = params.findOneFloat$2("height", 0);
        radius = params.findOneFloat$2("radius", 1);
        inner_radius = params.findOneFloat$2("innerradius", 0);
        phimax = params.findOneFloat$2("phimax", 360);
        t1 = $.Shape__nextShapeId;
        $.Shape__nextShapeId = t1 + 1;
        t1 = new M.DiskShape(height, radius, inner_radius, phimax, o2w, w2o, reverseOrientation, false, t1);
        t2 = J.clamp$2$n(phimax, 0, 360);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1.phiMax = 0.017453292519943295 * t2;
        return t1;
      }, "call$4", "DiskShape_Create$closure", 8, 0, 54]}
  },
  HyperboloidShape: {
    "^": "Shape;p1,p2,zmin,zmax,phiMax,rmax,a,c<,objectToWorld,worldToObject,reverseOrientation,transformSwapsHandedness,shapeId",
    objectBound$0: function() {
      var t1, t2;
      t1 = this.rmax;
      t2 = -t1;
      return G.BBox$(new G.Point(t2, t2, this.zmin), new G.Point(t1, t1, this.zmax));
    },
    intersect$4: function(r, tHit, rayEpsilon, dg) {
      var ray, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t00, t110, thit, phit, v, pr, phi, cosphi, sinphi, dpdu, dpdv, d2Pduu, d2Pduv, $E, $F, $G, $N, e, f, g, invEGF2, o2w;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      t1 = this.a;
      t2 = J.get$x$x(ray.direction);
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = J.get$x$x(ray.direction);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.a;
      t5 = J.get$y$x(ray.direction);
      if (typeof t4 !== "number")
        return t4.$mul();
      if (typeof t5 !== "number")
        return H.iae(t5);
      t6 = J.get$y$x(ray.direction);
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = this.c;
      t8 = J.get$z$x(ray.direction);
      if (typeof t7 !== "number")
        return t7.$mul();
      if (typeof t8 !== "number")
        return H.iae(t8);
      t9 = J.get$z$x(ray.direction);
      if (typeof t9 !== "number")
        return H.iae(t9);
      t10 = this.a;
      t11 = J.get$x$x(ray.direction);
      if (typeof t10 !== "number")
        return t10.$mul();
      if (typeof t11 !== "number")
        return H.iae(t11);
      t12 = J.get$x$x(ray.origin);
      if (typeof t12 !== "number")
        return H.iae(t12);
      t13 = this.a;
      t14 = J.get$y$x(ray.direction);
      if (typeof t13 !== "number")
        return t13.$mul();
      if (typeof t14 !== "number")
        return H.iae(t14);
      t15 = J.get$y$x(ray.origin);
      if (typeof t15 !== "number")
        return H.iae(t15);
      t16 = this.c;
      t17 = J.get$z$x(ray.direction);
      if (typeof t16 !== "number")
        return t16.$mul();
      if (typeof t17 !== "number")
        return H.iae(t17);
      t18 = J.get$z$x(ray.origin);
      if (typeof t18 !== "number")
        return H.iae(t18);
      t19 = this.a;
      t20 = J.get$x$x(ray.origin);
      if (typeof t19 !== "number")
        return t19.$mul();
      if (typeof t20 !== "number")
        return H.iae(t20);
      t21 = J.get$x$x(ray.origin);
      if (typeof t21 !== "number")
        return H.iae(t21);
      t22 = this.a;
      t23 = J.get$y$x(ray.origin);
      if (typeof t22 !== "number")
        return t22.$mul();
      if (typeof t23 !== "number")
        return H.iae(t23);
      t24 = J.get$y$x(ray.origin);
      if (typeof t24 !== "number")
        return H.iae(t24);
      t25 = this.c;
      t26 = J.get$z$x(ray.origin);
      if (typeof t25 !== "number")
        return t25.$mul();
      if (typeof t26 !== "number")
        return H.iae(t26);
      t27 = J.get$z$x(ray.origin);
      if (typeof t27 !== "number")
        return H.iae(t27);
      t00 = [0];
      t110 = [0];
      if (!G.Quadratic(t1 * t2 * t3 + t4 * t5 * t6 - t7 * t8 * t9, 2 * (t10 * t11 * t12 + t13 * t14 * t15 - t16 * t17 * t18), t19 * t20 * t21 + t22 * t23 * t24 - t25 * t26 * t27 - 1, t00, t110))
        return false;
      if (J.$gt$n(t00[0], ray.maxDistance) || J.$lt$n(t110[0], ray.minDistance))
        return false;
      thit = t00[0];
      if (J.$lt$n(thit, ray.minDistance)) {
        thit = t110[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
      }
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t2 = J.getInterceptor$x(t1);
      t3 = t2.get$x(t1);
      t4 = t2.get$y(t1);
      t1 = t2.get$z(t1);
      phit = new G.Point(t3, t4, t1);
      v = J.$div$n(J.$sub$n(t1, J.get$z$x(this.p1)), J.$sub$n(J.get$z$x(this.p2), J.get$z$x(this.p1)));
      t2 = this.p1;
      if (typeof v !== "number")
        return H.iae(v);
      pr = J.$add$ns(J.$mul$ns(t2, 1 - v), J.$mul$ns(this.p2, v));
      t2 = J.getInterceptor$x(pr);
      t5 = J.$sub$n(J.$mul$ns(t2.get$x(pr), t4), J.$mul$ns(t3, t2.get$y(pr)));
      t2 = J.$add$ns(J.$mul$ns(t3, t2.get$x(pr)), J.$mul$ns(t4, t2.get$y(pr)));
      if (typeof t5 !== "number")
        H.throwExpression(P.ArgumentError$(t5));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      phi = Math.atan2(t5, t2);
      if (phi < 0)
        phi += 6.283185307179586;
      if (J.$lt$n(t1, this.zmin) || J.$gt$n(t1, this.zmax) || phi > this.phiMax) {
        if (J.$eq(thit, t110[0]))
          return false;
        thit = t110[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        phit = new G.Point(t3, t4, t1);
        v = J.$div$n(J.$sub$n(t1, J.get$z$x(this.p1)), J.$sub$n(J.get$z$x(this.p2), J.get$z$x(this.p1)));
        t2 = this.p1;
        if (typeof v !== "number")
          return H.iae(v);
        pr = J.$add$ns(J.$mul$ns(t2, 1 - v), J.$mul$ns(this.p2, v));
        t2 = J.getInterceptor$x(pr);
        t5 = J.$sub$n(J.$mul$ns(t2.get$x(pr), t4), J.$mul$ns(t3, t2.get$y(pr)));
        t2 = J.$add$ns(J.$mul$ns(t3, t2.get$x(pr)), J.$mul$ns(t4, t2.get$y(pr)));
        if (typeof t5 !== "number")
          H.throwExpression(P.ArgumentError$(t5));
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        phi = Math.atan2(t5, t2);
        if (phi < 0)
          phi += 6.283185307179586;
        if (J.$lt$n(t1, this.zmin) || J.$gt$n(t1, this.zmax) || phi > this.phiMax)
          return false;
      }
      t1 = this.phiMax;
      cosphi = Math.cos(phi);
      sinphi = Math.sin(phi);
      t2 = this.phiMax;
      t3 = phit.y;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = phit.x;
      if (typeof t4 !== "number")
        return H.iae(t4);
      dpdu = new G.Vector(-t2 * t3, t2 * t4, 0);
      t4 = J.$sub$n(J.$mul$ns(J.$sub$n(J.get$x$x(this.p2), J.get$x$x(this.p1)), cosphi), J.$mul$ns(J.$sub$n(J.get$y$x(this.p2), J.get$y$x(this.p1)), sinphi));
      t2 = J.$add$ns(J.$mul$ns(J.$sub$n(J.get$x$x(this.p2), J.get$x$x(this.p1)), sinphi), J.$mul$ns(J.$sub$n(J.get$y$x(this.p2), J.get$y$x(this.p1)), cosphi));
      dpdv = new G.Vector(t4, t2, J.$sub$n(J.get$z$x(this.p2), J.get$z$x(this.p1)));
      t3 = phit.x;
      t5 = phit.y;
      t6 = this.phiMax;
      d2Pduu = new G.Vector(t3, t5, 0).$mul(0, -t6 * t6);
      d2Pduv = new G.Vector(J.$negate$n(t2), t4, 0).$mul(0, this.phiMax);
      $E = G.Vector_Dot(dpdu, dpdu);
      $F = G.Vector_Dot(dpdu, dpdv);
      $G = G.Vector_Dot(dpdv, dpdv);
      t4 = G.Vector_Cross(dpdu, dpdv);
      $N = t4.$div(0, t4.length$0(0));
      e = G.Vector_Dot($N, d2Pduu);
      f = G.Vector_Dot($N, d2Pduv);
      g = G.Vector_Dot($N, new G.Vector(0, 0, 0));
      t4 = J.$sub$n(J.$mul$ns($E, $G), J.$mul$ns($F, $F));
      if (typeof t4 !== "number")
        return H.iae(t4);
      invEGF2 = 1 / t4;
      t4 = J.getInterceptor$ns(f);
      t2 = J.getInterceptor$ns(e);
      t2 = dpdu.$mul(0, J.$mul$ns(J.$sub$n(t4.$mul(f, $F), t2.$mul(e, $G)), invEGF2)).$add(0, dpdv.$mul(0, J.$mul$ns(J.$sub$n(t2.$mul(e, $F), t4.$mul(f, $E)), invEGF2)));
      t6 = t2.x;
      t5 = t2.y;
      t2 = t2.z;
      t3 = J.getInterceptor$ns(g);
      t3 = dpdu.$mul(0, J.$mul$ns(J.$sub$n(t3.$mul(g, $F), t4.$mul(f, $G)), invEGF2)).$add(0, dpdv.$mul(0, J.$mul$ns(J.$sub$n(t4.$mul(f, $F), t3.$mul(g, $E)), invEGF2)));
      t4 = t3.x;
      t7 = t3.y;
      t3 = t3.z;
      o2w = this.objectToWorld;
      dg.set$8(o2w.transformPoint$1(phit), o2w.transformVector$1(dpdu), o2w.transformVector$1(dpdv), o2w.transformNormal$1(new G.Normal(t6, t5, t2)), o2w.transformNormal$1(new G.Normal(t4, t7, t3)), phi / t1, v, this);
      tHit[0] = thit;
      if (typeof thit !== "number")
        return H.iae(thit);
      rayEpsilon[0] = 0.0005 * thit;
      return true;
    },
    intersectP$1: function(r) {
      var ray, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t00, t110, thit, v, pr, phi;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      t1 = this.a;
      t2 = J.get$x$x(ray.direction);
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = J.get$x$x(ray.direction);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.a;
      t5 = J.get$y$x(ray.direction);
      if (typeof t4 !== "number")
        return t4.$mul();
      if (typeof t5 !== "number")
        return H.iae(t5);
      t6 = J.get$y$x(ray.direction);
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = this.c;
      t8 = J.get$z$x(ray.direction);
      if (typeof t7 !== "number")
        return t7.$mul();
      if (typeof t8 !== "number")
        return H.iae(t8);
      t9 = J.get$z$x(ray.direction);
      if (typeof t9 !== "number")
        return H.iae(t9);
      t10 = this.a;
      t11 = J.get$x$x(ray.direction);
      if (typeof t10 !== "number")
        return t10.$mul();
      if (typeof t11 !== "number")
        return H.iae(t11);
      t12 = J.get$x$x(ray.origin);
      if (typeof t12 !== "number")
        return H.iae(t12);
      t13 = this.a;
      t14 = J.get$y$x(ray.direction);
      if (typeof t13 !== "number")
        return t13.$mul();
      if (typeof t14 !== "number")
        return H.iae(t14);
      t15 = J.get$y$x(ray.origin);
      if (typeof t15 !== "number")
        return H.iae(t15);
      t16 = this.c;
      t17 = J.get$z$x(ray.direction);
      if (typeof t16 !== "number")
        return t16.$mul();
      if (typeof t17 !== "number")
        return H.iae(t17);
      t18 = J.get$z$x(ray.origin);
      if (typeof t18 !== "number")
        return H.iae(t18);
      t19 = this.a;
      t20 = J.get$x$x(ray.origin);
      if (typeof t19 !== "number")
        return t19.$mul();
      if (typeof t20 !== "number")
        return H.iae(t20);
      t21 = J.get$x$x(ray.origin);
      if (typeof t21 !== "number")
        return H.iae(t21);
      t22 = this.a;
      t23 = J.get$y$x(ray.origin);
      if (typeof t22 !== "number")
        return t22.$mul();
      if (typeof t23 !== "number")
        return H.iae(t23);
      t24 = J.get$y$x(ray.origin);
      if (typeof t24 !== "number")
        return H.iae(t24);
      t25 = this.c;
      t26 = J.get$z$x(ray.origin);
      if (typeof t25 !== "number")
        return t25.$mul();
      if (typeof t26 !== "number")
        return H.iae(t26);
      t27 = J.get$z$x(ray.origin);
      if (typeof t27 !== "number")
        return H.iae(t27);
      t00 = [0];
      t110 = [0];
      if (!G.Quadratic(t1 * t2 * t3 + t4 * t5 * t6 - t7 * t8 * t9, 2 * (t10 * t11 * t12 + t13 * t14 * t15 - t16 * t17 * t18), t19 * t20 * t21 + t22 * t23 * t24 - t25 * t26 * t27 - 1, t00, t110))
        return false;
      if (J.$gt$n(t00[0], ray.maxDistance) || J.$lt$n(t110[0], ray.minDistance))
        return false;
      thit = t00[0];
      if (J.$lt$n(thit, ray.minDistance)) {
        thit = t110[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
      }
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t2 = J.getInterceptor$x(t1);
      t3 = t2.get$x(t1);
      t4 = t2.get$y(t1);
      t1 = t2.get$z(t1);
      v = J.$div$n(J.$sub$n(t1, J.get$z$x(this.p1)), J.$sub$n(J.get$z$x(this.p2), J.get$z$x(this.p1)));
      t2 = this.p1;
      if (typeof v !== "number")
        return H.iae(v);
      pr = J.$add$ns(J.$mul$ns(t2, 1 - v), J.$mul$ns(this.p2, v));
      t2 = J.getInterceptor$x(pr);
      t5 = J.$sub$n(J.$mul$ns(t2.get$x(pr), t4), J.$mul$ns(t3, t2.get$y(pr)));
      t2 = J.$add$ns(J.$mul$ns(t3, t2.get$x(pr)), J.$mul$ns(t4, t2.get$y(pr)));
      if (typeof t5 !== "number")
        H.throwExpression(P.ArgumentError$(t5));
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      phi = Math.atan2(t5, t2);
      if (phi < 0)
        phi += 6.283185307179586;
      if (J.$lt$n(t1, this.zmin) || J.$gt$n(t1, this.zmax) || phi > this.phiMax) {
        if (J.$eq(thit, t110[0]))
          return false;
        thit = t110[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        v = J.$div$n(J.$sub$n(t1, J.get$z$x(this.p1)), J.$sub$n(J.get$z$x(this.p2), J.get$z$x(this.p1)));
        t2 = this.p1;
        if (typeof v !== "number")
          return H.iae(v);
        pr = J.$add$ns(J.$mul$ns(t2, 1 - v), J.$mul$ns(this.p2, v));
        t2 = J.getInterceptor$x(pr);
        t5 = J.$sub$n(J.$mul$ns(t2.get$x(pr), t4), J.$mul$ns(t3, t2.get$y(pr)));
        t2 = J.$add$ns(J.$mul$ns(t3, t2.get$x(pr)), J.$mul$ns(t4, t2.get$y(pr)));
        if (typeof t5 !== "number")
          H.throwExpression(P.ArgumentError$(t5));
        if (typeof t2 !== "number")
          H.throwExpression(P.ArgumentError$(t2));
        phi = Math.atan2(t5, t2);
        if (phi < 0)
          phi += 6.283185307179586;
        if (J.$lt$n(t1, this.zmin) || J.$gt$n(t1, this.zmax) || phi > this.phiMax)
          return false;
      }
      return true;
    },
    area$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18;
      t1 = new M.HyperboloidShape_area_SQR();
      t2 = new M.HyperboloidShape_area_QUAD();
      t3 = this.phiMax;
      t4 = t2.call$1(J.get$x$x(this.p1));
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = J.get$x$x(this.p1);
      if (typeof t5 !== "number")
        return H.iae(t5);
      t6 = J.get$x$x(this.p1);
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = J.get$x$x(this.p1);
      if (typeof t7 !== "number")
        return H.iae(t7);
      t8 = J.get$x$x(this.p2);
      if (typeof t8 !== "number")
        return H.iae(t8);
      t2 = t2.call$1(J.get$x$x(this.p2));
      if (typeof t2 !== "number")
        return H.iae(t2);
      t9 = J.$add$ns(J.$add$ns(J.$mul$ns(J.get$y$x(this.p1), J.get$y$x(this.p1)), J.$mul$ns(J.get$y$x(this.p1), J.get$y$x(this.p2))), J.$mul$ns(J.get$y$x(this.p2), J.get$y$x(this.p2)));
      if (typeof t9 !== "number")
        return H.iae(t9);
      t10 = J.$add$ns(t1.call$1(J.$sub$n(J.get$y$x(this.p1), J.get$y$x(this.p2))), t1.call$1(J.$sub$n(J.get$z$x(this.p1), J.get$z$x(this.p2))));
      if (typeof t10 !== "number")
        return H.iae(t10);
      t11 = J.$mul$ns(J.get$x$x(this.p2), J.get$x$x(this.p2));
      t12 = J.get$y$x(this.p1);
      if (typeof t12 !== "number")
        return H.iae(t12);
      t13 = J.get$y$x(this.p1);
      if (typeof t13 !== "number")
        return H.iae(t13);
      t14 = J.get$y$x(this.p1);
      if (typeof t14 !== "number")
        return H.iae(t14);
      t15 = J.get$y$x(this.p2);
      if (typeof t15 !== "number")
        return H.iae(t15);
      t16 = J.get$y$x(this.p2);
      if (typeof t16 !== "number")
        return H.iae(t16);
      t17 = J.get$y$x(this.p2);
      if (typeof t17 !== "number")
        return H.iae(t17);
      t18 = t1.call$1(J.$sub$n(J.get$z$x(this.p1), J.get$z$x(this.p2)));
      if (typeof t18 !== "number")
        return H.iae(t18);
      t18 = J.$mul$ns(t11, 5 * t12 * t13 + 2 * t14 * t15 - 4 * t16 * t17 + 2 * t18);
      if (typeof t18 !== "number")
        return H.iae(t18);
      t17 = J.$mul$ns(J.get$x$x(this.p1), J.get$x$x(this.p1));
      t16 = J.get$y$x(this.p1);
      if (typeof t16 !== "number")
        return H.iae(t16);
      t15 = J.get$y$x(this.p1);
      if (typeof t15 !== "number")
        return H.iae(t15);
      t14 = J.get$y$x(this.p1);
      if (typeof t14 !== "number")
        return H.iae(t14);
      t13 = J.get$y$x(this.p2);
      if (typeof t13 !== "number")
        return H.iae(t13);
      t12 = J.get$y$x(this.p2);
      if (typeof t12 !== "number")
        return H.iae(t12);
      t11 = J.get$y$x(this.p2);
      if (typeof t11 !== "number")
        return H.iae(t11);
      t1 = t1.call$1(J.$sub$n(J.get$z$x(this.p1), J.get$z$x(this.p2)));
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = J.$mul$ns(t17, -4 * t16 * t15 + 2 * t14 * t13 + 5 * t12 * t11 + 2 * t1);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t11 = J.get$x$x(this.p1);
      if (typeof t11 !== "number")
        return H.iae(t11);
      t12 = J.get$x$x(this.p2);
      if (typeof t12 !== "number")
        return H.iae(t12);
      t13 = J.$sub$n(J.$mul$ns(J.get$x$x(this.p2), J.get$x$x(this.p2)), J.$mul$ns(J.get$y$x(this.p1), J.get$y$x(this.p1)));
      t14 = J.get$y$x(this.p1);
      if (typeof t14 !== "number")
        return H.iae(t14);
      t15 = J.get$y$x(this.p2);
      if (typeof t15 !== "number")
        return H.iae(t15);
      t15 = J.$sub$n(J.$sub$n(J.$add$ns(t13, 5 * t14 * t15), J.$mul$ns(J.get$y$x(this.p2), J.get$y$x(this.p2))), J.$mul$ns(J.get$z$x(this.p1), J.get$z$x(this.p1)));
      t14 = J.get$z$x(this.p1);
      if (typeof t14 !== "number")
        return H.iae(t14);
      t13 = J.get$z$x(this.p2);
      if (typeof t13 !== "number")
        return H.iae(t13);
      t13 = J.$sub$n(J.$add$ns(t15, 2 * t14 * t13), J.$mul$ns(J.get$z$x(this.p2), J.get$z$x(this.p2)));
      if (typeof t13 !== "number")
        return H.iae(t13);
      return t3 / 6 * (2 * t4 - 2 * t5 * t6 * t7 * t8 + 2 * t2 + 2 * t9 * t10 + t18 + t1 - 2 * t11 * t12 * t13);
    },
    HyperboloidShape$6: function(o2w, w2o, ro, p1, p2, tm) {
      var t1, radius1, t, pp, xy1, xy2, t2, t3, t4;
      t1 = J.$add$ns(J.$mul$ns(J.get$x$x(this.p1), J.get$x$x(this.p1)), J.$mul$ns(J.get$y$x(this.p1), J.get$y$x(this.p1)));
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      radius1 = Math.sqrt(t1);
      t1 = J.$add$ns(J.$mul$ns(J.get$x$x(this.p2), J.get$x$x(this.p2)), J.$mul$ns(J.get$y$x(this.p2), J.get$y$x(this.p2)));
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      this.rmax = P.max(radius1, Math.sqrt(t1));
      this.zmin = P.min(J.get$z$x(this.p1), J.get$z$x(this.p2));
      this.zmax = P.max(J.get$z$x(this.p1), J.get$z$x(this.p2));
      t1 = J.clamp$2$n(tm, 0, 360);
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.phiMax = 0.017453292519943295 * t1;
      if (J.$eq(J.get$z$x(this.p2), 0)) {
        t = this.p1;
        this.p1 = this.p2;
        this.p2 = t;
      }
      pp = this.p1;
      do {
        pp = J.$add$ns(pp, J.$mul$ns(J.$sub$n(this.p2, this.p1), 2));
        t1 = J.getInterceptor$x(pp);
        xy1 = J.$add$ns(J.$mul$ns(t1.get$x(pp), t1.get$x(pp)), J.$mul$ns(t1.get$y(pp), t1.get$y(pp)));
        xy2 = J.$add$ns(J.$mul$ns(J.get$x$x(this.p2), J.get$x$x(this.p2)), J.$mul$ns(J.get$y$x(this.p2), J.get$y$x(this.p2)));
        if (typeof xy1 !== "number")
          return H.iae(xy1);
        t2 = J.$mul$ns(t1.get$z(pp), t1.get$z(pp));
        t3 = J.get$z$x(this.p2);
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = J.get$z$x(this.p2);
        if (typeof t4 !== "number")
          return H.iae(t4);
        t4 = J.$div$n(t2, xy1 * t3 * t4);
        if (typeof t4 !== "number")
          return H.iae(t4);
        t1 = J.$mul$ns(J.$mul$ns(xy2, t1.get$z(pp)), t1.get$z(pp));
        t3 = J.get$z$x(this.p2);
        if (typeof t3 !== "number")
          return H.iae(t3);
        t2 = J.get$z$x(this.p2);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = J.$div$n(t1, xy1 * t3 * t2);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = (1 / xy1 - t4) / (1 - t2);
        this.a = t2;
        if (typeof xy2 !== "number")
          return H.iae(xy2);
        t4 = J.$mul$ns(J.get$z$x(this.p2), J.get$z$x(this.p2));
        if (typeof t4 !== "number")
          return H.iae(t4);
        this.c = (t2 * xy2 - 1) / t4;
        t1 = this.a;
        t1.toString;
      } while (t1 == Infinity || t1 == -Infinity || isNaN(t1));
    },
    static: {HyperboloidShape$: function(o2w, w2o, ro, p1, p2, tm) {
        var t1 = $.Shape__nextShapeId;
        $.Shape__nextShapeId = t1 + 1;
        t1 = new M.HyperboloidShape(p1, p2, null, null, null, null, null, null, o2w, w2o, ro, false, t1);
        t1.HyperboloidShape$6(o2w, w2o, ro, p1, p2, tm);
        return t1;
      }, HyperboloidShape_Create: [function(o2w, w2o, reverseOrientation, params) {
        return M.HyperboloidShape$(o2w, w2o, reverseOrientation, params.findOnePoint$2("p1", new G.Point(0, 0, 0)), params.findOnePoint$2("p2", new G.Point(1, 1, 1)), params.findOneFloat$2("phimax", 360));
      }, "call$4", "HyperboloidShape_Create$closure", 8, 0, 55]}
  },
  HyperboloidShape_area_SQR: {
    "^": "Closure:88;",
    call$1: function(a) {
      return J.$mul$ns(a, a);
    }
  },
  HyperboloidShape_area_QUAD: {
    "^": "Closure:88;",
    call$1: function(a) {
      return J.$mul$ns(J.$mul$ns(J.$mul$ns(a, a), a), a);
    }
  },
  LoopSubdivisionShape: {
    "^": "Shape;nLevels,vertices,faces,objectToWorld,worldToObject,reverseOrientation,transformSwapsHandedness,shapeId",
    canIntersect$0: function() {
      return false;
    },
    refine$1: function(refined) {
      var f, v, t1, i, newFaces, newVertices, j, t2, t3, k, edgeVerts, face, fv1, k0, fv2, vert, t4, vertNum, t5, f2, Plimit, Ns, Pring, $S, $T, valence, theta, ntris, verts, totVerts, usedVerts, vi, vi0, paramSet;
      f = this.faces;
      v = this.vertices;
      t1 = this.nLevels;
      if (typeof t1 !== "number")
        return H.iae(t1);
      i = 0;
      for (; i < t1; ++i, v = newVertices, f = newFaces) {
        newFaces = [];
        newVertices = [];
        for (j = 0; j < v.length; ++j) {
          t2 = v[j];
          t2.set$child(new M._SDVertex(null, null, null, false, false));
          t3 = v.length;
          if (j >= t3)
            return H.ioore(v, j);
          t2.child.regular = t2.regular;
          if (j >= t3)
            return H.ioore(v, j);
          t2.child.boundary = t2.boundary;
          if (j >= t3)
            return H.ioore(v, j);
          newVertices.push(t2.child);
        }
        for (j = 0; j < f.length; ++j)
          for (k = 0; k < 4; ++k) {
            if (j >= f.length)
              return H.ioore(f, j);
            J.$indexSet$ax(J.get$children$x(f[j]), k, new M._SDFace([null, null, null], [null, null, null], [null, null, null, null]));
            if (j >= f.length)
              return H.ioore(f, j);
            newFaces.push(J.$index$asx(J.get$children$x(f[j]), k));
          }
        for (j = 0; j < v.length; ++j) {
          t2 = v[j];
          if (!t2.get$boundary())
            if (t2.regular)
              t2.child.P = M.LoopSubdivisionShape_weightOneRing(t2, 0.0625);
            else
              t2.child.P = M.LoopSubdivisionShape_weightOneRing(t2, M.LoopSubdivisionShape_beta(t2.valence$0()));
          else
            t2.child.P = M.LoopSubdivisionShape_weightBoundary(t2, 0.125);
        }
        t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        edgeVerts = new M._SDEdgeMap(t2);
        for (j = 0; j < f.length; ++j) {
          face = f[j];
          for (k = 0; k < 3; k = k0) {
            fv1 = J.$index$asx(face.get$v(), k);
            k0 = k + 1;
            fv2 = J.$index$asx(face.get$v(), C.JSInt_methods.$mod(k0, 3));
            if (edgeVerts.getEdge$2(fv1, fv2) == null) {
              vert = new M._SDVertex(null, null, null, false, false);
              newVertices.push(vert);
              vert.regular = true;
              vert.boundary = J.$index$asx(face.get$f(), k) == null;
              vert.startFace = J.$index$asx(J.get$children$x(face), 3);
              if (vert.boundary)
                vert.P = J.$add$ns(J.$mul$ns(fv1.get$P(), 0.5), J.$mul$ns(fv2.get$P(), 0.5));
              else {
                t3 = J.$add$ns(J.$mul$ns(fv1.get$P(), 0.375), J.$mul$ns(fv2.get$P(), 0.375));
                vert.P = t3;
                t3 = J.$add$ns(t3, J.$mul$ns(face.otherVert$2(fv1, fv2).get$P(), 0.125));
                vert.P = t3;
                t4 = face.f;
                if (k >= t4.length)
                  return H.ioore(t4, k);
                vert.P = J.$add$ns(t3, J.$mul$ns(t4[k].otherVert$2(fv1, fv2).get$P(), 0.125));
              }
              if (!t2.containsKey$1(fv1))
                t2.$indexSet(0, fv1, P.LinkedHashMap_LinkedHashMap(null, null, null, null, null));
              J.$indexSet$ax(t2.$index(0, fv1), fv2, vert);
            }
          }
        }
        for (j = 0; j < v.length; ++j) {
          vert = v[j];
          vertNum = vert.get$startFace().vnum$1(vert);
          vert.child.startFace = J.$index$asx(J.get$children$x(vert.startFace), vertNum);
        }
        for (j = 0; j < f.length; ++j) {
          face = f[j];
          for (t2 = J.getInterceptor$x(face), k = 0; k < 3; k = k0) {
            t3 = J.$index$asx(t2.get$children(face), 3).get$f();
            t4 = t2.get$children(face);
            k0 = k + 1;
            t5 = C.JSInt_methods.$mod(k0, 3);
            J.$indexSet$ax(t3, k, J.$index$asx(t4, t5));
            J.$indexSet$ax(J.$index$asx(t2.get$children(face), k).get$f(), t5, J.$index$asx(t2.get$children(face), 3));
            f2 = J.$index$asx(face.get$f(), k);
            t5 = J.$index$asx(t2.get$children(face), k).get$f();
            J.$indexSet$ax(t5, k, f2 != null ? J.$index$asx(J.get$children$x(f2), f2.vnum$1(J.$index$asx(face.get$v(), k))) : null);
            t3 = face.get$f();
            t4 = C.JSInt_methods.$mod(k + 2, 3);
            f2 = J.$index$asx(t3, t4);
            t3 = J.$index$asx(t2.get$children(face), k).get$f();
            J.$indexSet$ax(t3, t4, f2 != null ? J.$index$asx(J.get$children$x(f2), f2.vnum$1(J.$index$asx(face.get$v(), k))) : null);
          }
        }
        for (j = 0; j < f.length; ++j) {
          face = f[j];
          for (t2 = J.getInterceptor$x(face), k = 0; k < 3; k = k0) {
            J.$indexSet$ax(J.$index$asx(t2.get$children(face), k).get$v(), k, J.$index$asx(face.get$v(), k).get$child());
            fv1 = J.$index$asx(face.get$v(), k);
            t3 = face.get$v();
            k0 = k + 1;
            t4 = C.JSInt_methods.$mod(k0, 3);
            vert = edgeVerts.getEdge$2(fv1, J.$index$asx(t3, t4));
            J.$indexSet$ax(J.$index$asx(t2.get$children(face), k).get$v(), t4, vert);
            J.$indexSet$ax(J.$index$asx(t2.get$children(face), t4).get$v(), k, vert);
            J.$indexSet$ax(J.$index$asx(t2.get$children(face), 3).get$v(), k, vert);
          }
        }
      }
      t1 = Array(v.length);
      t1.fixed$length = init;
      Plimit = H.setRuntimeTypeInfo(t1, [G.Point]);
      for (t1 = Plimit.length, i = 0; i < v.length; ++i) {
        t2 = v[i];
        if (t2.get$boundary()) {
          t2 = M.LoopSubdivisionShape_weightBoundary(t2, 0.2);
          if (i >= t1)
            return H.ioore(Plimit, i);
          Plimit[i] = t2;
        } else {
          t3 = t2.valence$0();
          t3 = M.LoopSubdivisionShape_weightOneRing(t2, 1 / (t3 + 3 / (8 * M.LoopSubdivisionShape_beta(t3))));
          if (i >= t1)
            return H.ioore(Plimit, i);
          Plimit[i] = t3;
        }
      }
      for (i = 0; i < v.length; ++i) {
        t2 = v[i];
        if (i >= t1)
          return H.ioore(Plimit, i);
        t2.set$P(Plimit[i]);
      }
      Ns = [];
      Pring = H.setRuntimeTypeInfo([], [G.Point]);
      C.JSArray_methods.set$length(Pring, 16);
      for (i = 0; i < v.length; ++i) {
        vert = v[i];
        $S = new G.Vector(0, 0, 0);
        $T = new G.Vector(0, 0, 0);
        valence = vert.valence$0();
        if (valence > Pring.length)
          C.JSArray_methods.set$length(Pring, valence);
        vert.oneRing$2(Pring, 0);
        if (!vert.boundary)
          for (k = 0; k < valence; ++k) {
            if (k >= Pring.length)
              return H.ioore(Pring, k);
            t1 = Pring[k];
            t2 = 6.283185307179586 * k / valence;
            t1 = J.$mul$ns(t1, Math.cos(t2));
            t3 = J.getInterceptor$x(t1);
            $S = new G.Vector(J.$add$ns($S.x, t3.get$x(t1)), J.$add$ns($S.y, t3.get$y(t1)), J.$add$ns($S.z, t3.get$z(t1)));
            if (k >= Pring.length)
              return H.ioore(Pring, k);
            t1 = Pring[k];
            t1 = J.$mul$ns(t1, Math.sin(t2));
            t2 = J.getInterceptor$x(t1);
            $T = new G.Vector(J.$add$ns($T.x, t2.get$x(t1)), J.$add$ns($T.y, t2.get$y(t1)), J.$add$ns($T.z, t2.get$z(t1)));
          }
        else {
          t1 = valence - 1;
          t2 = Pring.length;
          if (t1 < 0 || t1 >= t2)
            return H.ioore(Pring, t1);
          t3 = Pring[t1];
          if (0 >= t2)
            return H.ioore(Pring, 0);
          $S = J.$sub$n(t3, Pring[0]);
          if (valence === 2) {
            t1 = Pring.length;
            if (0 >= t1)
              return H.ioore(Pring, 0);
            t2 = Pring[0];
            if (1 >= t1)
              return H.ioore(Pring, 1);
            $T = J.$sub$n(J.$add$ns(t2, Pring[1]), J.$mul$ns(vert.P, 2));
          } else if (valence === 3) {
            if (1 >= Pring.length)
              return H.ioore(Pring, 1);
            $T = J.$sub$n(Pring[1], vert.P);
          } else {
            t2 = Pring.length;
            t3 = Pring[0];
            if (valence === 4) {
              if (0 >= t2)
                return H.ioore(Pring, 0);
              t1 = J.$mul$ns(t3, -1);
              if (1 >= Pring.length)
                return H.ioore(Pring, 1);
              t1 = J.$add$ns(t1, J.$mul$ns(Pring[1], 2));
              if (2 >= Pring.length)
                return H.ioore(Pring, 2);
              t1 = J.$add$ns(t1, J.$mul$ns(Pring[2], 2));
              if (3 >= Pring.length)
                return H.ioore(Pring, 3);
              $T = J.$add$ns(J.$add$ns(t1, J.$mul$ns(Pring[3], -1)), J.$mul$ns(vert.P, -2));
            } else {
              theta = 3.141592653589793 / t1;
              if (0 >= t2)
                return H.ioore(Pring, 0);
              if (t1 >= t2)
                return H.ioore(Pring, t1);
              t2 = J.$add$ns(t3, Pring[t1]);
              $T = J.$mul$ns(t2, Math.sin(theta));
              for (k = 1; k < t1; ++k) {
                t2 = Math.cos(theta);
                t3 = Math.sin(k * theta);
                if (k >= Pring.length)
                  return H.ioore(Pring, k);
                $T = J.$add$ns($T, J.$mul$ns(Pring[k], (2 * t2 - 2) * t3));
              }
              $T = J.$negate$n($T);
            }
          }
        }
        t1 = G.Vector_Cross($S, $T);
        Ns.push(new G.Normal(t1.x, t1.y, t1.z));
      }
      ntris = f.length;
      t1 = 3 * ntris;
      verts = new Uint32Array(t1);
      totVerts = v.length;
      usedVerts = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      for (i = 0; i < totVerts; ++i) {
        if (i >= v.length)
          return H.ioore(v, i);
        usedVerts.$indexSet(0, v[i], i);
      }
      for (vi = 0, i = 0; i < ntris; ++i)
        for (j = 0; j < 3; ++j, vi = vi0) {
          vi0 = vi + 1;
          if (i >= f.length)
            return H.ioore(f, i);
          t2 = usedVerts.$index(0, J.$index$asx(f[i].get$v(), j));
          if (vi < 0 || vi >= t1)
            return H.ioore(verts, vi);
          verts[vi] = t2;
        }
      paramSet = new G.ParamSet([], [], [], [], [], [], [], [], []);
      paramSet.addInt$2("indices", verts);
      paramSet.addPoint$2("P", Plimit);
      paramSet.addNormal$2("N", Ns);
      refined.push(M.TriangleMeshShape_Create(this.objectToWorld, this.worldToObject, this.reverseOrientation, paramSet, null));
    },
    objectBound$0: function() {
      var b, t1, t2, i, t3, t4, t5, t6, t7;
      b = G.BBox$(null, null);
      for (t1 = this.vertices, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i].get$P();
        t4 = b.pMin;
        t5 = t4.x;
        t6 = t4.y;
        t4 = t4.z;
        t7 = b.pMax;
        b = new G.BBox(new G.Point(t5, t6, t4), new G.Point(t7.x, t7.y, t7.z)).unionPoint$1(t3);
      }
      return b;
    },
    worldBound$0: function() {
      var b, t1, t2, t3, i, t4, t5, t6, t7, t8;
      b = G.BBox$(null, null);
      for (t1 = this.vertices, t2 = t1.length, t3 = this.objectToWorld, i = 0; i < t2; ++i) {
        t4 = t3.transformPoint$1(t1[i].get$P());
        t5 = b.pMin;
        t6 = t5.x;
        t7 = t5.y;
        t5 = t5.z;
        t8 = b.pMax;
        b = new G.BBox(new G.Point(t6, t7, t5), new G.Point(t8.x, t8.y, t8.z)).unionPoint$1(t4);
      }
      return b;
    },
    LoopSubdivisionShape$8: function(o2w, w2o, ro, nfaces, nvertices, vertexIndices, $P, nLevels) {
      var t1, t2, t3, i, t4, t5, j, t6, f, j0, t7, v, edges, ei, v0, ei0, v1, edge, t8, val;
      if (typeof nvertices !== "number")
        return H.iae(nvertices);
      t1 = this.vertices;
      t2 = J.getInterceptor$asx($P);
      t3 = t1.length;
      i = 0;
      for (; i < nvertices; ++i) {
        t4 = t2.$index($P, i);
        if (i >= t3)
          return H.ioore(t1, i);
        t1[i] = new M._SDVertex(t4, null, null, false, false);
      }
      if (typeof nfaces !== "number")
        return H.iae(nfaces);
      t2 = this.faces;
      t4 = t2.length;
      t5 = J.getInterceptor$asx(vertexIndices);
      i = 0;
      j = 0;
      for (; i < nfaces; ++i, j = j0) {
        t6 = [null, null, null];
        f = new M._SDFace(t6, [null, null, null], [null, null, null, null]);
        if (i >= t4)
          return H.ioore(t2, i);
        t2[i] = f;
        j0 = j + 1;
        t7 = t5.$index(vertexIndices, j);
        if (t7 >>> 0 !== t7 || t7 >= t3)
          return H.ioore(t1, t7);
        v = t1[t7];
        if (0 >= t6.length)
          return H.ioore(t6, 0);
        t6[0] = v;
        v.set$startFace(f);
        j = j0 + 1;
        t7 = t5.$index(vertexIndices, j0);
        if (t7 >>> 0 !== t7 || t7 >= t3)
          return H.ioore(t1, t7);
        v = t1[t7];
        if (1 >= t6.length)
          return H.ioore(t6, 1);
        t6[1] = v;
        v.set$startFace(f);
        j0 = j + 1;
        t7 = t5.$index(vertexIndices, j);
        if (t7 >>> 0 !== t7 || t7 >= t3)
          return H.ioore(t1, t7);
        v = t1[t7];
        if (2 >= t6.length)
          return H.ioore(t6, 2);
        t6[2] = v;
        v.set$startFace(f);
      }
      t5 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      edges = new M._SDEdgeMap(t5);
      for (i = 0; i < nfaces; ++i) {
        if (i >= t4)
          return H.ioore(t2, i);
        f = t2[i];
        for (ei = 0; ei < 3; ei = ei0) {
          v0 = J.$index$asx(f.get$v(), ei);
          ei0 = ei + 1;
          v1 = J.$index$asx(f.get$v(), C.JSInt_methods.$mod(ei0, 3));
          edge = edges.getEdge$2(v0, v1);
          if (edge == null) {
            t6 = [null, null];
            t7 = [null, null];
            edge = new M._SDEdge(t6, t7, null);
            t8 = t6.length;
            if (0 >= t8)
              return H.ioore(t6, 0);
            t6[0] = v0;
            if (1 >= t8)
              return H.ioore(t6, 1);
            t6[1] = v1;
            edge.f0edgeNum = -1;
            if (0 >= t7.length)
              return H.ioore(t7, 0);
            t7[0] = f;
            edge.f0edgeNum = ei;
            if (!t5.containsKey$1(v0))
              t5.$indexSet(0, v0, P.LinkedHashMap_LinkedHashMap(null, null, null, null, null));
            J.$indexSet$ax(t5.$index(0, v0), v1, edge);
          } else {
            J.$indexSet$ax(J.$index$asx(edge.get$f(), 0).get$f(), edge.get$f0edgeNum(), f);
            t6 = f.get$f();
            t7 = edge.f;
            if (0 >= t7.length)
              return H.ioore(t7, 0);
            J.$indexSet$ax(t6, ei, t7[0]);
          }
        }
      }
      for (i = 0; i < nvertices; ++i) {
        if (i >= t3)
          return H.ioore(t1, i);
        v = t1[i];
        f = v.get$startFace();
        do {
          f = f.nextFace$1(v);
          t2 = f == null;
        } while (!t2 && !J.$eq(f, v.startFace));
        v.boundary = t2;
        val = v.valence$0();
        t2 = v.boundary;
        if (!t2 && val === 6)
          v.regular = true;
        else if (t2 && val === 4)
          v.regular = true;
        else
          v.regular = false;
      }
    },
    static: {LoopSubdivisionShape_Create: [function(o2w, w2o, reverseOrientation, params) {
        var nlevels, vi, $P;
        nlevels = params.findOneInt$2("nlevels", 1);
        vi = params.findInt$1("indices");
        $P = params.findPoint$1("P");
        if (vi == null || $P == null)
          return;
        return M.LoopSubdivisionShape$(o2w, w2o, reverseOrientation, J.$tdiv$n(J.get$length$asx(vi), 3), J.get$length$asx($P), vi, $P, nlevels);
      }, "call$4", "LoopSubdivisionShape_Create$closure", 8, 0, 56], LoopSubdivisionShape$: function(o2w, w2o, ro, nfaces, nvertices, vertexIndices, $P, nLevels) {
        var t1, t2;
        t1 = $.Shape__nextShapeId;
        $.Shape__nextShapeId = t1 + 1;
        if (typeof nvertices !== "number")
          return H.iae(nvertices);
        t2 = H.setRuntimeTypeInfo(Array(nvertices), [M._SDVertex]);
        if (typeof nfaces !== "number")
          return H.iae(nfaces);
        t1 = new M.LoopSubdivisionShape(nLevels, t2, H.setRuntimeTypeInfo(Array(nfaces), [M._SDFace]), o2w, w2o, ro, false, t1);
        t1.LoopSubdivisionShape$8(o2w, w2o, ro, nfaces, nvertices, vertexIndices, $P, nLevels);
        return t1;
      }, LoopSubdivisionShape_beta: function(valence) {
        if (valence === 3)
          return 0.1875;
        return 3 / (8 * valence);
      }, LoopSubdivisionShape_weightOneRing: function(vert, beta) {
        var valence, Pring, $P, i;
        valence = vert.valence$0();
        Pring = Array(valence);
        Pring.$builtinTypeInfo = [G.Point];
        vert.oneRing$1(Pring);
        $P = J.$mul$ns(vert.P, 1 - valence * beta);
        for (i = 0; i < valence; ++i)
          $P = J.$add$ns($P, J.$mul$ns(Pring[i], beta));
        return $P;
      }, LoopSubdivisionShape_weightBoundary: function(vert, beta) {
        var valence, Pring, $P, t1;
        valence = vert.valence$0();
        Pring = Array(valence);
        Pring.$builtinTypeInfo = [G.Point];
        vert.oneRing$1(Pring);
        $P = J.$mul$ns(vert.P, 1 - 2 * beta);
        if (0 >= valence)
          return H.ioore(Pring, 0);
        $P = J.$add$ns($P, J.$mul$ns(Pring[0], beta));
        t1 = valence - 1;
        if (t1 < 0)
          return H.ioore(Pring, t1);
        return J.$add$ns($P, J.$mul$ns(Pring[t1], beta));
      }}
  },
  _SDEdgeMap: {
    "^": "Object;_edgeMap",
    getEdge$2: function(a, b) {
      var t1 = this._edgeMap;
      if (t1.containsKey$1(a))
        if (t1.$index(0, a).containsKey$1(b))
          return t1.$index(0, a).$index(0, b);
      if (t1.containsKey$1(b))
        if (t1.$index(0, b).containsKey$1(a))
          return t1.$index(0, b).$index(0, a);
      return;
    }
  },
  _SDVertex: {
    "^": "Object;P@,startFace@,child@,regular,boundary<",
    valence$0: function() {
      var f, nf;
      f = this.startFace;
      if (!this.boundary) {
        for (nf = 1; f = f.nextFace$1(this), !J.$eq(f, this.startFace);)
          ++nf;
        return nf;
      } else {
        for (nf = 1; f = f.nextFace$1(this), f != null;)
          ++nf;
        f = this.startFace;
        for (; f = f.prevFace$1(this), ++nf, f != null;)
          ;
        return nf;
      }
    },
    oneRing$2: function(p, pi) {
      var t1, face, pi0, t2, t3, f2;
      t1 = this.boundary;
      face = this.startFace;
      if (!t1) {
        t1 = J.getInterceptor$ax(p);
        do {
          pi0 = pi + 1;
          t1.$indexSet(p, pi, face.nextVert$1(this).get$P());
          t2 = face.f;
          t3 = face.vnum$1(this);
          if (t3 < 0 || t3 >= t2.length)
            return H.ioore(t2, t3);
          face = t2[t3];
          if (!J.$eq(face, this.startFace)) {
            pi = pi0;
            continue;
          } else
            break;
        } while (true);
      } else {
        for (; f2 = face.nextFace$1(this), f2 != null; face = f2)
          ;
        pi0 = pi + 1;
        t1 = J.getInterceptor$ax(p);
        t1.$indexSet(p, pi, face.nextVert$1(this).get$P());
        pi = pi0;
        do {
          pi0 = pi + 1;
          t1.$indexSet(p, pi, face.prevVert$1(this).get$P());
          t2 = face.f;
          t3 = C.JSInt_methods.$mod(face.vnum$1(this) + 2, 3);
          if (t3 >= t2.length)
            return H.ioore(t2, t3);
          face = t2[t3];
          if (face != null) {
            pi = pi0;
            continue;
          } else
            break;
        } while (true);
      }
    },
    oneRing$1: function(p) {
      return this.oneRing$2(p, 0);
    }
  },
  _SDFace: {
    "^": "Object;v<,f<,children>",
    vnum$1: function(vert) {
      var t1, i;
      for (t1 = this.v, i = 0; i < 3; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (J.$eq(t1[i], vert))
          return i;
      }
      $.Log.call$2(3, "Basic logic error in SDFace::vnum()");
      return -1;
    },
    nextFace$1: function(vert) {
      var t1, t2;
      t1 = this.f;
      t2 = this.vnum$1(vert);
      if (t2 < 0 || t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    prevFace$1: function(vert) {
      var t1, t2;
      t1 = this.f;
      t2 = C.JSInt_methods.$mod(this.vnum$1(vert) + 2, 3);
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    nextVert$1: function(vert) {
      var t1, t2;
      t1 = this.v;
      t2 = C.JSInt_methods.$mod(this.vnum$1(vert) + 1, 3);
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    prevVert$1: function(vert) {
      var t1, t2;
      t1 = this.v;
      t2 = C.JSInt_methods.$mod(this.vnum$1(vert) + 2, 3);
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    otherVert$2: function(v0, v1) {
      var t1, i, t2;
      for (t1 = this.v, i = 0; i < 3; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (!J.$eq(t1[i], v0)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = !J.$eq(t1[i], v1);
        } else
          t2 = false;
        if (t2) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          return t1[i];
        }
      }
      $.Log.call$2(3, "Basic logic error in SDVertex::otherVert()");
      return;
    },
    f$2: function(arg0, arg1) {
      return this.f.call$2(arg0, arg1);
    }
  },
  _SDEdge: {
    "^": "Object;v<,f<,f0edgeNum<",
    f$2: function(arg0, arg1) {
      return this.f.call$2(arg0, arg1);
    }
  },
  ParaboloidShape: {
    "^": "Shape;radius,zmin,zmax,phiMax,objectToWorld,worldToObject,reverseOrientation,transformSwapsHandedness,shapeId",
    objectBound$0: function() {
      var t1, t2;
      t1 = this.radius;
      t2 = J.getInterceptor$n(t1);
      return G.BBox$(new G.Point(t2.$negate(t1), t2.$negate(t1), this.zmin), new G.Point(t1, t1, this.zmax));
    },
    intersect$4: function(r, tHit, rayEpsilon, dg) {
      var ray, t1, t2, k, t3, t4, t5, t00, t10, thit, phit, phi, v, dpdu, dpdv, d2Pduu, d2Pduv, d2Pdvv, $E, $F, $G, $N, e, f, g, invEGF2, t6, t7, o2w;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      t1 = this.zmax;
      t2 = this.radius;
      t2 = J.$mul$ns(t2, t2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      k = t1 / t2;
      t2 = J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.direction)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.direction)));
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1 = J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.origin)));
      if (typeof t1 !== "number")
        return H.iae(t1);
      t3 = J.get$z$x(ray.direction);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = J.$add$ns(J.$mul$ns(J.get$x$x(ray.origin), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.origin), J.get$y$x(ray.origin)));
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = J.get$z$x(ray.origin);
      if (typeof t5 !== "number")
        return H.iae(t5);
      t00 = [0];
      t10 = [0];
      if (!G.Quadratic(k * t2, 2 * k * t1 - t3, k * t4 - t5, t00, t10))
        return false;
      if (J.$gt$n(t00[0], ray.maxDistance) || J.$lt$n(t10[0], ray.minDistance))
        return false;
      thit = t00[0];
      if (J.$lt$n(thit, ray.minDistance)) {
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
      }
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t2 = J.getInterceptor$x(t1);
      t3 = t2.get$x(t1);
      t4 = t2.get$y(t1);
      t1 = t2.get$z(t1);
      phit = new G.Point(t3, t4, t1);
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      phi = Math.atan2(t4, t3);
      if (phi < 0)
        phi += 6.283185307179586;
      if (J.$lt$n(t1, this.zmin) || J.$gt$n(t1, this.zmax) || phi > this.phiMax) {
        if (J.$eq(thit, t10[0]))
          return false;
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        phit = new G.Point(t3, t4, t1);
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        phi = Math.atan2(t4, t3);
        if (phi < 0)
          phi += 6.283185307179586;
        if (J.$lt$n(t1, this.zmin) || J.$gt$n(t1, this.zmax) || phi > this.phiMax)
          return false;
      }
      t1 = this.phiMax;
      v = J.$div$n(J.$sub$n(phit.z, this.zmin), this.zmax - this.zmin);
      t2 = this.phiMax;
      t3 = phit.y;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = phit.x;
      if (typeof t4 !== "number")
        return H.iae(t4);
      dpdu = new G.Vector(-t2 * t3, t2 * t4, 0);
      t2 = phit.z;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = phit.y;
      t5 = phit.z;
      if (typeof t5 !== "number")
        return H.iae(t5);
      dpdv = new G.Vector(t4 / (2 * t2), J.$div$n(t3, 2 * t5), 1).$mul(0, this.zmax - this.zmin);
      t5 = phit.x;
      t3 = phit.y;
      t2 = this.phiMax;
      d2Pduu = new G.Vector(t5, t3, 0).$mul(0, -t2 * t2);
      t2 = J.$negate$n(phit.y);
      t3 = phit.z;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = J.$div$n(t2, 2 * t3);
      t2 = phit.x;
      t5 = phit.z;
      if (typeof t5 !== "number")
        return H.iae(t5);
      d2Pduv = new G.Vector(t3, J.$div$n(t2, 2 * t5), 0).$mul(0, this.zmax - this.zmin).$mul(0, this.phiMax);
      t5 = phit.x;
      t2 = phit.z;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = J.$div$n(t5, 4 * t2 * t2);
      t5 = phit.y;
      t3 = phit.z;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = J.$div$n(t5, 4 * t3 * t3);
      t5 = this.zmax - this.zmin;
      d2Pdvv = new G.Vector(t2, t3, 0).$mul(0, -t5 * t5);
      $E = G.Vector_Dot(dpdu, dpdu);
      $F = G.Vector_Dot(dpdu, dpdv);
      $G = G.Vector_Dot(dpdv, dpdv);
      t5 = G.Vector_Cross(dpdu, dpdv);
      $N = t5.$div(0, t5.length$0(0));
      e = G.Vector_Dot($N, d2Pduu);
      f = G.Vector_Dot($N, d2Pduv);
      g = G.Vector_Dot($N, d2Pdvv);
      t5 = J.$sub$n(J.$mul$ns($E, $G), J.$mul$ns($F, $F));
      if (typeof t5 !== "number")
        return H.iae(t5);
      invEGF2 = 1 / t5;
      t5 = J.getInterceptor$ns(f);
      t3 = J.getInterceptor$ns(e);
      t3 = dpdu.$mul(0, J.$mul$ns(J.$sub$n(t5.$mul(f, $F), t3.$mul(e, $G)), invEGF2)).$add(0, dpdv.$mul(0, J.$mul$ns(J.$sub$n(t3.$mul(e, $F), t5.$mul(f, $E)), invEGF2)));
      t2 = t3.x;
      t4 = t3.y;
      t3 = t3.z;
      t6 = J.getInterceptor$ns(g);
      t6 = dpdu.$mul(0, J.$mul$ns(J.$sub$n(t6.$mul(g, $F), t5.$mul(f, $G)), invEGF2)).$add(0, dpdv.$mul(0, J.$mul$ns(J.$sub$n(t5.$mul(f, $F), t6.$mul(g, $E)), invEGF2)));
      t5 = t6.x;
      t7 = t6.y;
      t6 = t6.z;
      o2w = this.objectToWorld;
      dg.set$8(o2w.transformPoint$1(phit), o2w.transformVector$1(dpdu), o2w.transformVector$1(dpdv), o2w.transformNormal$1(new G.Normal(t2, t4, t3)), o2w.transformNormal$1(new G.Normal(t5, t7, t6)), phi / t1, v, this);
      tHit[0] = thit;
      if (typeof thit !== "number")
        return H.iae(thit);
      rayEpsilon[0] = 0.0005 * thit;
      return true;
    },
    intersectP$1: function(r) {
      var ray, t1, t2, k, t3, t4, t5, t00, t10, thit, phi;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      t1 = this.zmax;
      t2 = this.radius;
      t2 = J.$mul$ns(t2, t2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      k = t1 / t2;
      t2 = J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.direction)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.direction)));
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1 = J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.origin)));
      if (typeof t1 !== "number")
        return H.iae(t1);
      t3 = J.get$z$x(ray.direction);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = J.$add$ns(J.$mul$ns(J.get$x$x(ray.origin), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.origin), J.get$y$x(ray.origin)));
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = J.get$z$x(ray.origin);
      if (typeof t5 !== "number")
        return H.iae(t5);
      t00 = [0];
      t10 = [0];
      if (!G.Quadratic(k * t2, 2 * k * t1 - t3, k * t4 - t5, t00, t10))
        return false;
      if (J.$gt$n(t00[0], ray.maxDistance) || J.$lt$n(t10[0], ray.minDistance))
        return false;
      thit = t00[0];
      if (J.$lt$n(thit, ray.minDistance)) {
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
      }
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t2 = J.getInterceptor$x(t1);
      t3 = t2.get$x(t1);
      t4 = t2.get$y(t1);
      t1 = t2.get$z(t1);
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      phi = Math.atan2(t4, t3);
      if (phi < 0)
        phi += 6.283185307179586;
      if (J.$lt$n(t1, this.zmin) || J.$gt$n(t1, this.zmax) || phi > this.phiMax) {
        if (J.$eq(thit, t10[0]))
          return false;
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$x(t1);
        t4 = t2.get$y(t1);
        t1 = t2.get$z(t1);
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        if (typeof t3 !== "number")
          H.throwExpression(P.ArgumentError$(t3));
        phi = Math.atan2(t4, t3);
        if (phi < 0)
          phi += 6.283185307179586;
        if (J.$lt$n(t1, this.zmin) || J.$gt$n(t1, this.zmax) || phi > this.phiMax)
          return false;
      }
      return true;
    },
    area$0: function() {
      var t1, t2, t3;
      t1 = this.phiMax;
      t2 = this.zmin;
      t2 = Math.pow(1 + 4 * t2, 1.5);
      t3 = this.zmax;
      return t1 / 12 * (t2 - Math.pow(1 + 4 * t3, 1.5));
    },
    ParaboloidShape$7: function(o2w, w2o, ro, radius, z0, z1, tm) {
      var t1;
      this.zmin = P.min(z0, z1);
      this.zmax = P.max(z0, z1);
      t1 = J.clamp$2$n(tm, 0, 360);
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.phiMax = 0.017453292519943295 * t1;
    },
    static: {ParaboloidShape_Create: [function(o2w, w2o, reverseOrientation, params) {
        var radius, zmin, zmax, phimax, t1;
        radius = params.findOneFloat$2("radius", 1);
        zmin = params.findOneFloat$2("zmin", 0);
        zmax = params.findOneFloat$2("zmax", 1);
        phimax = params.findOneFloat$2("phimax", 360);
        t1 = $.Shape__nextShapeId;
        $.Shape__nextShapeId = t1 + 1;
        t1 = new M.ParaboloidShape(radius, null, null, null, o2w, w2o, reverseOrientation, false, t1);
        t1.ParaboloidShape$7(o2w, w2o, reverseOrientation, radius, zmin, zmax, phimax);
        return t1;
      }, "call$4", "ParaboloidShape_Create$closure", 8, 0, 57]}
  },
  SphereShape: {
    "^": "Shape;radius,phiMax,zmin,zmax,thetaMin,thetaMax,objectToWorld,worldToObject,reverseOrientation,transformSwapsHandedness,shapeId",
    objectBound$0: function() {
      var t1, t2;
      t1 = this.radius;
      t2 = J.getInterceptor$n(t1);
      return G.BBox$(new G.Point(t2.$negate(t1), t2.$negate(t1), this.zmin), new G.Point(t1, t1, this.zmax));
    },
    intersect$4: function(r, tHit, rayEpsilon, dg) {
      var ray, $A, t1, t2, t3, t00, t10, thit, t4, t5, t6, phit, phi, theta, t7, invzradius, cosphi, sinphi, t8, dpdu, dpdv, d2Pduu, d2Pduv, d2Pdvv, $E, $F, $G, $N, e, f, g, invEGF2, t9, o2w;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      $A = J.$add$ns(J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.direction)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.direction))), J.$mul$ns(J.get$z$x(ray.direction), J.get$z$x(ray.direction)));
      t1 = J.$add$ns(J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.origin))), J.$mul$ns(J.get$z$x(ray.direction), J.get$z$x(ray.origin)));
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.radius;
      t3 = J.getInterceptor$ns(t2);
      t00 = [0];
      t10 = [0];
      if (!G.Quadratic($A, 2 * t1, J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(J.get$x$x(ray.origin), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.origin), J.get$y$x(ray.origin))), J.$mul$ns(J.get$z$x(ray.origin), J.get$z$x(ray.origin))), t3.$mul(t2, t2)), t00, t10))
        return false;
      if (J.$gt$n(t00[0], ray.maxDistance) || J.$lt$n(t10[0], ray.minDistance))
        return false;
      thit = t00[0];
      if (J.$lt$n(thit, ray.minDistance)) {
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
      }
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t4 = J.getInterceptor$x(t1);
      t5 = t4.get$x(t1);
      t6 = t4.get$y(t1);
      t1 = t4.get$z(t1);
      phit = new G.Point(t5, t6, t1);
      if (J.$eq(t5, 0) && J.$eq(t6, 0)) {
        if (typeof t2 !== "number")
          return H.iae(t2);
        t4 = 0.00001 * t2;
        phit.x = t4;
      } else
        t4 = t5;
      if (typeof t6 !== "number")
        H.throwExpression(P.ArgumentError$(t6));
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      phi = Math.atan2(t6, t4);
      if (phi < 0)
        phi += 6.283185307179586;
      t4 = this.zmin;
      t5 = t3.$negate(t2);
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (!(t4 > t5 && J.$lt$n(t1, this.zmin))) {
        t4 = this.zmax;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1 = t4 < t2 && J.$gt$n(t1, t4) || phi > this.phiMax;
      } else
        t1 = true;
      if (t1) {
        if (J.$eq(thit, t10[0]))
          return false;
        if (J.$gt$n(t10[0], ray.maxDistance))
          return false;
        thit = t10[0];
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
        t4 = J.getInterceptor$x(t1);
        t5 = t4.get$x(t1);
        t6 = t4.get$y(t1);
        t1 = t4.get$z(t1);
        phit = new G.Point(t5, t6, t1);
        if (J.$eq(t5, 0) && J.$eq(t6, 0)) {
          if (typeof t2 !== "number")
            return H.iae(t2);
          t4 = 0.00001 * t2;
          phit.x = t4;
        } else
          t4 = t5;
        if (typeof t6 !== "number")
          H.throwExpression(P.ArgumentError$(t6));
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        phi = Math.atan2(t6, t4);
        if (phi < 0)
          phi += 6.283185307179586;
        t4 = this.zmin;
        t5 = t3.$negate(t2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(t4 > t5 && J.$lt$n(t1, this.zmin))) {
          t4 = this.zmax;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t1 = t4 < t2 && J.$gt$n(t1, t4) || phi > this.phiMax;
        } else
          t1 = true;
        if (t1)
          return false;
      }
      t1 = this.phiMax;
      t4 = J.clamp$2$n(J.$div$n(phit.z, t2), -1, 1);
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      theta = Math.acos(t4);
      t4 = this.thetaMin;
      t5 = this.thetaMax;
      t6 = phit.x;
      t6 = J.$mul$ns(t6, t6);
      t7 = phit.y;
      t7 = J.$add$ns(t6, J.$mul$ns(t7, t7));
      if (typeof t7 !== "number")
        H.throwExpression(P.ArgumentError$(t7));
      invzradius = 1 / Math.sqrt(t7);
      cosphi = J.$mul$ns(phit.x, invzradius);
      sinphi = J.$mul$ns(phit.y, invzradius);
      t6 = this.phiMax;
      t7 = phit.y;
      if (typeof t7 !== "number")
        return H.iae(t7);
      t8 = phit.x;
      if (typeof t8 !== "number")
        return H.iae(t8);
      dpdu = new G.Vector(-t6 * t7, t6 * t8, 0);
      t8 = J.$mul$ns(phit.z, cosphi);
      t6 = J.$mul$ns(phit.z, sinphi);
      t2 = t3.$negate(t2);
      dpdv = new G.Vector(t8, t6, J.$mul$ns(t2, Math.sin(theta))).$mul(0, this.thetaMax - this.thetaMin);
      d2Pduu = new G.Vector(phit.x, phit.y, 0).$mul(0, -this.phiMax).$mul(0, this.phiMax);
      d2Pduv = new G.Vector(J.$negate$n(sinphi), cosphi, 0).$mul(0, this.thetaMax - this.thetaMin).$mul(0, phit.z).$mul(0, this.phiMax);
      d2Pdvv = new G.Vector(phit.x, phit.y, phit.z).$mul(0, -(this.thetaMax - this.thetaMin)).$mul(0, this.thetaMax - this.thetaMin);
      $E = G.Vector_Dot(dpdu, dpdu);
      $F = G.Vector_Dot(dpdu, dpdv);
      $G = G.Vector_Dot(dpdv, dpdv);
      t2 = G.Vector_Cross(dpdu, dpdv);
      $N = t2.$div(0, t2.length$0(0));
      e = G.Vector_Dot($N, d2Pduu);
      f = G.Vector_Dot($N, d2Pduv);
      g = G.Vector_Dot($N, d2Pdvv);
      t2 = J.$sub$n(J.$mul$ns($E, $G), J.$mul$ns($F, $F));
      if (typeof t2 !== "number")
        return H.iae(t2);
      invEGF2 = 1 / t2;
      t2 = J.getInterceptor$ns(f);
      t3 = J.getInterceptor$ns(e);
      t3 = dpdu.$mul(0, J.$sub$n(t2.$mul(f, $F), t3.$mul(e, $G))).$mul(0, invEGF2).$add(0, dpdv.$mul(0, J.$sub$n(t3.$mul(e, $F), t2.$mul(f, $E))).$mul(0, invEGF2));
      t6 = t3.x;
      t7 = t3.y;
      t3 = t3.z;
      t8 = J.getInterceptor$ns(g);
      t8 = dpdu.$mul(0, J.$sub$n(t8.$mul(g, $F), t2.$mul(f, $G))).$mul(0, invEGF2).$add(0, dpdv.$mul(0, J.$sub$n(t2.$mul(f, $F), t8.$mul(g, $E))).$mul(0, invEGF2));
      t2 = t8.x;
      t9 = t8.y;
      t8 = t8.z;
      o2w = this.objectToWorld;
      dg.set$8(o2w.transformPoint$1(phit), o2w.transformVector$1(dpdu), o2w.transformVector$1(dpdv), o2w.transformNormal$1(new G.Normal(t6, t7, t3)), o2w.transformNormal$1(new G.Normal(t2, t9, t8)), phi / t1, (theta - t4) / (t5 - t4), this);
      tHit[0] = thit;
      if (typeof thit !== "number")
        return H.iae(thit);
      rayEpsilon[0] = 0.0005 * thit;
      return true;
    },
    intersectP$1: function(r) {
      var ray, $A, t1, t2, t3, t00, t10, thit, t4, t5, t6, phi;
      ray = G.Ray$(null, null, 0, 1 / 0, 0, 0);
      this.worldToObject.transformRay$2(r, ray);
      $A = J.$add$ns(J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.direction)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.direction))), J.$mul$ns(J.get$z$x(ray.direction), J.get$z$x(ray.direction)));
      t1 = J.$add$ns(J.$add$ns(J.$mul$ns(J.get$x$x(ray.direction), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.direction), J.get$y$x(ray.origin))), J.$mul$ns(J.get$z$x(ray.direction), J.get$z$x(ray.origin)));
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.radius;
      t3 = J.getInterceptor$ns(t2);
      t00 = [0];
      t10 = [0];
      if (!G.Quadratic($A, 2 * t1, J.$sub$n(J.$add$ns(J.$add$ns(J.$mul$ns(J.get$x$x(ray.origin), J.get$x$x(ray.origin)), J.$mul$ns(J.get$y$x(ray.origin), J.get$y$x(ray.origin))), J.$mul$ns(J.get$z$x(ray.origin), J.get$z$x(ray.origin))), t3.$mul(t2, t2)), t00, t10))
        return false;
      if (!J.$gt$n(t00[0], ray.maxDistance)) {
        if (0 >= t10.length)
          return H.ioore(t10, 0);
        t1 = J.$lt$n(t10[0], ray.minDistance);
      } else
        t1 = true;
      if (t1)
        return false;
      thit = t00[0];
      if (J.$lt$n(thit, ray.minDistance)) {
        if (0 >= t10.length)
          return H.ioore(t10, 0);
        thit = t10[0];
        if (J.$gt$n(thit, ray.maxDistance))
          return false;
      }
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
      t4 = J.getInterceptor$x(t1);
      t5 = t4.get$x(t1);
      t6 = t4.get$y(t1);
      t1 = t4.get$z(t1);
      if (J.$eq(t5, 0) && J.$eq(t6, 0)) {
        if (typeof t2 !== "number")
          return H.iae(t2);
        t4 = 0.00001 * t2;
        new G.Point(t5, t6, t1).x = t4;
      } else
        t4 = t5;
      if (typeof t6 !== "number")
        H.throwExpression(P.ArgumentError$(t6));
      if (typeof t4 !== "number")
        H.throwExpression(P.ArgumentError$(t4));
      phi = Math.atan2(t6, t4);
      if (phi < 0)
        phi += 6.283185307179586;
      t4 = this.zmin;
      t5 = t3.$negate(t2);
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (!(t4 > t5 && J.$lt$n(t1, this.zmin))) {
        t4 = this.zmax;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1 = t4 < t2 && J.$gt$n(t1, t4) || phi > this.phiMax;
      } else
        t1 = true;
      if (t1) {
        if (J.$eq(thit, t10))
          return false;
        if (0 >= t10.length)
          return H.ioore(t10, 0);
        if (J.$gt$n(t10[0], ray.maxDistance))
          return false;
        if (0 >= t10.length)
          return H.ioore(t10, 0);
        thit = t10[0];
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, thit));
        t4 = J.getInterceptor$x(t1);
        t5 = t4.get$x(t1);
        t6 = t4.get$y(t1);
        t1 = t4.get$z(t1);
        if (J.$eq(t5, 0) && J.$eq(t6, 0)) {
          if (typeof t2 !== "number")
            return H.iae(t2);
          t4 = 0.00001 * t2;
          new G.Point(t5, t6, t1).x = t4;
        } else
          t4 = t5;
        if (typeof t6 !== "number")
          H.throwExpression(P.ArgumentError$(t6));
        if (typeof t4 !== "number")
          H.throwExpression(P.ArgumentError$(t4));
        phi = Math.atan2(t6, t4);
        if (phi < 0)
          phi += 6.283185307179586;
        t4 = this.zmin;
        t3 = t3.$negate(t2);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(t4 > t3 && J.$lt$n(t1, this.zmin))) {
          t3 = this.zmax;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t1 = t3 < t2 && J.$gt$n(t1, t3) || phi > this.phiMax;
        } else
          t1 = true;
        if (t1)
          return false;
      }
      return true;
    },
    area$0: function() {
      var t1, t2;
      t1 = this.phiMax;
      t2 = this.radius;
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 * t2 * (this.zmax - this.zmin);
    },
    sample$3: function(u1, u2, ns) {
      var p, t1, t2;
      p = new G.Point(0, 0, 0).$add(0, G.UniformSampleSphere(u1, u2).$mul(0, this.radius));
      t1 = this.objectToWorld;
      t2 = t1.transformNormal$1(new G.Normal(p.x, p.y, p.z));
      ns.copy$1(t2.$div(0, t2.length$0(0)));
      if (this.reverseOrientation === true) {
        t2 = J.getInterceptor$x(ns);
        t2.set$x(ns, J.$negate$n(t2.get$x(ns)));
        t2.set$y(ns, J.$negate$n(t2.get$y(ns)));
        t2.set$z(ns, J.$negate$n(t2.get$z(ns)));
      }
      return t1.transformPoint$1(p);
    },
    sample2$4: function(p, u1, u2, ns) {
      var Pcenter, t1, wc, wcX, wcY, t2, sinThetaMax2, cosThetaMax, dgSphere, thit, r, t3, ps;
      Pcenter = this.objectToWorld.transformPoint$1(new G.Point(0, 0, 0));
      t1 = Pcenter.$sub(0, p);
      wc = t1.$div(t1, t1.length$0(0));
      wcX = new G.Vector(0, 0, 0);
      wcY = new G.Vector(0, 0, 0);
      G.Vector_CoordinateSystem(wc, wcX, wcY);
      t1 = this.radius;
      t2 = J.getInterceptor$ns(t1);
      if (J.$lt$n(J.$sub$n(Pcenter.$sub(0, p).lengthSquared$0(), t2.$mul(t1, t1)), 0.0001))
        return this.sample$3(u1, u2, ns);
      sinThetaMax2 = J.$div$n(t2.$mul(t1, t1), Pcenter.$sub(0, p).lengthSquared$0());
      if (typeof sinThetaMax2 !== "number")
        return H.iae(sinThetaMax2);
      t1 = P.max(0, 1 - sinThetaMax2);
      cosThetaMax = Math.sqrt(t1);
      dgSphere = G.DifferentialGeometry$();
      thit = [0];
      r = G.Ray$(p, G.UniformSampleCone2(u1, u2, cosThetaMax, wcX, wcY, wc), 0.001, 1 / 0, 0, 0);
      if (!this.intersect$4(r, thit, [0], dgSphere)) {
        t1 = Pcenter.$sub(0, p);
        t2 = r.direction;
        t3 = J.getInterceptor$asx(t2);
        thit[0] = G.Vector_Dot(t1, t3.$div(t2, t3.length$0(t2)));
      }
      t1 = thit[0];
      t1 = J.$add$ns(r.origin, J.$mul$ns(r.direction, t1));
      t2 = J.getInterceptor$x(t1);
      ps = new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1));
      t1 = ps.$sub(0, Pcenter);
      ns.copy$1(t1.$div(0, t1.length$0(0)));
      if (this.reverseOrientation === true) {
        t1 = J.getInterceptor$x(ns);
        t1.set$x(ns, J.$negate$n(t1.get$x(ns)));
        t1.set$y(ns, J.$negate$n(t1.get$y(ns)));
        t1.set$z(ns, J.$negate$n(t1.get$z(ns)));
      }
      return ps;
    },
    pdf2$2: function(p, wi) {
      var Pcenter, t1, t2, sinThetaMax2;
      Pcenter = this.objectToWorld.transformPoint$1(new G.Point(0, 0, 0));
      t1 = this.radius;
      t2 = J.getInterceptor$ns(t1);
      if (J.$lt$n(J.$sub$n(Pcenter.$sub(0, p).lengthSquared$0(), t2.$mul(t1, t1)), 0.0001))
        return G.Shape.prototype.pdf2$2.call(this, p, wi);
      sinThetaMax2 = J.$div$n(t2.$mul(t1, t1), Pcenter.$sub(0, p).lengthSquared$0());
      if (typeof sinThetaMax2 !== "number")
        return H.iae(sinThetaMax2);
      t1 = P.max(0, 1 - sinThetaMax2);
      return G.UniformConePdf(Math.sqrt(t1));
    },
    SphereShape$7: function(o2w, w2o, ro, radius, z0, z1, pm) {
      var t1, t2;
      t1 = this.radius;
      t2 = J.getInterceptor$n(t1);
      this.zmin = C.JSNumber_methods.clamp$2(P.min(z0, z1), t2.$negate(t1), t1);
      this.zmax = C.JSNumber_methods.clamp$2(P.max(z0, z1), t2.$negate(t1), t1);
      t2 = this.zmin;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = C.JSNumber_methods.clamp$2(t2 / t1, -1, 1);
      this.thetaMin = Math.acos(t2);
      t1 = C.JSNumber_methods.clamp$2(this.zmax / t1, -1, 1);
      this.thetaMax = Math.acos(t1);
      t1 = J.clamp$2$n(pm, 0, 360);
      if (typeof t1 !== "number")
        return H.iae(t1);
      this.phiMax = 0.017453292519943295 * t1;
    },
    static: {SphereShape_Create: [function(o2w, w2o, reverseOrientation, params) {
        var radius, zmin, zmax, phimax, t1;
        radius = params.findOneFloat$2("radius", 1);
        zmin = params.findOneFloat$2("zmin", J.$negate$n(radius));
        zmax = params.findOneFloat$2("zmax", radius);
        phimax = params.findOneFloat$2("phimax", 360);
        t1 = $.Shape__nextShapeId;
        $.Shape__nextShapeId = t1 + 1;
        t1 = new M.SphereShape(radius, null, null, null, null, null, o2w, w2o, reverseOrientation, false, t1);
        t1.SphereShape$7(o2w, w2o, reverseOrientation, radius, zmin, zmax, phimax);
        return t1;
      }, "call$4", "SphereShape_Create$closure", 8, 0, 58]}
  },
  TriangleMeshShape: {
    "^": "Shape;ntris,nverts,vertexIndex,p>,n<,s,uvs,alphaTexture,objectToWorld,worldToObject,reverseOrientation,transformSwapsHandedness,shapeId",
    objectBound$0: function() {
      var objectBounds, t1, t2, i, t3, t4, t5, t6, t7;
      objectBounds = G.BBox$(null, null);
      t1 = this.nverts;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.worldToObject;
      i = 0;
      for (; i < t1; ++i) {
        t3 = this.p;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3 = t2.transformPoint$1(t3[i]);
        t4 = objectBounds.pMin;
        t5 = t4.x;
        t6 = t4.y;
        t4 = t4.z;
        t7 = objectBounds.pMax;
        objectBounds = new G.BBox(new G.Point(t5, t6, t4), new G.Point(t7.x, t7.y, t7.z)).unionPoint$1(t3);
      }
      return objectBounds;
    },
    worldBound$0: function() {
      var worldBounds, t1, i, t2, t3, t4, t5, t6;
      worldBounds = G.BBox$(null, null);
      t1 = this.nverts;
      if (typeof t1 !== "number")
        return H.iae(t1);
      i = 0;
      for (; i < t1; ++i) {
        t2 = this.p;
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2 = t2[i];
        t3 = worldBounds.pMin;
        t4 = t3.x;
        t5 = t3.y;
        t3 = t3.z;
        t6 = worldBounds.pMax;
        worldBounds = new G.BBox(new G.Point(t4, t5, t3), new G.Point(t6.x, t6.y, t6.z)).unionPoint$1(t2);
      }
      return worldBounds;
    },
    canIntersect$0: function() {
      return false;
    },
    refine$1: function(refined) {
      var t1, t2, t3, i, t4, t5;
      t1 = this.ntris;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.objectToWorld;
      t3 = this.worldToObject;
      i = 0;
      for (; i < t1; ++i) {
        t4 = this.reverseOrientation;
        t5 = $.Shape__nextShapeId;
        $.Shape__nextShapeId = t5 + 1;
        t5 = new M.TriangleShape(this, i, t2, t3, t4, false, t5);
        t5.index = i * 3;
        refined.push(t5);
      }
    },
    p$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.p.call$4(arg0, arg1, arg2, arg3);
    },
    TriangleMeshShape$11: function(o2w, w2o, ro, ntris, nverts, vertexIndex, $P, n, s, uvs, alphaTexture) {
      var t1, t2, t3, i, t4, t5;
      t1 = this.nverts;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = Array(t1);
      t2.fixed$length = init;
      this.p = H.setRuntimeTypeInfo(t2, [G.Point]);
      for (t2 = this.objectToWorld, t3 = J.getInterceptor$asx($P), i = 0; i < t1; ++i) {
        t4 = this.p;
        t5 = t2.transformPoint$1(t3.$index($P, i));
        if (i >= t4.length)
          return H.ioore(t4, i);
        t4[i] = t5;
      }
    },
    static: {TriangleMeshShape$: function(o2w, w2o, ro, ntris, nverts, vertexIndex, $P, n, s, uvs, alphaTexture) {
        var t1 = $.Shape__nextShapeId;
        $.Shape__nextShapeId = t1 + 1;
        t1 = new M.TriangleMeshShape(ntris, nverts, vertexIndex, null, n, s, uvs, alphaTexture, o2w, w2o, ro, false, t1);
        t1.TriangleMeshShape$11(o2w, w2o, ro, ntris, nverts, vertexIndex, $P, n, s, uvs, alphaTexture);
        return t1;
      }, TriangleMeshShape_Create: [function(o2w, w2o, reverseOrientation, params, floatTextures) {
        var vi, $P, uvs, discardDegnerateUVs, t1, npi, t2, nuvi, t3, t4, $S, $N, nvi, vp, i, t5, t6, t7, t8, alphaTexName, alphaTex;
        vi = params.findInt$1("indices");
        $P = params.findPoint$1("P");
        uvs = params.findFloat$1("uv");
        if (uvs == null)
          uvs = params.findFloat$1("st");
        if (vi == null || $P == null)
          return;
        discardDegnerateUVs = params.findOneBool$2("discarddegenerateUVs", false);
        if (uvs != null) {
          t1 = J.getInterceptor$asx($P);
          npi = t1.get$length($P);
          t2 = J.getInterceptor$asx(uvs);
          nuvi = t2.get$length(uvs);
          t3 = t2.get$length(uvs);
          t4 = t1.get$length($P);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (J.$lt$n(t3, 2 * t4)) {
            if (typeof npi !== "number")
              return H.iae(npi);
            t1 = "Not enough of 'uv's for triangle mesh. Expencted " + H.S(2 * npi) + ", found " + H.S(nuvi) + ".  Discarding.";
            $.Log.call$2(1, t1);
            uvs = null;
          } else {
            t2 = t2.get$length(uvs);
            t1 = t1.get$length($P);
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (J.$gt$n(t2, 2 * t1)) {
              if (typeof npi !== "number")
                return H.iae(npi);
              t1 = "More 'uv's provided than will be used for triangle mesh.  (" + H.S(2 * npi) + " expcted, " + H.S(nuvi) + " found)";
              $.Log.call$2(1, t1);
            }
          }
        }
        $S = params.findVector$1("S");
        if ($S != null && !J.$eq(J.get$length$asx($S), J.get$length$asx($P))) {
          $.Log.call$2(1, "Number of 'S's for triangle mesh must match 'P's");
          $S = null;
        }
        $N = params.findNormal$1("N");
        if ($N != null && !J.$eq(J.get$length$asx($N), J.get$length$asx($P))) {
          $.Log.call$2(1, "Number of 'N's for triangle mesh must match 'P's");
          $N = null;
        }
        if (discardDegnerateUVs === true && uvs != null && $N != null) {
          nvi = J.get$length$asx($N);
          if (typeof nvi !== "number")
            return H.iae(nvi);
          t1 = J.getInterceptor$asx(uvs);
          t2 = J.getInterceptor$asx(vi);
          t3 = J.getInterceptor$asx($P);
          vp = 0;
          i = 0;
          for (; i < nvi; i += 3, vp += 3) {
            t4 = vp + 1;
            t5 = vp + 2;
            t6 = G.Vector_Cross(J.$sub$n(t3.$index($P, t2.$index(vi, vp)), t3.$index($P, t2.$index(vi, t4))), J.$sub$n(t3.$index($P, t2.$index(vi, t5)), t3.$index($P, t2.$index(vi, t4))));
            t7 = t6.x;
            t7 = J.$mul$ns(t7, t7);
            t8 = t6.y;
            t8 = J.$add$ns(t7, J.$mul$ns(t8, t8));
            t6 = t6.z;
            t6 = J.$add$ns(t8, J.$mul$ns(t6, t6));
            if (typeof t6 !== "number")
              H.throwExpression(P.ArgumentError$(t6));
            if (0.5 * Math.sqrt(t6) < 1e-7)
              continue;
            t6 = t2.$index(vi, vp);
            if (typeof t6 !== "number")
              return H.iae(t6);
            t6 = t1.$index(uvs, 2 * t6);
            t7 = t2.$index(vi, t4);
            if (typeof t7 !== "number")
              return H.iae(t7);
            if (J.$eq(t6, t1.$index(uvs, 2 * t7))) {
              t6 = t2.$index(vi, vp);
              if (typeof t6 !== "number")
                return H.iae(t6);
              t6 = t1.$index(uvs, 2 * t6 + 1);
              t7 = t2.$index(vi, t4);
              if (typeof t7 !== "number")
                return H.iae(t7);
              t7 = J.$eq(t6, t1.$index(uvs, 2 * t7 + 1));
              t6 = t7;
            } else
              t6 = false;
            if (!t6) {
              t6 = t2.$index(vi, t4);
              if (typeof t6 !== "number")
                return H.iae(t6);
              t6 = t1.$index(uvs, 2 * t6);
              t7 = t2.$index(vi, t5);
              if (typeof t7 !== "number")
                return H.iae(t7);
              if (J.$eq(t6, t1.$index(uvs, 2 * t7))) {
                t4 = t2.$index(vi, t4);
                if (typeof t4 !== "number")
                  return H.iae(t4);
                t4 = t1.$index(uvs, 2 * t4 + 1);
                t6 = t2.$index(vi, t5);
                if (typeof t6 !== "number")
                  return H.iae(t6);
                t6 = J.$eq(t4, t1.$index(uvs, 2 * t6 + 1));
                t4 = t6;
              } else
                t4 = false;
              if (!t4) {
                t4 = t2.$index(vi, t5);
                if (typeof t4 !== "number")
                  return H.iae(t4);
                t4 = t1.$index(uvs, 2 * t4);
                t6 = t2.$index(vi, vp);
                if (typeof t6 !== "number")
                  return H.iae(t6);
                if (J.$eq(t4, t1.$index(uvs, 2 * t6))) {
                  t4 = t2.$index(vi, t5);
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  t4 = t1.$index(uvs, 2 * t4 + 1);
                  t5 = t2.$index(vi, vp);
                  if (typeof t5 !== "number")
                    return H.iae(t5);
                  t5 = J.$eq(t4, t1.$index(uvs, 2 * t5 + 1));
                  t4 = t5;
                } else
                  t4 = false;
              } else
                t4 = true;
            } else
              t4 = true;
            if (t4) {
              $.Log.call$2(1, "Degenerate uv coordinates in triangle mesh. Discarding all uvs.");
              uvs = null;
              break;
            }
          }
        }
        t1 = J.getInterceptor$asx($P);
        npi = t1.get$length($P);
        t2 = J.getInterceptor$asx(vi);
        nvi = t2.get$length(vi);
        if (typeof nvi !== "number")
          return H.iae(nvi);
        i = 0;
        for (; i < nvi; ++i)
          if (J.$ge$n(t2.$index(vi, i), npi)) {
            t1 = "TriangleMesh has out of-bounds vertex index " + H.S(t2.$index(vi, i)) + " (" + H.S(npi) + " 'P' values were given";
            $.Log.call$2(1, t1);
            return;
          }
        alphaTexName = params.findTexture$1("alpha");
        if (!J.$eq(alphaTexName, ""))
          if (floatTextures.containsKey$1(alphaTexName) === true)
            alphaTex = floatTextures.$index(0, alphaTexName);
          else {
            t3 = "Couldn't find float texture '" + H.S(alphaTexName) + "' for 'alpha' parameter";
            $.Log.call$2(1, t3);
            alphaTex = null;
          }
        else
          alphaTex = J.$eq(params.findOneFloat$2("alpha", 1), 0) ? new G.ConstantTexture(0) : null;
        return M.TriangleMeshShape$(o2w, w2o, reverseOrientation, J.$tdiv$n(t2.get$length(vi), 3), t1.get$length($P), vi, $P, $N, $S, uvs, alphaTex);
      }, function(o2w, w2o, reverseOrientation, params) {
        return M.TriangleMeshShape_Create(o2w, w2o, reverseOrientation, params, null);
      }, null, "call$5", "call$4", "TriangleMeshShape_Create$closure", 8, 2, 59, 13]}
  },
  TriangleShape: {
    "^": "Shape;mesh,index,objectToWorld,worldToObject,reverseOrientation,transformSwapsHandedness,shapeId",
    objectBound$0: function() {
      var t1, t2, t3, t4, t5, p1, p2, p3;
      t1 = this.mesh;
      t2 = t1.p;
      t3 = t1.vertexIndex;
      t4 = J.getInterceptor$asx(t3);
      t5 = t4.$index(t3, this.index);
      if (t5 >>> 0 !== t5 || t5 >= t2.length)
        return H.ioore(t2, t5);
      p1 = t2[t5];
      t5 = t1.p;
      t2 = t4.$index(t3, this.index + 1);
      if (t2 >>> 0 !== t2 || t2 >= t5.length)
        return H.ioore(t5, t2);
      p2 = t5[t2];
      t1 = t1.p;
      t3 = t4.$index(t3, this.index + 2);
      if (t3 >>> 0 !== t3 || t3 >= t1.length)
        return H.ioore(t1, t3);
      p3 = t1[t3];
      t3 = this.worldToObject;
      t1 = G.BBox$(t3.transformPoint$1(p1), t3.transformPoint$1(p2));
      t3 = t3.transformPoint$1(p3);
      return G.BBox$from(t1).unionPoint$1(t3);
    },
    worldBound$0: function() {
      var t1, t2, t3, t4, t5, p1, p2, p3;
      t1 = this.mesh;
      t2 = t1.p;
      t3 = t1.vertexIndex;
      t4 = J.getInterceptor$asx(t3);
      t5 = t4.$index(t3, this.index);
      if (t5 >>> 0 !== t5 || t5 >= t2.length)
        return H.ioore(t2, t5);
      p1 = t2[t5];
      t5 = t1.p;
      t2 = t4.$index(t3, this.index + 1);
      if (t2 >>> 0 !== t2 || t2 >= t5.length)
        return H.ioore(t5, t2);
      p2 = t5[t2];
      t1 = t1.p;
      t3 = t4.$index(t3, this.index + 2);
      if (t3 >>> 0 !== t3 || t3 >= t1.length)
        return H.ioore(t1, t3);
      p3 = t1[t3];
      return G.BBox$from(G.BBox$(p1, p2)).unionPoint$1(p3);
    },
    intersect$4: function(ray, tHit, rayEpsilon, dg) {
      var t1, t2, t3, t4, t5, p1, p2, p3, e1, e2, s1, divisor, invDivisor, s, b1, s2, b2, t, dpdu, dpdv, uvs, du1, du2, dv1, dv2, dp1, dp2, determinant, invdet, b0, tu, tv;
      t1 = this.mesh;
      t2 = t1.p;
      t3 = t1.vertexIndex;
      t4 = J.getInterceptor$asx(t3);
      t5 = t4.$index(t3, this.index);
      if (t5 >>> 0 !== t5 || t5 >= t2.length)
        return H.ioore(t2, t5);
      p1 = t2[t5];
      t5 = t1.p;
      t2 = t4.$index(t3, this.index + 1);
      if (t2 >>> 0 !== t2 || t2 >= t5.length)
        return H.ioore(t5, t2);
      p2 = t5[t2];
      t2 = t1.p;
      t3 = t4.$index(t3, this.index + 2);
      if (t3 >>> 0 !== t3 || t3 >= t2.length)
        return H.ioore(t2, t3);
      p3 = t2[t3];
      t3 = J.getInterceptor$n(p2);
      e1 = t3.$sub(p2, p1);
      e2 = J.$sub$n(p3, p1);
      s1 = G.Vector_Cross(ray.get$direction(), e2);
      divisor = G.Vector_Dot(s1, e1);
      if (J.$eq(divisor, 0))
        return false;
      if (typeof divisor !== "number")
        return H.iae(divisor);
      invDivisor = 1 / divisor;
      s = J.$sub$n(ray.origin, p1);
      b1 = J.$mul$ns(G.Vector_Dot(s, s1), invDivisor);
      t2 = J.getInterceptor$n(b1);
      if (t2.$lt(b1, 0) || t2.$gt(b1, 1))
        return false;
      s2 = G.Vector_Cross(s, e1);
      b2 = J.$mul$ns(G.Vector_Dot(ray.direction, s2), invDivisor);
      if (J.$lt$n(b2, 0) || J.$gt$n(t2.$add(b1, b2), 1))
        return false;
      t = J.$mul$ns(G.Vector_Dot(e2, s2), invDivisor);
      t2 = J.getInterceptor$n(t);
      if (t2.$lt(t, ray.minDistance) || t2.$gt(t, ray.maxDistance))
        return false;
      dpdu = new G.Vector(0, 0, 0);
      dpdv = new G.Vector(0, 0, 0);
      uvs = H.setRuntimeTypeInfo(Array(6), [J.JSDouble]);
      this.getUVs$1(uvs);
      du1 = J.$sub$n(uvs[0], uvs[4]);
      du2 = J.$sub$n(uvs[2], uvs[4]);
      dv1 = J.$sub$n(uvs[1], uvs[5]);
      dv2 = J.$sub$n(uvs[3], uvs[5]);
      dp1 = J.$sub$n(p1, p3);
      dp2 = t3.$sub(p2, p3);
      determinant = J.$sub$n(J.$mul$ns(du1, dv2), J.$mul$ns(dv1, du2));
      if (J.$eq(determinant, 0)) {
        t2 = G.Vector_Cross(e2, e1);
        G.Vector_CoordinateSystem(t2.$div(0, t2.length$0(0)), dpdu, dpdv);
      } else {
        if (typeof determinant !== "number")
          return H.iae(determinant);
        invdet = 1 / determinant;
        t2 = J.getInterceptor$ns(dp1);
        t3 = J.getInterceptor$ns(dp2);
        dpdu = J.$mul$ns(J.$sub$n(t2.$mul(dp1, dv2), t3.$mul(dp2, dv1)), invdet);
        dpdv = J.$mul$ns(J.$add$ns(t2.$mul(dp1, J.$negate$n(du2)), t3.$mul(dp2, du1)), invdet);
      }
      if (typeof b1 !== "number")
        return H.iae(b1);
      if (typeof b2 !== "number")
        return H.iae(b2);
      b0 = 1 - b1 - b2;
      t2 = uvs[0];
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = uvs[2];
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = uvs[4];
      if (typeof t4 !== "number")
        return H.iae(t4);
      tu = b0 * t2 + b1 * t3 + b2 * t4;
      t4 = uvs[1];
      if (typeof t4 !== "number")
        return H.iae(t4);
      t3 = uvs[3];
      if (typeof t3 !== "number")
        return H.iae(t3);
      t2 = uvs[5];
      if (typeof t2 !== "number")
        return H.iae(t2);
      tv = b0 * t4 + b1 * t3 + b2 * t2;
      if (ray.depth !== -1) {
        t1 = t1.alphaTexture;
        if (t1 != null) {
          t2 = G.DifferentialGeometry$();
          t3 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t));
          t4 = J.getInterceptor$x(t3);
          if (J.$eq(t1.evaluate$1(t2.set$8(new G.Point(t4.get$x(t3), t4.get$y(t3), t4.get$z(t3)), dpdu, dpdv, new G.Normal(0, 0, 0), new G.Normal(0, 0, 0), tu, tv, this)), 0))
            return false;
        }
      }
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t));
      t2 = J.getInterceptor$x(t1);
      dg.set$8(new G.Point(t2.get$x(t1), t2.get$y(t1), t2.get$z(t1)), dpdu, dpdv, new G.Normal(0, 0, 0), new G.Normal(0, 0, 0), tu, tv, this);
      tHit[0] = t;
      if (typeof t !== "number")
        return H.iae(t);
      rayEpsilon[0] = 0.001 * t;
      return true;
    },
    intersectP$1: function(ray) {
      var t1, t2, t3, t4, t5, p1, p2, p3, e1, e2, s1, divisor, invDivisor, s, b1, s2, b2, t, uvs, du1, du2, dv1, dv2, dp1, dp2, determinant, dpdu, dpdv, invdet, b0, t6, t7, t8, t9, t10;
      t1 = this.mesh;
      t2 = t1.p;
      t3 = t1.vertexIndex;
      t4 = J.getInterceptor$asx(t3);
      t5 = t4.$index(t3, this.index);
      if (t5 >>> 0 !== t5 || t5 >= t2.length)
        return H.ioore(t2, t5);
      p1 = t2[t5];
      t5 = t1.p;
      t2 = t4.$index(t3, this.index + 1);
      if (t2 >>> 0 !== t2 || t2 >= t5.length)
        return H.ioore(t5, t2);
      p2 = t5[t2];
      t2 = t1.p;
      t3 = t4.$index(t3, this.index + 2);
      if (t3 >>> 0 !== t3 || t3 >= t2.length)
        return H.ioore(t2, t3);
      p3 = t2[t3];
      t3 = J.getInterceptor$n(p2);
      e1 = t3.$sub(p2, p1);
      e2 = J.$sub$n(p3, p1);
      s1 = G.Vector_Cross(ray.direction, e2);
      divisor = G.Vector_Dot(s1, e1);
      if (J.$eq(divisor, 0))
        return false;
      if (typeof divisor !== "number")
        return H.iae(divisor);
      invDivisor = 1 / divisor;
      s = J.$sub$n(ray.origin, p1);
      b1 = J.$mul$ns(G.Vector_Dot(s, s1), invDivisor);
      t2 = J.getInterceptor$n(b1);
      if (t2.$lt(b1, 0) || t2.$gt(b1, 1))
        return false;
      s2 = G.Vector_Cross(s, e1);
      b2 = J.$mul$ns(G.Vector_Dot(ray.direction, s2), invDivisor);
      if (J.$lt$n(b2, 0) || J.$gt$n(t2.$add(b1, b2), 1))
        return false;
      t = J.$mul$ns(G.Vector_Dot(e2, s2), invDivisor);
      t2 = J.getInterceptor$n(t);
      if (t2.$lt(t, ray.minDistance) || t2.$gt(t, ray.maxDistance))
        return false;
      if (ray.depth !== -1 && t1.alphaTexture != null) {
        uvs = H.setRuntimeTypeInfo(Array(6), [J.JSDouble]);
        this.getUVs$1(uvs);
        du1 = J.$sub$n(uvs[0], uvs[4]);
        du2 = J.$sub$n(uvs[2], uvs[4]);
        dv1 = J.$sub$n(uvs[1], uvs[5]);
        dv2 = J.$sub$n(uvs[3], uvs[5]);
        dp1 = J.$sub$n(p1, p3);
        dp2 = t3.$sub(p2, p3);
        determinant = J.$sub$n(J.$mul$ns(du1, dv2), J.$mul$ns(dv1, du2));
        if (J.$eq(determinant, 0)) {
          t2 = G.Vector_Cross(e2, e1);
          G.Vector_CoordinateSystem(t2.$div(0, t2.length$0(0)), null, null);
          dpdu = null;
          dpdv = null;
        } else {
          if (typeof determinant !== "number")
            return H.iae(determinant);
          invdet = 1 / determinant;
          t2 = J.getInterceptor$ns(dp1);
          t3 = J.getInterceptor$ns(dp2);
          dpdu = J.$mul$ns(J.$sub$n(t2.$mul(dp1, dv2), t3.$mul(dp2, dv1)), invdet);
          dpdv = J.$mul$ns(J.$add$ns(t2.$mul(dp1, J.$negate$n(du2)), t3.$mul(dp2, du1)), invdet);
        }
        if (typeof b1 !== "number")
          return H.iae(b1);
        if (typeof b2 !== "number")
          return H.iae(b2);
        b0 = 1 - b1 - b2;
        t2 = uvs[0];
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = uvs[2];
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = uvs[4];
        if (typeof t4 !== "number")
          return H.iae(t4);
        t5 = uvs[1];
        if (typeof t5 !== "number")
          return H.iae(t5);
        t6 = uvs[3];
        if (typeof t6 !== "number")
          return H.iae(t6);
        t7 = uvs[5];
        if (typeof t7 !== "number")
          return H.iae(t7);
        t8 = G.DifferentialGeometry$();
        t9 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t));
        t10 = J.getInterceptor$x(t9);
        if (J.$eq(t1.alphaTexture.evaluate$1(t8.set$8(new G.Point(t10.get$x(t9), t10.get$y(t9), t10.get$z(t9)), dpdu, dpdv, new G.Normal(0, 0, 0), new G.Normal(0, 0, 0), b0 * t2 + b1 * t3 + b2 * t4, b0 * t5 + b1 * t6 + b2 * t7, this)), 0))
          return false;
      }
      return true;
    },
    v$1: [function(i) {
      var t1 = this.index;
      if (typeof i !== "number")
        return H.iae(i);
      return J.$index$asx(this.mesh.vertexIndex, t1 + i);
    }, "call$1", "get$v", 2, 0, 113],
    getUVs$1: function(uv) {
      var t1, t2, t3, t4, t5;
      t1 = this.mesh;
      t2 = t1.uvs;
      if (t2 != null) {
        t1 = t1.vertexIndex;
        t3 = J.getInterceptor$asx(t1);
        t4 = t3.$index(t1, this.index);
        if (typeof t4 !== "number")
          return H.iae(t4);
        t5 = J.getInterceptor$asx(t2);
        uv[0] = t5.$index(t2, 2 * t4);
        t4 = t3.$index(t1, this.index);
        if (typeof t4 !== "number")
          return H.iae(t4);
        uv[1] = t5.$index(t2, 2 * t4 + 1);
        t4 = t3.$index(t1, this.index + 1);
        if (typeof t4 !== "number")
          return H.iae(t4);
        uv[2] = t5.$index(t2, 2 * t4);
        t4 = t3.$index(t1, this.index + 1);
        if (typeof t4 !== "number")
          return H.iae(t4);
        uv[3] = t5.$index(t2, 2 * t4 + 1);
        t4 = t3.$index(t1, this.index + 2);
        if (typeof t4 !== "number")
          return H.iae(t4);
        uv[4] = t5.$index(t2, 2 * t4);
        t1 = t3.$index(t1, this.index + 2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        uv[5] = t5.$index(t2, 2 * t1 + 1);
      } else {
        uv[0] = 0;
        uv[1] = 0;
        uv[2] = 1;
        uv[3] = 0;
        uv[4] = 1;
        uv[5] = 1;
      }
    },
    area$0: function() {
      var t1, t2, t3, t4, t5, p1, p2, p3;
      t1 = this.mesh;
      t2 = t1.p;
      t3 = t1.vertexIndex;
      t4 = J.getInterceptor$asx(t3);
      t5 = t4.$index(t3, this.index);
      if (t5 >>> 0 !== t5 || t5 >= t2.length)
        return H.ioore(t2, t5);
      p1 = t2[t5];
      t5 = t1.p;
      t2 = t4.$index(t3, this.index + 1);
      if (t2 >>> 0 !== t2 || t2 >= t5.length)
        return H.ioore(t5, t2);
      p2 = t5[t2];
      t1 = t1.p;
      t3 = t4.$index(t3, this.index + 2);
      if (t3 >>> 0 !== t3 || t3 >= t1.length)
        return H.ioore(t1, t3);
      p3 = t1[t3];
      t3 = G.Vector_Cross(J.$sub$n(p2, p1), J.$sub$n(p3, p1)).lengthSquared$0();
      if (typeof t3 !== "number")
        H.throwExpression(P.ArgumentError$(t3));
      return 0.5 * Math.sqrt(t3);
    },
    getShadingGeometry$3: function(obj2world, dg, dgShading) {
      var t1, t2, t3, _by, _bz, _uv, t4, t5, t6, t7, t8, t9, bx, ns, ss, ts, du1, du2, dv1, dv2, dn1, dn2, determinant, dndu, dndv, invdet;
      t1 = this.mesh;
      t2 = t1.n;
      t3 = t2 == null;
      if (t3 && t1.s == null) {
        dgShading.copy$1(dg);
        return;
      }
      _by = [0];
      _bz = [0];
      _uv = H.setRuntimeTypeInfo(Array(6), [J.JSDouble]);
      this.getUVs$1(_uv);
      t4 = J.$sub$n(_uv[2], _uv[0]);
      t5 = J.$sub$n(_uv[4], _uv[0]);
      t6 = J.$sub$n(_uv[3], _uv[1]);
      t7 = J.$sub$n(_uv[5], _uv[1]);
      t8 = dg.u;
      t9 = _uv[0];
      if (typeof t9 !== "number")
        return H.iae(t9);
      if (!G.SolveLinearSystem2x2([t4, t5, t6, t7], [t8 - t9, J.$sub$n(dg.v, _uv[1])], _by, _bz)) {
        _bz[0] = 0.3333333333333333;
        _by[0] = 0.3333333333333333;
        bx = 0.3333333333333333;
      } else {
        t4 = _by[0];
        if (typeof t4 !== "number")
          return H.iae(t4);
        t5 = _bz[0];
        if (typeof t5 !== "number")
          return H.iae(t5);
        bx = 1 - t4 - t5;
      }
      t3 = !t3;
      if (t3) {
        t4 = t1.vertexIndex;
        t5 = J.getInterceptor$asx(t4);
        t6 = J.getInterceptor$asx(t2);
        t4 = obj2world.transformNormal$1(J.$add$ns(J.$add$ns(J.$mul$ns(t6.$index(t2, t5.$index(t4, this.index)), bx), J.$mul$ns(t6.$index(t2, t5.$index(t4, this.index + 1)), _by[0])), J.$mul$ns(t6.$index(t2, t5.$index(t4, this.index + 2)), _bz[0])));
        ns = t4.$div(0, t4.length$0(0));
      } else {
        t4 = dg.nn;
        t5 = J.getInterceptor$x(t4);
        ns = new G.Normal(t5.get$x(t4), t5.get$y(t4), t5.get$z(t4));
      }
      t4 = t1.s;
      if (t4 != null) {
        t5 = t1.vertexIndex;
        t6 = J.getInterceptor$asx(t5);
        t7 = J.getInterceptor$asx(t4);
        t5 = obj2world.transformVector$1(J.$add$ns(J.$add$ns(J.$mul$ns(t7.$index(t4, t6.$index(t5, this.index)), bx), J.$mul$ns(t7.$index(t4, t6.$index(t5, this.index + 1)), _by[0])), J.$mul$ns(t7.$index(t4, t6.$index(t5, this.index + 2)), _bz[0])));
        ss = t5.$div(t5, t5.length$0(0));
      } else {
        t4 = dg.dpdu;
        ss = t4.$div(t4, t4.length$0(0));
      }
      ts = G.Vector_Cross(ss, ns);
      if (J.$gt$n(ts.lengthSquared$0(), 0)) {
        ts = ts.$div(0, ts.length$0(0));
        ss = G.Vector_Cross(ts, ns);
      } else
        G.Vector_CoordinateSystem(ns, ss, ts);
      if (t3) {
        du1 = J.$sub$n(_uv[0], _uv[4]);
        du2 = J.$sub$n(_uv[2], _uv[4]);
        dv1 = J.$sub$n(_uv[1], _uv[5]);
        dv2 = J.$sub$n(_uv[3], _uv[5]);
        t1 = t1.vertexIndex;
        t3 = J.getInterceptor$asx(t1);
        t4 = J.getInterceptor$asx(t2);
        dn1 = J.$sub$n(t4.$index(t2, t3.$index(t1, this.index)), t4.$index(t2, t3.$index(t1, this.index + 2)));
        dn2 = J.$sub$n(t4.$index(t2, t3.$index(t1, this.index + 1)), t4.$index(t2, t3.$index(t1, this.index + 2)));
        determinant = J.$sub$n(J.$mul$ns(du1, dv2), J.$mul$ns(dv1, du2));
        if (J.$eq(determinant, 0)) {
          dndu = new G.Normal(0, 0, 0);
          dndv = new G.Normal(0, 0, 0);
        } else {
          if (typeof determinant !== "number")
            return H.iae(determinant);
          invdet = 1 / determinant;
          t1 = J.getInterceptor$ns(dn1);
          t2 = J.getInterceptor$ns(dn2);
          dndu = J.$mul$ns(J.$sub$n(t1.$mul(dn1, dv2), t2.$mul(dn2, dv1)), invdet);
          dndv = J.$mul$ns(J.$add$ns(t1.$mul(dn1, J.$negate$n(du2)), t2.$mul(dn2, du1)), invdet);
        }
      } else {
        dndu = new G.Normal(0, 0, 0);
        dndv = new G.Normal(0, 0, 0);
      }
      t1 = this.objectToWorld;
      dgShading.set$8(dg.p, ss, ts, t1.transformNormal$1(dndu), t1.transformNormal$1(dndv), dg.u, dg.v, dg.shape);
      dgShading.dudx = dg.dudx;
      dgShading.dvdx = dg.dvdx;
      dgShading.dudy = dg.dudy;
      dgShading.dvdy = dg.dvdy;
      dgShading.dpdx = dg.dpdx;
      dgShading.dpdy = dg.dpdy;
    },
    sample$3: function(u1, u2, Ns) {
      var b1, b2, su1, t1, t2, t3, t4, t5, p1, p2, p3, p, n;
      b1 = [0];
      b2 = [0];
      if (typeof u1 !== "number")
        H.throwExpression(P.ArgumentError$(u1));
      su1 = Math.sqrt(u1);
      b1[0] = 1 - su1;
      b2[0] = J.$mul$ns(u2, su1);
      t1 = this.mesh;
      t2 = t1.p;
      t3 = t1.vertexIndex;
      t4 = J.getInterceptor$asx(t3);
      t5 = t4.$index(t3, this.index);
      if (t5 >>> 0 !== t5 || t5 >= t2.length)
        return H.ioore(t2, t5);
      p1 = t2[t5];
      t5 = t1.p;
      t2 = t4.$index(t3, this.index + 1);
      if (t2 >>> 0 !== t2 || t2 >= t5.length)
        return H.ioore(t5, t2);
      p2 = t5[t2];
      t1 = t1.p;
      t3 = t4.$index(t3, this.index + 2);
      if (t3 >>> 0 !== t3 || t3 >= t1.length)
        return H.ioore(t1, t3);
      p3 = t1[t3];
      t3 = J.getInterceptor$ns(p2);
      t1 = J.$add$ns(J.$mul$ns(p1, b1[0]), t3.$mul(p2, b2[0]));
      t4 = b1[0];
      if (typeof t4 !== "number")
        return H.iae(t4);
      t2 = b2[0];
      if (typeof t2 !== "number")
        return H.iae(t2);
      t5 = J.getInterceptor$ns(p3);
      p = J.$add$ns(t1, t5.$mul(p3, 1 - t4 - t2));
      n = G.Vector_Cross(t3.$sub(p2, p1), t5.$sub(p3, p1));
      Ns.copy$1(n.$div(0, n.length$0(0)));
      if (this.reverseOrientation === true) {
        t1 = J.getInterceptor$x(Ns);
        t1.set$x(Ns, J.$mul$ns(t1.get$x(Ns), -1));
        t1.set$y(Ns, J.$mul$ns(t1.get$y(Ns), -1));
        t1.set$z(Ns, J.$mul$ns(t1.get$z(Ns), -1));
      }
      return p;
    }
  }
}],
["surface_integrators", "package:dartray/surface_integrators/surface_integrators.dart", , U, {
  "^": "",
  _LPhoton: function(map, nPaths, nLookup, lookupBuf, bsdf, rng, isect, wo, maxDist2) {
    var $L, proc, nFound, Nf, t1, i, p, t2, t3, s, Lr, Lt, t4, t5, t6, t7;
    $L = G.Spectrum_Spectrum(0);
    if (map != null && bsdf.numComponents$1(15) > 0) {
      proc = new U.PhotonProcess(lookupBuf, nLookup, 0);
      map._core0$_lookup$4(0, isect.dg.p, proc, maxDist2);
      nFound = proc.nFound;
      Nf = G.Normal_FaceForward(bsdf.dgShading.nn, wo);
      if (bsdf.numComponents$1(11) > 0)
        for (t1 = lookupBuf.length, i = 0; i < nFound; ++i) {
          if (i >= t1)
            return H.ioore(lookupBuf, i);
          p = lookupBuf[i].get$photon();
          t2 = isect.dg.p;
          if (0 >= maxDist2.length)
            return H.ioore(maxDist2, 0);
          t3 = maxDist2[0];
          t3 = J.$div$n(t2.$sub(0, J.get$p$x(p)).lengthSquared$0(), t3);
          if (typeof t3 !== "number")
            return H.iae(t3);
          s = 1 - t3;
          t3 = bsdf.f$2(wo, p.get$wi()).$mul(0, p.alpha);
          if (0 >= maxDist2.length)
            return H.ioore(maxDist2, 0);
          t2 = maxDist2[0];
          if (typeof t2 !== "number")
            return H.iae(t2);
          $L = $L.$add(0, t3.$mul(0, 0.954929658551372 * s * s / (nPaths * t2)));
        }
      else {
        Lr = G.Spectrum_Spectrum(0);
        Lt = G.Spectrum_Spectrum(0);
        for (t1 = lookupBuf.length, t2 = J.getInterceptor$x(Nf), i = 0; i < nFound; ++i) {
          if (i >= t1)
            return H.ioore(lookupBuf, i);
          t3 = lookupBuf[i].get$photon().get$wi();
          t4 = J.getInterceptor$x(t3);
          t3 = J.$gt$n(J.$add$ns(J.$add$ns(J.$mul$ns(t2.get$x(Nf), t4.get$x(t3)), J.$mul$ns(t2.get$y(Nf), t4.get$y(t3))), J.$mul$ns(t2.get$z(Nf), t4.get$z(t3))), 0);
          t4 = lookupBuf[i];
          t5 = maxDist2[0];
          t6 = isect.dg;
          t7 = maxDist2.length;
          if (t3) {
            t3 = t4.get$photon();
            t6 = t6.p;
            if (0 >= t7)
              return H.ioore(maxDist2, 0);
            t5 = J.$div$n(t6.$sub(0, J.get$p$x(t3)).lengthSquared$0(), t5);
            if (typeof t5 !== "number")
              return H.iae(t5);
            s = 1 - t5;
            t5 = J.get$alpha$x(lookupBuf[i].get$photon());
            if (0 >= maxDist2.length)
              return H.ioore(maxDist2, 0);
            t3 = maxDist2[0];
            if (typeof t3 !== "number")
              return H.iae(t3);
            Lr = Lr.$add(0, J.$mul$ns(t5, 0.954929658551372 * s * s / (nPaths * t3)));
          } else {
            t3 = t4.get$photon();
            t6 = t6.p;
            if (0 >= t7)
              return H.ioore(maxDist2, 0);
            t5 = J.$div$n(t6.$sub(0, J.get$p$x(t3)).lengthSquared$0(), t5);
            if (typeof t5 !== "number")
              return H.iae(t5);
            s = 1 - t5;
            t5 = J.get$alpha$x(lookupBuf[i].get$photon());
            if (0 >= maxDist2.length)
              return H.ioore(maxDist2, 0);
            t3 = maxDist2[0];
            if (typeof t3 !== "number")
              return H.iae(t3);
            Lt = Lt.$add(0, J.$mul$ns(t5, 0.954929658551372 * s * s / (nPaths * t3)));
          }
        }
        $L = $L.$add(0, Lr.$mul(0, bsdf.rho2$3(wo, rng, 29)).$mul(0, 0.3183098861837907).$add(0, Lt.$mul(0, bsdf.rho2$3(wo, rng, 30)).$mul(0, 0.3183098861837907)));
      }
    }
    return $L;
  },
  _EPhoton: function(map, count, nLookup, lookupBuf, maxDist2, p, n) {
    var proc, md2, $E, t1, t2, i, t3, t4;
    if (map == null)
      return G.Spectrum_Spectrum(0);
    proc = new U.PhotonProcess(lookupBuf, nLookup, 0);
    if (0 >= maxDist2.length)
      return H.ioore(maxDist2, 0);
    md2 = [maxDist2[0]];
    map._core0$_lookup$4(0, p, proc, md2);
    if (proc.nFound === 0)
      return G.Spectrum_Spectrum(0);
    $E = G.Spectrum_Spectrum(0);
    for (t1 = lookupBuf.length, t2 = J.getInterceptor$x(n), i = 0; i < proc.nFound; ++i) {
      if (i >= t1)
        return H.ioore(lookupBuf, i);
      t3 = lookupBuf[i].get$photon().get$wi();
      t4 = J.getInterceptor$x(t3);
      if (J.$gt$n(J.$add$ns(J.$add$ns(J.$mul$ns(t2.get$x(n), t4.get$x(t3)), J.$mul$ns(t2.get$y(n), t4.get$y(t3))), J.$mul$ns(t2.get$z(n), t4.get$z(t3))), 0))
        $E = $E.$add(0, J.get$alpha$x(lookupBuf[i].get$photon()));
    }
    if (0 >= md2.length)
      return H.ioore(md2, 0);
    return $E.$div(0, J.$mul$ns(J.$mul$ns(count, md2[0]), 3.141592653589793));
  },
  AmbientOcclusionIntegrator: {
    "^": "SurfaceIntegrator;nSamples<,minDist,maxDist<",
    Li$6: function(scene, renderer, ray, isect, sample, rng) {
      var p, n, scramble, u, t1, t2, t3, t4, nClear, i, t5, w, t6, hit;
      p = isect.getBSDF$1(ray).dgShading.p;
      n = G.Normal_FaceForward(isect.dg.nn, J.$negate$n(ray.get$direction()));
      scramble = [rng.randomUInt$0(), rng.randomUInt$0()];
      u = [0, 0];
      for (t1 = scene.aggregate, t2 = this.minDist, t3 = this.maxDist, t4 = J.getInterceptor$x(n), nClear = 0, i = 0; t5 = this.nSamples, i < t5; ++i) {
        u[0] = G.VanDerCorput(i, scramble[0]);
        t5 = G.Sobol2(i, scramble[1]);
        u[1] = t5;
        w = G.UniformSampleSphere(u[0], t5);
        if (J.$lt$n(J.$add$ns(J.$add$ns(J.$mul$ns(w.x, t4.get$x(n)), J.$mul$ns(w.y, t4.get$y(n))), J.$mul$ns(w.z, t4.get$z(n))), 0))
          w = new G.Vector(J.$negate$n(w.x), J.$negate$n(w.y), J.$negate$n(w.z));
        t5 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
        t6 = new G.Vector(w.x, w.y, w.z);
        hit = t1.intersectP$1(new G.Ray(t5, t6, t2, t3, 0, 0));
        t5 = $.get$Stats_shadowRays();
        t5.count = J.$add$ns(t5.count, 1);
        $.Stats_shadowRays = t5;
        if (!hit)
          ++nClear;
      }
      return G.Spectrum_Spectrum(nClear / t5);
    },
    static: {AmbientOcclusionIntegrator_Create: [function(params) {
        var nSamples, maxDist, t1;
        nSamples = params.findOneInt$2("nsamples", 2048);
        maxDist = params.findOneFloat$2("maxdist", 1 / 0);
        t1 = new U.AmbientOcclusionIntegrator(null, params.findOneFloat$2("mindist", 0.0001), maxDist);
        t1.nSamples = G.RoundUpPow2(nSamples);
        return t1;
      }, "call$1", "AmbientOcclusionIntegrator_Create$closure", 2, 0, 60]}
  },
  DiffusePRTIntegrator: {
    "^": "SurfaceIntegrator;lmax,nSamples<,c_in",
    preprocess$3: function(scene, camera, renderer) {
      var bbox, p, rng;
      bbox = scene.worldBound;
      p = bbox.get$pMin().$mul(0, 0.5).$add(0, bbox.pMax.$mul(0, 0.5));
      rng = new G.RNG(null, new Uint32Array(624), null);
      rng.mti = 625;
      rng.seed$1(0, 5489);
      G.SphericalHarmonics_ProjectIncidentDirectRadiance(p, 0, camera.get$shutterOpen(), scene, false, this.lmax, rng, this.c_in);
    },
    requestSamples$3: function(sampler, sample, scene) {
    },
    Li$6: function(scene, renderer, ray, isect, sample, rng) {
      var $L, wo, bsdf, t1, p, n, t2, t3, c_transfer, len, i, Kd, Lo, len0;
      $L = G.Spectrum_Spectrum(0);
      wo = J.$negate$n(ray.get$direction());
      $L = $L.$add(0, isect.Le$1(wo));
      bsdf = isect.getBSDF$1(ray);
      t1 = bsdf.dgShading;
      p = t1.p;
      n = t1.nn;
      t1 = this.lmax;
      t2 = J.getInterceptor$ns(t1);
      t3 = J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1));
      if (typeof t3 !== "number")
        return H.iae(t3);
      c_transfer = H.setRuntimeTypeInfo(Array(t3), [G.Spectrum]);
      for (len = c_transfer.length, i = 0; i < len; ++i)
        c_transfer[i] = G.Spectrum_Spectrum(0);
      G.SphericalHarmonics_ComputeDiffuseTransfer(p, G.Normal_FaceForward(n, wo), isect.rayEpsilon, scene, rng, this.nSamples, t1, c_transfer);
      Kd = bsdf.rho2$3(wo, rng, 29).$mul(0, 0.3183098861837907);
      Lo = G.Spectrum_Spectrum(0);
      len0 = J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1));
      if (typeof len0 !== "number")
        return H.iae(len0);
      t1 = this.c_in;
      t2 = t1.length;
      i = 0;
      for (; i < len0; ++i) {
        if (i >= t2)
          return H.ioore(t1, i);
        t3 = t1[i];
        if (i >= len)
          return H.ioore(c_transfer, i);
        Lo = Lo.$add(0, J.$mul$ns(t3, c_transfer[i]));
      }
      return $L.$add(0, Kd.$mul(0, Lo.clamp$0(0)));
    },
    DiffusePRTIntegrator$2: function(lm, ns) {
      var t1, len, i;
      for (t1 = this.c_in, len = t1.length, i = 0; i < len; ++i)
        t1[i] = G.Spectrum_Spectrum(0);
    },
    static: {DiffusePRTIntegrator$: function(lm, ns) {
        var t1, t2;
        t1 = G.RoundUpPow2(ns);
        t2 = J.getInterceptor$ns(lm);
        t2 = J.$mul$ns(t2.$add(lm, 1), t2.$add(lm, 1));
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = new U.DiffusePRTIntegrator(lm, t1, H.setRuntimeTypeInfo(Array(t2), [G.Spectrum]));
        t2.DiffusePRTIntegrator$2(lm, ns);
        return t2;
      }, DiffusePRTIntegrator_Create: [function(params) {
        return U.DiffusePRTIntegrator$(params.findOneInt$2("lmax", 4), params.findOneInt$2("nsamples", 4096));
      }, "call$1", "DiffusePRTIntegrator_Create$closure", 2, 0, 61]}
  },
  DirectLightingIntegrator: {
    "^": "SurfaceIntegrator;strategy,maxDepth,lightSampleOffsets,bsdfSampleOffsets,lightNumOffset",
    Li$6: function(scene, renderer, ray, isect, sample, rng) {
      var $L, bsdf, wo, t1, p, n, t2, t3, t4, t5;
      $L = G.Spectrum_Spectrum(0);
      bsdf = isect.getBSDF$1(ray);
      wo = J.$negate$n(ray.get$direction());
      t1 = bsdf.dgShading;
      p = t1.p;
      n = t1.nn;
      $L = $L.$add(0, isect.Le$1(wo));
      if (scene.lights.length > 0)
        switch (this.strategy) {
          case 0:
            $L = $L.$add(0, G.Integrator_UniformSampleAllLights(scene, renderer, p, n, wo, isect.rayEpsilon, ray.time, bsdf, sample, rng, this.lightSampleOffsets, this.bsdfSampleOffsets));
            break;
          case 1:
            t1 = isect.rayEpsilon;
            t2 = ray.time;
            t3 = this.lightNumOffset;
            t4 = this.lightSampleOffsets;
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t4 = t4[0];
            t5 = this.bsdfSampleOffsets;
            if (0 >= t5.length)
              return H.ioore(t5, 0);
            $L = $L.$add(0, G.Integrator_UniformSampleOneLight(scene, renderer, p, n, wo, t1, t2, bsdf, sample, rng, t3, t4, t5[0]));
            break;
        }
      t1 = ray.depth;
      t2 = this.maxDepth;
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 + 1 < t2 ? $L.$add(0, G.Integrator_SpecularReflect(ray, bsdf, rng, isect, renderer, scene, sample)).$add(0, G.Integrator_SpecularTransmit(ray, bsdf, rng, isect, renderer, scene, sample)) : $L;
    },
    requestSamples$3: function(sampler, sample, scene) {
      var t1, nLights, t2, i, nSamples, t3, t4;
      if (this.strategy === 0) {
        t1 = scene.lights;
        nLights = t1.length;
        this.lightSampleOffsets = H.setRuntimeTypeInfo(Array(nLights), [G.LightSampleOffsets]);
        this.bsdfSampleOffsets = H.setRuntimeTypeInfo(Array(nLights), [G.BSDFSampleOffsets]);
        for (t2 = sampler != null, i = 0; i < nLights; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          nSamples = t1[i].get$nSamples();
          if (t2)
            nSamples = sampler.roundSize$1(nSamples);
          t3 = this.lightSampleOffsets;
          t4 = new G.LightSampleOffsets(nSamples, null, null);
          sample.n1D.push(nSamples);
          t4.componentOffset = sample.n1D.length - 1;
          sample.n2D.push(nSamples);
          t4.posOffset = sample.n2D.length - 1;
          if (i >= t3.length)
            return H.ioore(t3, i);
          t3[i] = t4;
          t3 = this.bsdfSampleOffsets;
          t4 = new G.BSDFSampleOffsets(nSamples, null, null);
          sample.n1D.push(nSamples);
          t4.componentOffset = sample.n1D.length - 1;
          sample.n2D.push(nSamples);
          t4.dirOffset = sample.n2D.length - 1;
          if (i >= t3.length)
            return H.ioore(t3, i);
          t3[i] = t4;
        }
        this.lightNumOffset = -1;
      } else {
        t1 = H.setRuntimeTypeInfo(Array(1), [G.LightSampleOffsets]);
        this.lightSampleOffsets = t1;
        t2 = G.LightSampleOffsets$(1, sample);
        if (0 >= 1)
          return H.ioore(t1, 0);
        t1[0] = t2;
        sample.n1D.push(1);
        this.lightNumOffset = sample.n1D.length - 1;
        t2 = H.setRuntimeTypeInfo(Array(1), [G.BSDFSampleOffsets]);
        this.bsdfSampleOffsets = t2;
        t1 = G.BSDFSampleOffsets$(1, sample);
        if (0 >= 1)
          return H.ioore(t2, 0);
        t2[0] = t1;
      }
    },
    static: {"^": "DirectLightingIntegrator_SAMPLE_ALL_UNIFORM,DirectLightingIntegrator_SAMPLE_ONE_UNIFORM", DirectLightingIntegrator_Create: [function(params) {
        var maxDepth, st, t1, strategy;
        maxDepth = params.findOneInt$2("maxdepth", 5);
        st = params.findOneString$2("strategy", "all");
        t1 = J.getInterceptor(st);
        if (t1.$eq(st, "one"))
          strategy = 1;
        else {
          if (t1.$eq(st, "all"))
            ;
          else {
            t1 = "Strategy '" + H.S(st) + "' for direct lighting unknown. Using 'all'.";
            $.Log.call$2(1, t1);
          }
          strategy = 0;
        }
        return new U.DirectLightingIntegrator(strategy, maxDepth, null, null, null);
      }, "call$1", "DirectLightingIntegrator_Create$closure", 2, 0, 62]}
  },
  GlossyPRTIntegrator: {
    "^": "SurfaceIntegrator;Kd,Ks,roughness,lmax,nSamples<,c_in,B",
    preprocess$3: function(scene, camera, renderer) {
      var bbox, p, rng, t1, t2, t3, len, i, t4;
      bbox = scene.worldBound;
      p = bbox.get$pMin().$mul(0, 0.5).$add(0, bbox.pMax.$mul(0, 0.5));
      rng = new G.RNG(null, new Uint32Array(624), null);
      rng.mti = 625;
      rng.seed$1(0, 5489);
      t1 = this.lmax;
      t2 = J.getInterceptor$ns(t1);
      t3 = J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1));
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = H.setRuntimeTypeInfo(Array(t3), [G.Spectrum]);
      this.c_in = t3;
      for (len = t3.length, i = 0; t3 = this.c_in, i < len; ++i) {
        t4 = G.Spectrum_Spectrum(0);
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3[i] = t4;
      }
      G.SphericalHarmonics_ProjectIncidentDirectRadiance(p, 0, camera.get$shutterOpen(), scene, false, t1, rng, t3);
      t2 = J.$mul$ns(J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1)), J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1)));
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = H.setRuntimeTypeInfo(Array(t2), [G.Spectrum]);
      this.B = t2;
      G.SphericalHarmonics_ComputeBSDFMatrix(this.Kd, this.Ks, this.roughness, rng, 1024, t1, t2);
    },
    requestSamples$3: function(sampler, sample, scene) {
    },
    Li$6: function(scene, renderer, ray, isect, sample, rng) {
      var $L, wo, bsdf, p, t1, t2, t3, c_t, $T, r1, r2, t4, t5, rot, c_l, len, i, alpha, beta, gamma, t6, sy, work, c_o, woLocal, Ylm, Li;
      $L = G.Spectrum_Spectrum(0);
      wo = J.$negate$n(ray.get$direction());
      $L = $L.$add(0, isect.Le$1(wo));
      bsdf = isect.getBSDF$1(ray);
      p = bsdf.dgShading.p;
      t1 = this.lmax;
      t2 = J.getInterceptor$ns(t1);
      t3 = J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1));
      if (typeof t3 !== "number")
        return H.iae(t3);
      c_t = H.setRuntimeTypeInfo(Array(t3), [G.Spectrum]);
      t3 = J.$mul$ns(J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1)), J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1)));
      if (typeof t3 !== "number")
        return H.iae(t3);
      $T = H.setRuntimeTypeInfo(Array(t3), [G.Spectrum]);
      G.SphericalHarmonics_ComputeTransferMatrix(p, isect.rayEpsilon, scene, rng, this.nSamples, t1, $T);
      G.SphericalHarmonics_MatrixVectorMultiply($T, this.c_in, c_t, t1);
      r1 = bsdf.localToWorld$1(new G.Vector(1, 0, 0));
      r2 = bsdf.localToWorld$1(new G.Vector(0, 1, 0));
      t3 = bsdf.localToWorld$1(new G.Vector(0, 0, 1));
      t4 = t3.x;
      t5 = t3.y;
      t3 = t3.z;
      rot = G.Matrix4x4$values(r1.x, r2.x, t4, 0, r1.y, r2.y, t5, 0, r1.z, r2.z, t3, 0, 0, 0, 0, 1);
      t3 = J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1));
      if (typeof t3 !== "number")
        return H.iae(t3);
      c_l = H.setRuntimeTypeInfo(Array(t3), [G.Spectrum]);
      for (len = c_l.length, i = 0; i < len; ++i)
        c_l[i] = G.Spectrum_Spectrum(0);
      alpha = [0];
      beta = [0];
      gamma = [0];
      t3 = rot.m;
      t4 = t3.length;
      if (9 >= t4)
        return H.ioore(t3, 9);
      t5 = t3[9];
      t6 = t3[8];
      sy = Math.sqrt(t5 * t5 + t6 * t6);
      if (sy > 0.00000190734864) {
        t5 = t3[6];
        t6 = t3[2];
        gamma[0] = -Math.atan2(t5, -t6);
        if (10 >= t4)
          return H.ioore(t3, 10);
        t4 = t3[10];
        beta[0] = -Math.atan2(sy, t4);
        t4 = t3[9];
        t3 = t3[8];
        alpha[0] = -Math.atan2(t4, t3);
      } else {
        gamma[0] = 0;
        if (10 >= t4)
          return H.ioore(t3, 10);
        t4 = t3[10];
        beta[0] = -Math.atan2(sy, t4);
        t4 = t3[4];
        t3 = t3[5];
        alpha[0] = -Math.atan2(-t4, t3);
      }
      work = G.Spectrum_AllocateList(J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1)));
      G.SphericalHarmonics_RotateZ(c_t, c_l, gamma[0], t1);
      G.SphericalHarmonics_RotateXPlus(c_l, work, t1);
      G.SphericalHarmonics_RotateZ(work, c_l, beta[0], t1);
      G.SphericalHarmonics_RotateXMinus(c_l, work, t1);
      G.SphericalHarmonics_RotateZ(work, c_l, alpha[0], t1);
      t3 = J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1));
      if (typeof t3 !== "number")
        return H.iae(t3);
      c_o = H.setRuntimeTypeInfo(Array(t3), [G.Spectrum]);
      G.SphericalHarmonics_MatrixVectorMultiply(this.B, c_l, c_o, t1);
      woLocal = bsdf.worldToLocal$1(wo);
      t3 = J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1));
      if (typeof t3 !== "number" || Math.floor(t3) !== t3)
        H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t3)));
      Ylm = new Float32Array(t3);
      G.SphericalHarmonics_Evaluate(woLocal, t1, Ylm, 0);
      Li = G.Spectrum_Spectrum(0);
      t3 = c_o.length;
      t4 = Ylm.length;
      i = 0;
      while (true) {
        t5 = J.$mul$ns(t2.$add(t1, 1), t2.$add(t1, 1));
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (!(i < t5))
          break;
        if (i >= t3)
          return H.ioore(c_o, i);
        t5 = c_o[i];
        if (i >= t4)
          return H.ioore(Ylm, i);
        Li = Li.$add(0, J.$mul$ns(t5, Ylm[i]));
        ++i;
      }
      return $L.$add(0, Li.clamp$0(0));
    },
    static: {GlossyPRTIntegrator_Create: [function(params) {
        var lmax, ns, t1;
        lmax = params.findOneInt$2("lmax", 4);
        ns = params.findOneInt$2("nsamples", 4096);
        t1 = new U.GlossyPRTIntegrator(params.findOneSpectrum$2("Kd", G.Spectrum_Spectrum(0.5)), params.findOneSpectrum$2("Ks", G.Spectrum_Spectrum(0.25)), params.findOneFloat$2("roughness", 0.1), lmax, null, null, null);
        t1.nSamples = G.RoundUpPow2(ns);
        return t1;
      }, "call$1", "GlossyPRTIntegrator_Create$closure", 2, 0, 63]}
  },
  IGIIntegrator: {
    "^": "SurfaceIntegrator;lightSampleOffsets,bsdfSampleOffsets,nLightPaths,nLightSets,gLimit,nGatherSamples,rrThreshold,maxSpecularDepth,vlSetOffset,gatherSampleOffset,virtualLights",
    Li$6: function(scene, renderer, ray, isect, sample, rng) {
      var $L, wo, bsdf, t1, p, n, t2, lSet, t3, i, t4, vl, d2, t5, wi, t6, t7, $G, f, Llight, connectRay, hit, nSamples, pdf, bsdfSample, maxDist, t8, t9, t10, gatherIsect, Li, Ggather;
      $L = G.Spectrum_Spectrum(0);
      wo = J.$negate$n(ray.get$direction());
      $L = $L.$add(0, isect.Le$1(wo));
      bsdf = isect.getBSDF$1(ray);
      t1 = bsdf.dgShading;
      p = t1.p;
      n = t1.nn;
      $L = $L.$add(0, G.Integrator_UniformSampleAllLights(scene, renderer, p, n, wo, isect.rayEpsilon, ray.time, bsdf, sample, rng, this.lightSampleOffsets, this.bsdfSampleOffsets));
      t1 = J.toInt$0$n(J.$mul$ns(J.$index$asx(J.$index$asx(sample.get$oneD(), this.vlSetOffset), 0), this.nLightSets));
      t2 = this.nLightSets;
      if (typeof t2 !== "number")
        return t2.$sub();
      lSet = P.min(t1, t2 - 1);
      t1 = scene.aggregate;
      t2 = renderer.volumeIntegrator;
      t3 = J.getInterceptor$x(n);
      i = 0;
      while (true) {
        t4 = this.virtualLights;
        if (lSet >>> 0 !== lSet || lSet >= t4.length)
          return H.ioore(t4, lSet);
        t4 = J.get$length$asx(t4[lSet]);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(i < t4))
          break;
        c$0: {
          t4 = this.virtualLights;
          if (lSet >= t4.length)
            return H.ioore(t4, lSet);
          vl = J.$index$asx(t4[lSet], i);
          t4 = J.getInterceptor$x(vl);
          d2 = J.$sub$n(t4.get$p(vl), p).lengthSquared$0();
          t4 = J.$sub$n(t4.get$p(vl), p);
          t5 = J.getInterceptor$asx(t4);
          wi = t5.$div(t4, t5.length$0(t4));
          t4 = J.getInterceptor$x(wi);
          t5 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(t4.get$x(wi), t3.get$x(n)), J.$mul$ns(t4.get$y(wi), t3.get$y(n))), J.$mul$ns(t4.get$z(wi), t3.get$z(n))));
          t6 = vl.get$n();
          t7 = J.getInterceptor$x(t6);
          t6 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(t4.get$x(wi), t7.get$x(t6)), J.$mul$ns(t4.get$y(wi), t7.get$y(t6))), J.$mul$ns(t4.get$z(wi), t7.get$z(t6))));
          if (typeof d2 !== "number")
            return H.iae(d2);
          $G = P.min(t5 * t6 / d2, this.gLimit);
          f = bsdf.f$2(wo, wi);
          if ($G === 0 || f.isBlack$0())
            break c$0;
          Llight = f.$mul(0, $G).$mul(0, vl.get$pathContrib()).$div(0, this.nLightPaths);
          t5 = isect.rayEpsilon;
          t6 = Math.sqrt(d2);
          t7 = vl.rayEpsilon;
          if (typeof t7 !== "number")
            return H.iae(t7);
          connectRay = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(p.get$x(p), p.get$y(p), p.get$z(p)), new G.Vector(t4.get$x(wi), t4.get$y(wi), t4.get$z(wi)), t5, t6 * (1 - t7), ray.time, ray.depth + 1);
          Llight = Llight.$mul(0, t2.transmittance$5(scene, renderer, connectRay, null, rng));
          if (J.$lt$n(Llight.get$y(Llight), this.rrThreshold)) {
            if (rng.randomFloat$0() > 0.1)
              break c$0;
            Llight = Llight.$div(0, 0.1);
          }
          hit = t1.intersectP$1(connectRay);
          t4 = $.get$Stats_shadowRays();
          t4.count = J.$add$ns(t4.count, 1);
          $.Stats_shadowRays = t4;
          if (!hit)
            $L = $L.$add(0, Llight);
        }
        ++i;
      }
      t1 = ray.depth;
      t2 = this.maxSpecularDepth;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 < t2) {
        nSamples = t1 === 0 ? this.nGatherSamples : 1;
        pdf = [0];
        if (typeof nSamples !== "number")
          return H.iae(nSamples);
        i = 0;
        for (; i < nSamples; ++i) {
          wi = new G.Vector(0, 0, 0);
          if (ray.depth === 0)
            bsdfSample = G.BSDFSample$sample(sample, this.gatherSampleOffset, i);
          else {
            t1 = Array(2);
            t1.$builtinTypeInfo = [J.JSDouble];
            bsdfSample = new G.BSDFSample(t1, 0);
            t1[0] = rng.randomFloat$0();
            t1[1] = (rng.randomUInt$0() & 16777215) / 16777216;
            bsdfSample.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
          }
          f = bsdf.sample_f$5(wo, wi, bsdfSample, pdf, 15);
          if (!f.isBlack$0()) {
            if (0 >= pdf.length)
              return H.ioore(pdf, 0);
            t1 = J.$gt$n(pdf[0], 0);
          } else
            t1 = false;
          if (t1) {
            t1 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t3.get$x(n)), J.$mul$ns(wi.y, t3.get$y(n))), J.$mul$ns(wi.z, t3.get$z(n))));
            t2 = this.gLimit;
            if (typeof t2 !== "number")
              return H.iae(t2);
            maxDist = Math.sqrt(t1 / t2);
            t1 = isect.rayEpsilon;
            t2 = p.get$x(p);
            t4 = p.get$y(p);
            t5 = p.get$z(p);
            t6 = wi.x;
            t7 = wi.y;
            t8 = wi.z;
            t9 = ray.time;
            t10 = ray.depth;
            gatherIsect = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
            gatherIsect.primitive = null;
            gatherIsect.shapeId = 0;
            gatherIsect.primitiveId = 0;
            gatherIsect.rayEpsilon = 0;
            Li = renderer.Li$5(scene, new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(t2, t4, t5), new G.Vector(t6, t7, t8), t1, maxDist, t9, t10 + 1), sample, rng, gatherIsect);
            if (Li.isBlack$0())
              continue;
            t1 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t3.get$x(n)), J.$mul$ns(wi.y, t3.get$y(n))), J.$mul$ns(wi.z, t3.get$z(n))));
            t2 = J.$negate$n(wi.x);
            t4 = J.$negate$n(wi.y);
            t5 = J.$negate$n(wi.z);
            t6 = gatherIsect.dg.nn;
            t7 = J.getInterceptor$x(t6);
            t6 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(t2, t7.get$x(t6)), J.$mul$ns(t4, t7.get$y(t6))), J.$mul$ns(t5, t7.get$z(t6))));
            t7 = gatherIsect.dg.p.$sub(0, p).lengthSquared$0();
            if (typeof t7 !== "number")
              return H.iae(t7);
            Ggather = t1 * t6 / t7;
            t1 = this.gLimit;
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (Ggather - t1 > 0 && isFinite(Ggather)) {
              t1 = this.gLimit;
              if (typeof t1 !== "number")
                return H.iae(t1);
              t2 = f.$mul(0, Li);
              t4 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t3.get$x(n)), J.$mul$ns(wi.y, t3.get$y(n))), J.$mul$ns(wi.z, t3.get$z(n))));
              if (0 >= pdf.length)
                return H.ioore(pdf, 0);
              t5 = pdf[0];
              if (typeof t5 !== "number")
                return H.iae(t5);
              $L = $L.$add(0, t2.$mul(0, t4 * ((Ggather - t1) / Ggather) / (nSamples * t5)));
            }
          }
        }
      }
      t1 = ray.depth;
      t2 = this.maxSpecularDepth;
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 + 1 < t2 ? $L.$add(0, G.Integrator_SpecularReflect(ray, bsdf, rng, isect, renderer, scene, sample)).$add(0, G.Integrator_SpecularTransmit(ray, bsdf, rng, isect, renderer, scene, sample)) : $L;
    },
    requestSamples$3: function(sampler, sample, scene) {
      var t1, nLights, t2, i, nSamples, t3, t4;
      t1 = scene.lights;
      nLights = t1.length;
      this.lightSampleOffsets = H.setRuntimeTypeInfo(Array(nLights), [G.LightSampleOffsets]);
      this.bsdfSampleOffsets = H.setRuntimeTypeInfo(Array(nLights), [G.BSDFSampleOffsets]);
      for (t2 = sampler != null, i = 0; i < nLights; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        nSamples = t1[i].get$nSamples();
        if (t2)
          nSamples = sampler.roundSize$1(nSamples);
        t3 = this.lightSampleOffsets;
        t4 = new G.LightSampleOffsets(nSamples, null, null);
        sample.n1D.push(nSamples);
        t4.componentOffset = sample.n1D.length - 1;
        sample.n2D.push(nSamples);
        t4.posOffset = sample.n2D.length - 1;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3[i] = t4;
        t3 = this.bsdfSampleOffsets;
        t4 = new G.BSDFSampleOffsets(nSamples, null, null);
        sample.n1D.push(nSamples);
        t4.componentOffset = sample.n1D.length - 1;
        sample.n2D.push(nSamples);
        t4.dirOffset = sample.n2D.length - 1;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3[i] = t4;
      }
      sample.n1D.push(1);
      this.vlSetOffset = sample.n1D.length - 1;
      if (t2)
        this.nGatherSamples = sampler.roundSize$1(this.nGatherSamples);
      this.gatherSampleOffset = G.BSDFSampleOffsets$(this.nGatherSamples, sample);
    },
    preprocess$3: function(scene, camera, renderer) {
      var t1, rng, t2, t3, lightNum, t4, lightSampPos, t5, lightSampComp, t6, lightSampDir, lightDistribution, lightPdf, pdf, s, t7, i, sampOffset, ln, light, t8, ray, t9, t10, t11, t12, ls, Nl, alpha, isect, hit, t13, t14, t15, t16, t17, wo, bsdf, contrib, wi, bsdfSample, fr, contribScale, rrProb;
      t1 = scene.lights;
      if (t1.length === 0)
        return;
      rng = new G.RNG(null, new Uint32Array(624), null);
      rng.mti = 625;
      rng.seed$1(0, 5489);
      t2 = this.nLightPaths;
      t3 = this.nLightSets;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = t2 * t3;
      lightNum = new Float32Array(t3);
      t2 = this.nLightPaths;
      t4 = this.nLightSets;
      if (typeof t4 !== "number")
        return H.iae(t4);
      t4 = 2 * t2 * t4;
      lightSampPos = new Float32Array(t4);
      t2 = this.nLightPaths;
      t5 = this.nLightSets;
      if (typeof t5 !== "number")
        return H.iae(t5);
      t5 = t2 * t5;
      lightSampComp = new Float32Array(t5);
      t2 = this.nLightPaths;
      t6 = this.nLightSets;
      if (typeof t6 !== "number")
        return H.iae(t6);
      t6 = 2 * t2 * t6;
      lightSampDir = new Float32Array(t6);
      G.LDShuffleScrambled1D(this.nLightPaths, this.nLightSets, lightNum, rng);
      G.LDShuffleScrambled2D(this.nLightPaths, this.nLightSets, lightSampPos, rng);
      G.LDShuffleScrambled1D(this.nLightPaths, this.nLightSets, lightSampComp, rng);
      G.LDShuffleScrambled2D(this.nLightPaths, this.nLightSets, lightSampDir, rng);
      lightDistribution = G.Integrator_ComputeLightSamplingCDF(scene);
      lightPdf = [0];
      pdf = [0];
      t2 = renderer.volumeIntegrator;
      s = 0;
      while (true) {
        t7 = this.nLightSets;
        if (typeof t7 !== "number")
          return H.iae(t7);
        if (!(s < t7))
          break;
        for (i = 0; t7 = this.nLightPaths, i < t7; ++i) {
          sampOffset = s * t7 + i;
          if (sampOffset >= t3)
            return H.ioore(lightNum, sampOffset);
          ln = lightDistribution.sampleDiscrete$2(lightNum[sampOffset], lightPdf);
          if (ln >>> 0 !== ln || ln >= t1.length)
            return H.ioore(t1, ln);
          light = t1[ln];
          t7 = new G.Point(0, 0, 0);
          t8 = new G.Vector(0, 0, 0);
          ray = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t7, t8, 0, 1 / 0, 0, 0);
          t8 = 2 * sampOffset;
          if (t8 >= t4)
            return H.ioore(lightSampPos, t8);
          t7 = lightSampPos[t8];
          t9 = t8 + 1;
          if (t9 >= t4)
            return H.ioore(lightSampPos, t9);
          t10 = lightSampPos[t9];
          if (sampOffset >= t5)
            return H.ioore(lightSampComp, sampOffset);
          t11 = lightSampComp[sampOffset];
          t12 = Array(2);
          t12.$builtinTypeInfo = [J.JSDouble];
          ls = new G.LightSample(t12, 0);
          t12[0] = t7;
          t12[1] = t10;
          ls.uComponent = t11;
          Nl = new G.Normal(0, 0, 0);
          if (t8 >= t6)
            return H.ioore(lightSampDir, t8);
          t7 = lightSampDir[t8];
          if (t9 >= t6)
            return H.ioore(lightSampDir, t9);
          alpha = light.sampleL$8(scene, ls, t7, lightSampDir[t9], camera.get$shutterOpen(), ray, Nl, pdf);
          if (0 >= pdf.length)
            return H.ioore(pdf, 0);
          if (J.$eq(pdf[0], 0) || alpha.isBlack$0())
            continue;
          t7 = ray.direction;
          t8 = J.getInterceptor$x(t7);
          t7 = J.$mul$ns(alpha, J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(Nl.x, t8.get$x(t7)), J.$mul$ns(Nl.y, t8.get$y(t7))), J.$mul$ns(Nl.z, t8.get$z(t7)))));
          if (0 >= pdf.length)
            return H.ioore(pdf, 0);
          alpha = J.$div$n(t7, J.$mul$ns(pdf[0], lightPdf[0]));
          isect = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
          isect.primitive = null;
          isect.shapeId = 0;
          isect.primitiveId = 0;
          isect.rayEpsilon = 0;
          t7 = scene.aggregate;
          while (true) {
            hit = t7.intersect$2(ray, isect);
            t8 = $.get$Stats_nonShadowRays();
            t8.count = J.$add$ns(t8.count, 1);
            $.Stats_nonShadowRays = t8;
            if (!(hit && !alpha.isBlack$0()))
              break;
            t8 = ray.origin;
            t9 = J.getInterceptor$x(t8);
            t10 = t9.get$x(t8);
            t11 = t9.get$y(t8);
            t8 = t9.get$z(t8);
            t9 = ray.direction;
            t12 = J.getInterceptor$x(t9);
            t13 = t12.get$x(t9);
            t14 = t12.get$y(t9);
            t9 = t12.get$z(t9);
            t12 = ray.minDistance;
            t15 = ray.maxDistance;
            t16 = ray.time;
            t17 = ray.depth;
            t8 = new G.Point(t10, t11, t8);
            t9 = new G.Vector(t13, t14, t9);
            alpha = J.$mul$ns(alpha, t2.transmittance$5(scene, renderer, new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t8, t9, t12, t15, t16, t17), null, rng));
            wo = J.$negate$n(ray.direction);
            bsdf = isect.getBSDF$1(ray);
            t17 = J.getInterceptor$ns(alpha);
            contrib = J.$div$n(t17.$mul(alpha, bsdf.rho2$2(wo, rng)), 3.141592653589793);
            t16 = this.virtualLights;
            if (s >= t16.length)
              return H.ioore(t16, s);
            t16 = t16[s];
            t15 = isect.dg;
            J.add$1$ax(t16, new U._VirtualLight(t15.p, t15.nn, contrib, isect.rayEpsilon));
            wi = new G.Vector(0, 0, 0);
            t15 = Array(2);
            t15.$builtinTypeInfo = [J.JSDouble];
            bsdfSample = new G.BSDFSample(t15, 0);
            t15[0] = rng.randomFloat$0();
            t15[1] = (rng.randomUInt$0() & 16777215) / 16777216;
            bsdfSample.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
            fr = bsdf.sample_f$4(wo, wi, bsdfSample, pdf);
            if (fr.isBlack$0() || false)
              break;
            t8 = bsdf.dgShading.nn;
            t9 = J.getInterceptor$x(t8);
            t8 = fr.$mul(0, J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t9.get$x(t8)), J.$mul$ns(wi.y, t9.get$y(t8))), J.$mul$ns(wi.z, t9.get$z(t8)))));
            if (0 >= pdf.length)
              return H.ioore(pdf, 0);
            contribScale = t8.$div(0, pdf[0]);
            rrProb = P.min(1, contribScale.get$y(contribScale));
            if ((rng.randomUInt$0() & 16777215) / 16777216 > rrProb)
              break;
            alpha = t17.$mul(alpha, contribScale.$div(0, rrProb));
            t8 = isect.dg.p;
            t9 = isect.rayEpsilon;
            ray = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(t8.get$x(t8), t8.get$y(t8), t8.get$z(t8)), new G.Vector(wi.x, wi.y, wi.z), t9, 1 / 0, ray.time, ray.depth + 1);
          }
        }
        ++s;
      }
    },
    IGIIntegrator$6: function(nl, ns, rrt, maxd, gl, ng) {
      var t1, i, t2;
      this.nLightPaths = G.RoundUpPow2(nl);
      t1 = G.RoundUpPow2(ns);
      this.nLightSets = t1;
      this.rrThreshold = rrt;
      this.maxSpecularDepth = maxd;
      this.virtualLights = Array(t1);
      this.gLimit = gl;
      this.nGatherSamples = ng;
      i = 0;
      while (true) {
        t1 = this.nLightSets;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        t1 = this.virtualLights;
        t2 = [];
        t2.$builtinTypeInfo = [U._VirtualLight];
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
        ++i;
      }
    },
    static: {IGIIntegrator$: function(nl, ns, rrt, maxd, gl, ng) {
        var t1 = new U.IGIIntegrator(null, null, null, null, null, null, null, null, null, null, null);
        t1.IGIIntegrator$6(nl, ns, rrt, maxd, gl, ng);
        return t1;
      }, IGIIntegrator_Create: [function(params) {
        return U.IGIIntegrator$(params.findOneInt$2("nlights", 64), params.findOneInt$2("nsets", 4), params.findOneFloat$2("rrthreshold", 0.0001), params.findOneInt$2("maxdepth", 5), params.findOneFloat$2("glimit", 10), params.findOneInt$2("gathersamples", 16));
      }, "call$1", "IGIIntegrator_Create$closure", 2, 0, 64]}
  },
  _VirtualLight: {
    "^": "Object;p>,n<,pathContrib<,rayEpsilon",
    p$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.p.call$4(arg0, arg1, arg2, arg3);
    }
  },
  IrradianceCacheIntegrator: {
    "^": "SurfaceIntegrator;minSamplePixelSpacing,maxSamplePixelSpacing,minWeight,cosMaxSampleAngleDifference,nSamples<,maxSpecularDepth,maxIndirectDepth,lightSampleOffsets,bsdfSampleOffsets,octree",
    Li$6: function(scene, renderer, ray, isect, sample, rng) {
      var $L, bsdf, wo, t1, p, n, t2, ng, pixelSpacing;
      $L = G.Spectrum_Spectrum(0);
      bsdf = isect.getBSDF$1(ray);
      wo = J.$negate$n(ray.get$direction());
      t1 = bsdf.dgShading;
      p = t1.p;
      n = t1.nn;
      $L = $L.$add(0, isect.Le$1(wo)).$add(0, G.Integrator_UniformSampleAllLights(scene, renderer, p, n, wo, isect.rayEpsilon, ray.time, bsdf, sample, rng, this.lightSampleOffsets, this.bsdfSampleOffsets));
      t1 = ray.depth;
      t2 = this.maxSpecularDepth;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 + 1 < t2)
        $L = $L.$add(0, G.Integrator_SpecularReflect(ray, bsdf, rng, isect, renderer, scene, sample)).$add(0, G.Integrator_SpecularTransmit(ray, bsdf, rng, isect, renderer, scene, sample));
      ng = G.Normal_FaceForward(isect.dg.nn, wo);
      t1 = isect.dg;
      t1 = G.Vector_Cross(t1.dpdx, t1.dpdy).lengthSquared$0();
      if (typeof t1 !== "number")
        H.throwExpression(P.ArgumentError$(t1));
      t1 = Math.sqrt(t1);
      pixelSpacing = Math.sqrt(t1);
      return $L.$add(0, this.indirectLo$10(p, ng, pixelSpacing, wo, isect.rayEpsilon, bsdf, 13, rng, scene, renderer)).$add(0, this.indirectLo$10(p, J.$negate$n(ng), pixelSpacing, wo, isect.rayEpsilon, bsdf, 14, rng, scene, renderer));
    },
    requestSamples$3: function(sampler, sample, scene) {
      var t1, nLights, t2, i, nSamples, t3, t4;
      t1 = scene.lights;
      nLights = t1.length;
      this.lightSampleOffsets = H.setRuntimeTypeInfo(Array(nLights), [G.LightSampleOffsets]);
      this.bsdfSampleOffsets = H.setRuntimeTypeInfo(Array(nLights), [G.BSDFSampleOffsets]);
      for (t2 = sampler != null, i = 0; i < nLights; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        nSamples = t1[i].get$nSamples();
        if (t2)
          nSamples = sampler.roundSize$1(nSamples);
        t3 = this.lightSampleOffsets;
        t4 = new G.LightSampleOffsets(nSamples, null, null);
        sample.n1D.push(nSamples);
        t4.componentOffset = sample.n1D.length - 1;
        sample.n2D.push(nSamples);
        t4.posOffset = sample.n2D.length - 1;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3[i] = t4;
        t3 = this.bsdfSampleOffsets;
        t4 = new G.BSDFSampleOffsets(nSamples, null, null);
        sample.n1D.push(nSamples);
        t4.componentOffset = sample.n1D.length - 1;
        sample.n2D.push(nSamples);
        t4.dirOffset = sample.n2D.length - 1;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3[i] = t4;
      }
    },
    preprocess$3: function(scene, camera, renderer) {
      var wb, delta, extent, sampler;
      wb = G.BBox$from(scene.worldBound);
      delta = wb.pMax.$sub(0, wb.pMin).$mul(0, 0.01);
      wb.pMin = wb.pMin.$sub(0, delta);
      wb.pMax = wb.pMax.$add(0, delta);
      this.octree = new G.Octree(16, G.BBox$from(wb), G._OctreeNode$());
      this.minWeight = J.$mul$ns(this.minWeight, 1.5);
      extent = [0, 0, 0, 0];
      camera.get$film().getSampleExtent$1(extent);
      sampler = U.HaltonSampler$(extent[0], extent[1], extent[2], extent[3], 1, camera.get$shutterOpen(), camera.shutterClose);
      new U.IrradiancePrimeTask(scene, camera, renderer, sampler, G.Sample$(sampler, this, null, scene), this).run$0();
      this.minWeight = J.$div$n(this.minWeight, 1.5);
    },
    indirectLo$10: function(p, ng, pixelSpacing, wo, rayEpsilon, bsdf, flags, rng, scene, renderer) {
      var $E, wi, scramble, wAvg, LiSum, u, t1, minHitDistance, i, t2, t3, r, $L, maxDist, contribExtent, sampleExtent, t4;
      if (bsdf.numComponents$1(flags) === 0)
        return G.Spectrum_Spectrum(0);
      $E = G.Spectrum_Spectrum(0);
      wi = new G.Vector(0, 0, 0);
      if (!this.interpolateE$5(scene, p, ng, $E, wi)) {
        scramble = [rng.randomUInt$0(), rng.randomUInt$0()];
        wAvg = new G.Vector(0, 0, 0);
        LiSum = G.Spectrum_Spectrum(0);
        u = [0, 0];
        t1 = J.getInterceptor$x(ng);
        minHitDistance = 1 / 0;
        i = 0;
        while (true) {
          t2 = this.nSamples;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          u[0] = G.VanDerCorput(i, scramble[0]);
          t2 = G.Sobol2(i, scramble[1]);
          u[1] = t2;
          t2 = bsdf.localToWorld$1(G.CosineSampleHemisphere(u[0], t2));
          t3 = new G.Point(p.get$x(p), p.get$y(p), p.get$z(p));
          t2 = new G.Vector(t2.x, t2.y, t2.z);
          r = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t3, t2, rayEpsilon, 1 / 0, 0, 0);
          r.direction = J.$lt$n(J.$add$ns(J.$add$ns(J.$mul$ns(t2.x, t1.get$x(ng)), J.$mul$ns(t2.y, t1.get$y(ng))), J.$mul$ns(t2.z, t1.get$z(ng))), 0) ? new G.Vector(J.$negate$n(t2.x), J.$negate$n(t2.y), J.$negate$n(t2.z)) : t2;
          $L = this.pathL$4(r, scene, renderer, rng);
          LiSum = LiSum.$add(0, $L);
          t2 = J.$mul$ns(r.direction, $L.get$y($L));
          t3 = J.getInterceptor$x(t2);
          wAvg = new G.Vector(J.$add$ns(wAvg.x, t3.get$x(t2)), J.$add$ns(wAvg.y, t3.get$y(t2)), J.$add$ns(wAvg.z, t3.get$z(t2)));
          minHitDistance = P.min(minHitDistance, r.maxDistance);
          ++i;
        }
        $E = LiSum.$mul(0, 3.141592653589793 / t2);
        maxDist = J.$mul$ns(this.maxSamplePixelSpacing, pixelSpacing);
        contribExtent = C.JSNumber_methods.clamp$2(minHitDistance / 2, J.$mul$ns(this.minSamplePixelSpacing, pixelSpacing), maxDist);
        sampleExtent = G.BBox$(p, null);
        sampleExtent.expand$1(0, contribExtent);
        t1 = this.octree;
        t2 = t1.root;
        t3 = t1.bound;
        t4 = sampleExtent.pMin;
        t1._core0$_add$5(t2, t3, new U.IrradianceSample($E, ng, p, wAvg, contribExtent), sampleExtent, sampleExtent.pMax.$sub(0, t4).lengthSquared$0());
        wi = wAvg;
      }
      if (J.$eq(wi.lengthSquared$0(), 0))
        return G.Spectrum_Spectrum(0);
      return bsdf.f$3(wo, wi.$div(0, wi.length$0(0)), flags).$mul(0, $E);
    },
    interpolateE$5: function(scene, p, n, $E, wi) {
      var t1, t2, proc;
      if (this.octree == null)
        return false;
      t1 = this.minWeight;
      t2 = this.cosMaxSampleAngleDifference;
      proc = new U.IrradProcess(p, n, t1, t2, null, null, null, null);
      proc.IrradProcess$4(p, n, t1, t2);
      this.octree.lookup$2(p, proc);
      t1 = proc.sumWt;
      t2 = proc.minWeight;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = t1 >= t2;
      if (t2)
        ;
      if (!t2)
        return false;
      $E.copy$1(proc.E.$div(0, t1));
      wi.copy$1(proc.wAvg);
      return true;
    },
    pathL$4: function(r, scene, renderer, rng) {
      var $L, pathThroughput, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, ray, specularBounce, pathLength, isect, hit, area, bsdf, p, n, wo, pathLength0, wi, pdf, flags, f, rrProb;
      $L = G.Spectrum_Spectrum(0);
      pathThroughput = G.Spectrum_Spectrum(1);
      t1 = r.origin;
      t2 = J.getInterceptor$x(t1);
      t3 = t2.get$x(t1);
      t4 = t2.get$y(t1);
      t1 = t2.get$z(t1);
      t2 = r.direction;
      t5 = J.getInterceptor$x(t2);
      t6 = t5.get$x(t2);
      t7 = t5.get$y(t2);
      t2 = t5.get$z(t2);
      t5 = r.minDistance;
      t8 = r.maxDistance;
      t9 = r.time;
      t10 = r.depth;
      t1 = new G.Point(t3, t4, t1);
      t2 = new G.Vector(t6, t7, t2);
      ray = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t1, t2, t5, t8, t9, t10);
      for (t1 = this.maxIndirectDepth, t2 = renderer.volumeIntegrator, t3 = scene.aggregate, specularBounce = false, pathLength = 0; true; pathLength = pathLength0) {
        isect = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
        isect.primitive = null;
        isect.shapeId = 0;
        isect.primitiveId = 0;
        isect.rayEpsilon = 0;
        hit = t3.intersect$2(ray, isect);
        t4 = $.get$Stats_nonShadowRays();
        t4.count = J.$add$ns(t4.count, 1);
        $.Stats_nonShadowRays = t4;
        if (!hit)
          break;
        if (pathLength === 0)
          r.maxDistance = ray.maxDistance;
        pathThroughput = pathThroughput.$mul(0, t2.transmittance$5(scene, renderer, ray, null, rng));
        if (specularBounce) {
          t4 = J.$negate$n(ray.direction);
          area = isect.primitive.areaLight;
          if (area != null) {
            t5 = isect.dg;
            t4 = area.L$3(t5.p, t5.nn, t4);
          } else
            t4 = G.Spectrum_Spectrum(0);
          $L = $L.$add(0, pathThroughput.$mul(0, t4));
        }
        bsdf = isect.getBSDF$1(ray);
        t4 = bsdf.dgShading;
        p = t4.p;
        n = t4.nn;
        wo = J.$negate$n(ray.direction);
        $L = $L.$add(0, pathThroughput.$mul(0, G.Integrator_UniformSampleOneLight(scene, renderer, p, n, wo, isect.rayEpsilon, ray.time, bsdf, null, rng, -1, null, null)));
        pathLength0 = pathLength + 1;
        if (pathLength0 === t1)
          break;
        wi = new G.Vector(0, 0, 0);
        pdf = [0];
        flags = [0];
        t4 = Array(2);
        t4.$builtinTypeInfo = [J.JSDouble];
        t5 = new G.BSDFSample(t4, 0);
        t4[0] = rng.randomFloat$0();
        t4[1] = (rng.randomUInt$0() & 16777215) / 16777216;
        t5.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
        f = bsdf.sample_f$6(wo, wi, t5, pdf, 31, flags);
        if (!f.isBlack$0()) {
          if (0 >= pdf.length)
            return H.ioore(pdf, 0);
          t4 = J.$eq(pdf[0], 0);
        } else
          t4 = true;
        if (t4)
          break;
        specularBounce = J.$and$n(flags[0], 16) !== 0;
        t4 = J.getInterceptor$x(n);
        t4 = f.$mul(0, J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t4.get$x(n)), J.$mul$ns(wi.y, t4.get$y(n))), J.$mul$ns(wi.z, t4.get$z(n)))));
        if (0 >= pdf.length)
          return H.ioore(pdf, 0);
        pathThroughput = pathThroughput.$mul(0, t4.$div(0, pdf[0]));
        t4 = isect.rayEpsilon;
        ray = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(p.get$x(p), p.get$y(p), p.get$z(p)), new G.Vector(wi.x, wi.y, wi.z), t4, 1 / 0, ray.time, ray.depth + 1);
        if (pathLength > 2) {
          rrProb = P.min(1, pathThroughput.get$y(pathThroughput));
          if ((rng.randomUInt$0() & 16777215) / 16777216 > rrProb)
            break;
          pathThroughput = pathThroughput.$div(0, rrProb);
        }
      }
      return $L;
    },
    static: {IrradianceCacheIntegrator_Create: [function(params) {
        var minWeight, minSpacing, maxSpacing, maxAngle, maxSpecularDepth, maxIndirectDepth, t1;
        minWeight = params.findOneFloat$2("minweight", 0.5);
        minSpacing = params.findOneFloat$2("minpixelspacing", 2.5);
        maxSpacing = params.findOneFloat$2("maxpixelspacing", 15);
        maxAngle = params.findOneFloat$2("maxangledifference", 10);
        maxSpecularDepth = params.findOneInt$2("maxspeculardepth", 5);
        maxIndirectDepth = params.findOneInt$2("maxindirectdepth", 3);
        t1 = new U.IrradianceCacheIntegrator(minSpacing, maxSpacing, minWeight, null, params.findOneInt$2("nsamples", 4096), maxSpecularDepth, maxIndirectDepth, null, null, null);
        if (typeof maxAngle !== "number")
          return H.iae(maxAngle);
        t1.cosMaxSampleAngleDifference = Math.cos(57.29577951308232 * maxAngle);
        return t1;
      }, "call$1", "IrradianceCacheIntegrator_Create$closure", 2, 0, 65]}
  },
  IrradianceSample: {
    "^": "Object;E,n<,p>,wAvg,maxDist<",
    p$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.p.call$4(arg0, arg1, arg2, arg3);
    }
  },
  IrradiancePrimeTask: {
    "^": "Object;scene,camera,renderer,sampler,origSample,irradianceCache",
    run$0: function() {
      var rng, samples, t1, t2, t3, t4, t5, t6, t7, sampleCount, i, t8, t9, ray, isect, hit;
      rng = new G.RNG(null, new Uint32Array(624), null);
      rng.mti = 625;
      rng.seed$1(0, 29);
      samples = this.origSample.duplicate$1(1);
      for (t1 = this.sampler, t2 = this.scene, t3 = t2.aggregate, t4 = this.camera, t5 = samples.length, t6 = this.irradianceCache, t7 = this.renderer; sampleCount = t1.getMoreSamples$2(samples, rng), sampleCount > 0;)
        for (i = 0; i < sampleCount; ++i) {
          t8 = new G.Point(0, 0, 0);
          t9 = new G.Vector(0, 0, 0);
          ray = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t8, t9, 0, 1 / 0, 0, 0);
          if (i >= t5)
            return H.ioore(samples, i);
          t4.generateRayDifferential$2(samples[i], ray);
          isect = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
          isect.primitive = null;
          isect.shapeId = 0;
          isect.primitiveId = 0;
          isect.rayEpsilon = 0;
          hit = t3.intersect$2(ray, isect);
          t8 = $.get$Stats_nonShadowRays();
          t8.count = J.$add$ns(t8.count, 1);
          $.Stats_nonShadowRays = t8;
          if (hit)
            t6.Li$6(t2, t7, ray, isect, samples[i], rng);
        }
    }
  },
  IrradProcess: {
    "^": "Object:126;p>,n<,minWeight,cosMaxSampleAngleDifference,sumWt,nFound,E,wAvg",
    call$1: function(sample) {
      var t1, perr, t2, err, wt;
      t1 = this.p;
      perr = J.$div$n(J.length$0$asx(J.$sub$n(J.get$p$x(sample), t1)), sample.get$maxDist());
      t1 = G.Vector_Dot(this.n, sample.get$n());
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = this.cosMaxSampleAngleDifference;
      err = P.max(perr, Math.sqrt((1 - t1) / (1 - t2)));
      if (err < 1) {
        ++this.nFound;
        wt = 1 - err;
        this.E = this.E.$add(0, sample.E.$mul(0, wt));
        this.wAvg = this.wAvg.$add(0, sample.wAvg.$mul(0, wt));
        this.sumWt += wt;
      }
      return true;
    },
    p$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.p.call$4(arg0, arg1, arg2, arg3);
    },
    IrradProcess$4: function(p, n, minWeight, cosMaxSampleAngleDifference) {
      this.nFound = 0;
      this.sumWt = 0;
      this.E = G.Spectrum_Spectrum(0);
      this.wAvg = new G.Vector(0, 0, 0);
    }
  },
  PathIntegrator: {
    "^": "SurfaceIntegrator;maxDepth,lightSampleOffsets,lightNumOffset,bsdfSampleOffsets,pathSampleOffsets",
    Li$6: function(scene, renderer, r, isect, sample, rng) {
      var pathThroughput, $L, ray, localIsect, wi, pdf, flags, t1, t2, t3, isectP, specularBounce, bounces, bsdf, t4, p, n, wo, t5, t6, outgoingBSDFSample, f, continueProbability, hit, i;
      pathThroughput = G.Spectrum_Spectrum(1);
      $L = G.Spectrum_Spectrum(0);
      ray = G.RayDifferential$fromRay(r);
      localIsect = G.Intersection$();
      wi = new G.Vector(0, 0, 0);
      pdf = [0];
      flags = [0];
      for (t1 = renderer.volumeIntegrator, t2 = scene.aggregate, t3 = this.pathSampleOffsets, isectP = isect, specularBounce = false, bounces = 0; true; ++bounces, isectP = localIsect) {
        if (bounces === 0 || specularBounce)
          $L = $L.$add(0, pathThroughput.$mul(0, isectP.Le$1(J.$negate$n(ray.direction))));
        bsdf = isectP.getBSDF$1(ray);
        t4 = bsdf.dgShading;
        p = t4.p;
        n = t4.nn;
        wo = J.$negate$n(ray.direction);
        t4 = bounces < 3;
        t5 = ray.time;
        t6 = isectP.rayEpsilon;
        $L = t4 ? $L.$add(0, pathThroughput.$mul(0, G.Integrator_UniformSampleOneLight(scene, renderer, p, n, wo, t6, t5, bsdf, sample, rng, this.lightNumOffset[bounces], this.lightSampleOffsets[bounces], this.bsdfSampleOffsets[bounces]))) : $L.$add(0, pathThroughput.$mul(0, G.Integrator_UniformSampleOneLight(scene, renderer, p, n, wo, t6, t5, bsdf, sample, rng, -1, null, null)));
        if (t4)
          outgoingBSDFSample = G.BSDFSample$sample(sample, t3[bounces], 0);
        else {
          t4 = Array(2);
          t4.$builtinTypeInfo = [J.JSDouble];
          outgoingBSDFSample = new G.BSDFSample(t4, 0);
          t4[0] = rng.randomFloat$0();
          t4[1] = (rng.randomUInt$0() & 16777215) / 16777216;
          outgoingBSDFSample.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
        }
        f = bsdf.sample_f$6(wo, wi, outgoingBSDFSample, pdf, 31, flags);
        if (!f.isBlack$0()) {
          if (0 >= pdf.length)
            return H.ioore(pdf, 0);
          t4 = J.$eq(pdf[0], 0);
        } else
          t4 = true;
        if (t4)
          break;
        specularBounce = J.$and$n(flags[0], 16) !== 0;
        t4 = J.getInterceptor$x(n);
        t4 = f.$mul(0, J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t4.get$x(n)), J.$mul$ns(wi.y, t4.get$y(n))), J.$mul$ns(wi.z, t4.get$z(n)))));
        if (0 >= pdf.length)
          return H.ioore(pdf, 0);
        pathThroughput = pathThroughput.$mul(0, t4.$div(0, pdf[0]));
        t4 = isectP.rayEpsilon;
        ray = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(p.get$x(p), p.get$y(p), p.get$z(p)), new G.Vector(wi.x, wi.y, wi.z), t4, 1 / 0, ray.time, ray.depth + 1);
        if (bounces > 3) {
          continueProbability = P.min(0.5, pathThroughput.get$y(pathThroughput));
          if (rng.randomFloat$0() > continueProbability)
            break;
          pathThroughput = pathThroughput.$div(0, continueProbability);
        }
        if (bounces === this.maxDepth)
          break;
        hit = t2.intersect$2(ray, localIsect);
        t4 = $.get$Stats_nonShadowRays();
        t4.count = J.$add$ns(t4.count, 1);
        $.Stats_nonShadowRays = t4;
        if (!hit) {
          if (specularBounce)
            for (t1 = scene.lights, i = 0; i < t1.length; ++i)
              $L = $L.$add(0, pathThroughput.$mul(0, t1[i].Le$1(ray)));
          break;
        }
        pathThroughput = pathThroughput.$mul(0, t1.transmittance$5(scene, renderer, ray, null, rng));
      }
      return $L;
    },
    requestSamples$3: function(sampler, sample, scene) {
      var t1, i, t2, t3, t4;
      for (t1 = this.pathSampleOffsets, i = 0; i < 3; ++i) {
        t2 = this.lightSampleOffsets;
        t3 = new G.LightSampleOffsets(1, null, null);
        sample.n1D.push(1);
        t3.componentOffset = sample.n1D.length - 1;
        sample.n2D.push(1);
        t3.posOffset = sample.n2D.length - 1;
        t2[i] = t3;
        t2 = this.lightNumOffset;
        sample.n1D.push(1);
        t3 = sample.n1D;
        t2[i] = t3.length - 1;
        t2 = this.bsdfSampleOffsets;
        t4 = new G.BSDFSampleOffsets(1, null, null);
        t3.push(1);
        t4.componentOffset = sample.n1D.length - 1;
        sample.n2D.push(1);
        t4.dirOffset = sample.n2D.length - 1;
        t2[i] = t4;
        t2 = new G.BSDFSampleOffsets(1, null, null);
        sample.n1D.push(1);
        t2.componentOffset = sample.n1D.length - 1;
        sample.n2D.push(1);
        t2.dirOffset = sample.n2D.length - 1;
        t1[i] = t2;
      }
    },
    static: {"^": "PathIntegrator_SAMPLE_DEPTH", PathIntegrator_Create: [function(params) {
        var maxDepth, t1;
        maxDepth = params.findOneInt$2("maxdepth", 5);
        t1 = new U.PathIntegrator(null, H.setRuntimeTypeInfo(Array(3), [G.LightSampleOffsets]), H.setRuntimeTypeInfo(Array(3), [J.JSInt]), H.setRuntimeTypeInfo(Array(3), [G.BSDFSampleOffsets]), H.setRuntimeTypeInfo(Array(3), [G.BSDFSampleOffsets]));
        t1.maxDepth = maxDepth;
        return t1;
      }, "call$1", "PathIntegrator_Create$closure", 2, 0, 66]}
  },
  PhotonMapIntegrator: {
    "^": "SurfaceIntegrator;nCausticPhotonsWanted,nIndirectPhotonsWanted,nLookup,maxDistSquared,maxSpecularDepth,maxPhotonDepth,finalGather,gatherSamples,cosGatherAngle,lightSampleOffsets,bsdfSampleOffsets,bsdfGatherSampleOffsets,indirGatherSampleOffsets,nCausticPaths,nIndirectPaths,causticMap,indirectMap,radianceMap",
    Li$6: function(scene, renderer, ray, isect, sample, rng) {
      var $L, wo, bsdf, t1, p, n, lookupBuf, t2, proc, searchDist2, photonDirs, t3, i, t4, Li, t5, t6, conePdf, t7, wi, pdf, fr, bounceRay, gatherIsect, hit, Lindir, nGather, t8, t9, photonPdf, j, wt, gatherSample, photonNum, vx, vy, bsdfPdf;
      $L = G.Spectrum_Spectrum(0);
      wo = J.$negate$n(ray.get$direction());
      $L = $L.$add(0, isect.Le$1(wo));
      bsdf = isect.getBSDF$1(ray);
      t1 = bsdf.dgShading;
      p = t1.p;
      n = t1.nn;
      $L = $L.$add(0, G.Integrator_UniformSampleAllLights(scene, renderer, p, n, wo, isect.rayEpsilon, ray.time, bsdf, sample, rng, this.lightSampleOffsets, this.bsdfSampleOffsets));
      t1 = this.nLookup;
      if (typeof t1 !== "number")
        return H.iae(t1);
      lookupBuf = H.setRuntimeTypeInfo(Array(t1), [U.ClosePhoton]);
      t2 = this.maxDistSquared;
      $L = $L.$add(0, U._LPhoton(this.causticMap, this.nCausticPaths, t1, lookupBuf, bsdf, rng, isect, wo, t2));
      if (this.finalGather === true && this.indirectMap != null) {
        if (bsdf.numComponents$1(15) > 0) {
          proc = new U.PhotonProcess(H.setRuntimeTypeInfo(Array(50), [U.ClosePhoton]), 50, 0);
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          searchDist2 = t2[0];
          for (; proc.nFound < 50;) {
            proc.nFound = 0;
            this.indirectMap._core0$_lookup$4(0, p, proc, [searchDist2]);
            searchDist2 = J.$mul$ns(searchDist2, 2);
          }
          photonDirs = H.setRuntimeTypeInfo(Array(50), [G.Vector]);
          for (t1 = proc.photons, t2 = t1.length, t3 = photonDirs.length, i = 0; i < 50; ++i) {
            if (i >= t2)
              return H.ioore(t1, i);
            t4 = t1[i].get$photon().get$wi();
            if (i >= t3)
              return H.ioore(photonDirs, i);
            photonDirs[i] = t4;
          }
          Li = G.Spectrum_Spectrum(0);
          t1 = scene.aggregate;
          t2 = J.getInterceptor$x(n);
          t4 = this.cosGatherAngle;
          t5 = 0.999 * t4;
          t6 = renderer.volumeIntegrator;
          conePdf = 1 / (6.283185307179586 * (1 - t4));
          i = 0;
          while (true) {
            t7 = this.gatherSamples;
            if (typeof t7 !== "number")
              return H.iae(t7);
            if (!(i < t7))
              break;
            c$0: {
              wi = new G.Vector(0, 0, 0);
              pdf = [0];
              fr = bsdf.sample_f$5(wo, wi, G.BSDFSample$sample(sample, this.bsdfGatherSampleOffsets, i), pdf, 15);
              if (!fr.isBlack$0()) {
                if (0 >= pdf.length)
                  return H.ioore(pdf, 0);
                t7 = J.$eq(pdf[0], 0);
              } else
                t7 = true;
              if (t7)
                break c$0;
              t7 = isect.rayEpsilon;
              bounceRay = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(p.get$x(p), p.get$y(p), p.get$z(p)), new G.Vector(wi.x, wi.y, wi.z), t7, 1 / 0, ray.time, ray.depth + 1);
              gatherIsect = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
              gatherIsect.primitive = null;
              gatherIsect.shapeId = 0;
              gatherIsect.primitiveId = 0;
              gatherIsect.rayEpsilon = 0;
              hit = t1.intersect$2(bounceRay, gatherIsect);
              t7 = $.get$Stats_nonShadowRays();
              t7.count = J.$add$ns(t7.count, 1);
              $.Stats_nonShadowRays = t7;
              if (hit) {
                Lindir = G.Spectrum_Spectrum(0);
                nGather = gatherIsect.dg.nn;
                t7 = J.$negate$n(bounceRay.direction);
                t8 = J.getInterceptor$x(nGather);
                t9 = J.getInterceptor$x(t7);
                if (J.$lt$n(J.$add$ns(J.$add$ns(J.$mul$ns(t8.get$x(nGather), t9.get$x(t7)), J.$mul$ns(t8.get$y(nGather), t9.get$y(t7))), J.$mul$ns(t8.get$z(nGather), t9.get$z(t7))), 0))
                  nGather = new G.Normal(J.$negate$n(t8.get$x(nGather)), J.$negate$n(t8.get$y(nGather)), J.$negate$n(t8.get$z(nGather)));
                proc = new U.RadiancePhotonProcess(nGather, null);
                this.radianceMap._core0$_lookup$4(0, gatherIsect.dg.p, proc, [1 / 0]);
                t7 = proc.photon;
                if (t7 != null)
                  Lindir = t7.get$Lo();
                Lindir = Lindir.$mul(0, t6.transmittance$5(scene, renderer, bounceRay, null, rng));
                for (photonPdf = 0, j = 0; j < 50; ++j) {
                  if (j >= t3)
                    return H.ioore(photonDirs, j);
                  t7 = photonDirs[j];
                  t8 = J.getInterceptor$x(t7);
                  if (J.$gt$n(J.$add$ns(J.$add$ns(J.$mul$ns(t8.get$x(t7), wi.x), J.$mul$ns(t8.get$y(t7), wi.y)), J.$mul$ns(t8.get$z(t7), wi.z)), t5))
                    photonPdf += conePdf;
                }
                t7 = this.gatherSamples;
                if (0 >= pdf.length)
                  return H.ioore(pdf, 0);
                wt = G.PowerHeuristic(t7, pdf[0], t7, photonPdf / 50);
                t7 = fr.$mul(0, Lindir);
                t8 = J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t2.get$x(n)), J.$mul$ns(wi.y, t2.get$y(n))), J.$mul$ns(wi.z, t2.get$z(n))));
                if (typeof wt !== "number")
                  return H.iae(wt);
                if (0 >= pdf.length)
                  return H.ioore(pdf, 0);
                t9 = pdf[0];
                if (typeof t9 !== "number")
                  return H.iae(t9);
                Li = Li.$add(0, t7.$mul(0, t8 * wt / t9));
              }
            }
            ++i;
          }
          $L = $L.$add(0, Li.$div(0, t7));
          Li = G.Spectrum_Spectrum(0);
          i = 0;
          while (true) {
            t7 = this.gatherSamples;
            if (typeof t7 !== "number")
              return H.iae(t7);
            if (!(i < t7))
              break;
            c$0: {
              gatherSample = G.BSDFSample$sample(sample, this.indirGatherSampleOffsets, i);
              photonNum = P.min(49, J.floor$0$n(J.$mul$ns(gatherSample.uComponent, 50)));
              vx = new G.Vector(0, 0, 0);
              vy = new G.Vector(0, 0, 0);
              if (photonNum >>> 0 !== photonNum || photonNum >= t3)
                return H.ioore(photonDirs, photonNum);
              G.Vector_CoordinateSystem(photonDirs[photonNum], vx, vy);
              t7 = gatherSample.uDir;
              wi = G.UniformSampleCone2(t7[0], t7[1], t4, vx, vy, photonDirs[photonNum]);
              fr = bsdf.f$2(wo, wi);
              if (fr.isBlack$0())
                break c$0;
              t7 = isect.rayEpsilon;
              bounceRay = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(p.get$x(p), p.get$y(p), p.get$z(p)), new G.Vector(wi.x, wi.y, wi.z), t7, 1 / 0, ray.time, ray.depth + 1);
              gatherIsect = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
              gatherIsect.primitive = null;
              gatherIsect.shapeId = 0;
              gatherIsect.primitiveId = 0;
              gatherIsect.rayEpsilon = 0;
              hit = t1.intersect$2(bounceRay, gatherIsect);
              t7 = $.get$Stats_nonShadowRays();
              t7.count = J.$add$ns(t7.count, 1);
              $.Stats_nonShadowRays = t7;
              if (hit) {
                Lindir = G.Spectrum_Spectrum(0);
                nGather = gatherIsect.dg.nn;
                t7 = J.$negate$n(bounceRay.direction);
                t8 = J.getInterceptor$x(nGather);
                t9 = J.getInterceptor$x(t7);
                if (J.$lt$n(J.$add$ns(J.$add$ns(J.$mul$ns(t8.get$x(nGather), t9.get$x(t7)), J.$mul$ns(t8.get$y(nGather), t9.get$y(t7))), J.$mul$ns(t8.get$z(nGather), t9.get$z(t7))), 0))
                  nGather = new G.Normal(J.$negate$n(t8.get$x(nGather)), J.$negate$n(t8.get$y(nGather)), J.$negate$n(t8.get$z(nGather)));
                proc = new U.RadiancePhotonProcess(nGather, null);
                this.radianceMap._core0$_lookup$4(0, gatherIsect.dg.p, proc, [1 / 0]);
                t7 = proc.photon;
                if (t7 != null)
                  Lindir = t7.get$Lo();
                Lindir = Lindir.$mul(0, t6.transmittance$5(scene, renderer, bounceRay, null, rng));
                for (photonPdf = 0, j = 0; j < 50; ++j) {
                  if (j >= t3)
                    return H.ioore(photonDirs, j);
                  t7 = photonDirs[j];
                  t8 = J.getInterceptor$x(t7);
                  if (J.$gt$n(J.$add$ns(J.$add$ns(J.$mul$ns(t8.get$x(t7), wi.x), J.$mul$ns(t8.get$y(t7), wi.y)), J.$mul$ns(t8.get$z(t7), wi.z)), t5))
                    photonPdf += conePdf;
                }
                photonPdf /= 50;
                bsdfPdf = bsdf.pdf$2(wo, wi);
                t7 = this.gatherSamples;
                wt = G.PowerHeuristic(t7, photonPdf, t7, bsdfPdf);
                Li = Li.$add(0, fr.$mul(0, Lindir).$mul(0, J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t2.get$x(n)), J.$mul$ns(wi.y, t2.get$y(n))), J.$mul$ns(wi.z, t2.get$z(n))))).$mul(0, wt).$div(0, photonPdf));
              }
            }
            ++i;
          }
          $L = $L.$add(0, Li.$div(0, t7));
        }
      } else
        $L = $L.$add(0, U._LPhoton(this.indirectMap, this.nIndirectPaths, t1, lookupBuf, bsdf, rng, isect, wo, t2));
      t1 = ray.depth;
      t2 = this.maxSpecularDepth;
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 + 1 < t2 ? $L.$add(0, G.Integrator_SpecularReflect(ray, bsdf, rng, isect, renderer, scene, sample)).$add(0, G.Integrator_SpecularTransmit(ray, bsdf, rng, isect, renderer, scene, sample)) : $L;
    },
    requestSamples$3: function(sampler, sample, scene) {
      var t1, nLights, t2, i, nSamples, t3, t4;
      t1 = scene.lights;
      nLights = t1.length;
      this.lightSampleOffsets = H.setRuntimeTypeInfo(Array(nLights), [G.LightSampleOffsets]);
      this.bsdfSampleOffsets = H.setRuntimeTypeInfo(Array(nLights), [G.BSDFSampleOffsets]);
      for (t2 = sampler != null, i = 0; i < nLights; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        nSamples = t1[i].get$nSamples();
        if (t2)
          nSamples = sampler.roundSize$1(nSamples);
        t3 = this.lightSampleOffsets;
        t4 = new G.LightSampleOffsets(nSamples, null, null);
        sample.n1D.push(nSamples);
        t4.componentOffset = sample.n1D.length - 1;
        sample.n2D.push(nSamples);
        t4.posOffset = sample.n2D.length - 1;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3[i] = t4;
        t3 = this.bsdfSampleOffsets;
        t4 = new G.BSDFSampleOffsets(nSamples, null, null);
        sample.n1D.push(nSamples);
        t4.componentOffset = sample.n1D.length - 1;
        sample.n2D.push(nSamples);
        t4.dirOffset = sample.n2D.length - 1;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t3[i] = t4;
      }
      if (this.finalGather === true) {
        t1 = P.max(1, J.$tdiv$n(this.gatherSamples, 2));
        this.gatherSamples = t1;
        if (t2) {
          t1 = sampler.roundSize$1(t1);
          this.gatherSamples = t1;
        }
        this.bsdfGatherSampleOffsets = G.BSDFSampleOffsets$(t1, sample);
        this.indirGatherSampleOffsets = G.BSDFSampleOffsets$(this.gatherSamples, sample);
      }
    },
    preprocess$3: function(scene, camera, renderer) {
      var nDirectPaths, causticPhotons, directPhotons, indirectPhotons, radiancePhotons, rpReflectances, rpTransmittances, lightDistribution, t1, directMap, t2, t3;
      if (scene.lights.length === 0)
        return;
      nDirectPaths = [0];
      causticPhotons = [];
      directPhotons = [];
      indirectPhotons = [];
      radiancePhotons = [];
      rpReflectances = [];
      rpTransmittances = [];
      lightDistribution = G.Integrator_ComputeLightSamplingCDF(scene);
      t1 = camera.get$shutterOpen();
      new U.PhotonShootingTask(0, t1, this, [false], nDirectPaths, directPhotons, indirectPhotons, causticPhotons, radiancePhotons, rpReflectances, rpTransmittances, [0], lightDistribution, scene, renderer).run$0();
      directMap = directPhotons.length !== 0 ? G.KdTree$(directPhotons) : null;
      if (causticPhotons.length !== 0)
        this.causticMap = G.KdTree$(causticPhotons);
      if (indirectPhotons.length !== 0)
        this.indirectMap = G.KdTree$(indirectPhotons);
      if (this.finalGather === true && radiancePhotons.length !== 0) {
        t1 = nDirectPaths[0];
        t2 = this.nIndirectPaths;
        t3 = this.indirectMap;
        new U.ComputeRadianceTask(0, 1, radiancePhotons, rpReflectances, rpTransmittances, this.nLookup, this.maxDistSquared, t1, t2, this.nCausticPaths, directMap, t3, this.causticMap).run$0();
        this.radianceMap = G.KdTree$(radiancePhotons);
      }
    },
    static: {PhotonMapIntegrator_Create: [function(params) {
        var nCaustic, nIndirect, nUsed, maxSpecularDepth, maxPhotonDepth, finalGather, gatherSamples, maxDist, gatherAngle, t1;
        nCaustic = params.findOneInt$2("causticphotons", 20000);
        nIndirect = params.findOneInt$2("indirectphotons", 100000);
        nUsed = params.findOneInt$2("nused", 50);
        maxSpecularDepth = params.findOneInt$2("maxspeculardepth", 5);
        maxPhotonDepth = params.findOneInt$2("maxphotondepth", 5);
        finalGather = params.findOneBool$2("finalgather", true);
        gatherSamples = params.findOneInt$2("finalgathersamples", 32);
        maxDist = params.findOneFloat$2("maxdist", 0.1);
        gatherAngle = params.findOneFloat$2("gatherangle", 10);
        t1 = J.$mul$ns(maxDist, maxDist);
        if (typeof gatherAngle !== "number")
          return H.iae(gatherAngle);
        return new U.PhotonMapIntegrator(nCaustic, nIndirect, nUsed, [t1], maxSpecularDepth, maxPhotonDepth, finalGather, gatherSamples, Math.cos(0.017453292519943295 * gatherAngle), null, null, null, null, 0, 0, null, null, null);
      }, "call$1", "PhotonMapIntegrator_Create$closure", 2, 0, 67]}
  },
  Photon: {
    "^": "Object;p>,alpha>,wi<",
    p$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.p.call$4(arg0, arg1, arg2, arg3);
    }
  },
  RadiancePhoton: {
    "^": "Object;p>,n<,Lo<",
    p$4: function($receiver, arg0, arg1, arg2, arg3) {
      return this.p.call$4(arg0, arg1, arg2, arg3);
    }
  },
  PhotonShootingTask: {
    "^": "Object;taskNum,time@,integrator,abortTasks,nDirectPaths,directPhotons,indirectPhotons,causticPhotons,radiancePhotons,rpReflectances,rpTransmittances,nshot,lightDistribution,scene,renderer",
    run$0: function() {
      var t1, rng, localDirectPhotons, localIndirectPhotons, localCausticPhotons, localRadiancePhotons, t2, causticDone, t3, indirectDone, halton, localRpReflectances, localRpTransmittances, u, lightPdf, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, totalPaths, t21, t22, i, lightNum, light, t23, t24, photonRay, pdf, t25, t26, ls, Nl, Le, alpha, photonIsect, specularPath, nIntersections, hit, photonBSDF, wo, photon, depositedPhoton, n, wi, flags, fr, anew, continueProb;
      t1 = this.taskNum;
      rng = new G.RNG(null, new Uint32Array(624), null);
      rng.mti = 625;
      rng.seed$1(0, 31 * t1);
      localDirectPhotons = [];
      localIndirectPhotons = [];
      localCausticPhotons = [];
      localRadiancePhotons = [];
      t1 = this.integrator;
      t2 = t1.nCausticPhotonsWanted;
      causticDone = J.$eq(t2, 0);
      t3 = t1.nIndirectPhotonsWanted;
      indirectDone = J.$eq(t3, 0);
      halton = G.PermutedHalton$(6, rng);
      localRpReflectances = [];
      localRpTransmittances = [];
      u = [0, 0, 0, 0, 0, 0];
      lightPdf = [0];
      for (t4 = this.rpTransmittances, t5 = this.rpReflectances, t6 = this.radiancePhotons, t7 = this.nshot, t8 = this.abortTasks, t9 = this.scene, t10 = this.lightDistribution, t11 = t9.lights, t12 = t9.aggregate, t13 = t1.maxPhotonDepth, t14 = this.renderer, t15 = t14.volumeIntegrator, t16 = t1.finalGather === true, t17 = this.causticPhotons, t18 = this.indirectPhotons, t19 = this.directPhotons, t20 = this.nDirectPaths, totalPaths = 0; true;) {
        for (t21 = !indirectDone, t22 = !causticDone, i = 0; i < 4096; ++i) {
          ++totalPaths;
          halton.sample$2(totalPaths, u);
          lightNum = t10.sampleDiscrete$2(u[0], lightPdf);
          if (lightNum >>> 0 !== lightNum || lightNum >= t11.length)
            return H.ioore(t11, lightNum);
          light = t11[lightNum];
          t23 = new G.Point(0, 0, 0);
          t24 = new G.Vector(0, 0, 0);
          photonRay = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t23, t24, 0, 1 / 0, 0, 0);
          pdf = [0];
          t24 = u[1];
          t23 = u[2];
          t25 = u[3];
          t26 = Array(2);
          t26.$builtinTypeInfo = [J.JSDouble];
          ls = new G.LightSample(t26, 0);
          t26[0] = t24;
          t26[1] = t23;
          ls.uComponent = t25;
          Nl = new G.Normal(0, 0, 0);
          Le = light.sampleL$8(t9, ls, u[4], u[5], this.time, photonRay, Nl, pdf);
          if (J.$eq(pdf[0], 0) || Le.isBlack$0())
            continue;
          t23 = photonRay.direction;
          t24 = J.getInterceptor$x(t23);
          alpha = J.$div$n(J.$mul$ns(Le, J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(Nl.x, t24.get$x(t23)), J.$mul$ns(Nl.y, t24.get$y(t23))), J.$mul$ns(Nl.z, t24.get$z(t23))))), J.$mul$ns(pdf[0], lightPdf[0]));
          if (!alpha.isBlack$0()) {
            photonIsect = new G.Intersection(G.DifferentialGeometry$(), null, null, null, null, null, null);
            photonIsect.primitive = null;
            photonIsect.shapeId = 0;
            photonIsect.primitiveId = 0;
            photonIsect.rayEpsilon = 0;
            for (specularPath = true, nIntersections = 0; hit = t12.intersect$2(photonRay, photonIsect), t23 = $.get$Stats_nonShadowRays(), t23.count = J.$add$ns(t23.count, 1), $.Stats_nonShadowRays = t23, hit;) {
              ++nIntersections;
              alpha = alpha.$mul(0, t15.transmittance$5(t9, t14, photonRay, null, rng));
              photonBSDF = photonIsect.getBSDF$1(photonRay);
              t23 = photonBSDF.numComponents$0();
              t24 = photonBSDF.numComponents$1(19);
              wo = J.$negate$n(photonRay.direction);
              if (t23 > t24) {
                photon = new U.Photon(photonIsect.dg.p, alpha, wo);
                if (specularPath && nIntersections > 1)
                  if (t22) {
                    localCausticPhotons.push(photon);
                    depositedPhoton = true;
                  } else
                    depositedPhoton = false;
                else if (nIntersections === 1 && t21 && t16) {
                  localDirectPhotons.push(photon);
                  depositedPhoton = true;
                } else if (nIntersections > 1 && t21) {
                  localIndirectPhotons.push(photon);
                  depositedPhoton = true;
                } else
                  depositedPhoton = false;
                if (depositedPhoton && t16 && (rng.randomUInt$0() & 16777215) / 16777216 < 0.125) {
                  n = photonIsect.dg.nn;
                  t23 = J.$negate$n(photonRay.direction);
                  t24 = J.getInterceptor$x(n);
                  t25 = J.getInterceptor$x(t23);
                  if (J.$lt$n(J.$add$ns(J.$add$ns(J.$mul$ns(t24.get$x(n), t25.get$x(t23)), J.$mul$ns(t24.get$y(n), t25.get$y(t23))), J.$mul$ns(t24.get$z(n), t25.get$z(t23))), 0))
                    n = new G.Normal(J.$negate$n(t24.get$x(n)), J.$negate$n(t24.get$y(n)), J.$negate$n(t24.get$z(n)));
                  localRadiancePhotons.push(new U.RadiancePhoton(photonIsect.dg.p, n, G.Spectrum_Spectrum(0)));
                  localRpReflectances.push(photonBSDF.rho$2(rng, 29));
                  localRpTransmittances.push(photonBSDF.rho$2(rng, 30));
                }
              }
              if (typeof t13 !== "number")
                return H.iae(t13);
              if (nIntersections >= t13)
                break;
              wi = new G.Vector(0, 0, 0);
              pdf = [0];
              flags = [0];
              t23 = Array(2);
              t23.$builtinTypeInfo = [J.JSDouble];
              t24 = new G.BSDFSample(t23, 0);
              t23[0] = rng.randomFloat$0();
              t23[1] = (rng.randomUInt$0() & 16777215) / 16777216;
              t24.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
              fr = photonBSDF.sample_f$6(wo, wi, t24, pdf, 31, flags);
              if (!fr.isBlack$0()) {
                if (0 >= pdf.length)
                  return H.ioore(pdf, 0);
                t23 = J.$eq(pdf[0], 0);
              } else
                t23 = true;
              if (t23)
                break;
              t23 = alpha.$mul(0, fr);
              t24 = photonBSDF.dgShading.nn;
              t25 = J.getInterceptor$x(t24);
              t24 = t23.$mul(0, J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t25.get$x(t24)), J.$mul$ns(wi.y, t25.get$y(t24))), J.$mul$ns(wi.z, t25.get$z(t24)))));
              if (0 >= pdf.length)
                return H.ioore(pdf, 0);
              anew = t24.$div(0, pdf[0]);
              continueProb = P.min(1, J.$div$n(anew.get$y(anew), alpha.get$y(alpha)));
              if ((rng.randomUInt$0() & 16777215) / 16777216 > continueProb)
                break;
              alpha = anew.$div(0, continueProb);
              specularPath = specularPath && J.$and$n(flags[0], 16) !== 0;
              if (indirectDone && !specularPath)
                break;
              t23 = photonIsect.dg.p;
              t24 = photonIsect.rayEpsilon;
              photonRay = new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), new G.Point(t23.get$x(t23), t23.get$y(t23), t23.get$z(t23)), new G.Vector(wi.x, wi.y, wi.z), t24, 1 / 0, photonRay.time, photonRay.depth + 1);
            }
          }
        }
        if (t8[0] === true)
          return;
        if (J.$gt$n(t7[0], 500000)) {
          t23 = t17.length;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (t23 < t2)
            t23 = t23 === 0 || t23 < 4;
          else
            t23 = false;
          if (!t23) {
            t23 = t18.length;
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (t23 < t3)
              t23 = t23 === 0 || t23 < 4;
            else
              t23 = false;
          } else
            t23 = true;
        } else
          t23 = false;
        if (t23) {
          $.Log.call$2(2, "Unable to store enough photons. Giving up.\n");
          C.JSArray_methods.set$length(t17, 0);
          C.JSArray_methods.set$length(t18, 0);
          C.JSArray_methods.set$length(t6, 0);
          t8[0] = true;
          return;
        }
        t7[0] = J.$add$ns(t7[0], 4096);
        if (t21) {
          t1.nIndirectPaths += 4096;
          for (i = 0; i < localIndirectPhotons.length; ++i)
            t18.push(localIndirectPhotons[i]);
          C.JSArray_methods.set$length(localIndirectPhotons, 0);
          t21 = t18.length;
          if (typeof t3 !== "number")
            return H.iae(t3);
          indirectDone = t21 >= t3 && true;
          t20[0] = J.$add$ns(t20[0], 4096);
          for (i = 0; i < localDirectPhotons.length; ++i)
            t19.push(localDirectPhotons[i]);
          C.JSArray_methods.set$length(localDirectPhotons, 0);
        }
        if (t22) {
          t1.nCausticPaths += 4096;
          for (i = 0; i < localCausticPhotons.length; ++i)
            t17.push(localCausticPhotons[i]);
          C.JSArray_methods.set$length(localCausticPhotons, 0);
          t21 = t17.length;
          if (typeof t2 !== "number")
            return H.iae(t2);
          causticDone = t21 >= t2 && true;
        }
        for (i = 0; i < localRadiancePhotons.length; ++i)
          t6.push(localRadiancePhotons[i]);
        C.JSArray_methods.set$length(localRadiancePhotons, 0);
        for (i = 0; i < localRpReflectances.length; ++i)
          t5.push(localRpReflectances[i]);
        C.JSArray_methods.set$length(localRpReflectances, 0);
        for (i = 0; i < localRpTransmittances.length; ++i)
          t4.push(localRpTransmittances[i]);
        C.JSArray_methods.set$length(localRpTransmittances, 0);
        if (indirectDone && causticDone)
          break;
      }
    }
  },
  ComputeRadianceTask: {
    "^": "Object;taskNum,numTasks,radiancePhotons,rpReflectances,rpTransmittances,nLookup,maxDistSquared,nDirectPaths,nIndirectPaths,nCausticPaths,directMap,indirectMap,causticMap",
    run$0: function() {
      var t1, t2, t3, taskSize, excess, rpStart, t4, rpEnd, lookupBuf, t5, t6, t7, i, rp, rho_r, rho_t, t8, t9, t10, $E, t11;
      t1 = this.radiancePhotons;
      t2 = t1.length;
      t3 = this.numTasks;
      taskSize = C.JSInt_methods.$tdiv(t2, t3);
      excess = C.JSInt_methods.$mod(t2, t3);
      rpStart = P.min(this.taskNum, excess) * (taskSize + 1) + P.max(0, this.taskNum - excess) * taskSize;
      t2 = this.taskNum;
      t4 = t2 < excess ? 1 : 0;
      rpEnd = rpStart + taskSize + t4;
      if (t2 === t3 - 1)
        ;
      t2 = this.nLookup;
      if (typeof t2 !== "number")
        return H.iae(t2);
      lookupBuf = H.setRuntimeTypeInfo(Array(t2), [U.ClosePhoton]);
      for (t3 = this.rpReflectances, t4 = this.rpTransmittances, t5 = this.directMap, t6 = this.nDirectPaths, t7 = this.maxDistSquared, i = rpStart; i < rpEnd; ++i) {
        if (i >>> 0 !== i || i >= t1.length)
          return H.ioore(t1, i);
        rp = t1[i];
        if (i >= t3.length)
          return H.ioore(t3, i);
        rho_r = t3[i];
        if (i >= t4.length)
          return H.ioore(t4, i);
        rho_t = t4[i];
        if (!rho_r.isBlack$0()) {
          t8 = J.getInterceptor$x(rp);
          t9 = t8.get$p(rp);
          t10 = rp.get$n();
          $E = U._EPhoton(t5, t6, t2, lookupBuf, t7, t9, t10).$add(0, U._EPhoton(this.indirectMap, this.nIndirectPaths, t2, lookupBuf, t7, t8.get$p(rp), t10)).$add(0, U._EPhoton(this.causticMap, this.nCausticPaths, t2, lookupBuf, t7, t8.get$p(rp), t10));
          rp.Lo = rp.get$Lo().$add(0, rho_r.$mul(0, $E).$mul(0, 0.3183098861837907));
        }
        if (!rho_t.isBlack$0()) {
          t8 = J.getInterceptor$x(rp);
          t9 = t8.get$p(rp);
          t10 = rp.get$n();
          t11 = J.getInterceptor$n(t10);
          $E = U._EPhoton(t5, t6, t2, lookupBuf, t7, t9, t11.$negate(t10)).$add(0, U._EPhoton(this.indirectMap, this.nIndirectPaths, t2, lookupBuf, t7, t8.get$p(rp), t11.$negate(t10))).$add(0, U._EPhoton(this.causticMap, this.nCausticPaths, t2, lookupBuf, t7, t8.get$p(rp), t11.$negate(t10)));
          rp.Lo = rp.get$Lo().$add(0, rho_t.$mul(0, $E).$mul(0, 0.3183098861837907));
        }
      }
    }
  },
  ClosePhoton: {
    "^": "Object;photon<,distanceSquared<",
    $lt: function(_, p2) {
      var t1, t2;
      t1 = this.distanceSquared;
      t2 = J.getInterceptor(t1);
      return t2.$eq(t1, p2.get$distanceSquared()) ? J.$lt$n(J.get$hashCode$(this.photon), J.get$hashCode$(p2.photon)) : t2.$lt(t1, p2.distanceSquared);
    }
  },
  PhotonProcess: {
    "^": "Object:127;photons,nLookup,nFound",
    call$4: function(p, photon, distSquared, maxDistSquared) {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.nFound;
      t2 = this.nLookup;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.photons;
      if (t1 < t2) {
        t4 = t1 + 1;
        this.nFound = t4;
        t5 = t3.length;
        if (t1 >= t5)
          return H.ioore(t3, t1);
        t3[t1] = new U.ClosePhoton(photon, distSquared);
        if (t4 === t2) {
          G.make_heap(t3, 0, t2);
          if (0 >= t5)
            return H.ioore(t3, 0);
          J.$indexSet$ax(maxDistSquared, 0, t3[0].get$distanceSquared());
        }
      } else {
        t1 = t2 - 1;
        t4 = t2 - 1;
        t5 = t3.length;
        if (t4 >>> 0 !== t4 || t4 >= t5)
          return H.ioore(t3, t4);
        t4 = t3[t4];
        if (0 >= t5)
          return H.ioore(t3, 0);
        t6 = t3[0];
        if (t1 >>> 0 !== t1 || t1 >= t5)
          return H.ioore(t3, t1);
        t3[t1] = t6;
        G._adjust_heap(t3, 0, 0, t2 - 1 - 0, t4);
        t4 = t2 - 1;
        if (t4 >>> 0 !== t4 || t4 >= t5)
          return H.ioore(t3, t4);
        t3[t4] = new U.ClosePhoton(photon, distSquared);
        t4 = t2 - 1;
        if (t4 >>> 0 !== t4 || t4 >= t5)
          return H.ioore(t3, t4);
        G._push_heap(t3, 0, t2 - 0 - 1, 0, t3[t4]);
        J.$indexSet$ax(maxDistSquared, 0, t3[0].get$distanceSquared());
      }
    }
  },
  RadiancePhotonProcess: {
    "^": "Object:128;n<,photon<",
    call$4: function(p, rp, distSquared, maxDistSquared) {
      if (J.$gt$n(G.Vector_Dot(rp.get$n(), this.n), 0)) {
        this.photon = rp;
        J.$indexSet$ax(maxDistSquared, 0, distSquared);
      }
    }
  },
  WhittedIntegrator: {
    "^": "SurfaceIntegrator;maxDepth",
    Li$6: function(scene, renderer, ray, isect, sample, rng) {
      var $L, bsdf, t1, p, n, wo, t2, t3, i, wi, pdf, visibility, t4, t5, t6, t7, Li, f, hit, t8, t9, t10, t11, t12, t13, t14;
      $L = G.Spectrum_Spectrum(0);
      bsdf = isect.getBSDF$1(ray);
      t1 = bsdf.dgShading;
      p = t1.p;
      n = t1.nn;
      wo = J.$negate$n(ray.get$direction());
      $L = $L.$add(0, isect.Le$1(wo));
      for (t1 = scene.lights, t2 = scene.aggregate, t3 = J.getInterceptor$x(n), i = 0; i < t1.length; ++i) {
        wi = new G.Vector(0, 0, 0);
        pdf = [0];
        visibility = new G.VisibilityTester(null);
        t4 = t1[i];
        t5 = isect.rayEpsilon;
        t6 = Array(2);
        t6.$builtinTypeInfo = [J.JSDouble];
        t7 = new G.LightSample(t6, 0);
        t6[0] = rng.randomFloat$0();
        t6[1] = (rng.randomUInt$0() & 16777215) / 16777216;
        t7.uComponent = (rng.randomUInt$0() & 16777215) / 16777216;
        Li = t4.sampleLAtPoint$7(p, t5, t7, ray.time, wi, pdf, visibility);
        if (Li.isBlack$0() || J.$eq(pdf[0], 0))
          continue;
        f = bsdf.f$2(wo, wi);
        if (!f.isBlack$0()) {
          hit = t2.intersectP$1(visibility.r);
          t4 = $.get$Stats_shadowRays();
          t4.count = J.$add$ns(t4.count, 1);
          $.Stats_shadowRays = t4;
          t4 = !hit;
        } else
          t4 = false;
        if (t4) {
          t4 = f.$mul(0, Li).$mul(0, J.abs$0$n(J.$add$ns(J.$add$ns(J.$mul$ns(wi.x, t3.get$x(n)), J.$mul$ns(wi.y, t3.get$y(n))), J.$mul$ns(wi.z, t3.get$z(n)))));
          t5 = visibility.r;
          t6 = t5.origin;
          t7 = J.getInterceptor$x(t6);
          t8 = t7.get$x(t6);
          t9 = t7.get$y(t6);
          t6 = t7.get$z(t6);
          t7 = t5.direction;
          t10 = J.getInterceptor$x(t7);
          t11 = t10.get$x(t7);
          t12 = t10.get$y(t7);
          t7 = t10.get$z(t7);
          t10 = t5.minDistance;
          t13 = t5.maxDistance;
          t14 = t5.time;
          t5 = t5.depth;
          t6 = new G.Point(t8, t9, t6);
          t7 = new G.Vector(t11, t12, t7);
          $L = $L.$add(0, t4.$mul(0, renderer.transmittance$4(scene, new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t6, t7, t10, t13, t14, t5), sample, rng)).$div(0, pdf[0]));
        }
      }
      t1 = ray.depth;
      t2 = this.maxDepth;
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 + 1 < t2 ? $L.$add(0, G.Integrator_SpecularReflect(ray, bsdf, rng, isect, renderer, scene, sample)).$add(0, G.Integrator_SpecularTransmit(ray, bsdf, rng, isect, renderer, scene, sample)) : $L;
    },
    static: {WhittedIntegrator_Create: [function(params) {
        return new U.WhittedIntegrator(params.findOneInt$2("maxdepth", 5));
      }, "call$1", "WhittedIntegrator_Create$closure", 2, 0, 68]}
  }
}],
["textures", "package:dartray/textures/textures.dart", , G, {
  "^": "",
  BilerpTexture: {
    "^": "Texture;mapping,v00,v01,v10,v11",
    evaluate$1: function(dg) {
      var _s, _t, s, t, t1, t2;
      _s = [0];
      _t = [0];
      this.mapping.map$7(0, dg, _s, _t, [0], [0], [0], [0]);
      s = _s[0];
      t = _t[0];
      if (typeof s !== "number")
        return H.iae(s);
      t1 = 1 - s;
      if (typeof t !== "number")
        return H.iae(t);
      t2 = 1 - t;
      return J.$add$ns(J.$add$ns(J.$add$ns(J.$mul$ns(this.v00, t1 * t2), J.$mul$ns(J.$mul$ns(this.v01, t1), t)), J.$mul$ns(J.$mul$ns(this.v10, s), t2)), J.$mul$ns(J.$mul$ns(this.v11, s), t));
    },
    static: {BilerpTexture_CreateFloat: [function(tex2world, tp) {
        var type, t1, map, t2, t3, t4;
        type = tp.findString$2("mapping", "uv");
        t1 = J.getInterceptor(type);
        if (t1.$eq(type, "uv")) {
          t1 = tp.geomParams;
          map = new G.UVMapping2D(t1.findOneFloat$2("uscale", tp.materialParams.findOneFloat$2("uscale", 1)), t1.findOneFloat$2("vscale", tp.materialParams.findOneFloat$2("vscale", 1)), t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0)), t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0)));
        } else if (t1.$eq(type, "spherical"))
          map = new G.SphericalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "cylindrical"))
          map = new G.CylindricalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "planar")) {
          t1 = tp.geomParams;
          t2 = t1.findOneVector$2("v1", tp.materialParams.findOneVector$2("v1", new G.Vector(1, 0, 0)));
          t3 = t1.findOneVector$2("v2", tp.materialParams.findOneVector$2("v2", new G.Vector(0, 1, 0)));
          t4 = t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0));
          t1 = t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0));
          map = new G.PlanarMapping2D(G.Vector$from(t2), G.Vector$from(t3), t4, t1);
        } else {
          t1 = "2D texture mapping \"" + H.S(type) + "\" unknown";
          $.Log.call$2(2, t1);
          map = new G.UVMapping2D(1, 1, 0, 0);
        }
        t1 = tp.geomParams;
        return new G.BilerpTexture(map, t1.findOneFloat$2("v00", tp.materialParams.findOneFloat$2("v00", 0)), t1.findOneFloat$2("v01", tp.materialParams.findOneFloat$2("v01", 1)), t1.findOneFloat$2("v10", tp.materialParams.findOneFloat$2("v10", 0)), t1.findOneFloat$2("v11", tp.materialParams.findOneFloat$2("v11", 1)));
      }, "call$2", "BilerpTexture_CreateFloat$closure", 4, 0, 69], BilerpTexture_CreateSpectrum: [function(tex2world, tp) {
        var type, t1, map, t2, t3, t4, t5;
        type = tp.findString$2("mapping", "uv");
        t1 = J.getInterceptor(type);
        if (t1.$eq(type, "uv")) {
          t1 = tp.geomParams;
          map = new G.UVMapping2D(t1.findOneFloat$2("uscale", tp.materialParams.findOneFloat$2("uscale", 1)), t1.findOneFloat$2("vscale", tp.materialParams.findOneFloat$2("vscale", 1)), t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0)), t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0)));
        } else if (t1.$eq(type, "spherical"))
          map = new G.SphericalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "cylindrical"))
          map = new G.CylindricalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "planar")) {
          t1 = tp.geomParams;
          t2 = t1.findOneVector$2("v1", tp.materialParams.findOneVector$2("v1", new G.Vector(1, 0, 0)));
          t3 = t1.findOneVector$2("v2", tp.materialParams.findOneVector$2("v2", new G.Vector(0, 1, 0)));
          t4 = t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0));
          t1 = t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0));
          map = new G.PlanarMapping2D(G.Vector$from(t2), G.Vector$from(t3), t4, t1);
        } else {
          t1 = "2D texture mapping \"" + H.S(type) + "\" unknown";
          $.Log.call$2(2, t1);
          map = new G.UVMapping2D(1, 1, 0, 0);
        }
        t1 = G.Spectrum_Spectrum(0);
        t2 = tp.geomParams;
        t1 = t2.findOneSpectrum$2("v00", tp.materialParams.findOneSpectrum$2("v00", t1));
        t3 = G.Spectrum_Spectrum(1);
        t3 = t2.findOneSpectrum$2("v01", tp.materialParams.findOneSpectrum$2("v01", t3));
        t4 = G.Spectrum_Spectrum(0);
        t4 = t2.findOneSpectrum$2("v10", tp.materialParams.findOneSpectrum$2("v10", t4));
        t5 = G.Spectrum_Spectrum(1);
        return new G.BilerpTexture(map, t1, t3, t4, t2.findOneSpectrum$2("v11", tp.materialParams.findOneSpectrum$2("v11", t5)));
      }, "call$2", "BilerpTexture_CreateSpectrum$closure", 4, 0, 69]}
  },
  Checkerboard3DTexture: {
    "^": "Texture;mapping,tex1,tex2",
    evaluate$1: function(dg) {
      var p = this.mapping.map$3(0, dg, new G.Vector(0, 0, 0), new G.Vector(0, 0, 0));
      if (C.JSInt_methods.$mod(J.floor$0$n(p.get$x(p)) + J.floor$0$n(p.get$y(p)) + J.floor$0$n(p.get$z(p)), 2) === 0)
        return this.tex1.evaluate$1(dg);
      else
        return this.tex2.evaluate$1(dg);
    }
  },
  CheckerboardTexture: {
    "^": "Texture;mapping,tex1,tex2,aaMethod",
    evaluate$1: function(dg) {
      var _s, _t, _dsdx, _dtdx, _dsdy, _dtdy, s, t, dsdx, dsdy, dtdx, dtdy, ds, dt, t1, s0, s1, t2, t00, t10, sint, tint, area2;
      _s = [0];
      _t = [0];
      _dsdx = [0];
      _dtdx = [0];
      _dsdy = [0];
      _dtdy = [0];
      this.mapping.map$7(0, dg, _s, _t, _dsdx, _dtdx, _dsdy, _dtdy);
      s = _s[0];
      t = _t[0];
      dsdx = _dsdx[0];
      dsdy = _dsdy[0];
      dtdx = _dtdx[0];
      dtdy = _dtdy[0];
      if (this.aaMethod === 0) {
        if (C.JSInt_methods.$mod(J.floor$0$n(s) + J.floor$0$n(t), 2) === 0)
          return this.tex1.evaluate$1(dg);
        return this.tex2.evaluate$1(dg);
      } else {
        ds = P.max(J.abs$0$n(dsdx), J.abs$0$n(dsdy));
        dt = P.max(J.abs$0$n(dtdx), J.abs$0$n(dtdy));
        t1 = J.getInterceptor$n(s);
        s0 = t1.$sub(s, ds);
        s1 = t1.$add(s, ds);
        t2 = J.getInterceptor$n(t);
        t00 = t2.$sub(t, dt);
        t10 = t2.$add(t, dt);
        if (J.floor$0$n(s0) === J.floor$0$n(s1) && J.floor$0$n(t00) === J.floor$0$n(t10)) {
          if (C.JSInt_methods.$mod(t1.floor$0(s) + t2.floor$0(t), 2) === 0)
            return this.tex1.evaluate$1(dg);
          return this.tex2.evaluate$1(dg);
        }
        t1 = new G.CheckerboardTexture_evaluate_BUMPINT();
        sint = J.$sub$n(t1.call$1(s1), t1.call$1(s0)) / (2 * ds);
        tint = J.$sub$n(t1.call$1(t10), t1.call$1(t00)) / (2 * dt);
        area2 = sint + tint - 2 * sint * tint;
        if (ds > 1 || dt > 1)
          area2 = 0.5;
        return J.$add$ns(J.$mul$ns(this.tex1.evaluate$1(dg), 1 - area2), J.$mul$ns(this.tex2.evaluate$1(dg), area2));
      }
    },
    static: {"^": "CheckerboardTexture_AA_NONE,CheckerboardTexture_AA_CLOSED_FORM", CheckerboardTexture__Create: function(tex2world, tp, tex1, tex2) {
        var t1, dim, t2, type, map, t3, t4, t5, aa, aaMethod;
        t1 = tp.geomParams;
        dim = t1.findOneInt$2("dimension", tp.materialParams.findOneInt$2("dimension", 2));
        t2 = J.getInterceptor(dim);
        if (!t2.$eq(dim, 2) && !t2.$eq(dim, 3)) {
          t1 = H.S(dim) + " dimensional checkerboard texture not supported";
          $.Log.call$2(1, t1);
          return;
        }
        if (t2.$eq(dim, 2)) {
          type = t1.findOneString$2("mapping", tp.materialParams.findOneString$2("mapping", "uv"));
          t2 = J.getInterceptor(type);
          if (t2.$eq(type, "uv"))
            map = new G.UVMapping2D(t1.findOneFloat$2("uscale", tp.materialParams.findOneFloat$2("uscale", 1)), t1.findOneFloat$2("vscale", tp.materialParams.findOneFloat$2("vscale", 1)), t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0)), t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0)));
          else if (t2.$eq(type, "spherical"))
            map = new G.SphericalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
          else if (t2.$eq(type, "cylindrical"))
            map = new G.CylindricalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
          else if (t2.$eq(type, "planar")) {
            t2 = t1.findOneVector$2("v1", tp.materialParams.findOneVector$2("v1", new G.Vector(1, 0, 0)));
            t3 = t1.findOneVector$2("v2", tp.materialParams.findOneVector$2("v2", new G.Vector(0, 1, 0)));
            t4 = t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0));
            t5 = t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0));
            map = new G.PlanarMapping2D(G.Vector$from(t2), G.Vector$from(t3), t4, t5);
          } else {
            t2 = "2D texture mapping \"" + H.S(type) + "\" unknown";
            $.Log.call$2(1, t2);
            map = new G.UVMapping2D(1, 1, 0, 0);
          }
          aa = t1.findOneString$2("aamode", tp.materialParams.findOneString$2("aamode", "closedform"));
          t1 = J.getInterceptor(aa);
          if (t1.$eq(aa, "none"))
            aaMethod = 0;
          else {
            if (t1.$eq(aa, "closedform"))
              ;
            else {
              t1 = "Antialiasing mode \"" + H.S(aa) + "\" not understood by Checkerboard2DTexture; using \"closedform\"";
              $.Log.call$2(1, t1);
            }
            aaMethod = 1;
          }
          return new G.CheckerboardTexture(map, tex1, tex2, aaMethod);
        } else
          return new G.Checkerboard3DTexture(new G.IdentityMapping3D(tex2world), tex1, tex2);
      }, CheckerboardTexture_CreateFloat: [function(tex2world, tp) {
        return G.CheckerboardTexture__Create(tex2world, tp, tp.getFloatTexture$2("tex1", 1), tp.getFloatTexture$2("tex2", 0));
      }, "call$2", "CheckerboardTexture_CreateFloat$closure", 4, 0, 70], CheckerboardTexture_CreateSpectrum: [function(tex2world, tp) {
        return G.CheckerboardTexture__Create(tex2world, tp, tp.getSpectrumTexture$2("tex1", G.Spectrum_Spectrum(1)), tp.getSpectrumTexture$2("tex2", G.Spectrum_Spectrum(0)));
      }, "call$2", "CheckerboardTexture_CreateSpectrum$closure", 4, 0, 70]}
  },
  CheckerboardTexture_evaluate_BUMPINT: {
    "^": "Closure:88;",
    call$1: function(x) {
      var t1 = J.getInterceptor$n(x);
      return J.floor$0$n(t1.$div(x, 2)) + 2 * P.max(J.$sub$n(J.$sub$n(t1.$div(x, 2), J.floor$0$n(t1.$div(x, 2))), 0.5), 0);
    }
  },
  DotsTexture: {
    "^": "Texture;mapping,outsideDot,insideDot",
    evaluate$1: function(dg) {
      var _s, _t, s, t, t1, sCell, t2, tCell, t3, t4, ds, dt;
      _s = [0];
      _t = [0];
      this.mapping.map$7(0, dg, _s, _t, [0], [0], [0], [0]);
      s = _s[0];
      t = _t[0];
      t1 = J.getInterceptor$ns(s);
      sCell = J.floor$0$n(t1.$add(s, 0.5));
      t2 = J.getInterceptor$ns(t);
      tCell = J.floor$0$n(t2.$add(t, 0.5));
      if (G.Noise(sCell + 0.5, tCell + 0.5, 0.5) > 0) {
        t3 = G.Noise(sCell + 1.5, tCell + 2.8, 0.5);
        t4 = G.Noise(sCell + 4.5, tCell + 9.8, 0.5);
        ds = t1.$sub(s, sCell + 0.15000000000000002 * t3);
        dt = t2.$sub(t, tCell + 0.15000000000000002 * t4);
        if (J.$lt$n(J.$add$ns(J.$mul$ns(ds, ds), J.$mul$ns(dt, dt)), 0.12249999999999998))
          return this.insideDot.evaluate$1(dg);
      }
      return this.outsideDot.evaluate$1(dg);
    },
    static: {DotsTexture_CreateFloat: [function(tex2world, tp) {
        var type, t1, map, t2, t3, t4;
        type = tp.findString$2("mapping", "uv");
        t1 = J.getInterceptor(type);
        if (t1.$eq(type, "uv")) {
          t1 = tp.geomParams;
          map = new G.UVMapping2D(t1.findOneFloat$2("uscale", tp.materialParams.findOneFloat$2("uscale", 1)), t1.findOneFloat$2("vscale", tp.materialParams.findOneFloat$2("vscale", 1)), t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0)), t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0)));
        } else if (t1.$eq(type, "spherical"))
          map = new G.SphericalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "cylindrical"))
          map = new G.CylindricalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "planar")) {
          t1 = tp.geomParams;
          t2 = t1.findOneVector$2("v1", tp.materialParams.findOneVector$2("v1", new G.Vector(1, 0, 0)));
          t3 = t1.findOneVector$2("v2", tp.materialParams.findOneVector$2("v2", new G.Vector(0, 1, 0)));
          t4 = t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0));
          t1 = t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0));
          map = new G.PlanarMapping2D(G.Vector$from(t2), G.Vector$from(t3), t4, t1);
        } else {
          t1 = "2D texture mapping \"" + H.S(type) + "\" unknown";
          $.Log.call$2(2, t1);
          map = new G.UVMapping2D(1, 1, 0, 0);
        }
        return new G.DotsTexture(map, tp.getFloatTexture$2("inside", 1), tp.getFloatTexture$2("outside", 0));
      }, "call$2", "DotsTexture_CreateFloat$closure", 4, 0, 71], DotsTexture_CreateSpectrum: [function(tex2world, tp) {
        var type, t1, map, t2, t3, t4;
        type = tp.findString$2("mapping", "uv");
        t1 = J.getInterceptor(type);
        if (t1.$eq(type, "uv")) {
          t1 = tp.geomParams;
          map = new G.UVMapping2D(t1.findOneFloat$2("uscale", tp.materialParams.findOneFloat$2("uscale", 1)), t1.findOneFloat$2("vscale", tp.materialParams.findOneFloat$2("vscale", 1)), t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0)), t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0)));
        } else if (t1.$eq(type, "spherical"))
          map = new G.SphericalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "cylindrical"))
          map = new G.CylindricalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "planar")) {
          t1 = tp.geomParams;
          t2 = t1.findOneVector$2("v1", tp.materialParams.findOneVector$2("v1", new G.Vector(1, 0, 0)));
          t3 = t1.findOneVector$2("v2", tp.materialParams.findOneVector$2("v2", new G.Vector(0, 1, 0)));
          t4 = t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0));
          t1 = t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0));
          map = new G.PlanarMapping2D(G.Vector$from(t2), G.Vector$from(t3), t4, t1);
        } else {
          t1 = "2D texture mapping \"" + H.S(type) + "\" unknown";
          $.Log.call$2(2, t1);
          map = new G.UVMapping2D(1, 1, 0, 0);
        }
        return new G.DotsTexture(map, tp.getSpectrumTexture$2("inside", G.Spectrum_Spectrum(1)), tp.getSpectrumTexture$2("outside", G.Spectrum_Spectrum(0)));
      }, "call$2", "DotsTexture_CreateSpectrum$closure", 4, 0, 71]}
  },
  FBmTexture: {
    "^": "Texture;omega,octaves,spectrum,mapping",
    evaluate$1: function(dg) {
      var dpdx, dpdy, n;
      dpdx = new G.Vector(0, 0, 0);
      dpdy = new G.Vector(0, 0, 0);
      n = G.FBm(this.mapping.map$3(0, dg, dpdx, dpdy), dpdx, dpdy, this.omega, this.octaves);
      return this.spectrum ? G.Spectrum_Spectrum(n) : n;
    },
    static: {FBmTexture_CreateFloat: [function(tex2world, tp) {
        var t1 = tp.findInt$2("octaves", 8);
        return new G.FBmTexture(tp.geomParams.findOneFloat$2("roughness", tp.materialParams.findOneFloat$2("roughness", 0.5)), t1, false, new G.IdentityMapping3D(tex2world));
      }, "call$2", "FBmTexture_CreateFloat$closure", 4, 0, 72], FBmTexture_CreateSpectrum: [function(tex2world, tp) {
        var t1 = tp.findInt$2("octaves", 8);
        return new G.FBmTexture(tp.geomParams.findOneFloat$2("roughness", tp.materialParams.findOneFloat$2("roughness", 0.5)), t1, true, new G.IdentityMapping3D(tex2world));
      }, "call$2", "FBmTexture_CreateSpectrum$closure", 4, 0, 72]}
  },
  ImageTexture: {
    "^": "Texture;mipmap,mapping",
    evaluate$1: function(dg) {
      var s, t, dsdx, dtdx, dsdy, dtdy;
      s = [0];
      t = [0];
      dsdx = [0];
      dtdx = [0];
      dsdy = [0];
      dtdy = [0];
      this.mapping.map$7(0, dg, s, t, dsdx, dtdx, dsdy, dtdy);
      return this.mipmap.lookup2$6(s[0], t[0], dsdx[0], dtdx[0], dsdy[0], dtdy[0]);
    },
    ImageTexture$8: function(mapping, filename, doTri, maxAniso, wrap, scale, gamma, spectrum) {
      var completer, v, img;
      if (J.get$isNotEmpty$asx(filename)) {
        completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        $.ResourceManager_global.requestImage$2(filename, completer.future).then$1(new G.ImageTexture_closure(this, doTri, maxAniso, wrap, scale, gamma, spectrum, completer));
      }
      if (typeof scale !== "number")
        H.throwExpression(P.ArgumentError$(scale));
      if (typeof gamma !== "number")
        H.throwExpression(P.ArgumentError$(gamma));
      v = Math.pow(scale, gamma);
      img = G.SpectrumImage$(1, 1, spectrum ? 3 : 1);
      if (spectrum)
        img.$indexSet(0, 0, G.Spectrum_Spectrum(v));
      else
        img.$indexSet(0, 0, v);
      this.mipmap = G.MIPMap$texture(img, false, 8, 0);
    },
    static: {ImageTexture$: function(mapping, filename, doTri, maxAniso, wrap, scale, gamma, spectrum) {
        var t1 = new G.ImageTexture(null, mapping);
        t1.ImageTexture$8(mapping, filename, doTri, maxAniso, wrap, scale, gamma, spectrum);
        return t1;
      }, ImageTexture_CreateFloat: [function(tex2world, tp) {
        var type, t1, map, t2, t3, t4, maxAniso, trilerp, wrap, wrapMode, scale, gamma;
        type = tp.findString$2("mapping", "uv");
        t1 = J.getInterceptor(type);
        if (t1.$eq(type, "uv")) {
          t1 = tp.geomParams;
          map = new G.UVMapping2D(t1.findOneFloat$2("uscale", tp.materialParams.findOneFloat$2("uscale", 1)), t1.findOneFloat$2("vscale", tp.materialParams.findOneFloat$2("vscale", 1)), t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0)), t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0)));
        } else if (t1.$eq(type, "spherical"))
          map = new G.SphericalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "cylindrical"))
          map = new G.CylindricalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "planar")) {
          t1 = tp.geomParams;
          t2 = t1.findOneVector$2("v1", tp.materialParams.findOneVector$2("v1", new G.Vector(1, 0, 0)));
          t3 = t1.findOneVector$2("v2", tp.materialParams.findOneVector$2("v2", new G.Vector(0, 1, 0)));
          t4 = t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0));
          t1 = t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0));
          map = new G.PlanarMapping2D(G.Vector$from(t2), G.Vector$from(t3), t4, t1);
        } else {
          t1 = "2D texture mapping '" + H.S(type) + "' unknown";
          $.Log.call$2(2, t1);
          map = new G.UVMapping2D(1, 1, 0, 0);
        }
        t1 = tp.geomParams;
        maxAniso = t1.findOneFloat$2("maxanisotropy", tp.materialParams.findOneFloat$2("maxanisotropy", 8));
        trilerp = t1.findOneBool$2("trilinear", tp.materialParams.findOneBool$2("trilinear", false));
        wrap = t1.findOneString$2("wrap", tp.materialParams.findOneString$2("wrap", "repeat"));
        t2 = J.getInterceptor(wrap);
        if (t2.$eq(wrap, "black"))
          wrapMode = 1;
        else
          wrapMode = t2.$eq(wrap, "clamp") ? 2 : 0;
        scale = t1.findOneFloat$2("scale", tp.materialParams.findOneFloat$2("scale", 1));
        gamma = t1.findOneFloat$2("gamma", tp.materialParams.findOneFloat$2("gamma", 1));
        return G.ImageTexture$(map, t1.findOneFilename$2("filename", tp.materialParams.findOneFilename$2("filename", "")), trilerp, maxAniso, wrapMode, scale, gamma, false);
      }, "call$2", "ImageTexture_CreateFloat$closure", 4, 0, 73], ImageTexture_CreateSpectrum: [function(tex2world, tp) {
        var type, t1, map, t2, t3, t4, maxAniso, trilerp, wrap, wrapMode, scale, gamma;
        type = tp.findString$2("mapping", "uv");
        t1 = J.getInterceptor(type);
        if (t1.$eq(type, "uv")) {
          t1 = tp.geomParams;
          map = new G.UVMapping2D(t1.findOneFloat$2("uscale", tp.materialParams.findOneFloat$2("uscale", 1)), t1.findOneFloat$2("vscale", tp.materialParams.findOneFloat$2("vscale", 1)), t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0)), t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0)));
        } else if (t1.$eq(type, "spherical"))
          map = new G.SphericalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "cylindrical"))
          map = new G.CylindricalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "planar")) {
          t1 = tp.geomParams;
          t2 = t1.findOneVector$2("v1", tp.materialParams.findOneVector$2("v1", new G.Vector(1, 0, 0)));
          t3 = t1.findOneVector$2("v2", tp.materialParams.findOneVector$2("v2", new G.Vector(0, 1, 0)));
          t4 = t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0));
          t1 = t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0));
          map = new G.PlanarMapping2D(G.Vector$from(t2), G.Vector$from(t3), t4, t1);
        } else {
          t1 = "2D texture mapping '" + H.S(type) + "' unknown";
          $.Log.call$2(2, t1);
          map = new G.UVMapping2D(1, 1, 0, 0);
        }
        t1 = tp.geomParams;
        maxAniso = t1.findOneFloat$2("maxanisotropy", tp.materialParams.findOneFloat$2("maxanisotropy", 8));
        trilerp = t1.findOneBool$2("trilinear", tp.materialParams.findOneBool$2("trilinear", false));
        wrap = t1.findOneString$2("wrap", tp.materialParams.findOneString$2("wrap", "repeat"));
        t2 = J.getInterceptor(wrap);
        if (t2.$eq(wrap, "black"))
          wrapMode = 1;
        else
          wrapMode = t2.$eq(wrap, "clamp") ? 2 : 0;
        scale = t1.findOneFloat$2("scale", tp.materialParams.findOneFloat$2("scale", 1));
        gamma = t1.findOneFloat$2("gamma", tp.materialParams.findOneFloat$2("gamma", 1));
        return G.ImageTexture$(map, t1.findOneFilename$2("filename", tp.materialParams.findOneFilename$2("filename", "")), trilerp, maxAniso, wrapMode, scale, gamma, true);
      }, "call$2", "ImageTexture_CreateSpectrum$closure", 4, 0, 73]}
  },
  ImageTexture_closure: {
    "^": "Closure:119;this_0,doTri_1,maxAniso_2,wrap_3,scale_4,gamma_5,spectrum_6,completer_7",
    call$1: function(img) {
      var t1, len, t2, i, t3, t4;
      if (img != null) {
        img = !this.spectrum_6 ? img.convert$1(1) : G.SpectrumImage$from(img);
        t1 = this.scale_4;
        if (!J.$eq(t1, 1) || !J.$eq(this.gamma_5, 1))
          for (len = J.get$data$x(img).length, t2 = this.gamma_5, i = 0; i < len; ++i) {
            t3 = img.data;
            if (i >= t3.length)
              return H.ioore(t3, i);
            t4 = t3[i];
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (typeof t2 !== "number")
              H.throwExpression(P.ArgumentError$(t2));
            t3[i] = Math.pow(t4 * t1, t2);
          }
        this.this_0.mipmap = G.MIPMap$texture(img, this.doTri_1, this.maxAniso_2, this.wrap_3);
      }
      t1 = this.completer_7.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(null);
    }
  },
  MarbleTexture: {
    "^": "Texture;octaves,omega,scale,variation,mapping",
    evaluate$1: function(dg) {
      var dpdx, dpdy, t1, $P, marble, first, t, ci, t2, t3, c0, c1, c2, c3, s0, s1, s2;
      dpdx = new G.Vector(0, 0, 0);
      dpdy = new G.Vector(0, 0, 0);
      t1 = this.scale;
      $P = this.mapping.map$3(0, dg, dpdx, dpdy).$mul(0, t1);
      marble = J.$add$ns($P.get$y($P), J.$mul$ns(this.variation, G.FBm($P, dpdx.$mul(0, t1), dpdy.$mul(0, t1), this.omega, this.octaves)));
      if (typeof marble !== "number")
        H.throwExpression(P.ArgumentError$(marble));
      t1 = (0.5 + 0.5 * Math.sin(marble)) * 6;
      first = C.JSNumber_methods.toInt$0(Math.floor(t1));
      t = t1 - first;
      ci = first * 3;
      if (ci < 0 || ci >= 27)
        return H.ioore(C.List_PWB, ci);
      t1 = C.List_PWB[ci];
      t2 = ci + 1;
      if (t2 >= 27)
        return H.ioore(C.List_PWB, t2);
      t2 = C.List_PWB[t2];
      t3 = ci + 2;
      if (t3 >= 27)
        return H.ioore(C.List_PWB, t3);
      c0 = G.Spectrum_Spectrum$rgb(t1, t2, C.List_PWB[t3]);
      t3 = ci + 3;
      if (t3 >= 27)
        return H.ioore(C.List_PWB, t3);
      t3 = C.List_PWB[t3];
      t2 = ci + 4;
      if (t2 >= 27)
        return H.ioore(C.List_PWB, t2);
      t2 = C.List_PWB[t2];
      t1 = ci + 5;
      if (t1 >= 27)
        return H.ioore(C.List_PWB, t1);
      c1 = G.Spectrum_Spectrum$rgb(t3, t2, C.List_PWB[t1]);
      t1 = ci + 6;
      if (t1 >= 27)
        return H.ioore(C.List_PWB, t1);
      t1 = C.List_PWB[t1];
      t2 = ci + 7;
      if (t2 >= 27)
        return H.ioore(C.List_PWB, t2);
      t2 = C.List_PWB[t2];
      t3 = ci + 8;
      if (t3 >= 27)
        return H.ioore(C.List_PWB, t3);
      c2 = G.Spectrum_Spectrum$rgb(t1, t2, C.List_PWB[t3]);
      t3 = ci + 9;
      if (t3 >= 27)
        return H.ioore(C.List_PWB, t3);
      t3 = C.List_PWB[t3];
      t2 = ci + 10;
      if (t2 >= 27)
        return H.ioore(C.List_PWB, t2);
      t2 = C.List_PWB[t2];
      t1 = ci + 11;
      if (t1 >= 27)
        return H.ioore(C.List_PWB, t1);
      c3 = G.Spectrum_Spectrum$rgb(t3, t2, C.List_PWB[t1]);
      t1 = 1 - t;
      s0 = c0.$mul(0, t1).$add(0, c1.$mul(0, t));
      s1 = c1.$mul(c1, t1).$add(0, c2.$mul(0, t));
      s2 = c2.$mul(c2, t1).$add(0, c3.$mul(0, t));
      s0 = s0.$mul(0, t1).$add(0, s1.$mul(0, t));
      s1 = s1.$mul(0, t1).$add(0, s2.$mul(0, t));
      return s0.$mul(0, t1).$add(0, s1.$mul(0, t)).$mul(0, 1.5);
    },
    scale$1: function($receiver, arg0) {
      return this.scale.call$1(arg0);
    },
    static: {MarbleTexture_CreateFloat: [function(tex2world, tp) {
        return;
      }, "call$2", "MarbleTexture_CreateFloat$closure", 4, 0, 74], MarbleTexture_CreateSpectrum: [function(tex2world, tp) {
        var t1, t2;
        t1 = tp.findInt$2("octaves", 8);
        t2 = tp.geomParams;
        return new G.MarbleTexture(t1, t2.findOneFloat$2("roughness", tp.materialParams.findOneFloat$2("roughness", 0.5)), t2.findOneFloat$2("scale", tp.materialParams.findOneFloat$2("scale", 1)), t2.findOneFloat$2("variation", tp.materialParams.findOneFloat$2("variation", 0.2)), new G.IdentityMapping3D(tex2world));
      }, "call$2", "MarbleTexture_CreateSpectrum$closure", 4, 0, 74]}
  },
  MixTexture: {
    "^": "Texture;tex1,tex2,amount",
    evaluate$1: function(dg) {
      var t1, t2, amt;
      t1 = this.tex1.evaluate$1(dg);
      t2 = this.tex2.evaluate$1(dg);
      amt = this.amount.evaluate$1(dg);
      if (typeof amt !== "number")
        return H.iae(amt);
      return J.$add$ns(J.$mul$ns(t1, 1 - amt), J.$mul$ns(t2, amt));
    },
    static: {MixTexture_CreateFloat: [function(tex2world, tp) {
        return new G.MixTexture(tp.getFloatTexture$2("tex1", 0), tp.getFloatTexture$2("tex2", 1), tp.getFloatTexture$2("amount", 0.5));
      }, "call$2", "MixTexture_CreateFloat$closure", 4, 0, 75], MixTexture_CreateSpectrum: [function(tex2world, tp) {
        return new G.MixTexture(tp.getSpectrumTexture$2("tex1", G.Spectrum_Spectrum(0)), tp.getSpectrumTexture$2("tex2", G.Spectrum_Spectrum(1)), tp.getFloatTexture$2("amount", 0.5));
      }, "call$2", "MixTexture_CreateSpectrum$closure", 4, 0, 75]}
  },
  ScaleTexture: {
    "^": "Texture;tex1,tex2",
    evaluate$1: function(dg) {
      var t1, t2;
      t1 = this.tex1.evaluate$1(dg);
      t2 = this.tex2.evaluate$1(dg);
      if (typeof t1 === "number")
        return J.$mul$ns(t2, t1);
      return J.$mul$ns(t1, t2);
    },
    static: {ScaleTexture_CreateFloat: [function(tex2world, tp) {
        return new G.ScaleTexture(tp.getFloatTexture$2("tex1", 1), tp.getFloatTexture$2("tex2", 1));
      }, "call$2", "ScaleTexture_CreateFloat$closure", 4, 0, 76], ScaleTexture_CreateSpectrum: [function(tex2world, tp) {
        return new G.ScaleTexture(tp.getSpectrumTexture$2("tex1", G.Spectrum_Spectrum(1)), tp.getSpectrumTexture$2("tex2", G.Spectrum_Spectrum(1)));
      }, "call$2", "ScaleTexture_CreateSpectrum$closure", 4, 0, 76]}
  },
  UVTexture: {
    "^": "Texture;mapping",
    evaluate$1: function(dg) {
      var _s, _t, s, t;
      _s = [0];
      _t = [0];
      this.mapping.map$7(0, dg, _s, _t, [0], [0], [0], [0]);
      s = _s[0];
      t = _t[0];
      return G.Spectrum_Spectrum$rgb(s - J.floor$0$n(s), t - J.floor$0$n(t), 0);
    },
    static: {UVTexture_CreateFloat: [function(tex2world, tp) {
        return;
      }, "call$2", "UVTexture_CreateFloat$closure", 4, 0, 77], UVTexture_CreateSpectrum: [function(tex2world, tp) {
        var type, t1, map, t2, t3, t4;
        type = tp.findString$2("mapping", "uv");
        t1 = J.getInterceptor(type);
        if (t1.$eq(type, "uv")) {
          t1 = tp.geomParams;
          map = new G.UVMapping2D(t1.findOneFloat$2("uscale", tp.materialParams.findOneFloat$2("uscale", 1)), t1.findOneFloat$2("vscale", tp.materialParams.findOneFloat$2("vscale", 1)), t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0)), t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0)));
        } else if (t1.$eq(type, "spherical"))
          map = new G.SphericalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "cylindrical"))
          map = new G.CylindricalMapping2D(G.Transform$(tex2world.get$mInv(), tex2world.m));
        else if (t1.$eq(type, "planar")) {
          t1 = tp.geomParams;
          t2 = t1.findOneVector$2("v1", tp.materialParams.findOneVector$2("v1", new G.Vector(1, 0, 0)));
          t3 = t1.findOneVector$2("v2", tp.materialParams.findOneVector$2("v2", new G.Vector(0, 1, 0)));
          t4 = t1.findOneFloat$2("udelta", tp.materialParams.findOneFloat$2("udelta", 0));
          t1 = t1.findOneFloat$2("vdelta", tp.materialParams.findOneFloat$2("vdelta", 0));
          map = new G.PlanarMapping2D(G.Vector$from(t2), G.Vector$from(t3), t4, t1);
        } else {
          t1 = "2D texture mapping \"" + H.S(type) + "\" unknown";
          $.Log.call$2(2, t1);
          map = new G.UVMapping2D(1, 1, 0, 0);
        }
        return new G.UVTexture(map);
      }, "call$2", "UVTexture_CreateSpectrum$closure", 4, 0, 77]}
  },
  WindyTexture: {
    "^": "Texture;mapping,spectrum",
    evaluate$1: function(dg) {
      var dpdx, dpdy, $P, windStrength, waveHeight, w;
      dpdx = new G.Vector(0, 0, 0);
      dpdy = new G.Vector(0, 0, 0);
      $P = this.mapping.map$3(0, dg, dpdx, dpdy);
      windStrength = G.FBm($P.$mul(0, 0.1), dpdx.$mul(0, 0.1), dpdy.$mul(0, 0.1), 0.5, 3);
      waveHeight = G.FBm($P, dpdx, dpdy, 0.5, 6);
      w = Math.abs(windStrength) * waveHeight;
      if (this.spectrum)
        return G.Spectrum_Spectrum(w);
      return w;
    },
    static: {WindyTexture_CreateFloat: [function(tex2world, tp) {
        return new G.WindyTexture(new G.IdentityMapping3D(tex2world), false);
      }, "call$2", "WindyTexture_CreateFloat$closure", 4, 0, 78], WindyTexture_CreateSpectrum: [function(tex2world, tp) {
        return new G.WindyTexture(new G.IdentityMapping3D(tex2world), true);
      }, "call$2", "WindyTexture_CreateSpectrum$closure", 4, 0, 78]}
  },
  WrinkledTexture: {
    "^": "Texture;omega,octaves,spectrum,mapping",
    evaluate$1: function(dg) {
      var dpdx, dpdy, n;
      dpdx = new G.Vector(0, 0, 0);
      dpdy = new G.Vector(0, 0, 0);
      n = G.Turbulence(this.mapping.map$3(0, dg, dpdx, dpdy), dpdx, dpdy, this.omega, this.octaves);
      return this.spectrum ? G.Spectrum_Spectrum(n) : n;
    },
    static: {WrinkledTexture_CreateFloat: [function(tex2world, tp) {
        var t1 = tp.findInt$2("octaves", 8);
        return new G.WrinkledTexture(tp.geomParams.findOneFloat$2("roughness", tp.materialParams.findOneFloat$2("roughness", 0.5)), t1, false, new G.IdentityMapping3D(tex2world));
      }, "call$2", "WrinkledTexture_CreateFloat$closure", 4, 0, 79], WrinkledTexture_CreateSpectrum: [function(tex2world, tp) {
        var t1 = tp.findInt$2("octaves", 8);
        return new G.WrinkledTexture(tp.geomParams.findOneFloat$2("roughness", tp.materialParams.findOneFloat$2("roughness", 0.5)), t1, true, new G.IdentityMapping3D(tex2world));
      }, "call$2", "WrinkledTexture_CreateSpectrum$closure", 4, 0, 79]}
  }
}],
["volume_integrators", "package:dartray/volume_integrators/volume_integrators.dart", , S, {
  "^": "",
  EmissionIntegrator: {
    "^": "VolumeIntegrator;stepSize,tauSampleOffset,scatterSampleOffset",
    requestSamples$3: function(sampler, sample, scene) {
      var t1;
      sample.n1D.push(1);
      t1 = sample.n1D;
      this.tauSampleOffset = t1.length - 1;
      t1.push(1);
      this.scatterSampleOffset = sample.n1D.length - 1;
    },
    Li$6: function(scene, renderer, ray, sample, rng, $T) {
      var vr, t00, t1, Lv, t2, nSamples, step, Tr, p, w, i, t3, t4, t5, p0, t6, t7;
      vr = scene.volumeRegion;
      t00 = [0];
      t1 = [0];
      if (vr == null || !vr.intersectP$3(ray, t00, t1) || J.$eq(J.$sub$n(t1[0], t00[0]), 0)) {
        $T.set$1(1);
        return G.Spectrum_Spectrum(0);
      }
      Lv = G.Spectrum_Spectrum(0);
      t2 = this.stepSize;
      nSamples = J.ceil$0$n(J.$div$n(J.$sub$n(t1[0], t00[0]), t2));
      step = J.$div$n(J.$sub$n(t1[0], t00[0]), nSamples);
      Tr = G.Spectrum_Spectrum(1);
      p = ray.pointAt$1(t00[0]);
      w = J.$negate$n(ray.direction);
      t1 = J.$add$ns(t00[0], J.$mul$ns(J.$index$asx(J.$index$asx(sample.get$oneD(), this.scatterSampleOffset), 0), step));
      t00[0] = t1;
      for (i = 0; i < nSamples; ++i, t1 = J.$add$ns(t00[0], step), t00[0] = t1, p = p0) {
        t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t1));
        t3 = J.getInterceptor$x(t1);
        t4 = t3.get$x(t1);
        t5 = t3.get$y(t1);
        t1 = t3.get$z(t1);
        p0 = new G.Point(t4, t5, t1);
        t4 = J.$sub$n(t4, p.x);
        t5 = J.$sub$n(t5, p.y);
        t1 = J.$sub$n(t1, p.z);
        t3 = ray.time;
        t6 = ray.depth;
        t7 = new G.Point(p.x, p.y, p.z);
        t1 = new G.Vector(t4, t5, t1);
        if (typeof t2 !== "number")
          return H.iae(t2);
        Tr = Tr.$mul(0, J.$negate$n(vr.tau$3(new G.Ray(t7, t1, 0, 1, t3, t6), 0.5 * t2, rng.randomFloat$0())).exp$0());
        if (J.$lt$n(Tr.get$y(Tr), 0.001)) {
          if ((rng.randomUInt$0() & 16777215) / 16777216 > 0.5) {
            Tr.set$1(0);
            break;
          }
          Tr = Tr.$div(0, 0.5);
        }
        Lv = Lv.$add(0, Tr.$mul(0, vr.Lve$3(p0, w, ray.time)));
      }
      $T.copy$1(Tr);
      return Lv.$mul(0, step);
    },
    transmittance$5: function(scene, renderer, ray, sample, rng) {
      var t1, step, offset;
      t1 = scene.volumeRegion;
      if (t1 == null)
        return G.Spectrum_Spectrum(1);
      step = this.stepSize;
      if (sample != null)
        offset = J.$index$asx(J.$index$asx(sample.get$oneD(), this.tauSampleOffset), 0);
      else {
        if (typeof step !== "number")
          return H.iae(step);
        step = 4 * step;
        offset = rng.randomFloat$0();
      }
      return J.$negate$n(t1.tau$3(ray, step, offset)).exp$0();
    },
    static: {EmissionIntegrator_Create: [function(params) {
        return new S.EmissionIntegrator(params.findOneFloat$2("stepsize", 1), null, null);
      }, "call$1", "EmissionIntegrator_Create$closure", 2, 0, 80]}
  },
  SingleScatteringIntegrator: {
    "^": "VolumeIntegrator;stepSize,tauSampleOffset,scatterSampleOffset",
    transmittance$5: function(scene, renderer, ray, sample, rng) {
      var t1, step, offset;
      t1 = scene.volumeRegion;
      if (t1 == null)
        return G.Spectrum_Spectrum(1);
      step = this.stepSize;
      if (sample != null)
        offset = J.$index$asx(J.$index$asx(sample.get$oneD(), this.tauSampleOffset), 0);
      else {
        if (typeof step !== "number")
          return H.iae(step);
        step = 4 * step;
        offset = rng.randomFloat$0();
      }
      return J.$negate$n(t1.tau$3(ray, step, offset)).exp$0();
    },
    requestSamples$3: function(sampler, sample, scene) {
      var t1;
      sample.n1D.push(1);
      t1 = sample.n1D;
      this.tauSampleOffset = t1.length - 1;
      t1.push(1);
      this.scatterSampleOffset = sample.n1D.length - 1;
    },
    Li$6: function(scene, renderer, ray, sample, rng, $T) {
      var vr, t00, t1, Lv, t2, nSamples, step, Tr, p, w, lightNum, lightComp, lightPos, t3, t4, sampOffset, i, t5, t6, t7, t8, p0, t9, t10, ss, nLights, ln, light, pdf, vis, wo, ls, $L, hit, t11, t12, t13, t14, Ld;
      vr = scene.volumeRegion;
      t00 = [0];
      t1 = [0];
      if (vr == null || !vr.intersectP$3(ray, t00, t1) || J.$eq(J.$sub$n(t1[0], t00[0]), 0)) {
        $T.set$1(1);
        return G.Spectrum_Spectrum(0);
      }
      Lv = G.Spectrum_Spectrum(0);
      t2 = this.stepSize;
      nSamples = J.ceil$0$n(J.$div$n(J.$sub$n(t1[0], t00[0]), t2));
      step = J.$div$n(J.$sub$n(t1[0], t00[0]), nSamples);
      Tr = G.Spectrum_Spectrum(1);
      p = ray.pointAt$1(t00[0]);
      w = J.$negate$n(ray.direction);
      t00[0] = J.$add$ns(t00[0], J.$mul$ns(J.$index$asx(J.$index$asx(sample.get$oneD(), this.scatterSampleOffset), 0), step));
      lightNum = new Float32Array(nSamples);
      G.LDShuffleScrambled1D(1, nSamples, lightNum, rng);
      lightComp = new Float32Array(nSamples);
      G.LDShuffleScrambled1D(1, nSamples, lightComp, rng);
      t1 = 2 * nSamples;
      lightPos = new Float32Array(t1);
      G.LDShuffleScrambled2D(1, nSamples, lightPos, rng);
      for (t3 = scene.lights, t4 = scene.aggregate, sampOffset = 0, i = 0; i < nSamples; ++i, t00[0] = J.$add$ns(t00[0], step), p = p0) {
        t5 = t00[0];
        t5 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t5));
        t6 = J.getInterceptor$x(t5);
        t7 = t6.get$x(t5);
        t8 = t6.get$y(t5);
        t5 = t6.get$z(t5);
        p0 = new G.Point(t7, t8, t5);
        t7 = J.$sub$n(t7, p.x);
        t8 = J.$sub$n(t8, p.y);
        t5 = J.$sub$n(t5, p.z);
        t6 = ray.time;
        t9 = ray.depth;
        t10 = new G.Point(p.x, p.y, p.z);
        t5 = new G.Vector(t7, t8, t5);
        if (typeof t2 !== "number")
          return H.iae(t2);
        Tr = Tr.$mul(0, J.$negate$n(vr.tau$3(new G.Ray(t10, t5, 0, 1, t6, t9), 0.5 * t2, rng.randomFloat$0())).exp$0());
        if (J.$lt$n(Tr.get$y(Tr), 0.001)) {
          if ((rng.randomUInt$0() & 16777215) / 16777216 > 0.5) {
            Tr = G.Spectrum_Spectrum(0);
            break;
          }
          Tr = Tr.$div(0, 0.5);
        }
        Lv = Lv.$add(0, Tr.$mul(0, vr.Lve$3(p0, w, ray.time)));
        ss = vr.sigma_s$3(p0, w, ray.time);
        if (!ss.isBlack$0() && t3.length !== 0) {
          nLights = t3.length;
          if (sampOffset >= nSamples)
            return H.ioore(lightNum, sampOffset);
          ln = P.min(C.JSNumber_methods.toInt$0(Math.floor(lightNum[sampOffset] * nLights)), nLights - 1);
          if (ln >>> 0 !== ln || ln >= t3.length)
            return H.ioore(t3, ln);
          light = t3[ln];
          pdf = [0];
          vis = new G.VisibilityTester(null);
          wo = new G.Vector(0, 0, 0);
          t5 = lightComp[sampOffset];
          t6 = 2 * sampOffset;
          if (t6 >= t1)
            return H.ioore(lightPos, t6);
          t7 = lightPos[t6];
          ++t6;
          if (t6 >= t1)
            return H.ioore(lightPos, t6);
          t6 = lightPos[t6];
          t8 = Array(2);
          t8.$builtinTypeInfo = [J.JSDouble];
          ls = new G.LightSample(t8, 0);
          t8[0] = t5;
          t8[1] = t7;
          ls.uComponent = t6;
          $L = light.sampleLAtPoint$7(p0, 0, ls, ray.time, wo, pdf, vis);
          if (!$L.isBlack$0())
            if (J.$gt$n(pdf[0], 0)) {
              hit = t4.intersectP$1(vis.r);
              t5 = $.get$Stats_shadowRays();
              t5.count = J.$add$ns(t5.count, 1);
              $.Stats_shadowRays = t5;
              t5 = !hit;
            } else
              t5 = false;
          else
            t5 = false;
          if (t5) {
            t5 = vis.r;
            t6 = t5.origin;
            t7 = J.getInterceptor$x(t6);
            t8 = t7.get$x(t6);
            t9 = t7.get$y(t6);
            t6 = t7.get$z(t6);
            t7 = t5.direction;
            t10 = J.getInterceptor$x(t7);
            t11 = t10.get$x(t7);
            t12 = t10.get$y(t7);
            t7 = t10.get$z(t7);
            t10 = t5.minDistance;
            t13 = t5.maxDistance;
            t14 = t5.time;
            t5 = t5.depth;
            t6 = new G.Point(t8, t9, t6);
            t7 = new G.Vector(t11, t12, t7);
            Ld = $L.$mul(0, renderer.transmittance$4(scene, new G.RayDifferential(false, new G.Point(0, 0, 0), new G.Point(0, 0, 0), new G.Vector(0, 0, 0), new G.Vector(0, 0, 0), t6, t7, t10, t13, t14, t5), null, rng));
            Lv = Lv.$add(0, Tr.$mul(0, ss).$mul(0, vr.p$4(0, p0, w, new G.Vector(J.$negate$n(wo.x), J.$negate$n(wo.y), J.$negate$n(wo.z)), ray.time)).$mul(0, Ld).$mul(0, nLights).$div(0, pdf[0]));
          }
        }
        ++sampOffset;
      }
      $T.copy$1(Tr);
      return Lv.$mul(0, step);
    },
    static: {SingleScatteringIntegrator_Create: [function(params) {
        return new S.SingleScatteringIntegrator(params.findOneFloat$2("stepsize", 1), null, null);
      }, "call$1", "SingleScatteringIntegrator_Create$closure", 2, 0, 81]}
  }
}],
["volume_regions", "package:dartray/volume_regions/volume_regions.dart", , B, {
  "^": "",
  ExponentialDensityRegion: {
    "^": "DensityRegion;extent,a,b,upDir,sig_a,sig_s,le,g,worldToVolume",
    worldBound$0: function() {
      var t1 = this.worldToVolume;
      return G.Transform$(t1.mInv, t1.m).transformBBox$1(this.extent);
    },
    intersectP$3: function(r, t00, t1) {
      var ray = this.worldToVolume.transformRay$1(r);
      return this.extent.intersectP$3(ray, t00, t1);
    },
    density$1: function(Pobj) {
      var height, t1, t2;
      if (!this.extent.inside$1(Pobj))
        return 0;
      height = G.Vector_Dot(Pobj.$sub(0, this.extent.pMin), this.upDir);
      t1 = this.a;
      t2 = J.$mul$ns(J.$negate$n(this.b), height);
      if (typeof t2 !== "number")
        H.throwExpression(P.ArgumentError$(t2));
      return J.$mul$ns(t1, Math.exp(t2));
    },
    static: {ExponentialDensityRegion_Create: [function(volume2world, params) {
        var sigma_a, sigma_s, g, Le, p0, p1, a, b, up, t1, t2;
        sigma_a = params.findOneSpectrum$2("sigma_a", G.Spectrum_Spectrum(0));
        sigma_s = params.findOneSpectrum$2("sigma_s", G.Spectrum_Spectrum(0));
        g = params.findOneFloat$2("g", 0);
        Le = params.findOneSpectrum$2("Le", G.Spectrum_Spectrum(0));
        p0 = params.findOnePoint$2("p0", new G.Point(0, 0, 0));
        p1 = params.findOnePoint$2("p1", new G.Point(1, 1, 1));
        a = params.findOneFloat$2("a", 1);
        b = params.findOneFloat$2("b", 1);
        up = params.findOneVector$2("updir", new G.Vector(0, 1, 0));
        t1 = new B.ExponentialDensityRegion(G.BBox$(p0, p1), a, b, null, G.Spectrum_Spectrum$from(sigma_a, 0), G.Spectrum_Spectrum$from(sigma_s, 0), G.Spectrum_Spectrum$from(Le, 0), g, G.Transform$(volume2world.get$mInv(), volume2world.m));
        t2 = J.getInterceptor$asx(up);
        t1.upDir = t2.$div(up, t2.length$0(up));
        return t1;
      }, "call$2", "ExponentialDensityRegion_Create$closure", 4, 0, 82]}
  },
  HomogeneousVolumeRegion: {
    "^": "VolumeRegion;sig_a,sig_s,le,g,extent,worldToVolume",
    worldBound$0: function() {
      var t1 = this.worldToVolume;
      return G.Transform$(t1.mInv, t1.m).transformBBox$1(this.extent);
    },
    intersectP$3: function(r, t00, t1) {
      var ray = this.worldToVolume.transformRay$1(r);
      return this.extent.intersectP$3(ray, t00, t1);
    },
    sigma_s$3: function(p, v, d) {
      return this.extent.inside$1(this.worldToVolume.transformPoint$1(p)) ? this.sig_s : G.Spectrum_Spectrum(0);
    },
    Lve$3: function(p, v, d) {
      return this.extent.inside$1(this.worldToVolume.transformPoint$1(p)) ? this.le : G.Spectrum_Spectrum(0);
    },
    p$4: [function(_, p, wi, wo, $double) {
      if (!this.extent.inside$1(this.worldToVolume.transformPoint$1(p)))
        return 0;
      return G.PhaseHG(wi, wo, this.g);
    }, "call$4", "get$p", 8, 0, 129],
    tau$3: function(ray, step, offset) {
      var t00, t1, t2, t3, t4, t5;
      t00 = [0];
      t1 = [0];
      if (!this.intersectP$3(ray, t00, t1))
        return G.Spectrum_Spectrum(0);
      t2 = J.$add$ns(this.sig_a, this.sig_s);
      t00 = t00[0];
      t00 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t00));
      t3 = J.getInterceptor$x(t00);
      t4 = t3.get$x(t00);
      t5 = t3.get$y(t00);
      t00 = t3.get$z(t00);
      t1 = t1[0];
      t1 = J.$add$ns(ray.origin, J.$mul$ns(ray.direction, t1));
      t3 = J.getInterceptor$x(t1);
      return J.$mul$ns(t2, new G.Point(t3.get$x(t1), t3.get$y(t1), t3.get$z(t1)).$sub(0, new G.Point(t4, t5, t00)).length$0(0));
    },
    HomogeneousVolumeRegion$6: function(sa, ss, gg, emit, e, v2w) {
      this.worldToVolume = G.Transform$(v2w.get$mInv(), v2w.m);
      this.sig_a = sa;
      this.sig_s = ss;
      this.g = gg;
      this.le = emit;
      this.extent = e;
    },
    static: {HomogeneousVolumeRegion_Create: [function(volume2world, params) {
        var t1 = new B.HomogeneousVolumeRegion(null, null, null, null, null, null);
        t1.HomogeneousVolumeRegion$6(params.findOneSpectrum$2("sigma_a", G.Spectrum_Spectrum(0)), params.findOneSpectrum$2("sigma_s", G.Spectrum_Spectrum(0)), params.findOneFloat$2("g", 0), params.findOneSpectrum$2("Le", G.Spectrum_Spectrum(0)), G.BBox$(params.findOnePoint$2("p0", new G.Point(0, 0, 0)), params.findOnePoint$2("p1", new G.Point(1, 1, 1))), volume2world);
        return t1;
      }, "call$2", "HomogeneousVolumeRegion_Create$closure", 4, 0, 83]}
  },
  VolumeGridDensity: {
    "^": "DensityRegion;_density,nx<,ny,nz@,extent,sig_a,sig_s,le,g,worldToVolume",
    worldBound$0: function() {
      var t1 = this.worldToVolume;
      return G.Transform$(t1.mInv, t1.m).transformBBox$1(this.extent);
    },
    intersectP$3: function(r, t00, t1) {
      var ray = this.worldToVolume.transformRay$1(r);
      return this.extent.intersectP$3(ray, t00, t1);
    },
    density$1: function(Pobj) {
      var t1, t2, t3, vox, vx, vy, vz, dx, dy, dz, t4, t5;
      if (!this.extent.inside$1(Pobj))
        return 0;
      t1 = this.extent;
      t2 = J.$div$n(J.$sub$n(Pobj.get$x(Pobj), t1.pMin.x), J.$sub$n(t1.pMax.x, t1.pMin.x));
      t3 = J.$div$n(J.$sub$n(Pobj.get$y(Pobj), t1.pMin.y), J.$sub$n(t1.pMax.y, t1.pMin.y));
      t1 = J.$div$n(J.$sub$n(Pobj.get$z(Pobj), t1.pMin.z), J.$sub$n(t1.pMax.z, t1.pMin.z));
      vox = new G.Vector(t2, t3, t1);
      t2 = J.$sub$n(J.$mul$ns(t2, this.nx), 0.5);
      vox.x = t2;
      t3 = J.$sub$n(J.$mul$ns(t3, this.ny), 0.5);
      vox.y = t3;
      t1 = J.$sub$n(J.$mul$ns(t1, this.nz), 0.5);
      vox.z = t1;
      vx = J.floor$0$n(t2);
      vy = J.floor$0$n(t3);
      vz = J.floor$0$n(t1);
      dx = t2 - vx;
      dy = t3 - vy;
      dz = t1 - vz;
      t1 = vx + 1;
      t3 = 1 - dx;
      t2 = vy + 1;
      t4 = vz + 1;
      t5 = 1 - dy;
      return (1 - dz) * (t5 * (t3 * this.d$3(vx, vy, vz) + dx * this.d$3(t1, vy, vz)) + dy * (t3 * this.d$3(vx, t2, vz) + dx * this.d$3(t1, t2, vz))) + dz * (t5 * (t3 * this.d$3(vx, vy, t4) + dx * this.d$3(t1, vy, t4)) + dy * (t3 * this.d$3(vx, t2, t4) + dx * this.d$3(t1, t2, t4)));
    },
    d$3: function(x, y, z) {
      var t1, t2, t3;
      x = C.JSInt_methods.clamp$2(x, 0, J.$sub$n(this.nx, 1));
      y = C.JSInt_methods.clamp$2(y, 0, J.$sub$n(this.ny, 1));
      z = C.JSInt_methods.clamp$2(z, 0, J.$sub$n(this.nz, 1));
      t1 = this._density;
      t2 = this.nx;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.ny;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t2 = z * t2 * t3 + y * t2 + x;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    static: {VolumeGridDensity_Create: [function(volume2world, params) {
        var sigma_a, sigma_s, g, Le, p0, p1, data, nx, ny, nz, t1, t2;
        sigma_a = params.findOneSpectrum$2("sigma_a", G.Spectrum_Spectrum(0));
        sigma_s = params.findOneSpectrum$2("sigma_s", G.Spectrum_Spectrum(0));
        g = params.findOneFloat$2("g", 0);
        Le = params.findOneSpectrum$2("Le", G.Spectrum_Spectrum(0));
        p0 = params.findOnePoint$2("p0", new G.Point(0, 0, 0));
        p1 = params.findOnePoint$2("p1", new G.Point(1, 1, 1));
        data = params.findFloat$1("density");
        if (data == null) {
          $.Log.call$2(2, "No 'density' values provided for volume grid?");
          return;
        }
        nx = params.findOneInt$2("nx", 1);
        ny = params.findOneInt$2("ny", 1);
        nz = params.findOneInt$2("nz", 1);
        t1 = J.getInterceptor$asx(data);
        t2 = J.getInterceptor$ns(nx);
        if (!J.$eq(t1.get$length(data), J.$mul$ns(t2.$mul(nx, ny), nz))) {
          t1 = "VolumeGridDensity has " + H.S(t1.get$length(data)) + " density values but nx*ny*nz = " + H.S(J.$mul$ns(t2.$mul(nx, ny), nz));
          $.Log.call$2(2, t1);
          return;
        }
        t1 = new B.VolumeGridDensity(null, nx, ny, nz, G.BBox$(p0, p1), G.Spectrum_Spectrum$from(sigma_a, 0), G.Spectrum_Spectrum$from(sigma_s, 0), G.Spectrum_Spectrum$from(Le, 0), g, G.Transform$(volume2world.get$mInv(), volume2world.m));
        t1._density = new Float64Array(H._ensureNativeList(data));
        return t1;
      }, "call$2", "VolumeGridDensity_Create$closure", 4, 0, 84]}
  }
}],
["", "web_isolate.dart", , M, {
  "^": "",
  main: [function(args, port) {
    var t1, t2, t3, t4, t5;
    t1 = new T.RenderManager(null, null, "scenes", [], [], P.LinkedHashMap_LinkedHashMap$_empty(null, null));
    $.ResourceManager_global = t1;
    t2 = U.TransformSet$();
    t3 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
    t4 = U.RenderOptions$();
    t5 = new U.GraphicsState(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), new G.ParamSet([], [], [], [], [], [], [], [], []), null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, new G.ParamSet([], [], [], [], [], [], [], [], []), "", null);
    t5.material = "matte";
    t5.reverseOrientation = false;
    U.Pbrt__registerStandardNodes();
    t1.pbrt = new U.Pbrt(t1, 1, t2, 3, t3, t4, t5, [], [], [], null, null);
    if (port != null) {
      t2 = new U.RenderIsolate(1, 2, 3, null, 0, 1, null, null, t1, C.C__JSRandom, P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      t1.isolate = t2;
      t2.start$1(0, port);
    }
  }, "call$2", "main$closure", 4, 0, 85]
},
1],
]);
Isolate.$finishClasses($$, $, null);
$$ = null;

// Runtime type support
J.JSDouble.$isdouble = true;
J.JSDouble.$isComparable = true;
J.JSDouble.$asComparable = [J.JSNumber];
J.JSDouble.$isComparable = true;
J.JSDouble.$asComparable = [J.JSNumber];
J.JSDouble.$isObject = true;
J.JSInt.$isint = true;
J.JSInt.$isComparable = true;
J.JSInt.$asComparable = [J.JSNumber];
J.JSInt.$isComparable = true;
J.JSInt.$asComparable = [J.JSNumber];
J.JSInt.$isComparable = true;
J.JSInt.$asComparable = [J.JSNumber];
J.JSInt.$isObject = true;
W.Node.$isNode = true;
W.Node.$isObject = true;
J.JSString.$isString = true;
J.JSString.$isPattern = true;
J.JSString.$isComparable = true;
J.JSString.$asComparable = [J.JSString];
J.JSString.$isObject = true;
J.JSNumber.$isComparable = true;
J.JSNumber.$asComparable = [J.JSNumber];
J.JSNumber.$isObject = true;
P.Duration.$isDuration = true;
P.Duration.$isComparable = true;
P.Duration.$asComparable = [P.Duration];
P.Duration.$isObject = true;
W.Element.$isElement = true;
W.Element.$isNode = true;
W.Element.$isObject = true;
G.OutputImage.$isObject = true;
J.JSArray.$isList = true;
J.JSArray.$isObject = true;
W.HttpRequest.$isObject = true;
W.ProgressEvent.$isObject = true;
J.JSBool.$isbool = true;
J.JSBool.$isObject = true;
G.Spectrum.$isSpectrum = true;
G.Spectrum.$isObject = true;
G.Vector.$isVector = true;
G.Vector.$isObject = true;
G.Normal.$isNormal = true;
G.Normal.$isVector = true;
G.Normal.$isObject = true;
G.Point.$isPoint = true;
G.Point.$isVector = true;
G.Point.$isObject = true;
G.Transform.$isTransform = true;
G.Transform.$isObject = true;
G.Primitive.$isPrimitive = true;
G.Primitive.$isObject = true;
G.Light.$isObject = true;
E._LinearBVHNode.$isObject = true;
E._BVHBucketInfo.$isObject = true;
Y._PathVertex.$isObject = true;
Y._MLTSample.$isObject = true;
Y._PathSample.$isObject = true;
Y._LightingSample.$isObject = true;
G.RayDifferential.$isRay = true;
G.RayDifferential.$isObject = true;
G.Intersection.$isObject = true;
P.Float32List.$isObject = true;
G.Sample.$isObject = true;
G.LightSampleOffsets.$isObject = true;
G.BSDFSampleOffsets.$isObject = true;
G.SpectrumImage.$isSpectrumImage = true;
G.SpectrumImage.$isObject = true;
G._ResampleWeight.$isObject = true;
P.Uint32List.$isUint32List = true;
P.Uint32List.$isObject = true;
U.ExrHufDec.$isObject = true;
U._PizChannelData.$isObject = true;
U.VP8BitReader.$isObject = true;
U.VP8QuantMatrix.$isObject = true;
U._HuffmanTree.$isObject = true;
U._HTreeGroup.$isObject = true;
U.VP8FInfo.$isObject = true;
U.VP8TopSamples.$isObject = true;
U.VP8MB.$isObject = true;
U.VP8MBData.$isObject = true;
U.VP8BandProbas.$isObject = true;
P.Uint8List.$isUint8List = true;
P.Uint8List.$isObject = true;
M._SDVertex.$isObject = true;
M._SDFace.$isObject = true;
G.BxDF.$isBxDF = true;
G.BxDF.$isObject = true;
G._KdNode.$isObject = true;
U.ClosePhoton.$isObject = true;
G._OctreeNode.$isObject = true;
U._VirtualLight.$isObject = true;
E._KdToDo.$isObject = true;
G.BBox.$isBBox = true;
G.BBox.$isObject = true;
E._BoundEdge.$isObject = true;
E._KdAccelNode.$isObject = true;
E._Voxel.$isObject = true;
H.RawReceivePortImpl.$isObject = true;
H._IsolateEvent.$isObject = true;
H._IsolateContext.$isObject = true;
P.Symbol.$isSymbol = true;
P.Symbol.$isObject = true;
P.StackTrace.$isStackTrace = true;
P.StackTrace.$isObject = true;
U.Image.$isImage = true;
U.Image.$isObject = true;
P.Object.$isObject = true;
E._BVHPrimitiveInfo.$is_BVHPrimitiveInfo = true;
E._BVHPrimitiveInfo.$isObject = true;
G.IrregIsotropicBRDFSample.$isIrregIsotropicBRDFSample = true;
G.IrregIsotropicBRDFSample.$isObject = true;
U.Photon.$isPhoton = true;
U.Photon.$isObject = true;
U.RadiancePhoton.$isRadiancePhoton = true;
U.RadiancePhoton.$isObject = true;
U.IrradianceSample.$isIrradianceSample = true;
U.IrradianceSample.$isObject = true;
P.SendPort.$isSendPort = true;
P.SendPort.$isCapability = true;
P.SendPort.$isObject = true;
P.Comparable.$isComparable = true;
P.Comparable.$isObject = true;
E.BVHAccel.$isBVHAccel = true;
E.BVHAccel.$isPrimitive = true;
E.BVHAccel.$isObject = true;
G.ParamSet.$isParamSet = true;
G.ParamSet.$isObject = true;
E.GridAccel.$isGridAccel = true;
E.GridAccel.$isPrimitive = true;
E.GridAccel.$isObject = true;
E.KdTreeAccel.$isKdTreeAccel = true;
E.KdTreeAccel.$isPrimitive = true;
E.KdTreeAccel.$isObject = true;
E.BruteForceAccel.$isBruteForceAccel = true;
E.BruteForceAccel.$isPrimitive = true;
E.BruteForceAccel.$isObject = true;
K.EnvironmentCamera.$isEnvironmentCamera = true;
K.EnvironmentCamera.$isCamera = true;
K.EnvironmentCamera.$isObject = true;
G.AnimatedTransform.$isAnimatedTransform = true;
G.AnimatedTransform.$isObject = true;
G.Film.$isFilm = true;
G.Film.$isObject = true;
K.OrthographicCamera.$isOrthographicCamera = true;
K.OrthographicCamera.$isCamera = true;
K.OrthographicCamera.$isObject = true;
K.PerspectiveCamera.$isPerspectiveCamera = true;
K.PerspectiveCamera.$isCamera = true;
K.PerspectiveCamera.$isObject = true;
R.ImageFilm.$isImageFilm = true;
R.ImageFilm.$isFilm = true;
R.ImageFilm.$isObject = true;
G.Filter.$isFilter = true;
G.Filter.$isObject = true;
S.BoxFilter.$isBoxFilter = true;
S.BoxFilter.$isFilter = true;
S.BoxFilter.$isObject = true;
S.GaussianFilter.$isGaussianFilter = true;
S.GaussianFilter.$isFilter = true;
S.GaussianFilter.$isObject = true;
S.LanczosSincFilter.$isLanczosSincFilter = true;
S.LanczosSincFilter.$isFilter = true;
S.LanczosSincFilter.$isObject = true;
S.MitchellFilter.$isMitchellFilter = true;
S.MitchellFilter.$isFilter = true;
S.MitchellFilter.$isObject = true;
S.TriangleFilter.$isTriangleFilter = true;
S.TriangleFilter.$isFilter = true;
S.TriangleFilter.$isObject = true;
U.AmbientOcclusionIntegrator.$isAmbientOcclusionIntegrator = true;
U.AmbientOcclusionIntegrator.$isObject = true;
U.DiffusePRTIntegrator.$isDiffusePRTIntegrator = true;
U.DiffusePRTIntegrator.$isObject = true;
U.DirectLightingIntegrator.$isDirectLightingIntegrator = true;
U.DirectLightingIntegrator.$isObject = true;
U.GlossyPRTIntegrator.$isGlossyPRTIntegrator = true;
U.GlossyPRTIntegrator.$isObject = true;
U.IGIIntegrator.$isIGIIntegrator = true;
U.IGIIntegrator.$isObject = true;
U.IrradianceCacheIntegrator.$isIrradianceCacheIntegrator = true;
U.IrradianceCacheIntegrator.$isObject = true;
U.PathIntegrator.$isPathIntegrator = true;
U.PathIntegrator.$isObject = true;
U.PhotonMapIntegrator.$isPhotonMapIntegrator = true;
U.PhotonMapIntegrator.$isObject = true;
U.WhittedIntegrator.$isWhittedIntegrator = true;
U.WhittedIntegrator.$isObject = true;
O.DistantLight.$isDistantLight = true;
O.DistantLight.$isObject = true;
O.PointLight.$isPointLight = true;
O.PointLight.$isObject = true;
O.SpotLight.$isSpotLight = true;
O.SpotLight.$isObject = true;
O.InfiniteAreaLight.$isInfiniteAreaLight = true;
O.InfiniteAreaLight.$isObject = true;
O.GoniometricLight.$isGoniometricLight = true;
O.GoniometricLight.$isObject = true;
O.ProjectionLight.$isProjectionLight = true;
O.ProjectionLight.$isObject = true;
O.DiffuseAreaLight.$isDiffuseAreaLight = true;
O.DiffuseAreaLight.$isObject = true;
G.Shape.$isShape = true;
G.Shape.$isObject = true;
D.GlassMaterial.$isGlassMaterial = true;
D.GlassMaterial.$isObject = true;
G.TextureParams.$isTextureParams = true;
G.TextureParams.$isObject = true;
D.KdSubsurfaceMaterial.$isKdSubsurfaceMaterial = true;
D.KdSubsurfaceMaterial.$isObject = true;
D.MatteMaterial.$isMatteMaterial = true;
D.MatteMaterial.$isObject = true;
D.MeasuredMaterial.$isMeasuredMaterial = true;
D.MeasuredMaterial.$isObject = true;
D.MetalMaterial.$isMetalMaterial = true;
D.MetalMaterial.$isObject = true;
D.MirrorMaterial.$isMirrorMaterial = true;
D.MirrorMaterial.$isObject = true;
D.PlasticMaterial.$isPlasticMaterial = true;
D.PlasticMaterial.$isObject = true;
D.ShinyMetalMaterial.$isShinyMetalMaterial = true;
D.ShinyMetalMaterial.$isObject = true;
D.SubstrateMaterial.$isSubstrateMaterial = true;
D.SubstrateMaterial.$isObject = true;
D.SubsurfaceMaterial.$isSubsurfaceMaterial = true;
D.SubsurfaceMaterial.$isObject = true;
D.TranslucentMaterial.$isTranslucentMaterial = true;
D.TranslucentMaterial.$isObject = true;
D.UberMaterial.$isUberMaterial = true;
D.UberMaterial.$isObject = true;
U.AdaptiveSampler.$isAdaptiveSampler = true;
U.AdaptiveSampler.$isObject = true;
G.Camera.$isCamera = true;
G.Camera.$isObject = true;
U.BestCandidateSampler.$isBestCandidateSampler = true;
U.BestCandidateSampler.$isObject = true;
U.HaltonSampler.$isHaltonSampler = true;
U.HaltonSampler.$isObject = true;
U.LowDiscrepancySampler.$isLowDiscrepancySampler = true;
U.LowDiscrepancySampler.$isObject = true;
U.RandomSampler.$isRandomSampler = true;
U.RandomSampler.$isObject = true;
U.StratifiedSampler.$isStratifiedSampler = true;
U.StratifiedSampler.$isObject = true;
M.ConeShape.$isConeShape = true;
M.ConeShape.$isShape = true;
M.ConeShape.$isObject = true;
M.CylinderShape.$isCylinderShape = true;
M.CylinderShape.$isShape = true;
M.CylinderShape.$isObject = true;
M.DiskShape.$isDiskShape = true;
M.DiskShape.$isShape = true;
M.DiskShape.$isObject = true;
M.HyperboloidShape.$isHyperboloidShape = true;
M.HyperboloidShape.$isShape = true;
M.HyperboloidShape.$isObject = true;
M.LoopSubdivisionShape.$isLoopSubdivisionShape = true;
M.LoopSubdivisionShape.$isShape = true;
M.LoopSubdivisionShape.$isObject = true;
M.ParaboloidShape.$isParaboloidShape = true;
M.ParaboloidShape.$isShape = true;
M.ParaboloidShape.$isObject = true;
M.SphereShape.$isSphereShape = true;
M.SphereShape.$isShape = true;
M.SphereShape.$isObject = true;
M.TriangleMeshShape.$isTriangleMeshShape = true;
M.TriangleMeshShape.$isShape = true;
M.TriangleMeshShape.$isObject = true;
P.Map.$isMap = true;
P.Map.$isObject = true;
G.Texture.$isTexture = true;
G.Texture.$isObject = true;
G.BilerpTexture.$isBilerpTexture = true;
G.BilerpTexture.$isTexture = true;
G.BilerpTexture.$isObject = true;
G.DotsTexture.$isDotsTexture = true;
G.DotsTexture.$isTexture = true;
G.DotsTexture.$isObject = true;
G.FBmTexture.$isFBmTexture = true;
G.FBmTexture.$isTexture = true;
G.FBmTexture.$isObject = true;
G.ImageTexture.$isImageTexture = true;
G.ImageTexture.$isTexture = true;
G.ImageTexture.$isObject = true;
G.MarbleTexture.$isMarbleTexture = true;
G.MarbleTexture.$isTexture = true;
G.MarbleTexture.$isObject = true;
G.MixTexture.$isMixTexture = true;
G.MixTexture.$isTexture = true;
G.MixTexture.$isObject = true;
G.ScaleTexture.$isScaleTexture = true;
G.ScaleTexture.$isTexture = true;
G.ScaleTexture.$isObject = true;
G.UVTexture.$isUVTexture = true;
G.UVTexture.$isTexture = true;
G.UVTexture.$isObject = true;
G.WindyTexture.$isWindyTexture = true;
G.WindyTexture.$isTexture = true;
G.WindyTexture.$isObject = true;
G.WrinkledTexture.$isWrinkledTexture = true;
G.WrinkledTexture.$isTexture = true;
G.WrinkledTexture.$isObject = true;
S.EmissionIntegrator.$isEmissionIntegrator = true;
S.EmissionIntegrator.$isObject = true;
S.SingleScatteringIntegrator.$isSingleScatteringIntegrator = true;
S.SingleScatteringIntegrator.$isObject = true;
B.ExponentialDensityRegion.$isExponentialDensityRegion = true;
B.ExponentialDensityRegion.$isObject = true;
B.HomogeneousVolumeRegion.$isHomogeneousVolumeRegion = true;
B.HomogeneousVolumeRegion.$isObject = true;
B.VolumeGridDensity.$isVolumeGridDensity = true;
B.VolumeGridDensity.$isObject = true;
U.InputBuffer.$isInputBuffer = true;
U.InputBuffer.$isObject = true;
P._EventSink.$is_EventSink = true;
P._EventSink.$isObject = true;
P.Function.$isFunction = true;
P.Function.$isObject = true;
P.Capability.$isCapability = true;
P.Capability.$isObject = true;
P.Future.$isFuture = true;
P.Future.$isObject = true;
P.DateTime.$isDateTime = true;
P.DateTime.$isComparable = true;
P.DateTime.$asComparable = [null];
P.DateTime.$isObject = true;
P._DelayedEvent.$is_DelayedEvent = true;
P._DelayedEvent.$isObject = true;
P.StreamSubscription.$isStreamSubscription = true;
P.StreamSubscription.$isObject = true;
G.Quaternion.$isQuaternion = true;
G.Quaternion.$isObject = true;
U.JpegComponent.$isJpegComponent = true;
U.JpegComponent.$isObject = true;
G.Ray.$isRay = true;
G.Ray.$isObject = true;
P.Pattern.$isPattern = true;
P.Pattern.$isObject = true;
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$asx = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$ax = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$s = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$x = function(receiver) {
  if (receiver == null)
    return receiver;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$and$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver & a0) >>> 0;
  return J.getInterceptor$n(receiver).$and(receiver, a0);
};
J.$div$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver / a0;
  return J.getInterceptor$n(receiver).$div(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.$ge$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver >= a0;
  return J.getInterceptor$n(receiver).$ge(receiver, a0);
};
J.$gt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver > a0;
  return J.getInterceptor$n(receiver).$gt(receiver, a0);
};
J.$index$asx = function(receiver, a0) {
  if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
    if (a0 >>> 0 === a0 && a0 < receiver.length)
      return receiver[a0];
  return J.getInterceptor$asx(receiver).$index(receiver, a0);
};
J.$indexSet$ax = function(receiver, a0, a1) {
  if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
    return receiver[a0] = a1;
  return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
};
J.$le$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver <= a0;
  return J.getInterceptor$n(receiver).$le(receiver, a0);
};
J.$lt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver < a0;
  return J.getInterceptor$n(receiver).$lt(receiver, a0);
};
J.$mod$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$mod(receiver, a0);
};
J.$mul$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver * a0;
  return J.getInterceptor$ns(receiver).$mul(receiver, a0);
};
J.$negate$n = function(receiver) {
  if (typeof receiver == "number")
    return -receiver;
  return J.getInterceptor$n(receiver).$negate(receiver);
};
J.$or$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver | a0) >>> 0;
  return J.getInterceptor$n(receiver).$or(receiver, a0);
};
J.$sub$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver - a0;
  return J.getInterceptor$n(receiver).$sub(receiver, a0);
};
J.$tdiv$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$tdiv(receiver, a0);
};
J._replaceChild$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver)._replaceChild$2(receiver, a0, a1);
};
J.abs$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).abs$0(receiver);
};
J.add$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).add$1(receiver, a0);
};
J.addEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
};
J.ceil$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).ceil$0(receiver);
};
J.clamp$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).clamp$0(receiver);
};
J.clamp$2$n = function(receiver, a0, a1) {
  return J.getInterceptor$n(receiver).clamp$2(receiver, a0, a1);
};
J.compareTo$1$ns = function(receiver, a0) {
  return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
};
J.contains$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
};
J.contains$2$asx = function(receiver, a0, a1) {
  return J.getInterceptor$asx(receiver).contains$2(receiver, a0, a1);
};
J.elementAt$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
};
J.fillRange$3$ax = function(receiver, a0, a1, a2) {
  return J.getInterceptor$ax(receiver).fillRange$3(receiver, a0, a1, a2);
};
J.floor$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).floor$0(receiver);
};
J.forEach$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
};
J.get$alpha$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$alpha(receiver);
};
J.get$buffer$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$buffer(receiver);
};
J.get$children$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$children(receiver);
};
J.get$codeUnits$s = function(receiver) {
  return J.getInterceptor$s(receiver).get$codeUnits(receiver);
};
J.get$data$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$data(receiver);
};
J.get$error$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$error(receiver);
};
J.get$first$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$first(receiver);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$height$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$height(receiver);
};
J.get$id$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$id(receiver);
};
J.get$isEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
};
J.get$isInfinite$n = function(receiver) {
  return J.getInterceptor$n(receiver).get$isInfinite(receiver);
};
J.get$isNaN$n = function(receiver) {
  return J.getInterceptor$n(receiver).get$isNaN(receiver);
};
J.get$isNotEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
};
J.get$iterator$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$iterator(receiver);
};
J.get$length$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$length(receiver);
};
J.get$name$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$name(receiver);
};
J.get$origin$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$origin(receiver);
};
J.get$p$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$p(receiver);
};
J.get$path$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$path(receiver);
};
J.get$response$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$response(receiver);
};
J.get$size$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$size(receiver);
};
J.get$type$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$type(receiver);
};
J.get$width$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$width(receiver);
};
J.get$x$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$x(receiver);
};
J.get$y$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$y(receiver);
};
J.get$z$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$z(receiver);
};
J.length$0$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).length$0(receiver);
};
J.p$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).p$4(receiver, a0, a1, a2, a3);
};
J.remove$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).remove$0(receiver);
};
J.remove$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
};
J.removeEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).removeEventListener$3(receiver, a0, a1, a2);
};
J.replaceWith$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).replaceWith$1(receiver, a0);
};
J.round$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).round$0(receiver);
};
J.scale$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).scale$1(receiver, a0);
};
J.send$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).send$1(receiver, a0);
};
J.set$duration$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$duration(receiver, value);
};
J.set$length$asx = function(receiver, value) {
  return J.getInterceptor$asx(receiver).set$length(receiver, value);
};
J.set$offset$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$offset(receiver, value);
};
J.set$origin$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$origin(receiver, value);
};
J.setRange$3$ax = function(receiver, a0, a1, a2) {
  return J.getInterceptor$ax(receiver).setRange$3(receiver, a0, a1, a2);
};
J.setRange$4$ax = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$ax(receiver).setRange$4(receiver, a0, a1, a2, a3);
};
J.size$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).size$0(receiver);
};
J.sort$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).sort$1(receiver, a0);
};
J.sublist$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).sublist$2(receiver, a0, a1);
};
J.toDouble$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).toDouble$0(receiver);
};
J.toInt$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).toInt$0(receiver);
};
J.toList$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).toList$0(receiver);
};
J.toList$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).toList$2(receiver, a0, a1);
};
J.toLowerCase$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
J.trim$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).trim$0(receiver);
};
C.HttpRequest_methods = W.HttpRequest.prototype;
C.JSArray_methods = J.JSArray.prototype;
C.JSDouble_methods = J.JSDouble.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.NativeFloat32List_methods = H.NativeFloat32List.prototype;
C.NativeInt32List_methods = H.NativeInt32List.prototype;
C.NativeUint32List_methods = H.NativeUint32List.prototype;
C.NativeUint8List_methods = H.NativeUint8List.prototype;
C.NodeList_methods = W.NodeList.prototype;
C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
C.C_DynamicRuntimeType = new H.DynamicRuntimeType();
C.C_OutOfMemoryError = new P.OutOfMemoryError();
C.C__DelayedDone = new P._DelayedDone();
C.C__JSRandom = new P._JSRandom();
C.C__RootZone = new P._RootZone();
C.Duration_0 = new P.Duration(0);
C.EventStreamProvider_error = new W.EventStreamProvider("error");
C.EventStreamProvider_load = new W.EventStreamProvider("load");
C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
C.JS_CONST_IX5 = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string"
        && name !== ""
        && name !== "Object"
        && name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
C.JS_CONST_U4w = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
C.JS_CONST_aQP = function() {
  function typeNameInChrome(o) {
    var name = o.constructor.name;
    if (name) return name;
    var s = Object.prototype.toString.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = Object.prototype.toString.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: typeNameInChrome,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
C.JS_CONST_gkc = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
Isolate.makeConstantList = function(list) {
  list.immutable$list = init;
  list.fixed$length = init;
  return list;
};
C.List_0W6 = Isolate.makeConstantList([U.VP8Filter_DC8uv$closure(), U.VP8Filter_TM8uv$closure(), U.VP8Filter_VE8uv$closure(), U.VP8Filter_HE8uv$closure(), U.VP8Filter_DC8uvNoTop$closure(), U.VP8Filter_DC8uvNoLeft$closure(), U.VP8Filter_DC8uvNoTopLeft$closure()]);
C.List_0_2567483615 = Isolate.makeConstantList([0, 2567483615]);
C.List_0_2_8 = Isolate.makeConstantList([0, 2, 8]);
C.List_0_4_2_1 = Isolate.makeConstantList([0, 4, 2, 1]);
C.List_1_2_0 = Isolate.makeConstantList([1, 2, 0]);
C.List_292_260_226_226 = Isolate.makeConstantList([292, 260, 226, 226]);
C.List_2Bc = Isolate.makeConstantList([8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8]);
C.List_2Vk = Isolate.makeConstantList([137, 80, 78, 71, 13, 10, 26, 10]);
C.List_2Vk0 = Isolate.makeConstantList([2, 1, 2, 1, 2, 2, 0, 0]);
C.List_2_3_7 = Isolate.makeConstantList([2, 3, 7]);
C.List_2jN = Isolate.makeConstantList([151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180, 151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]);
C.List_3_3_11 = Isolate.makeConstantList([3, 3, 11]);
C.List_511_1023_2047_4095 = Isolate.makeConstantList([511, 1023, 2047, 4095]);
C.List_65X = Isolate.makeConstantList([0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 272, 288, 304, 320, 336, 352, 368, 384, 400, 416, 432, 448, 464, 480, 496, 512, 528, 544, 560, 576, 592, 608, 624, 640, 656, 672, 688, 704, 720, 736, 752, 768, 784, 800, 816, 832, 848, 864, 880, 896, 912, 928, 944, 960, 976, 992, 1008, 1024, 1040, 1056, 1072, 1088, 1104, 1120, 1136, 1152, 1168, 1184, 1200, 1216, 1232, 1248, 1264, 1280, 1296, 1312, 1328, 1344, 1360, 1376, 1392, 1408, 1424, 1440, 1456, 1472, 1488, 1504, 1520, 1536, 1552, 1568, 1584, 1600, 1616, 1632, 1648, 1664, 1680, 1696, 1712, 1728, 1744, 1760, 1776, 1792, 1808, 1824, 1840, 1856, 1872, 1888, 1904, 1920, 1936, 1952, 1968, 1984, 2000, 2016, 2032, 2048, 2064, 2080, 2096, 2112, 2128, 2144, 2160, 2176, 2192, 2208, 2224, 2240, 2256, 2272, 2288, 2304, 2320, 2336, 2352, 2368, 2384, 2400, 2416, 2432, 2448, 2464, 2480, 2496, 2512, 2528, 2544, 2560, 2576, 2592, 2608, 2624, 2640, 2656, 2672, 2688, 2704, 2720, 2736, 2752, 2768, 2784, 2800, 2816, 2832, 2848, 2864, 2880, 2896, 2912, 2928, 2944, 2960, 2976, 2992, 3008, 3024, 3040, 3056, 3072, 3088, 3104, 3120, 3136, 3152, 3168, 3184, 3200, 3216, 3232, 3248, 3264, 3280, 3296, 3312, 3328, 3344, 3360, 3376, 3392, 3408, 3424, 3440, 3456, 3472, 3488, 3504, 3520, 3536, 3552, 3568, 3584, 3600, 3616, 3632, 3648, 3664, 3680, 3696, 3712, 3728, 3744, 3760, 3776, 3792, 3808, 3824, 3840, 3856, 3872, 3888, 3904, 3920, 3936, 3952, 3968, 3984, 4000, 4016, 4032, 4048, 4064, 4080]);
C.List_U2p = Isolate.makeConstantList([231, 120, 48, 89, 115, 113, 120, 152, 112]);
C.List_yXZ = Isolate.makeConstantList([152, 179, 64, 126, 170, 118, 46, 70, 95]);
C.List_yXZ0 = Isolate.makeConstantList([175, 69, 143, 80, 85, 82, 72, 155, 103]);
C.List_yXZ1 = Isolate.makeConstantList([56, 58, 10, 171, 218, 189, 17, 13, 152]);
C.List_yXZ2 = Isolate.makeConstantList([114, 26, 17, 163, 44, 195, 21, 10, 173]);
C.List_yXZ3 = Isolate.makeConstantList([121, 24, 80, 195, 26, 62, 44, 64, 85]);
C.List_yXZ4 = Isolate.makeConstantList([144, 71, 10, 38, 171, 213, 144, 34, 26]);
C.List_yXZ5 = Isolate.makeConstantList([170, 46, 55, 19, 136, 160, 33, 206, 71]);
C.List_yXZ6 = Isolate.makeConstantList([63, 20, 8, 114, 114, 208, 12, 9, 226]);
C.List_yXZ7 = Isolate.makeConstantList([81, 40, 11, 96, 182, 84, 29, 16, 36]);
C.List_sty0 = Isolate.makeConstantList([C.List_U2p, C.List_yXZ, C.List_yXZ0, C.List_yXZ1, C.List_yXZ2, C.List_yXZ3, C.List_yXZ4, C.List_yXZ5, C.List_yXZ6, C.List_yXZ7]);
C.List_yXZ8 = Isolate.makeConstantList([134, 183, 89, 137, 98, 101, 106, 165, 148]);
C.List_yXZ9 = Isolate.makeConstantList([72, 187, 100, 130, 157, 111, 32, 75, 80]);
C.List_yXZ10 = Isolate.makeConstantList([66, 102, 167, 99, 74, 62, 40, 234, 128]);
C.List_kfn = Isolate.makeConstantList([41, 53, 9, 178, 241, 141, 26, 8, 107]);
C.List_yXZ11 = Isolate.makeConstantList([74, 43, 26, 146, 73, 166, 49, 23, 157]);
C.List_yXZ12 = Isolate.makeConstantList([65, 38, 105, 160, 51, 52, 31, 115, 128]);
C.List_eDA = Isolate.makeConstantList([104, 79, 12, 27, 217, 255, 87, 17, 7]);
C.List_yXZ13 = Isolate.makeConstantList([87, 68, 71, 44, 114, 51, 15, 186, 23]);
C.List_yXZ14 = Isolate.makeConstantList([47, 41, 14, 110, 182, 183, 21, 17, 194]);
C.List_yXZ15 = Isolate.makeConstantList([66, 45, 25, 102, 197, 189, 23, 18, 22]);
C.List_L3W = Isolate.makeConstantList([C.List_yXZ8, C.List_yXZ9, C.List_yXZ10, C.List_kfn, C.List_yXZ11, C.List_yXZ12, C.List_eDA, C.List_yXZ13, C.List_yXZ14, C.List_yXZ15]);
C.List_yXZ16 = Isolate.makeConstantList([88, 88, 147, 150, 42, 46, 45, 196, 205]);
C.List_yXZ17 = Isolate.makeConstantList([43, 97, 183, 117, 85, 38, 35, 179, 61]);
C.List_yXZ18 = Isolate.makeConstantList([39, 53, 200, 87, 26, 21, 43, 232, 171]);
C.List_yXZ19 = Isolate.makeConstantList([56, 34, 51, 104, 114, 102, 29, 93, 77]);
C.List_yXZ20 = Isolate.makeConstantList([39, 28, 85, 171, 58, 165, 90, 98, 64]);
C.List_yXZ21 = Isolate.makeConstantList([34, 22, 116, 206, 23, 34, 43, 166, 73]);
C.List_yXZ22 = Isolate.makeConstantList([107, 54, 32, 26, 51, 1, 81, 43, 31]);
C.List_yXZ23 = Isolate.makeConstantList([68, 25, 106, 22, 64, 171, 36, 225, 114]);
C.List_yXZ24 = Isolate.makeConstantList([34, 19, 21, 102, 132, 188, 16, 76, 124]);
C.List_yXZ25 = Isolate.makeConstantList([62, 18, 78, 95, 85, 57, 50, 48, 51]);
C.List_ECY = Isolate.makeConstantList([C.List_yXZ16, C.List_yXZ17, C.List_yXZ18, C.List_yXZ19, C.List_yXZ20, C.List_yXZ21, C.List_yXZ22, C.List_yXZ23, C.List_yXZ24, C.List_yXZ25]);
C.List_yXZ26 = Isolate.makeConstantList([193, 101, 35, 159, 215, 111, 89, 46, 111]);
C.List_yXZ27 = Isolate.makeConstantList([60, 148, 31, 172, 219, 228, 21, 18, 111]);
C.List_eDA0 = Isolate.makeConstantList([112, 113, 77, 85, 179, 255, 38, 120, 114]);
C.List_kfn0 = Isolate.makeConstantList([40, 42, 1, 196, 245, 209, 10, 25, 109]);
C.List_yXZ28 = Isolate.makeConstantList([88, 43, 29, 140, 166, 213, 37, 43, 154]);
C.List_yXZ29 = Isolate.makeConstantList([61, 63, 30, 155, 67, 45, 68, 1, 209]);
C.List_yXZ30 = Isolate.makeConstantList([100, 80, 8, 43, 154, 1, 51, 26, 71]);
C.List_kfn1 = Isolate.makeConstantList([142, 78, 78, 16, 255, 128, 34, 197, 171]);
C.List_yXZ31 = Isolate.makeConstantList([41, 40, 5, 102, 211, 183, 4, 1, 221]);
C.List_yXZ32 = Isolate.makeConstantList([51, 50, 17, 168, 209, 192, 23, 25, 82]);
C.List_JO4 = Isolate.makeConstantList([C.List_yXZ26, C.List_yXZ27, C.List_eDA0, C.List_kfn0, C.List_yXZ28, C.List_yXZ29, C.List_yXZ30, C.List_kfn1, C.List_yXZ31, C.List_yXZ32]);
C.List_knt1 = Isolate.makeConstantList([138, 31, 36, 171, 27, 166, 38, 44, 229]);
C.List_yXZ33 = Isolate.makeConstantList([67, 87, 58, 169, 82, 115, 26, 59, 179]);
C.List_yXZ34 = Isolate.makeConstantList([63, 59, 90, 180, 59, 166, 93, 73, 154]);
C.List_yXZ35 = Isolate.makeConstantList([40, 40, 21, 116, 143, 209, 34, 39, 175]);
C.List_yXZ36 = Isolate.makeConstantList([47, 15, 16, 183, 34, 223, 49, 45, 183]);
C.List_yXZ37 = Isolate.makeConstantList([46, 17, 33, 183, 6, 98, 15, 32, 183]);
C.List_yXZ38 = Isolate.makeConstantList([57, 46, 22, 24, 128, 1, 54, 17, 37]);
C.List_yXZ39 = Isolate.makeConstantList([65, 32, 73, 115, 28, 128, 23, 128, 205]);
C.List_yXZ40 = Isolate.makeConstantList([40, 3, 9, 115, 51, 192, 18, 6, 223]);
C.List_yXZ41 = Isolate.makeConstantList([87, 37, 9, 115, 59, 77, 64, 21, 47]);
C.List_wEo = Isolate.makeConstantList([C.List_knt1, C.List_yXZ33, C.List_yXZ34, C.List_yXZ35, C.List_yXZ36, C.List_yXZ37, C.List_yXZ38, C.List_yXZ39, C.List_yXZ40, C.List_yXZ41]);
C.List_yXZ42 = Isolate.makeConstantList([104, 55, 44, 218, 9, 54, 53, 130, 226]);
C.List_yXZ43 = Isolate.makeConstantList([64, 90, 70, 205, 40, 41, 23, 26, 57]);
C.List_yXZ44 = Isolate.makeConstantList([54, 57, 112, 184, 5, 41, 38, 166, 213]);
C.List_yXZ45 = Isolate.makeConstantList([30, 34, 26, 133, 152, 116, 10, 32, 134]);
C.List_knt2 = Isolate.makeConstantList([39, 19, 53, 221, 26, 114, 32, 73, 255]);
C.List_yXZ46 = Isolate.makeConstantList([31, 9, 65, 234, 2, 15, 1, 118, 73]);
C.List_eDA1 = Isolate.makeConstantList([75, 32, 12, 51, 192, 255, 160, 43, 51]);
C.List_yXZ47 = Isolate.makeConstantList([88, 31, 35, 67, 102, 85, 55, 186, 85]);
C.List_yXZ48 = Isolate.makeConstantList([56, 21, 23, 111, 59, 205, 45, 37, 192]);
C.List_yXZ49 = Isolate.makeConstantList([55, 38, 70, 124, 73, 102, 1, 34, 98]);
C.List_0 = Isolate.makeConstantList([C.List_yXZ42, C.List_yXZ43, C.List_yXZ44, C.List_yXZ45, C.List_knt2, C.List_yXZ46, C.List_eDA1, C.List_yXZ47, C.List_yXZ48, C.List_yXZ49]);
C.List_yXZ50 = Isolate.makeConstantList([125, 98, 42, 88, 104, 85, 117, 175, 82]);
C.List_yXZ51 = Isolate.makeConstantList([95, 84, 53, 89, 128, 100, 113, 101, 45]);
C.List_yXZ52 = Isolate.makeConstantList([75, 79, 123, 47, 51, 128, 81, 171, 1]);
C.List_yXZ53 = Isolate.makeConstantList([57, 17, 5, 71, 102, 57, 53, 41, 49]);
C.List_yXZ54 = Isolate.makeConstantList([38, 33, 13, 121, 57, 73, 26, 1, 85]);
C.List_yXZ55 = Isolate.makeConstantList([41, 10, 67, 138, 77, 110, 90, 47, 114]);
C.List_eDA2 = Isolate.makeConstantList([115, 21, 2, 10, 102, 255, 166, 23, 6]);
C.List_yXZ56 = Isolate.makeConstantList([101, 29, 16, 10, 85, 128, 101, 196, 26]);
C.List_yXZ57 = Isolate.makeConstantList([57, 18, 10, 102, 102, 213, 34, 20, 43]);
C.List_yXZ58 = Isolate.makeConstantList([117, 20, 15, 36, 163, 128, 68, 1, 26]);
C.List_a5W = Isolate.makeConstantList([C.List_yXZ50, C.List_yXZ51, C.List_yXZ52, C.List_yXZ53, C.List_yXZ54, C.List_yXZ55, C.List_eDA2, C.List_yXZ56, C.List_yXZ57, C.List_yXZ58]);
C.List_h47 = Isolate.makeConstantList([102, 61, 71, 37, 34, 53, 31, 243, 192]);
C.List_yXZ59 = Isolate.makeConstantList([69, 60, 71, 38, 73, 119, 28, 222, 37]);
C.List_h470 = Isolate.makeConstantList([68, 45, 128, 34, 1, 47, 11, 245, 171]);
C.List_yXZ60 = Isolate.makeConstantList([62, 17, 19, 70, 146, 85, 55, 62, 70]);
C.List_yXZ61 = Isolate.makeConstantList([37, 43, 37, 154, 100, 163, 85, 160, 1]);
C.List_yXZ62 = Isolate.makeConstantList([63, 9, 92, 136, 28, 64, 32, 201, 85]);
C.List_eDA3 = Isolate.makeConstantList([75, 15, 9, 9, 64, 255, 184, 119, 16]);
C.List_eDA4 = Isolate.makeConstantList([86, 6, 28, 5, 64, 255, 25, 248, 1]);
C.List_eDA5 = Isolate.makeConstantList([56, 8, 17, 132, 137, 255, 55, 116, 128]);
C.List_yXZ63 = Isolate.makeConstantList([58, 15, 20, 82, 135, 57, 26, 121, 40]);
C.List_6oq = Isolate.makeConstantList([C.List_h47, C.List_yXZ59, C.List_h470, C.List_yXZ60, C.List_yXZ61, C.List_yXZ62, C.List_eDA3, C.List_eDA4, C.List_eDA5, C.List_yXZ63]);
C.List_yXZ64 = Isolate.makeConstantList([164, 50, 31, 137, 154, 133, 25, 35, 218]);
C.List_yXZ65 = Isolate.makeConstantList([51, 103, 44, 131, 131, 123, 31, 6, 158]);
C.List_yXZ66 = Isolate.makeConstantList([86, 40, 64, 135, 148, 224, 45, 183, 128]);
C.List_yXZ67 = Isolate.makeConstantList([22, 26, 17, 131, 240, 154, 14, 1, 209]);
C.List_yXZ68 = Isolate.makeConstantList([45, 16, 21, 91, 64, 222, 7, 1, 197]);
C.List_yXZ69 = Isolate.makeConstantList([56, 21, 39, 155, 60, 138, 23, 102, 213]);
C.List_eDA6 = Isolate.makeConstantList([83, 12, 13, 54, 192, 255, 68, 47, 28]);
C.List_yXZ70 = Isolate.makeConstantList([85, 26, 85, 85, 128, 128, 32, 146, 171]);
C.List_yXZ71 = Isolate.makeConstantList([18, 11, 7, 63, 144, 171, 4, 4, 246]);
C.List_yXZ72 = Isolate.makeConstantList([35, 27, 10, 146, 174, 171, 12, 26, 128]);
C.List_a5W0 = Isolate.makeConstantList([C.List_yXZ64, C.List_yXZ65, C.List_yXZ66, C.List_yXZ67, C.List_yXZ68, C.List_yXZ69, C.List_eDA6, C.List_yXZ70, C.List_yXZ71, C.List_yXZ72]);
C.List_yXZ73 = Isolate.makeConstantList([190, 80, 35, 99, 180, 80, 126, 54, 45]);
C.List_yXZ74 = Isolate.makeConstantList([85, 126, 47, 87, 176, 51, 41, 20, 32]);
C.List_yXZ75 = Isolate.makeConstantList([101, 75, 128, 139, 118, 146, 116, 128, 85]);
C.List_yXZ76 = Isolate.makeConstantList([56, 41, 15, 176, 236, 85, 37, 9, 62]);
C.List_eDA7 = Isolate.makeConstantList([71, 30, 17, 119, 118, 255, 17, 18, 138]);
C.List_yXZ77 = Isolate.makeConstantList([101, 38, 60, 138, 55, 70, 43, 26, 142]);
C.List_eDA8 = Isolate.makeConstantList([146, 36, 19, 30, 171, 255, 97, 27, 20]);
C.List_yXZ78 = Isolate.makeConstantList([138, 45, 61, 62, 219, 1, 81, 188, 64]);
C.List_yXZ79 = Isolate.makeConstantList([32, 41, 20, 117, 151, 142, 20, 21, 163]);
C.List_yXZ80 = Isolate.makeConstantList([112, 19, 12, 61, 195, 128, 48, 4, 24]);
C.List_RrN = Isolate.makeConstantList([C.List_yXZ73, C.List_yXZ74, C.List_yXZ75, C.List_yXZ76, C.List_eDA7, C.List_yXZ77, C.List_eDA8, C.List_yXZ78, C.List_yXZ79, C.List_yXZ80]);
C.List_799 = Isolate.makeConstantList([C.List_sty0, C.List_L3W, C.List_ECY, C.List_JO4, C.List_wEo, C.List_0, C.List_a5W, C.List_6oq, C.List_a5W0, C.List_RrN]);
C.List_89P = Isolate.makeConstantList([3226, 6412, 200, 168, 38, 38, 134, 134, 100, 100, 100, 100, 68, 68, 68, 68]);
C.List_8_8_4_2 = Isolate.makeConstantList([8, 8, 4, 2]);
C.List_8aB = Isolate.makeConstantList([U.VP8Filter_DC16$closure(), U.VP8Filter_TM16$closure(), U.VP8Filter_VE16$closure(), U.VP8Filter_HE16$closure(), U.VP8Filter_DC16NoTop$closure(), U.VP8Filter_DC16NoLeft$closure(), U.VP8Filter_DC16NoTopLeft$closure()]);
C.List_8co = Isolate.makeConstantList([80, 88, 23, 71, 30, 30, 62, 62, 4, 4, 4, 4, 4, 4, 4, 4, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41]);
C.List_8co0 = Isolate.makeConstantList([7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]);
C.List_8co1 = Isolate.makeConstantList([4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157]);
C.List_AIB = Isolate.makeConstantList([1.400313, 1.38, 1.358438, 1.34, 1.329063, 1.325, 1.3325, 1.34, 1.334375, 1.325, 1.317812, 1.31, 1.300313, 1.29, 1.281563, 1.27, 1.249062, 1.225, 1.2, 1.18, 1.174375, 1.175, 1.1775, 1.18, 1.178125, 1.175, 1.172812, 1.17, 1.165312, 1.16, 1.155312, 1.15, 1.142812, 1.135, 1.131562, 1.12, 1.092437, 1.04, 0.950375, 0.826, 0.645875, 0.468, 0.35125, 0.272, 0.230813, 0.214, 0.20925, 0.213, 0.21625, 0.223, 0.2365, 0.25, 0.254188, 0.26, 0.28, 0.3]);
C.List_AYZ = Isolate.makeConstantList([24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112]);
C.List_AZw = Isolate.makeConstantList([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63]);
C.List_AiM = Isolate.makeConstantList([4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284]);
C.List_B8J = Isolate.makeConstantList([0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117]);
C.List_DFB = Isolate.makeConstantList([1.041462802142675, 1.0328661533771188, 1.0126146228964314, 1.035046052483621, 1.0078661447098567, 1.042228038508128, 1.0442596738499825, 1.0535238290294409, 1.018077622693812, 1.0442729908727713, 1.052936254192075, 1.0537034271160244, 1.053390186921597, 1.0537782700979574, 1.0527093770467102, 1.0530449040446797, 1.0550554640191208, 1.055367361072482, 1.0454306634683976, 0.623489506392308, 0.18038071613188977, -0.007630375920198454, -0.00015217847035781367, -0.007510225734725831, -0.002170863932849147, 0.0006591946660236964, 0.01227881531853978, -0.004466977563720803, 0.017119799082865147, 0.00492110897597598, 0.0058762925143334985, 0.02525939941555008]);
C.List_DKo = Isolate.makeConstantList([0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647, 4294967295]);
C.List_F1L = Isolate.makeConstantList([0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0]);
C.List_HHa = Isolate.makeConstantList([null, U.WebPFilters_horizontalUnfilter$closure(), U.WebPFilters_verticalUnfilter$closure(), U.WebPFilters_gradientUnfilter$closure()]);
C.List_KEl = Isolate.makeConstantList([380, 390.967743, 401.935486, 412.903229, 423.870972, 434.838715, 445.806458, 456.7742, 467.741943, 478.709686, 489.677429, 500.645172, 511.612915, 522.580627, 533.54834, 544.516052, 555.483765, 566.451477, 577.419189, 588.386902, 599.354614, 610.322327, 621.290039, 632.257751, 643.225464, 654.193176, 665.160889, 676.128601, 687.096313, 698.064026, 709.031738, 720]);
C.List_LkP = Isolate.makeConstantList([0.002775695896581197, 0.003967382099064661, -0.0001460693678860675, 0.00036198394557748065, -0.00025819258699309733, -0.000050133191628082274, -0.00024437242866157116, -0.00007806141994803895, 0.04969030120754092, 0.48515973574763166, 1.029572585436059, 1.0333210878457741, 1.0368102644026933, 1.0364884018886333, 1.0365427939411784, 1.036859540285454, 1.0365645405660555, 1.0363938240707142, 1.0367205578770746, 1.036523932944605, 1.0361531226427443, 1.0348785007827348, 1.0042729660717318, 0.8421848643235428, 0.7375939489480157, 0.6585315450029464, 0.6053168244406628, 0.5954979413242074, 0.5941926127844314, 0.5651768232663427, 0.5606118601496856, 0.5822861038101872]);
C.List_Ls5 = Isolate.makeConstantList([0.9920977146972068, 0.9887642605936913, 0.9953904074450564, 0.9952931735300822, 0.9918144741163395, 1.0002584039673432, 0.9996847843734251, 0.9998812076665717, 0.9850401214637043, 0.7902984905303128, 0.5608219861746397, 0.3313345851399653, 0.13692410840839175, 0.01891490655966415, -0.000005112977093255089, -0.00042395493167891873, -0.00041934593101534273, 0.0017473028136486615, 0.0037999160177631316, -0.0005510147490658864, -0.000043716662898480967, 0.00758745017487328, 0.02579565078055402, 0.03816837653250055, 0.04948958640803083, 0.049595992290102905, 0.04981481950581225, 0.03984091106497802, 0.03050102493723387, 0.02124305476524108, 0.00695965321043564, 0.0041733649330980525]);
C.List_MEg = Isolate.makeConstantList([28679, 28679, 31752, -32759, -31735, -30711, -29687, -28663, 29703, 29703, 30727, 30727, -27639, -26615, -25591, -24567]);
C.List_q8u = Isolate.makeConstantList([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_2du = Isolate.makeConstantList([C.List_q8u, C.List_q8u, C.List_q8u]);
C.List_n3E = Isolate.makeConstantList([176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_U8c = Isolate.makeConstantList([223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_q8u0 = Isolate.makeConstantList([249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_EkO = Isolate.makeConstantList([C.List_n3E, C.List_U8c, C.List_q8u0]);
C.List_mXg = Isolate.makeConstantList([255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_sav = Isolate.makeConstantList([234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_q8u1 = Isolate.makeConstantList([253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_ezx = Isolate.makeConstantList([C.List_mXg, C.List_sav, C.List_q8u1]);
C.List_mXg0 = Isolate.makeConstantList([255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_wX4 = Isolate.makeConstantList([239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_U8c0 = Isolate.makeConstantList([254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_Q1p = Isolate.makeConstantList([C.List_mXg0, C.List_wX4, C.List_U8c0]);
C.List_mXg1 = Isolate.makeConstantList([255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_wX40 = Isolate.makeConstantList([251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_ycb = Isolate.makeConstantList([C.List_mXg1, C.List_wX40, C.List_q8u]);
C.List_wX41 = Isolate.makeConstantList([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_mXg2 = Isolate.makeConstantList([251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_AuU = Isolate.makeConstantList([C.List_wX41, C.List_mXg2, C.List_U8c0]);
C.List_ekJ = Isolate.makeConstantList([255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255]);
C.List_vHK = Isolate.makeConstantList([250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255]);
C.List_Mic = Isolate.makeConstantList([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_3oi = Isolate.makeConstantList([C.List_ekJ, C.List_vHK, C.List_Mic]);
C.List_uwP = Isolate.makeConstantList([C.List_2du, C.List_EkO, C.List_ezx, C.List_Q1p, C.List_ycb, C.List_AuU, C.List_3oi, C.List_2du]);
C.List_Mic0 = Isolate.makeConstantList([217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_ku2 = Isolate.makeConstantList([225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255]);
C.List_unK = Isolate.makeConstantList([234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]);
C.List_EuK = Isolate.makeConstantList([C.List_Mic0, C.List_ku2, C.List_unK]);
C.List_H37 = Isolate.makeConstantList([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_sav0 = Isolate.makeConstantList([223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_00 = Isolate.makeConstantList([238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]);
C.List_U05 = Isolate.makeConstantList([C.List_H37, C.List_sav0, C.List_00]);
C.List_H370 = Isolate.makeConstantList([249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_wEo0 = Isolate.makeConstantList([C.List_mXg1, C.List_H370, C.List_q8u]);
C.List_q8u2 = Isolate.makeConstantList([255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_H371 = Isolate.makeConstantList([247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_HmY = Isolate.makeConstantList([C.List_q8u2, C.List_H371, C.List_q8u]);
C.List_Mic1 = Isolate.makeConstantList([252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_qJr = Isolate.makeConstantList([C.List_wX41, C.List_Mic1, C.List_q8u]);
C.List_mXg3 = Isolate.makeConstantList([255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_oIk = Isolate.makeConstantList([C.List_mXg3, C.List_q8u1, C.List_q8u]);
C.List_H372 = Isolate.makeConstantList([255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_Mic2 = Isolate.makeConstantList([250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_23h = Isolate.makeConstantList([C.List_H372, C.List_Mic2, C.List_Mic]);
C.List_Crw = Isolate.makeConstantList([C.List_EuK, C.List_U05, C.List_wEo0, C.List_HmY, C.List_qJr, C.List_oIk, C.List_23h, C.List_2du]);
C.List_U8c1 = Isolate.makeConstantList([186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_01 = Isolate.makeConstantList([234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255]);
C.List_IyW = Isolate.makeConstantList([251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]);
C.List_ujV = Isolate.makeConstantList([C.List_U8c1, C.List_01, C.List_IyW]);
C.List_U8c2 = Isolate.makeConstantList([236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_A8Z = Isolate.makeConstantList([251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]);
C.List_eFE = Isolate.makeConstantList([C.List_wX41, C.List_U8c2, C.List_A8Z]);
C.List_sav1 = Isolate.makeConstantList([254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_ezx0 = Isolate.makeConstantList([C.List_mXg3, C.List_sav1, C.List_q8u]);
C.List_n3E0 = Isolate.makeConstantList([254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_QXJ = Isolate.makeConstantList([C.List_H37, C.List_n3E0, C.List_Mic]);
C.List_yzJ = Isolate.makeConstantList([C.List_q8u, C.List_Mic, C.List_q8u]);
C.List_QcX = Isolate.makeConstantList([C.List_ujV, C.List_eFE, C.List_ezx0, C.List_QXJ, C.List_yzJ, C.List_2du, C.List_2du, C.List_2du]);
C.List_Mic3 = Isolate.makeConstantList([248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_AsR = Isolate.makeConstantList([250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255]);
C.List_n3E1 = Isolate.makeConstantList([248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]);
C.List_gkc = Isolate.makeConstantList([C.List_Mic3, C.List_AsR, C.List_n3E1]);
C.List_q8u3 = Isolate.makeConstantList([255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_Mic4 = Isolate.makeConstantList([246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_02 = Isolate.makeConstantList([252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]);
C.List_03 = Isolate.makeConstantList([C.List_q8u3, C.List_Mic4, C.List_02]);
C.List_mXg4 = Isolate.makeConstantList([255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_n3E2 = Isolate.makeConstantList([248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_m9F = Isolate.makeConstantList([253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]);
C.List_C3E = Isolate.makeConstantList([C.List_mXg4, C.List_n3E2, C.List_m9F]);
C.List_wX42 = Isolate.makeConstantList([255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_wX43 = Isolate.makeConstantList([245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_wX44 = Isolate.makeConstantList([253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_swR = Isolate.makeConstantList([C.List_wX42, C.List_wX43, C.List_wX44]);
C.List_q8u4 = Isolate.makeConstantList([255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_U8c3 = Isolate.makeConstantList([252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_uQV = Isolate.makeConstantList([C.List_q8u4, C.List_U8c3, C.List_H37]);
C.List_H373 = Isolate.makeConstantList([255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_wX45 = Isolate.makeConstantList([249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_wX46 = Isolate.makeConstantList([255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_46y = Isolate.makeConstantList([C.List_H373, C.List_wX45, C.List_wX46]);
C.List_q8u5 = Isolate.makeConstantList([255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255]);
C.List_yzJ0 = Isolate.makeConstantList([C.List_q8u5, C.List_Mic2, C.List_q8u]);
C.List_88p = Isolate.makeConstantList([C.List_gkc, C.List_03, C.List_C3E, C.List_swR, C.List_uQV, C.List_46y, C.List_yzJ0, C.List_yzJ]);
C.List_MIe = Isolate.makeConstantList([C.List_uwP, C.List_Crw, C.List_QcX, C.List_88p]);
C.List_PWB = Isolate.makeConstantList([0.58, 0.58, 0.6, 0.58, 0.58, 0.6, 0.58, 0.58, 0.6, 0.5, 0.5, 0.5, 0.6, 0.59, 0.58, 0.58, 0.58, 0.6, 0.58, 0.58, 0.6, 0.2, 0.2, 0.33, 0.58, 0.58, 0.6]);
C.List_Qaw = Isolate.makeConstantList([0.005574062292492087, -0.004798283163144679, -0.00525365642986138, -0.006457148004449971, -0.005969351465800701, -0.002183671603768672, 0.016781120601055327, 0.09609635542906264, 0.21217357081986446, 0.3616913329068507, 0.5396101154323253, 0.7440881049217151, 0.9220957114839405, 1.0460304298411225, 1.0513824989063714, 1.0511991822135085, 1.0510530911991052, 1.051739723036051, 1.0516043086790485, 1.051194403206146, 1.0511590325868068, 1.051661246548303, 1.0514038526836869, 1.0515941029228475, 1.051146043696084, 1.0515123758830476, 1.0508871369510702, 1.050892370810238, 1.0477492815668303, 1.0493272144017338, 1.0435963333422726, 1.0392280772051465]);
C.List_QmM = Isolate.makeConstantList([1.1334479663682135, 1.1266762330194116, 1.1346827504710164, 1.1357395805744794, 1.1356371830149636, 1.1361152989346193, 1.1362179057706772, 1.1364819652587022, 1.1355107110714324, 1.1364060941199556, 1.1360363621722465, 1.1360122641141395, 1.135426688246703, 1.1363099407179136, 1.1355450412632506, 1.1353732327376378, 1.1349496420726002, 1.1111113947168556, 0.9059874042972714, 0.6116078078746533, 0.29539752170999634, 0.0959542006711501, -0.011650792030826267, -0.012144633073395025, -0.011148167569748318, -0.011997606668458151, -0.005050685547539485, -0.007998274581954215, -0.009472281770823642, -0.0055329541006658815, -0.004542891402827449, -0.012541015360921132]);
C.List_Qu6 = Isolate.makeConstantList([0.9942213815123685, 0.9898693712297568, 0.9829365828611696, 0.9962786839985931, 1.0198955019000133, 1.016639550121036, 1.0220913178757398, 0.9965166604068244, 1.0097766178917882, 1.0215422470827016, 0.6403195338779096, 0.0025012379477078184, 0.006533993955576994, 0.0028334080462675826, -5.1209675389074505e-11, -0.009059229164664638, 0.00339367183233312, -0.0030638741121828406, 0.22203936168286292, 0.6314114002481197, 0.9748098557650096, 0.9720956233359057, 1.017377030286815, 0.9987519432273413, 0.9470172573960224, 0.852586231543548, 0.9489779858166084, 0.9475187609652149, 0.9959894419105979, 0.8630135150380908, 0.8915098785352314, 0.8486649265284508]);
C.List_Qw3 = Isolate.makeConstantList([0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095]);
C.List_2Vk1 = Isolate.makeConstantList([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_gkc0 = Isolate.makeConstantList([C.List_2Vk1, C.List_2Vk1, C.List_2Vk1]);
C.List_cdS = Isolate.makeConstantList([253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128]);
C.List_app = Isolate.makeConstantList([189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128]);
C.List_yFh = Isolate.makeConstantList([106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]);
C.List_y5k = Isolate.makeConstantList([C.List_cdS, C.List_app, C.List_yFh]);
C.List_INA = Isolate.makeConstantList([1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128]);
C.List_e4d = Isolate.makeConstantList([181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128]);
C.List_app0 = Isolate.makeConstantList([78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]);
C.List_iLh = Isolate.makeConstantList([C.List_INA, C.List_e4d, C.List_app0]);
C.List_MOR = Isolate.makeConstantList([1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128]);
C.List_iUw = Isolate.makeConstantList([184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128]);
C.List_Eba = Isolate.makeConstantList([77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]);
C.List_VS7 = Isolate.makeConstantList([C.List_MOR, C.List_iUw, C.List_Eba]);
C.List_MOR0 = Isolate.makeConstantList([1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128]);
C.List_wnc = Isolate.makeConstantList([170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128]);
C.List_XwU = Isolate.makeConstantList([37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]);
C.List_HTJ = Isolate.makeConstantList([C.List_MOR0, C.List_wnc, C.List_XwU]);
C.List_1yC = Isolate.makeConstantList([1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128]);
C.List_Eba0 = Isolate.makeConstantList([207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128]);
C.List_iUw0 = Isolate.makeConstantList([102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]);
C.List_4QF = Isolate.makeConstantList([C.List_1yC, C.List_Eba0, C.List_iUw0]);
C.List_uXo = Isolate.makeConstantList([1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128]);
C.List_iUw1 = Isolate.makeConstantList([177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128]);
C.List_Eba1 = Isolate.makeConstantList([80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]);
C.List_8Pu = Isolate.makeConstantList([C.List_uXo, C.List_iUw1, C.List_Eba1]);
C.List_2hT = Isolate.makeConstantList([1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_2hT0 = Isolate.makeConstantList([246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_10r = Isolate.makeConstantList([255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_Snu = Isolate.makeConstantList([C.List_2hT, C.List_2hT0, C.List_10r]);
C.List_23h0 = Isolate.makeConstantList([C.List_gkc0, C.List_y5k, C.List_iLh, C.List_VS7, C.List_HTJ, C.List_4QF, C.List_8Pu, C.List_Snu]);
C.List_2hT1 = Isolate.makeConstantList([198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62]);
C.List_2Vk2 = Isolate.makeConstantList([131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1]);
C.List_kOG = Isolate.makeConstantList([68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]);
C.List_BDr = Isolate.makeConstantList([C.List_2hT1, C.List_2Vk2, C.List_kOG]);
C.List_qNA = Isolate.makeConstantList([1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128]);
C.List_app1 = Isolate.makeConstantList([184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128]);
C.List_kr3 = Isolate.makeConstantList([81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]);
C.List_Hcu = Isolate.makeConstantList([C.List_qNA, C.List_app1, C.List_kr3]);
C.List_oqK = Isolate.makeConstantList([1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128]);
C.List_e4d0 = Isolate.makeConstantList([99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128]);
C.List_kr30 = Isolate.makeConstantList([23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]);
C.List_zAX = Isolate.makeConstantList([C.List_oqK, C.List_e4d0, C.List_kr30]);
C.List_uXo0 = Isolate.makeConstantList([1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128]);
C.List_YAl = Isolate.makeConstantList([109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128]);
C.List_INA0 = Isolate.makeConstantList([44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]);
C.List_QOg = Isolate.makeConstantList([C.List_uXo0, C.List_YAl, C.List_INA0]);
C.List_niO = Isolate.makeConstantList([1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128]);
C.List_INA1 = Isolate.makeConstantList([94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128]);
C.List_app2 = Isolate.makeConstantList([22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]);
C.List_i7r = Isolate.makeConstantList([C.List_niO, C.List_INA1, C.List_app2]);
C.List_xw8 = Isolate.makeConstantList([1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128]);
C.List_iUw2 = Isolate.makeConstantList([124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128]);
C.List_app3 = Isolate.makeConstantList([35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]);
C.List_sQ3 = Isolate.makeConstantList([C.List_xw8, C.List_iUw2, C.List_app3]);
C.List_UkC = Isolate.makeConstantList([1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128]);
C.List_qNA0 = Isolate.makeConstantList([121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128]);
C.List_app4 = Isolate.makeConstantList([45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]);
C.List_ACG = Isolate.makeConstantList([C.List_UkC, C.List_qNA0, C.List_app4]);
C.List_xw80 = Isolate.makeConstantList([1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128]);
C.List_e3N = Isolate.makeConstantList([203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128]);
C.List_uXo1 = Isolate.makeConstantList([137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]);
C.List_UMT = Isolate.makeConstantList([C.List_xw80, C.List_e3N, C.List_uXo1]);
C.List_IJC = Isolate.makeConstantList([C.List_BDr, C.List_Hcu, C.List_zAX, C.List_QOg, C.List_i7r, C.List_sQ3, C.List_ACG, C.List_UMT]);
C.List_oyU = Isolate.makeConstantList([253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128]);
C.List_fnl = Isolate.makeConstantList([175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128]);
C.List_kOG0 = Isolate.makeConstantList([73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]);
C.List_04 = Isolate.makeConstantList([C.List_oyU, C.List_fnl, C.List_kOG0]);
C.List_qNA1 = Isolate.makeConstantList([1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128]);
C.List_qph = Isolate.makeConstantList([239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128]);
C.List_yFh0 = Isolate.makeConstantList([155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]);
C.List_S0k = Isolate.makeConstantList([C.List_qNA1, C.List_qph, C.List_yFh0]);
C.List_niO0 = Isolate.makeConstantList([1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128]);
C.List_Eba2 = Isolate.makeConstantList([201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128]);
C.List_app5 = Isolate.makeConstantList([69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]);
C.List_gfn = Isolate.makeConstantList([C.List_niO0, C.List_Eba2, C.List_app5]);
C.List_8eb = Isolate.makeConstantList([1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128]);
C.List_xw81 = Isolate.makeConstantList([223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128]);
C.List_e3N0 = Isolate.makeConstantList([141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]);
C.List_EJ0 = Isolate.makeConstantList([C.List_8eb, C.List_xw81, C.List_e3N0]);
C.List_e3N1 = Isolate.makeConstantList([1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128]);
C.List_uXo2 = Isolate.makeConstantList([190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128]);
C.List_2hT2 = Isolate.makeConstantList([149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_WtZ = Isolate.makeConstantList([C.List_e3N1, C.List_uXo2, C.List_2hT2]);
C.List_2hT3 = Isolate.makeConstantList([1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_Jio = Isolate.makeConstantList([247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_2hT4 = Isolate.makeConstantList([240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_wsa0 = Isolate.makeConstantList([C.List_2hT3, C.List_Jio, C.List_2hT4]);
C.List_e3N2 = Isolate.makeConstantList([1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128]);
C.List_e3N3 = Isolate.makeConstantList([213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128]);
C.List_2hT5 = Isolate.makeConstantList([55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_OBP = Isolate.makeConstantList([C.List_e3N2, C.List_e3N3, C.List_2hT5]);
C.List_Net = Isolate.makeConstantList([C.List_04, C.List_S0k, C.List_gfn, C.List_EJ0, C.List_WtZ, C.List_wsa0, C.List_OBP, C.List_gkc0]);
C.List_ZEx = Isolate.makeConstantList([202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255]);
C.List_kOG1 = Isolate.makeConstantList([126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128]);
C.List_kOG2 = Isolate.makeConstantList([61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]);
C.List_wsa1 = Isolate.makeConstantList([C.List_ZEx, C.List_kOG1, C.List_kOG2]);
C.List_kr31 = Isolate.makeConstantList([1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128]);
C.List_e4d1 = Isolate.makeConstantList([166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128]);
C.List_kr32 = Isolate.makeConstantList([39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]);
C.List_UaZ = Isolate.makeConstantList([C.List_kr31, C.List_e4d1, C.List_kr32]);
C.List_kr33 = Isolate.makeConstantList([1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128]);
C.List_oqK0 = Isolate.makeConstantList([124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128]);
C.List_kr34 = Isolate.makeConstantList([24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]);
C.List_i09 = Isolate.makeConstantList([C.List_kr33, C.List_oqK0, C.List_kr34]);
C.List_app6 = Isolate.makeConstantList([1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128]);
C.List_e4d2 = Isolate.makeConstantList([149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128]);
C.List_XT3 = Isolate.makeConstantList([28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]);
C.List_OIF = Isolate.makeConstantList([C.List_app6, C.List_e4d2, C.List_XT3]);
C.List_e4d3 = Isolate.makeConstantList([1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128]);
C.List_INA2 = Isolate.makeConstantList([123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128]);
C.List_app7 = Isolate.makeConstantList([20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]);
C.List_CKI = Isolate.makeConstantList([C.List_e4d3, C.List_INA2, C.List_app7]);
C.List_Eba3 = Isolate.makeConstantList([1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128]);
C.List_IVU = Isolate.makeConstantList([168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128]);
C.List_INA3 = Isolate.makeConstantList([47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]);
C.List_SnA = Isolate.makeConstantList([C.List_Eba3, C.List_IVU, C.List_INA3]);
C.List_INA4 = Isolate.makeConstantList([1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128]);
C.List_e4d4 = Isolate.makeConstantList([141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128]);
C.List_e4d5 = Isolate.makeConstantList([42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]);
C.List_xw82 = Isolate.makeConstantList([C.List_INA4, C.List_e4d4, C.List_e4d5]);
C.List_2hT6 = Isolate.makeConstantList([244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_2hT7 = Isolate.makeConstantList([238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]);
C.List_Q1p0 = Isolate.makeConstantList([C.List_2hT, C.List_2hT6, C.List_2hT7]);
C.List_uLM = Isolate.makeConstantList([C.List_wsa1, C.List_UaZ, C.List_i09, C.List_OIF, C.List_CKI, C.List_SnA, C.List_xw82, C.List_Q1p0]);
C.List_S8N = Isolate.makeConstantList([C.List_23h0, C.List_IJC, C.List_Net, C.List_uLM]);
C.List_SCE = Isolate.makeConstantList([0.0006061, 0.0006808792, 0.0007651456, 0.0008600124, 0.0009665928, 0.001086, 0.001220586, 0.001372729, 0.001543579, 0.001734286, 0.001946, 0.002177777, 0.002435809, 0.002731953, 0.003078064, 0.003486, 0.003975227, 0.00454088, 0.00515832, 0.005802907, 0.006450001, 0.007083216, 0.007745488, 0.008501152, 0.009414544, 0.01054999, 0.0119658, 0.01365587, 0.01558805, 0.01773015, 0.02005001, 0.02251136, 0.02520288, 0.02827972, 0.03189704, 0.03621, 0.04143771, 0.04750372, 0.05411988, 0.06099803, 0.06785001, 0.07448632, 0.08136156, 0.08915364, 0.09854048, 0.1102, 0.1246133, 0.1417017, 0.1613035, 0.1832568, 0.2074, 0.2336921, 0.2626114, 0.2947746, 0.3307985, 0.3713, 0.4162091, 0.4654642, 0.5196948, 0.5795303, 0.6456, 0.7184838, 0.7967133, 0.8778459, 0.959439, 1.0390501, 1.1153673, 1.1884971, 1.2581233, 1.3239296, 1.3856, 1.4426352, 1.4948035, 1.5421903, 1.5848807, 1.62296, 1.6564048, 1.6852959, 1.7098745, 1.7303821, 1.74706, 1.7600446, 1.7696233, 1.7762637, 1.7804334, 1.7826, 1.7829682, 1.7816998, 1.7791982, 1.7758671, 1.77211, 1.7682589, 1.764039, 1.7589438, 1.7524663, 1.7441, 1.7335595, 1.7208581, 1.7059369, 1.6887372, 1.6692, 1.6475287, 1.6234127, 1.5960223, 1.564528, 1.5281, 1.4861114, 1.4395215, 1.3898799, 1.3387362, 1.28764, 1.2374223, 1.1878243, 1.1387611, 1.090148, 1.0419, 0.9941976, 0.9473473, 0.9014531, 0.8566193, 0.8129501, 0.7705173, 0.7294448, 0.6899136, 0.6521049, 0.6162, 0.5823286, 0.5504162, 0.5203376, 0.4919673, 0.46518, 0.4399246, 0.4161836, 0.3938822, 0.3729459, 0.3533, 0.3348578, 0.3175521, 0.3013375, 0.2861686, 0.272, 0.2588171, 0.2464838, 0.2347718, 0.2234533, 0.2123, 0.2011692, 0.1901196, 0.1792254, 0.1685608, 0.1582, 0.1481383, 0.1383758, 0.1289942, 0.1200751, 0.1117, 0.1039048, 0.09666748, 0.08998272, 0.08384531, 0.07824999, 0.07320899, 0.06867816, 0.06456784, 0.06078835, 0.05725001, 0.05390435, 0.05074664, 0.04775276, 0.04489859, 0.04216, 0.03950728, 0.03693564, 0.03445836, 0.03208872, 0.02984, 0.02771181, 0.02569444, 0.02378716, 0.02198925, 0.0203, 0.01871805, 0.01724036, 0.01586364, 0.01458461, 0.0134, 0.01230723, 0.01130188, 0.01037792, 0.009529306, 0.008749999, 0.0080352, 0.0073816, 0.0067854, 0.0062428, 0.005749999, 0.0053036, 0.0048998, 0.0045342, 0.0042024, 0.0039, 0.0036232, 0.0033706, 0.0031414, 0.0029348, 0.002749999, 0.0025852, 0.0024386, 0.0023094, 0.0021968, 0.0021, 0.002017733, 0.0019482, 0.0018898, 0.001840933, 0.0018, 0.001766267, 0.0017378, 0.0017112, 0.001683067, 0.001650001, 0.001610133, 0.0015644, 0.0015136, 0.001458533, 0.0014, 0.001336667, 0.00127, 0.001205, 0.001146667, 0.0011, 0.0010688, 0.0010494, 0.0010356, 0.0010212, 0.001, 0.00096864, 0.00092992, 0.00088688, 0.00084256, 0.0008, 0.00076096, 0.00072368, 0.00068592, 0.00064544, 0.0006, 0.0005478667, 0.0004916, 0.0004354, 0.0003834667, 0.00034, 0.0003072533, 0.00028316, 0.00026544, 0.0002518133, 0.00024, 0.0002295467, 0.00022064, 0.00021196, 0.0002021867, 0.00019, 0.0001742133, 0.00015564, 0.00013596, 0.0001168533, 0.0001, 0.00008613333, 0.0000746, 0.000065, 0.00005693333, 0.00004999999, 0.00004416, 0.00003948, 0.00003572, 0.00003264, 0.00003, 0.00002765333, 0.00002556, 0.00002364, 0.00002181333, 0.00002, 0.00001813333, 0.0000162, 0.0000142, 0.00001213333, 0.00001, 0.000007733333, 0.0000054, 0.0000032, 0.000001333333, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
C.List_Sby = Isolate.makeConstantList([0.1657560486708618, 0.11846442802747797, 0.12408293329637447, 0.11371272058349924, 0.07899243451889913, 0.03220560359310655, -0.010798365407877875, 0.018051975516730392, 0.005340719659873053, 0.013654918729501336, -0.005956421354564284, -0.0018444365067353252, -0.010571884361529504, -0.002937552107800001, -0.010790476271835936, -0.008022430669750363, -0.002266916770249594, 0.007020024049470663, -0.00815284690002993, 0.6077286696925279, 0.988315608654324, 0.9939169104407882, 1.0039338994753197, 0.9923449986116712, 0.9992653085885552, 1.008462155761727, 0.9835829682744122, 1.0085023660099048, 0.974511383265687, 0.9854326957005994, 0.9349576398096204, 0.987139077923194]);
C.List_U49 = Isolate.makeConstantList([360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830]);
C.List_UgT = Isolate.makeConstantList(["INFO", "WARNING", "ERROR", "SEVERE", "DEBUG"]);
C.List_V7h = Isolate.makeConstantList([-2872, -2849, -2827, -2804, -2782, -2760, -2737, -2715, -2692, -2670, -2647, -2625, -2603, -2580, -2558, -2535, -2513, -2490, -2468, -2446, -2423, -2401, -2378, -2356, -2333, -2311, -2289, -2266, -2244, -2221, -2199, -2176, -2154, -2132, -2109, -2087, -2064, -2042, -2019, -1997, -1975, -1952, -1930, -1907, -1885, -1862, -1840, -1817, -1795, -1773, -1750, -1728, -1705, -1683, -1660, -1638, -1616, -1593, -1571, -1548, -1526, -1503, -1481, -1459, -1436, -1414, -1391, -1369, -1346, -1324, -1302, -1279, -1257, -1234, -1212, -1189, -1167, -1145, -1122, -1100, -1077, -1055, -1032, -1010, -988, -965, -943, -920, -898, -875, -853, -830, -808, -786, -763, -741, -718, -696, -673, -651, -629, -606, -584, -561, -539, -516, -494, -472, -449, -427, -404, -382, -359, -337, -315, -292, -270, -247, -225, -202, -180, -158, -135, -113, -90, -68, -45, -23, 0, 22, 44, 67, 89, 112, 134, 157, 179, 201, 224, 246, 269, 291, 314, 336, 358, 381, 403, 426, 448, 471, 493, 515, 538, 560, 583, 605, 628, 650, 672, 695, 717, 740, 762, 785, 807, 829, 852, 874, 897, 919, 942, 964, 987, 1009, 1031, 1054, 1076, 1099, 1121, 1144, 1166, 1188, 1211, 1233, 1256, 1278, 1301, 1323, 1345, 1368, 1390, 1413, 1435, 1458, 1480, 1502, 1525, 1547, 1570, 1592, 1615, 1637, 1659, 1682, 1704, 1727, 1749, 1772, 1794, 1816, 1839, 1861, 1884, 1906, 1929, 1951, 1974, 1996, 2018, 2041, 2063, 2086, 2108, 2131, 2153, 2175, 2198, 2220, 2243, 2265, 2288, 2310, 2332, 2355, 2377, 2400, 2422, 2445, 2467, 2489, 2512, 2534, 2557, 2579, 2602, 2624, 2646, 2669, 2691, 2714, 2736, 2759, 2781, 2804, 2826, 2848]);
C.List_VSP = Isolate.makeConstantList([6430, 6400, 6400, 6400, 3225, 3225, 3225, 3225, 944, 944, 944, 944, 976, 976, 976, 976, 1456, 1456, 1456, 1456, 1488, 1488, 1488, 1488, 718, 718, 718, 718, 718, 718, 718, 718, 750, 750, 750, 750, 750, 750, 750, 750, 1520, 1520, 1520, 1520, 1552, 1552, 1552, 1552, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 654, 654, 654, 654, 654, 654, 654, 654, 1072, 1072, 1072, 1072, 1104, 1104, 1104, 1104, 1136, 1136, 1136, 1136, 1168, 1168, 1168, 1168, 1200, 1200, 1200, 1200, 1232, 1232, 1232, 1232, 622, 622, 622, 622, 622, 622, 622, 622, 1008, 1008, 1008, 1008, 1040, 1040, 1040, 1040, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 1712, 1712, 1712, 1712, 1744, 1744, 1744, 1744, 846, 846, 846, 846, 846, 846, 846, 846, 1264, 1264, 1264, 1264, 1296, 1296, 1296, 1296, 1328, 1328, 1328, 1328, 1360, 1360, 1360, 1360, 1392, 1392, 1392, 1392, 1424, 1424, 1424, 1424, 686, 686, 686, 686, 686, 686, 686, 686, 910, 910, 910, 910, 910, 910, 910, 910, 1968, 1968, 1968, 1968, 2000, 2000, 2000, 2000, 2032, 2032, 2032, 2032, 16, 16, 16, 16, 10257, 10257, 10257, 10257, 12305, 12305, 12305, 12305, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 878, 878, 878, 878, 878, 878, 878, 878, 1904, 1904, 1904, 1904, 1936, 1936, 1936, 1936, -18413, -18413, -16365, -16365, -14317, -14317, -10221, -10221, 590, 590, 590, 590, 590, 590, 590, 590, 782, 782, 782, 782, 782, 782, 782, 782, 1584, 1584, 1584, 1584, 1616, 1616, 1616, 1616, 1648, 1648, 1648, 1648, 1680, 1680, 1680, 1680, 814, 814, 814, 814, 814, 814, 814, 814, 1776, 1776, 1776, 1776, 1808, 1808, 1808, 1808, 1840, 1840, 1840, 1840, 1872, 1872, 1872, 1872, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, 14353, 14353, 14353, 14353, 16401, 16401, 16401, 16401, 22547, 22547, 24595, 24595, 20497, 20497, 20497, 20497, 18449, 18449, 18449, 18449, 26643, 26643, 28691, 28691, 30739, 30739, -32749, -32749, -30701, -30701, -28653, -28653, -26605, -26605, -24557, -24557, -22509, -22509, -20461, -20461, 8207, 8207, 8207, 8207, 8207, 8207, 8207, 8207, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232]);
C.List_VvJ = Isolate.makeConstantList([0, -128, 64, -64, 32, -96, 96, -32, 16, -112, 80, -48, 48, -80, 112, -16, 8, -120, 72, -56, 40, -88, 104, -24, 24, -104, 88, -40, 56, -72, 120, -8, 4, -124, 68, -60, 36, -92, 100, -28, 20, -108, 84, -44, 52, -76, 116, -12, 12, -116, 76, -52, 44, -84, 108, -20, 28, -100, 92, -36, 60, -68, 124, -4, 2, -126, 66, -62, 34, -94, 98, -30, 18, -110, 82, -46, 50, -78, 114, -14, 10, -118, 74, -54, 42, -86, 106, -22, 26, -102, 90, -38, 58, -70, 122, -6, 6, -122, 70, -58, 38, -90, 102, -26, 22, -106, 86, -42, 54, -74, 118, -10, 14, -114, 78, -50, 46, -82, 110, -18, 30, -98, 94, -34, 62, -66, 126, -2, 1, -127, 65, -63, 33, -95, 97, -31, 17, -111, 81, -47, 49, -79, 113, -15, 9, -119, 73, -55, 41, -87, 105, -23, 25, -103, 89, -39, 57, -71, 121, -7, 5, -123, 69, -59, 37, -91, 101, -27, 21, -107, 85, -43, 53, -75, 117, -11, 13, -115, 77, -51, 45, -83, 109, -19, 29, -99, 93, -35, 61, -67, 125, -3, 3, -125, 67, -61, 35, -93, 99, -29, 19, -109, 83, -45, 51, -77, 115, -13, 11, -117, 75, -53, 43, -85, 107, -21, 27, -101, 91, -37, 59, -69, 123, -5, 7, -121, 71, -57, 39, -89, 103, -25, 23, -105, 87, -41, 55, -73, 119, -9, 15, -113, 79, -49, 47, -81, 111, -17, 31, -97, 95, -33, 63, -65, 127, -1]);
C.List_X3d = Isolate.makeConstantList([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]);
C.List_X3d0 = Isolate.makeConstantList([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
C.List_Y3m = Isolate.makeConstantList([-0.0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9]);
C.List_aXZ = Isolate.makeConstantList([1.0570490759328752, 1.05384669128513, 1.055049425814067, 1.0530407754701832, 1.0579930596460185, 1.057843949481237, 1.0583132387180239, 1.0579712943137616, 1.0561884233578465, 1.057139928542649, 1.0425795187752152, 0.326030843740561, -0.0019255628442412243, -0.0012959221137046478, -0.0014357356276938696, -0.0012963697250337886, -0.00192270811623739, 0.0012621152526221778, -0.0016095249003578276, -0.0013029983817879568, -0.0017666600873954916, -0.001232528114028005, 0.010316809673254932, 0.03128451264835436, 0.08877387988174648, 0.1387362174023654, 0.15535067531939065, 0.1487847717823703, 0.16624255403475907, 0.16997613960634927, 0.15769743995852967, 0.19069090525482305]);
C.List_bge = Isolate.makeConstantList([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919]);
C.List_cGl = Isolate.makeConstantList([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);
C.List_cGl0 = Isolate.makeConstantList([0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396]);
C.List_cGl1 = Isolate.makeConstantList([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15]);
C.List_cQL = Isolate.makeConstantList([0.0026494153587602255, -0.005017501342973224, -0.012547236272489583, -0.009455496430838867, -0.012526086181600525, -0.007917069776043777, -0.007995573520417569, -0.009355943344446907, 0.0654686119829993, 0.3957287551763414, 0.7524402229988666, 0.9637647869021856, 0.9985443385516233, 0.9999297702528792, 0.9993908675114045, 0.999943722670714, 0.9993912181341867, 0.9991123731042448, 0.9601958487827158, 0.6318627933843244, 0.2579740102876347, 0.009401488852733564, -0.0030798345608649747, -0.0045230367033685034, -0.006893341038827404, -0.00903521955390154, -0.008591366716534021, -0.00836908691202894, -0.007868583233875431, -0.000008365757871108513, 0.005430122544281718, -0.0027745589759259194]);
C.List_chs = Isolate.makeConstantList([-3630, -3601, -3573, -3544, -3516, -3488, -3459, -3431, -3403, -3374, -3346, -3318, -3289, -3261, -3233, -3204, -3176, -3148, -3119, -3091, -3063, -3034, -3006, -2977, -2949, -2921, -2892, -2864, -2836, -2807, -2779, -2751, -2722, -2694, -2666, -2637, -2609, -2581, -2552, -2524, -2495, -2467, -2439, -2410, -2382, -2354, -2325, -2297, -2269, -2240, -2212, -2184, -2155, -2127, -2099, -2070, -2042, -2013, -1985, -1957, -1928, -1900, -1872, -1843, -1815, -1787, -1758, -1730, -1702, -1673, -1645, -1617, -1588, -1560, -1532, -1503, -1475, -1446, -1418, -1390, -1361, -1333, -1305, -1276, -1248, -1220, -1191, -1163, -1135, -1106, -1078, -1050, -1021, -993, -964, -936, -908, -879, -851, -823, -794, -766, -738, -709, -681, -653, -624, -596, -568, -539, -511, -482, -454, -426, -397, -369, -341, -312, -284, -256, -227, -199, -171, -142, -114, -86, -57, -29, 0, 28, 56, 85, 113, 141, 170, 198, 226, 255, 283, 311, 340, 368, 396, 425, 453, 481, 510, 538, 567, 595, 623, 652, 680, 708, 737, 765, 793, 822, 850, 878, 907, 935, 963, 992, 1020, 1049, 1077, 1105, 1134, 1162, 1190, 1219, 1247, 1275, 1304, 1332, 1360, 1389, 1417, 1445, 1474, 1502, 1531, 1559, 1587, 1616, 1644, 1672, 1701, 1729, 1757, 1786, 1814, 1842, 1871, 1899, 1927, 1956, 1984, 2012, 2041, 2069, 2098, 2126, 2154, 2183, 2211, 2239, 2268, 2296, 2324, 2353, 2381, 2409, 2438, 2466, 2494, 2523, 2551, 2580, 2608, 2636, 2665, 2693, 2721, 2750, 2778, 2806, 2835, 2863, 2891, 2920, 2948, 2976, 3005, 3033, 3062, 3090, 3118, 3147, 3175, 3203, 3232, 3260, 3288, 3317, 3345, 3373, 3402, 3430, 3458, 3487, 3515, 3544, 3572, 3600]);
C.List_cwh = Isolate.makeConstantList([298.7570554, 302.4004341, 306.1337728, 309.960445, 313.8839949, 317.9081487, 322.036826, 326.2741526, 330.6244747, 335.092373, 339.6826795, 344.4004944, 349.2512056, 354.2405086, 359.374429, 364.6593471, 370.1020239, 375.7096303, 381.4897785, 387.4505563, 393.6005651, 399.9489613, 406.5055016, 413.2805933, 420.2853492, 427.5316483, 435.0322035, 442.8006357, 450.8515564, 459.2006593, 467.8648226, 476.8622231, 486.2124627, 495.936712, 506.0578694, 516.6007417, 527.5922468, 539.0616435, 551.0407911, 563.5644455, 576.6705953, 590.4008476, 604.8008683, 619.92089, 635.8162974, 652.5483053, 670.1847459, 688.8009889, 708.4810171, 729.3186941, 751.4192606, 774.9011125, 799.8979226, 826.5611867, 855.0632966, 885.6012714]);
C.List_ec6 = Isolate.makeConstantList([0.02516838875551463, 0.03942743816942372, 0.006205957159642579, 0.007112085980742955, 0.0002176004464913943, 7.327183998429021e-12, -0.0216230662171817, 0.015670209409407512, 0.002801960318863622, 0.32494773799897647, 1.0164917292316602, 1.0329476657890369, 1.032158696299155, 1.0358667411948619, 1.015123547683494, 1.0338076690093119, 1.0371372378155013, 1.0361377027692558, 1.022982243255721, 0.9691032733565232, -0.005178592389987857, 0.001113126197106143, 0.006667550303301177, 0.0007402431568600196, 0.021591567633473925, 0.005148162005621723, 0.0014561928645728216, 0.00016414511045291513, -0.006463076496845329, 0.010250854718507939, 0.042387394733956134, 0.02125271692686162]);
C.List_eea = Isolate.makeConstantList([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);
C.List_empty = Isolate.makeConstantList([]);
C.List_fkS = Isolate.makeConstantList([-705, -700, -694, -689, -683, -678, -672, -667, -661, -656, -650, -645, -639, -634, -628, -623, -617, -612, -606, -601, -595, -590, -584, -579, -573, -568, -562, -557, -551, -546, -540, -535, -529, -524, -518, -513, -507, -502, -496, -491, -485, -480, -474, -469, -463, -458, -452, -447, -441, -435, -430, -424, -419, -413, -408, -402, -397, -391, -386, -380, -375, -369, -364, -358, -353, -347, -342, -336, -331, -325, -320, -314, -309, -303, -298, -292, -287, -281, -276, -270, -265, -259, -254, -248, -243, -237, -232, -226, -221, -215, -210, -204, -199, -193, -188, -182, -177, -171, -166, -160, -155, -149, -144, -138, -133, -127, -122, -116, -111, -105, -100, -94, -89, -83, -78, -72, -67, -61, -56, -50, -45, -39, -34, -28, -23, -17, -12, -6, 0, 5, 11, 16, 22, 27, 33, 38, 44, 49, 55, 60, 66, 71, 77, 82, 88, 93, 99, 104, 110, 115, 121, 126, 132, 137, 143, 148, 154, 159, 165, 170, 176, 181, 187, 192, 198, 203, 209, 214, 220, 225, 231, 236, 242, 247, 253, 258, 264, 269, 275, 280, 286, 291, 297, 302, 308, 313, 319, 324, 330, 335, 341, 346, 352, 357, 363, 368, 374, 379, 385, 390, 396, 401, 407, 412, 418, 423, 429, 434, 440, 446, 451, 457, 462, 468, 473, 479, 484, 490, 495, 501, 506, 512, 517, 523, 528, 534, 539, 545, 550, 556, 561, 567, 572, 578, 583, 589, 594, 600, 605, 611, 616, 622, 627, 633, 638, 644, 649, 655, 660, 666, 671, 677, 682, 688, 693, 699]);
C.List_i3t = Isolate.makeConstantList([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]);
C.List_iDZ = Isolate.makeConstantList([1.0618958571272863, 1.0615019980348779, 1.0614335379927147, 1.0622711654692485, 1.0622036218416742, 1.0625059965187085, 1.0623938486985884, 1.0624706448043137, 1.0625048144827762, 1.0624366131308856, 1.0620694238892607, 1.0613167586932164, 1.061033402937702, 1.0613868564828413, 1.0614215366116762, 1.0620336151299086, 1.062549745480505, 1.0624317487992085, 1.062524914055448, 1.0624277664486914, 1.062474985409077, 1.0625538581025402, 1.0625326910104864, 1.0623922312225325, 1.062365098035413, 1.0625256476715284, 1.0612277619533155, 1.0594262608698046, 1.0599810758292072, 1.0602547314449409, 1.0601263046243634, 1.0606565756823634]);
C.List_ild = Isolate.makeConstantList([1.0371892935878366, 1.0587542891035364, 1.0767271213688903, 1.0762706844110288, 1.0795289105258212, 1.0743644742950074, 1.0727028691194342, 1.0732447452056488, 1.0823760816041414, 1.0840545681409282, 0.9560756752630666, 0.5519789685506467, 0.08419109488724758, 0.000087940070557041, -0.002308640833507125, -0.0011248136628651192, -7.729761275498959e-11, -0.00027270769006770834, 0.014466473094035592, 0.2588311602716948, 0.5290799982756673, 0.9096662409710516, 1.0690571327307956, 1.0887326064796272, 1.0637622289511852, 1.020181291809426, 1.0262196688979945, 1.078308556061319, 0.9833384962321887, 1.070724634280262, 1.0634247770423768, 1.0150875475729566]);
C.List_int = Isolate.makeConstantList([-1463, -1452, -1440, -1429, -1417, -1406, -1394, -1383, -1372, -1360, -1349, -1337, -1326, -1315, -1303, -1292, -1280, -1269, -1257, -1246, -1235, -1223, -1212, -1200, -1189, -1177, -1166, -1155, -1143, -1132, -1120, -1109, -1097, -1086, -1075, -1063, -1052, -1040, -1029, -1017, -1006, -995, -983, -972, -960, -949, -937, -926, -915, -903, -892, -880, -869, -857, -846, -835, -823, -812, -800, -789, -777, -766, -755, -743, -732, -720, -709, -697, -686, -675, -663, -652, -640, -629, -618, -606, -595, -583, -572, -560, -549, -538, -526, -515, -503, -492, -480, -469, -458, -446, -435, -423, -412, -400, -389, -378, -366, -355, -343, -332, -320, -309, -298, -286, -275, -263, -252, -240, -229, -218, -206, -195, -183, -172, -160, -149, -138, -126, -115, -103, -92, -80, -69, -58, -46, -35, -23, -12, 0, 11, 22, 34, 45, 57, 68, 79, 91, 102, 114, 125, 137, 148, 159, 171, 182, 194, 205, 217, 228, 239, 251, 262, 274, 285, 297, 308, 319, 331, 342, 354, 365, 377, 388, 399, 411, 422, 434, 445, 457, 468, 479, 491, 502, 514, 525, 537, 548, 559, 571, 582, 594, 605, 617, 628, 639, 651, 662, 674, 685, 696, 708, 719, 731, 742, 754, 765, 776, 788, 799, 811, 822, 834, 845, 856, 868, 879, 891, 902, 914, 925, 936, 948, 959, 971, 982, 994, 1005, 1016, 1028, 1039, 1051, 1062, 1074, 1085, 1096, 1108, 1119, 1131, 1142, 1154, 1165, 1176, 1188, 1199, 1211, 1222, 1234, 1245, 1256, 1268, 1279, 1291, 1302, 1314, 1325, 1336, 1348, 1359, 1371, 1382, 1393, 1405, 1416, 1428, 1439, 1451]);
C.List_knt = Isolate.makeConstantList([0, 1, 3, 7, 15, 31, 63, 127, 255]);
C.List_knt0 = Isolate.makeConstantList([0, 128, 192, 224, 240, 248, 252, 254, 255]);
C.List_nLG = Isolate.makeConstantList([62, 62, 30, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 588, 588, 588, 588, 588, 588, 588, 588, 1680, 1680, 20499, 22547, 24595, 26643, 1776, 1776, 1808, 1808, -24557, -22509, -20461, -18413, 1904, 1904, 1936, 1936, -16365, -14317, 782, 782, 782, 782, 814, 814, 814, 814, -12269, -10221, 10257, 10257, 12305, 12305, 14353, 14353, 16403, 18451, 1712, 1712, 1744, 1744, 28691, 30739, -32749, -30701, -28653, -26605, 2061, 2061, 2061, 2061, 2061, 2061, 2061, 2061, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 750, 750, 750, 750, 1616, 1616, 1648, 1648, 1424, 1424, 1456, 1456, 1488, 1488, 1520, 1520, 1840, 1840, 1872, 1872, 1968, 1968, 8209, 8209, 524, 524, 524, 524, 524, 524, 524, 524, 556, 556, 556, 556, 556, 556, 556, 556, 1552, 1552, 1584, 1584, 2000, 2000, 2032, 2032, 976, 976, 1008, 1008, 1040, 1040, 1072, 1072, 1296, 1296, 1328, 1328, 718, 718, 718, 718, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 4113, 4113, 6161, 6161, 848, 848, 880, 880, 912, 912, 944, 944, 622, 622, 622, 622, 654, 654, 654, 654, 1104, 1104, 1136, 1136, 1168, 1168, 1200, 1200, 1232, 1232, 1264, 1264, 686, 686, 686, 686, 1360, 1360, 1392, 1392, 12, 12, 12, 12, 12, 12, 12, 12, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390]);
C.List_qQn = Isolate.makeConstantList([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]);
C.List_qtg = Isolate.makeConstantList([0.8147236705, 0.1354770064, 0.0000925521, 0.4019474089, 0.6087165475, 0.9057919383, 0.8350085616, 0.000355375, 0.0861424059, 0.0100619597, 0.5407393575, 0.269064337, 0.0006090801, 0.6007867455, 0.8780308366, 0.2601301968, 0.637970686, 0.0009086037, 0.7664164901, 0.8738085628, 0.319067806, 0.9074092507, 0.001191163, 0.9212453961, 0.6868487597, 0.7451665998, 0.5743905902, 0.0013162681, 0.9683164358, 0.5127110481, 0.400152415, 0.5284244418, 0.0016778698, 0.6921809912, 0.4125681221, 0.1100450456, 0.1057574451, 0.0018501711, 0.0146250632, 0.8812126517, 0.8948429227, 0.2533296347, 0.0020738356, 0.4565072358, 0.5722977519, 0.267468363, 0.5533290505, 0.0023895311, 0.1681169569, 0.294798106, 0.3942572773, 0.2532950938, 0.0026231781, 0.2203403264, 0.3363176882, 0.4852786958, 0.354539156, 0.0028830934, 0.3188484907, 0.9074358344, 0.6586979032, 0.8418058157, 0.0030069787, 0.7844486237, 0.6568627954, 0.9411987066, 0.5897576213, 0.0033880144, 0.8060938716, 0.4992469847, 0.539999783, 0.9201279879, 0.00345163, 0.7110665441, 0.9379280806, 0.7044532299, 0.361564517, 0.0038146735, 0.3312333524, 0.7043340802, 0.223674491, 0.6983554363, 0.004031301, 0.9803896546, 0.0122512933, 0.9424012303, 0.3758843243, 0.004381137, 0.127216652, 0.7057249546, 0.7769014239, 0.5007985234, 0.0045080204, 0.4891040921, 0.6144846678, 0.3352120221, 0.4250096679, 0.0048495578, 0.1398096681, 0.4732225239, 0.2864905894, 0.3687916994, 0.0050996765, 0.5154488683, 0.7148888111, 0.4302304387, 0.7953287363, 0.0053384029, 0.3845077455, 0.4471219778, 0.7122719884, 0.6312747002, 0.0053886301, 0.2098473012, 0.0359315202, 0.2255856991, 0.8242244124, 0.0057056206, 0.0154700223, 0.7429744601, 0.4062927365, 0.1937931925, 0.0059459647, 0.7694647908, 0.8217784762, 0.3468713462, 0.6767925024, 0.0062678517, 0.8330464959, 0.2177158743, 0.9666144252, 0.2009279728, 0.006493988, 0.8835488558, 0.7352885008, 0.354213953, 0.1368083954, 0.0068113748, 0.7127271891, 0.736957252, 0.0730623454, 0.9186591506, 0.0070059323, 0.8506008983, 0.2909074426, 0.0576261431, 0.6444487572, 0.0072751464, 0.1983753592, 0.6282710433, 0.8324630857, 0.0756615698, 0.0074814279, 0.8288900852, 0.9258258343, 0.6643590927, 0.7455400229, 0.007812032, 0.2949022353, 0.0725637302, 0.7771928906, 0.0457091779, 0.0079298988, 0.3379514217, 0.3358463049, 0.7178720832, 0.0836343467, 0.0081919432, 0.0248849336, 0.2305759937, 0.3458726108, 0.0467313565, 0.0085327048, 0.0916037932, 0.5246021152, 0.3535799682, 0.923904717, 0.0086721992, 0.2325491011, 0.1278568357, 0.4694392085, 0.1728783846, 0.0088718766, 0.293476373, 0.6021974683, 0.4273798168, 0.0501741581, 0.0092035085, 0.716029644, 0.3402471542, 0.9108628631, 0.2238015085, 0.009354868, 0.8826734424, 0.7824344039, 0.6898998618, 0.483579576, 0.0097168721, 0.0895984694, 0.6975994706, 0.7868241072, 0.8537104726, 0.0097885933, 0.1676693857, 0.8658806682, 0.5064531565, 0.1874002069, 0.010186947, 0.2452387512, 0.5405161977, 0.7579895854, 0.7569690943, 0.0103190392, 0.1678106338, 0.5750533342, 0.4616447687, 0.2728512287, 0.0106443241, 0.591934979, 0.2881401181, 0.4405889809, 0.4591084123, 0.0109313, 0.7328998446, 0.6630277634, 0.5048032403, 0.1451848596, 0.0110682091, 0.9092653394, 0.1455762088, 0.5176716447, 0.8154572845, 0.0114612412, 0.0788091794, 0.1426269263, 0.0507072657, 0.2023273557, 0.0115570212, 0.518648386, 0.1527025849, 0.0960686132, 0.998609364, 0.0118583171, 0.0184947345, 0.5494630933, 0.382912606, 0.332728833, 0.0121809021, 0.0219344981, 0.6127645969, 0.3661476672, 0.1958540827, 0.0123146856, 0.4433521628, 0.7052192092, 0.2274705768, 0.3423889875, 0.0124962647, 0.3325358033, 0.6719499826, 0.8564140797, 0.8799827099, 0.0128203863, 0.4616371095, 0.4424869716, 0.0257591251, 0.9929412603, 0.0129602877, 0.4425229132, 0.8805189133, 0.018948989, 0.8733308315, 0.0133971358, 0.426649034, 0.7925782204, 0.9364752769, 0.1634215117, 0.0136603368, 0.6092597246, 0.5063406229, 0.7860327363, 0.2605836987, 0.0137975588, 0.8142901659, 0.0293884389, 0.9804726243, 0.0265780203, 0.0140897799, 0.8962855339, 0.3561876714, 0.1831031144, 0.1188247874, 0.0143356901, 0.7261373997, 0.6238805056, 0.7739988565, 0.684348464, 0.0145266177, 0.0040075476, 0.6703180671, 0.8973402977, 0.9881284833, 0.0147383977, 0.110987477, 0.2047449797, 0.1769492477, 0.8110610247, 0.015077821, 0.5277686119, 0.2967748046, 0.4921269119, 0.3022507429, 0.0152802048, 0.6041954756, 0.4695280492, 0.0783381686, 0.7078509927, 0.0154551705, 0.1806261986, 0.474986732, 0.444193095, 0.3144947588, 0.0158082489, 0.6334674358, 0.0843452588, 0.483364284, 0.0819099694, 0.0159649383, 0.3896810114, 0.783201158, 0.9700933099, 0.9633082151, 0.0162235647, 0.0769674554, 0.5728059411, 0.4663167298, 0.610935986, 0.0165467877, 0.3170534968, 0.5696546435, 0.62086308, 0.1367374957, 0.0167269148, 0.013770517, 0.1829838008, 0.840079248, 0.4905676842, 0.0169972964, 0.7087520361, 0.5272886157, 0.4622295201, 0.9965586662, 0.0173130222, 0.9431533217, 0.9666104317, 0.0206090696, 0.642896831, 0.0175194405, 0.8819432855, 0.0703618452, 0.9498320222, 0.0117056081, 0.0177698825, 0.3387356699, 0.2081270069, 0.5681881309, 0.7464584708, 0.017946858, 0.825258255, 0.0903981924, 0.2801332176, 0.4389587045, 0.0182940979, 0.2809591591, 0.3265851736, 0.7442450523, 0.9018602371, 0.0183938816, 0.5043178201, 0.528845787, 0.9010351896, 0.9257849455, 0.0185957365, 0.0032330919, 0.7852386832, 0.2091527432, 0.4226507545, 0.0189210195, 0.140977785, 0.084676221, 0.8047815561, 0.5894420147, 0.0190771352, 0.2615225613, 0.4571531117, 0.1401103735, 0.0175967962, 0.0195146669, 0.6312081814, 0.7898635864, 0.0271497797, 0.3446519375, 0.0195794944, 0.9772230983, 0.3104098737, 0.3501657248, 0.7712000608, 0.0198350661, 0.7422171831, 0.0328862183, 0.2244993448, 0.98785007, 0.0200550221, 0.9384350777, 0.4154943228, 0.4029869437, 0.7474737763, 0.0204645973, 0.2761213779, 0.7616214752, 0.2186425477, 0.5974915624, 0.0205609128, 0.1831181645, 0.7619341016, 0.9248407483, 0.8833535314, 0.0209227093, 0.1526287049, 0.1579527855, 0.3336008787, 0.3455565572, 0.0211345553, 0.1134738997, 0.8607695103, 0.9732974768, 0.4391311109, 0.0214559622, 0.681289196, 0.9797594547, 0.7273365855, 0.0127240587, 0.0215192456, 0.904158473, 0.2457261384, 0.4251326621, 0.4004603624, 0.0218490809, 0.4733976722, 0.2654740512, 0.4099306166, 0.5888402462, 0.0220631715, 0.4979542196, 0.2041166872, 0.6102679968, 0.8612695336, 0.0223458037, 0.5463936925, 0.4322631061, 0.5966469049, 0.4805867374, 0.0226596743, 0.1803955585, 0.531778574, 0.0489680506, 0.719183147, 0.0228388328, 0.4975504875, 0.037984658, 0.7716502547, 0.8034937382, 0.0230321046, 0.3578487337, 0.8847640157, 0.1918073297, 0.640298903, 0.0233804137, 0.7596606612, 0.9317308664, 0.3741894662, 0.8122962117, 0.0234890021, 0.1669710577, 0.3774351478, 0.5275450945, 0.642598331, 0.023835307, 0.9419788718, 0.8392260671, 0.6433275342, 0.9961528778, 0.0241268668, 0.2342460603, 0.89078933, 0.6144811511, 0.3709629476, 0.0243708324, 0.0782319084, 0.6190319657, 0.6816558838, 0.9993784428, 0.024458373, 0.6334012747, 0.4117903709, 0.4726617336, 0.5447264314, 0.0247860309, 0.878932178, 0.422383666, 0.5717362165, 0.6817410588, 0.0249806046, 0.616032362, 0.1728063822, 0.6919798851, 0.4180691838, 0.0252522565, 0.8133153915, 0.3570474982, 0.8461546898, 0.2650289536, 0.0254083686, 0.4229061604, 0.0914310142, 0.0176351219, 0.3986770809, 0.0258302372, 0.7590498328, 0.7672837973, 0.028648546, 0.5403446555, 0.0259606503, 0.6974081993, 0.6889986396, 0.6547404528, 0.2553975582, 0.0261899736, 0.2342714965, 0.671962738, 0.3202907443, 0.7651812434, 0.0265327375, 0.3210408688, 0.2570245862, 0.6180875897, 0.0858205631, 0.0266514737, 0.5866110921, 0.9739878178, 0.23584795, 0.4541831017, 0.0270466581, 0.9057922959, 0.4995442629, 0.306671679, 0.8568725586, 0.0272267722, 0.9903813004, 0.3697066009, 0.2215915173, 0.0363276117, 0.0274902955, 0.7752750516, 0.5667720437, 0.1476514637, 0.8328262568, 0.0278153662, 0.5921120048, 0.0397551768, 0.0322317481, 0.4823409021, 0.0280717947, 0.1926080883, 0.9854156375, 0.1801132709, 0.4977526367, 0.0282866769, 0.6680429578, 0.6038916707, 0.6371629238, 0.2046487629, 0.0284619182, 0.6822410822, 0.133578375, 0.0786340758, 0.5616105199, 0.0286622979, 0.4424726069, 0.3179470003, 0.2680398226, 0.0542958677, 0.0288912673, 0.1232327446, 0.3603746593, 0.5928773284, 0.6370098591, 0.0292382184, 0.5372427106, 0.0153745608, 0.660220027, 0.5478175282, 0.0294613056, 0.7959799767, 0.2727995217, 0.1012622416, 0.5150785446, 0.029580418, 0.4599424005, 0.100717321, 0.9175854325, 0.3132068515, 0.0299239308, 0.6730643511, 0.3301970065, 0.1607560366, 0.4457321465, 0.0302418936, 0.8026931286, 0.847373724, 0.1940494776, 0.9447404742, 0.0304444674, 0.9928097129, 0.1495564878, 0.6413668394, 0.6585265398, 0.0305533614, 0.3597672582, 0.9672973156, 0.1912067384, 0.1551680863, 0.0309032984, 0.298956871, 0.9990157485, 0.9998430014, 0.5238247514, 0.0310248416, 0.0835820511, 0.3182901144, 0.5861057043, 0.5752487183, 0.0314886495, 0.499522388, 0.3906169236, 0.1257322431, 0.7310088277, 0.0315883681, 0.2163365036, 0.8022968173, 0.7773286104, 0.9719676375, 0.0318491347, 0.5086533427, 0.7980102301, 0.7954028845, 0.4589500129, 0.0320912041, 0.78031075, 0.1435992569, 0.8501529694, 0.1994784325, 0.0323931947, 0.330553025, 0.098283723, 0.1773519367, 0.3744114041, 0.0326150246, 0.7939080596, 0.3190090358, 0.9700883627, 0.1067062318, 0.0327795967, 0.1210447699, 0.4231351316, 0.4946098328, 0.8558630347, 0.0330642574, 0.9935570359, 0.0574124344, 0.0295954887, 0.5919592977, 0.0333239101, 0.2452888042, 0.984089613, 0.8895401359, 0.1269200742, 0.033494398, 0.2818838954, 0.1574520916, 0.3841145635, 0.0482447408, 0.0337872729, 0.9579399228, 0.7551828623, 0.5663750172, 0.1356172413, 0.0340032168, 0.5419430137, 0.9085814953, 0.6406635046, 0.4919643104, 0.0341934077, 0.7170193791, 0.18571648, 0.3853508234, 0.9630408883, 0.0345966704, 0.2728398442, 0.234296456, 0.4968118668, 0.6725898385, 0.0348359607, 0.8808291554, 0.5868647695, 0.7742865682, 0.1744856536, 0.0350137204, 0.4174623787, 0.5443277359, 0.6669078469, 0.3683382273, 0.0351756066, 0.1893181503, 0.076896742, 0.6054267883, 0.7039074898, 0.0355220959, 0.1502123773, 0.3435633183, 0.4638076425, 0.7313242555, 0.0357781947, 0.4730790555, 0.9558206797, 0.8493852615, 0.8290187716, 0.0359090529, 0.5293825865, 0.5766800046, 0.0524612069, 0.2923840582, 0.0361595266, 0.1765686423, 0.2269783914, 0.75803864, 0.3284719288, 0.0365415998, 0.1755308509, 0.7086476684, 0.5718393326, 0.3993137777, 0.0366347097, 0.1346118152, 0.9723603725, 0.7347082496, 0.4644138813, 0.0369054228, 0.771399498, 0.4232122302, 0.1327264458, 0.6681285501, 0.0373436734, 0.0478908755, 0.4894922972, 0.4221930206, 0.8320023417, 0.0375452377, 0.5311310291, 0.6686213017, 0.542717278, 0.5945629478, 0.0377456769, 0.5970438123, 0.1244033352, 0.234189555, 0.9043307304, 0.0380652733, 0.7040627599, 0.8816208243, 0.8437633514, 0.7053799629, 0.0381792784, 0.1664177179, 0.9150137305, 0.6732702255, 0.9473659992, 0.0384328924, 0.6328683496, 0.2354076356, 0.0066912696, 0.809797883, 0.0386478044, 0.211340785, 0.5908805728, 0.8053469658, 0.6347839832, 0.0388571545, 0.5441893935, 0.0701473728, 0.313336134, 0.0957893953, 0.0391662419, 0.449238807, 0.2216103524, 0.8475818634, 0.4353236854, 0.0393983871, 0.2861022055, 0.3857587278, 0.7463465929, 0.2790216506, 0.0396046303, 0.4482796788, 0.8284660578, 0.8919641972, 0.4985580146, 0.0398458429, 0.4852329195, 0.3255411386, 0.7066060305, 0.7637109756, 0.0401278362, 0.329051286, 0.0209563412, 0.6722646952, 0.6053004861, 0.0403660908, 0.9424302578, 0.6016924381, 0.1458182931, 0.9545296431, 0.0405431092, 0.9870889783, 0.4168865085, 0.1059840694, 0.1887766868, 0.0408416353, 0.8587096334, 0.4811220467, 0.1891167164, 0.2009778321, 0.0411720984, 0.4343391359, 0.3975535333, 0.2666101158, 0.296749264, 0.0413284376, 0.533054769, 0.2441772074, 0.0448957682, 0.0480144769, 0.0415939093, 0.486577034, 0.6698746085, 0.2736288011, 0.1566580087, 0.0419333726, 0.5710110068, 0.7737393975, 0.3498518169, 0.5168098807, 0.0421938039, 0.8241609335, 0.4251399636, 0.135341689, 0.9153692126, 0.0422598906, 0.6755535007, 0.4900777042, 0.2125526518, 0.8644635677, 0.0425663441, 0.9716135263, 0.2004876435, 0.5886977911, 0.2198120207, 0.042771969, 0.5127003193, 0.4849517047, 0.0703917071, 0.1007515416, 0.0431488492, 0.8210902214, 0.789953649, 0.0767651945, 0.7511868477, 0.0434283242, 0.3574953377, 0.1649470329, 0.0008240642, 0.2334658504, 0.0436701924, 0.5398108363, 0.9711065292, 0.5569124222, 0.8739325404, 0.0438596345, 0.7377768159, 0.242497474, 0.6102737784, 0.0294529982, 0.0439805835, 0.5558157563, 0.5363591909, 0.9640653133, 0.6786074042, 0.0443023629, 0.9775245786, 0.9434307814, 0.8117011786, 0.911670804, 0.044502832, 0.7437243462, 0.9962877035, 0.6231177449, 0.7698760033, 0.0448828004, 0.0271507986, 0.109492518, 0.3188054264, 0.6217828393, 0.0449406356, 0.0679292083, 0.9222252369, 0.9124069214, 0.0696860999, 0.0452763513, 0.5776777864, 0.3616185188, 0.8492888808, 0.3641744852, 0.0456503965, 0.3848410845, 0.8302230239, 0.2618224919, 0.7441193461, 0.0457888357, 0.0650434867, 0.0608354285, 0.7182237506, 0.8124958277, 0.0461096242, 0.8289935589, 0.9926660657, 0.5042542219, 0.9527418613, 0.0461843312, 0.7309857011, 0.453270793, 0.6644627452, 0.1013275832, 0.0464992747, 0.4423924983, 0.043887686, 0.4284345508, 0.9272229671, 0.0468358286, 0.5433413982, 0.8430919647, 0.7193606496, 0.2038395852, 0.0469797514, 0.0623772219, 0.9706354141, 0.2190305591, 0.5460209846, 0.0471397638, 0.0781095698, 0.2526320517, 0.9172998071, 0.793646276, 0.0474723727, 0.3083115816, 0.4762945473, 0.6551039815, 0.1564930826, 0.0476199314, 0.513315618, 0.1036999971, 0.1053718179, 0.3743568361, 0.0480879769, 0.6821129322, 0.0415123999, 0.3984370828, 0.4426503181, 0.0482615903, 0.4567431808, 0.5151667595, 0.1474771947, 0.6189020276, 0.0485207476, 0.8494740129, 0.133819133, 0.5166945457, 0.7381197214, 0.0487401374, 0.3090821505, 0.85105443, 0.5631777644, 0.7910258174, 0.0490162447, 0.6591098905, 0.2866385877, 0.1495835781, 0.293020606, 0.0491319709, 0.7515223026, 0.1923044026, 0.0222943667, 0.1526654065, 0.0494016558, 0.7231612802, 0.2935799956, 0.6939067245, 0.8788351417, 0.049581293, 0.5617181063, 0.1850942671, 0.0742898807, 0.8189433813, 0.0498057455, 0.0719347149, 0.7690908909, 0.3843702376, 0.0856694505, 0.0502408892, 0.0632688701, 0.1883670837, 0.8471630216, 0.9770510197, 0.0505254567, 0.943500936, 0.0184909068, 0.4755743742, 0.495613724, 0.050553482, 0.2663745284, 0.2870857418, 0.5003576279, 0.0493856855, 0.0507818721, 0.4078702033, 0.9913962483, 0.063474454, 0.3819875121, 0.0511389747, 0.656258285, 0.8385023475, 0.9663436413, 0.8378800154, 0.0514060855, 0.8269785047, 0.6928087473, 0.6748873591, 0.0387051813, 0.0516586639, 0.69707793, 0.2274947166, 0.3471541703, 0.269418925, 0.0518629141, 0.7180790305, 0.0973428786, 0.5997167826, 0.2987565398, 0.0520669073, 0.9336352348, 0.2970329821, 0.0647970438, 0.4367446005, 0.0524305478, 0.4101348519, 0.163980782, 0.3169389367, 0.9983556867, 0.0525224581, 0.9353601336, 0.9077124, 0.7611338496, 0.0960676968, 0.0529565662, 0.2388710082, 0.3941167891, 0.0540681593, 0.8735795021, 0.0531926192, 0.3957832754, 0.2782140374, 0.3029129207, 0.1325840801, 0.0532588921, 0.8127061725, 0.8821395636, 0.8986012936, 0.6072000861, 0.0534798093, 0.359318167, 0.398334384, 0.9129838943, 0.7453516126, 0.0537796691, 0.8607261181, 0.5410499573, 0.9417704344, 0.2610845864, 0.05398307, 0.025703894, 0.3592725992, 0.2048562467, 0.7651212811, 0.0543002672, 0.1183954701, 0.8158272505, 0.3784966767, 0.385497123, 0.0544520915, 0.6006575227, 0.5854203105, 0.1654667109, 0.5481364727, 0.0549034104, 0.5382045507, 0.3623740673, 0.1889458746, 0.3205667436, 0.0549550392, 0.5858517289, 0.8370037675, 0.2994317412, 0.8076255918, 0.0553018488, 0.3067924678, 0.8248385191, 0.9775391817, 0.5781039, 0.0555876419, 0.946393311, 0.3657433689, 0.5661306381, 0.0790204853, 0.0558209904, 0.5954768062, 0.642454803, 0.0183017049, 0.4401574433, 0.0560885035, 0.2119552642, 0.1980753243, 0.538097322, 0.5193555355, 0.0563860424, 0.7689244151, 0.0808177143, 0.8255710006, 0.7867128253, 0.0564623103, 0.8930397034, 0.8562948108, 0.5752024055, 0.5284490585, 0.0566996634, 0.9966987371, 0.4685010314, 0.9589093924, 0.7410116196, 0.0570079796, 0.6101198196, 0.7272050977, 0.0123756276, 0.1013899222, 0.0571777858, 0.4160855412, 0.6536789536, 0.4474143386, 0.6530405283, 0.0575506836, 0.6438226104, 0.9699420929, 0.5423610806, 0.3267042339, 0.0577740297, 0.1104684919, 0.7613546252, 0.9706943035, 0.6447551847, 0.0578642637, 0.841437161, 0.5892925262, 0.9663971066, 0.3403144777, 0.0581630543, 0.1323272884, 0.5152189732, 0.010796424, 0.9275842309, 0.0584492274, 0.2931319773, 0.7148856521, 0.5555430055, 0.4287147522, 0.0587269962, 0.7511355877, 0.3629468977, 0.9218703508, 0.5341714025, 0.058865156, 0.2927557528, 0.1145779639, 0.872220397, 0.6732161641, 0.0592366867, 0.3445213139, 0.4443978667, 0.6457434297, 0.3153223097, 0.0595620386, 0.1724845469, 0.0341088809, 0.7613945603, 0.6155192852, 0.059645813, 0.4148417711, 0.9365081191, 0.6043331623, 0.4050677121, 0.0599584319, 0.1357058436, 0.6250661016, 0.2862799466, 0.4940985739, 0.0602868572, 0.0855147615, 0.4534803033, 0.9881494641, 0.2781268954, 0.0603672117, 0.972065866, 0.7081292868, 0.8715701699, 0.5466591716, 0.0606565997, 0.0285781454, 0.839363575, 0.838781476, 0.0395718664, 0.0609819628, 0.3718280494, 0.5818833709, 0.4345148802, 0.8815767765, 0.0611360371, 0.9440345764, 0.0952378213, 0.1069847941, 0.4628326893, 0.0615231432, 0.2101773173, 0.9288322926, 0.5075126886, 0.4000643194, 0.0616699941, 0.0308158733, 0.4320195913, 0.816239059, 0.3211650252, 0.0619850792, 0.7479447722, 0.1394517124, 0.9539483786, 0.9044382572, 0.0622508638, 0.5755401254, 0.6758915782, 0.712007165, 0.68687886, 0.0622641221, 0.7057911158, 0.7800344229, 0.5653573275, 0.9720668197, 0.0626811981, 0.3935459554, 0.2007560879, 0.2615462542, 0.1205192506, 0.0628411695, 0.6551766992, 0.1969967037, 0.7768732309, 0.4172841311, 0.063041091, 0.3674635291, 0.4925908446, 0.6667024493, 0.7920866609, 0.0634110644, 0.8996462822, 0.9083211422, 0.709404707, 0.1457012445, 0.0635015145, 0.3562548161, 0.5322344303, 0.6049612164, 0.9375944734, 0.0637211204, 0.4981285334, 0.919822216, 0.725231111, 0.5214147568, 0.0640635043, 0.7540050745, 0.7136243582, 0.9189988375, 0.6631800532, 0.0642608404, 0.1623289287, 0.8097453117, 0.2993314564, 0.6986395121, 0.0644821525, 0.5717529655, 0.4875931144, 0.7453587651, 0.4093028903, 0.0647298992, 0.6292716265, 0.022967251, 0.2319925427, 0.2401632965, 0.0651091859, 0.8973861337, 0.9965874553, 0.8872523308, 0.3972734213, 0.0653588995, 0.9181726575, 0.1807984114, 0.3786160052, 0.6723023057, 0.0656563044, 0.5863515139, 0.4089870155, 0.2557370067, 0.9578768015, 0.0658259541, 0.9881767631, 0.8308966756, 0.879058063, 0.4285563231, 0.0661118031, 0.4060144722, 0.4772524834, 0.2992962301, 0.2059165388, 0.0663643777, 0.4671196342, 0.1619008482, 0.0289979875, 0.7550174594, 0.0665974542, 0.0359000526, 0.3192620575, 0.3674427867, 0.5780120492, 0.0667555034, 0.6541302204, 0.8969657421, 0.4474572539, 0.108690843, 0.0669978186, 0.0417408682, 0.0230331719, 0.3625333309, 0.8655498028, 0.067305319, 0.2341199815, 0.0855290517, 0.3467016518, 0.3802669048, 0.0674490258, 0.2344822884, 0.7505428791, 0.6175200343, 0.8083914518, 0.0676408187, 0.8380948901, 0.6287975311, 0.4477202594, 0.3626734614, 0.0680689439, 0.6547611356, 0.5478475094, 0.8220201135, 0.2012880147, 0.0683359578, 0.3885985017, 0.7240751386, 0.1448843628, 0.2296859622, 0.068401739, 0.7839163542, 0.986043036, 0.9685826302, 0.7999537587, 0.0688472837, 0.7031974792, 0.8250049353, 0.266218394, 0.8745645881, 0.0689502209, 0.3876169324, 0.0347653963, 0.2576650381, 0.0209626518, 0.0692833588, 0.3917622268, 0.3390086591, 0.125777334, 0.797745347, 0.0693983063, 0.1064087823, 0.9067006707, 0.1288160235, 0.0601612851, 0.0696804002, 0.4825960398, 0.8466435075, 0.4570294023, 0.2116647512, 0.0698961839, 0.9510145187, 0.650652647, 0.392989397, 0.4847156405, 0.0702058151, 0.2872371674, 0.6579374671, 0.7387816906, 0.9707887769, 0.0703754127, 0.5938100219, 0.2366212904, 0.5601204038, 0.0343928337, 0.0707908198, 0.2606928349, 0.9264442325, 0.0774890482, 0.0626507029, 0.0709281787, 0.6520555019, 0.7433550954, 0.1146918684, 0.4213481247, 0.0711388066, 0.2502732575, 0.845230639, 0.0544719659, 0.1501971781, 0.0715257749, 0.7733664513, 0.5148495436, 0.3153182268, 0.5712278485, 0.0715651736, 0.9528820515, 0.5524266958, 0.9439774156, 0.4815790355, 0.0718785897, 0.8494734168, 0.7470275164, 0.493755281, 0.9147025943, 0.0721168965, 0.2468672395, 0.7171310186, 0.1757197976, 0.2605859637, 0.0724579245, 0.9079783559, 0.5483204126, 0.7733299136, 0.2041899413, 0.072547473, 0.7994664311, 0.611772418, 0.7291424274, 0.8528920412, 0.0727805421, 0.3395567536, 0.7672840953, 0.8544574976, 0.9431186914, 0.0731034353, 0.6349754333, 0.6721323729, 0.6962663531, 0.3192598224, 0.0734091923, 0.8889439702, 0.6281045079, 0.8659900427, 0.3132424057, 0.0736058876, 0.2243998945, 0.2960400283, 0.0999320522, 0.2499219179, 0.5115166903, 0.0204182714, 0.663102746, 0.8230811954, 0.5496843457, 0.5046294928, 0.9811518192, 0.1133715957, 0.2259661108, 0.19990547, 0.5419001579, 0.0715354383, 0.2745304704, 0.1484488994, 0.3254649937, 0.5480608344, 0.1789485812, 0.5548414588, 0.0015056671, 0.6750273705, 0.522731781, 0.0008752898, 0.5411751866, 0.5249070525, 0.4570088685, 0.5505707264, 0.7655183077, 0.7792156339, 0.6483680606, 0.4496525824, 0.5599683523, 0.6312948465, 0.127844274, 0.4247913659, 0.0007082918, 0.5338511467, 0.4571608603, 0.2620616853, 0.1010501832, 0.8749824166, 0.527798295, 0.0978882238, 0.5404268503, 0.4003234804, 0.1471461952, 0.5669991374, 0.5410963893, 0.5188904405, 0.7992156148, 0.3746570647, 0.5364877582, 0.6718787551, 0.2058310509, 0.2480937093, 0.3753580451, 0.5190321207, 0.6394835711, 0.576433599, 0.5001162887, 0.5508361459, 0.5376195908, 0.1067471281, 0.6241273284, 0.801954031, 0.7488102913, 0.5381161571, 0.6607485414, 0.4171015918, 0.2246898711, 0.0752501786, 0.5143418908, 0.2288838625, 0.115642488, 0.099928759, 0.6014629006, 0.5073698759, 0.698384583, 0.1368516386, 0.8736896515, 0.752558887, 0.5565645099, 0.4013375938, 0.3540355265, 0.5754721761, 0.3261488676, 0.5243055224, 0.5820555091, 0.1185304895, 0.5007212162, 0.226235792, 0.5005226135, 0.0950565264, 0.3787706792, 0.1740462631, 0.762401104, 0.5504430532, 0.6341329813, 0.3289246559, 0.8504666686, 0.5751883388, 0.5534842014, 0.8555600643, 0.9008951187, 0.1483384818, 0.1497145593, 0.5018998981, 0.5148512721, 0.3895414472, 0.1749736965, 0.7005600333, 0.5315646529, 0.7238113284, 0.3066526055, 0.8754833937, 0.0253881328, 0.5453944206, 0.0735144466, 0.8595376015, 0.8770704269, 0.7007963061, 0.5539349914, 0.3620923758, 0.0416149981, 0.5511590242, 0.1753898561, 0.5428982377, 0.0061305529, 0.9809518456, 0.9500498176, 0.0746196732, 0.5140426159, 0.3935596943, 0.8545308113, 0.0751440227, 0.3258487582, 0.5482404232, 0.1663255543, 0.5424755216, 0.4755449295, 0.7762312889, 0.5112431049, 0.5744220614, 0.638240993, 0.065887861, 0.9506678581, 0.5125494003, 0.9269253016, 0.0504866913, 0.299456656, 0.2502886951, 0.5413233042, 0.0337529555, 0.7528452277, 0.2519438267, 0.7750726938, 0.5304656625, 0.7146564126, 0.2432672977, 0.3496539295, 0.9512079358, 0.5524450541, 0.4369109869, 0.4125491977, 0.3010438979, 0.300183028, 0.5212009549, 0.6104905605, 0.3683334589, 0.9504808784, 0.5489679575, 0.5309481621, 0.5791496038, 0.8105304241, 0.174946025, 0.8758938313, 0.5421879888, 0.1758835167, 0.9822794795, 0.6258250475, 0.5763518214, 0.5404347181, 0.4388094842, 0.1073131636, 0.3750612736, 0.7005741596, 0.5204791427, 0.7674415112, 0.2598839402, 0.7001037002, 0.2501595616, 0.5395210981, 0.9401791096, 0.3307978809, 0.6495859623, 0.8989270329, 0.522262156, 0.0505006835, 0.9291836023, 0.4744192362, 0.4241538048, 0.5217758417, 0.9684359431, 0.7657282948, 0.7503231168, 0.1255191863, 0.5349799395, 0.9138517976, 0.0479166918, 0.2491602898, 0.5001539588, 0.5472148061, 0.5830619335, 0.7588519454, 0.3500490189, 0.6250315309, 0.5657589436, 0.0816372111, 0.9144294262, 0.2504021227, 0.6756541729, 0.5644892454, 0.0794547722, 0.9875050783, 0.5760949254, 0.2500765324, 0.5521107912, 0.4363875091, 0.8016386032, 0.5240598917, 0.0005014921, 0.5508316159, 0.9080847502, 0.4784570336, 0.1754235327, 0.0088394545, 0.5237308741, 0.2941185832, 0.9301610589, 0.9761223197, 0.4750322104, 0.5312444568, 0.5898828506, 0.8245856762, 0.624982357, 0.5482255816, 0.5568055511, 0.4910352826, 0.9700344205, 0.7003957033, 0.9335463643, 0.5442412496, 0.0020940867, 0.825288415, 0.4500236213, 0.8267934918, 0.5330046415, 0.490790844, 0.5618960857, 0.6736150384, 0.6998431087, 0.5307450294, 0.8588863015, 0.464355588, 0.4020885229, 0.6251436472, 0.5615539551, 0.1339508742, 0.7263863683, 0.0744914934, 0.5144289732, 0.5268847942, 0.6987854838, 0.1880896091, 0.473520726, 0.0254445318, 0.5090574622, 0.2160100937, 0.8461467028, 0.1498632431, 0.4940408468, 0.5455294847, 0.7461754084, 0.6037412286, 0.800234735, 0.6767628789, 0.5379282236, 0.6735312343, 0.4157984555, 0.2249268442, 0.2818438113, 0.5636990666, 0.1006637216, 0.0505338572, 0.4440321028, 0.5000624061, 0.5133524537, 0.2775644362, 0.925563097, 0.1001772732, 0.2768403292, 0.5492872596, 0.2484582216, 0.6870269179, 0.0997253805, 0.6744239926, 0.5071257353, 0.6931677461, 0.120663695, 0.700317502, 0.5999883413, 0.5014630556, 0.4683262408, 0.025459677, 0.3272641003, 0.7245584726, 0.5063111782, 0.331953615, 0.7235289216, 0.8011968136, 0.0001621095, 0.5345208049, 0.8668708801, 0.5254281759, 0.3491019607, 0.4749787748, 0.5048764348, 0.6250700355, 0.9735502005, 0.0001044485, 0.074950479, 0.5278743505, 0.009206146, 0.8523430824, 0.3668426275, 0.0002808082, 0.5214610696, 0.4607114196, 0.0699647814, 0.0019413906, 0.1997381002, 0.5493205786, 0.22585015, 0.7851875424, 0.1752269715, 0.0598003455, 0.7709927559, 0.7297613621, 0.0649805665, 0.4251952767, 0.6993083358, 0.5573977828, 0.1529742479, 0.4662842453, 0.574539721, 0.8259099722, 0.543817997, 0.2359199971, 0.7312087417, 0.1745049804, 0.5756510496, 0.5485115051, 0.3477488458, 0.6228222847, 0.3994095325, 0.9007194638, 0.5086779594, 0.7389538288, 0.6282545328, 0.8500962853, 0.6250864267, 0.5561627746, 0.8481809497, 0.911229074, 0.8962005377, 0.1752026826, 0.5207901001, 0.3835842609, 0.5991029739, 0.325119108, 0.8248625994, 0.5234875083, 0.6679962277, 0.8833323121, 0.925121069, 0.4268980026, 0.5215517879, 0.1819206476, 0.4930852056, 0.5272848606, 0.3749874234, 0.547031939, 0.6138436198, 0.3826188147, 0.3000193536, 0.0254025068, 0.5083312392, 0.5883831382, 0.0250427239, 0.5253503919, 0.6984312534, 0.5249617696, 0.1148199067, 0.6741824746, 0.7499855757, 0.2483469546, 0.7933039665, 0.4377368391, 0.2851114273, 0.2500551641, 0.5995117426, 0.5023117065, 0.6605564356, 0.7936561704, 0.3750658035, 0.2997975647, 0.5025106072, 0.71665591, 0.8406170607, 0.2251778096, 0.1504408717, 0.2918845415, 0.5752936006, 0.2793307304, 0.700756371, 0.5500325561, 0.2513979077, 0.9613408446, 0.0115701305, 0.744176805, 0.7239213586, 0.53851825, 0.2844346166, 0.1727228463, 0.3000291586, 0.9515274167, 0.8023766279, 0.9329535365, 0.4029352665, 0.3253384531, 0.2250669003, 0.5517534018, 0.2216116488, 0.6016576886, 0.624948442, 0.253697902, 0.3020848632, 0.4296074212, 0.2982615232, 0.300278157, 0.6501519084, 0.5354457498, 0.3292373717, 0.9856880903, 0.1259277612, 0.5750076175, 0.7985692024, 0.8530553579, 0.6365734339, 0.9006658196, 0.3501928747, 0.5347179174, 0.624438405, 0.5994596481, 0.3002256453, 0.5259074569, 0.5570207238, 0.45246768, 0.9247552752, 0.0003350284, 0.7242047787, 0.7728614807, 0.0018703928, 0.0442872606, 0.8747982383, 0.0996252671, 0.507807374, 0.3267765045, 0.4316724539, 0.6261390448, 0.6247706413, 0.290464133, 0.4472540915, 0.607480824, 0.5492273569, 0.2247809023, 0.2553791404, 0.5050001144, 0.0748781487, 0.4740642905, 0.9500795007, 0.5319891572, 0.3242605627, 0.3491915762, 0.1001721472, 0.8254614472, 0.7777736187, 0.6033853889, 0.5377215743, 0.7752010226, 0.5498775244, 0.2544977665, 0.483201772, 0.1113383546, 0.9252296686, 0.1228583753, 0.5328768492, 0.620890379, 0.9137431383, 0.0465656333, 0.2499735206, 0.527382195, 0.0361996554, 0.5778218508, 0.6004186869, 0.975728631, 0.5239554048, 0.7314612269, 0.3885940313, 0.6759005785, 0.2239830643, 0.5468668938, 0.5622667074, 0.4704272747, 0.8742733002, 0.7999920845, 0.3064700365, 0.3837772608, 0.8443513513, 0.9754860401, 0.160550952, 0.7994903922, 0.2277876586, 0.2809434533, 0.9752686024, 0.3751614392, 0.5258629322, 0.2629101574, 0.2701103985, 0.1748678833, 0.4005971849, 0.5301225781, 0.3054472804, 0.3499853015, 0.3498946428, 0.3000138998, 0.7711179256, 0.6126044989, 0.8665628433, 0.3245068491, 0.1747387946, 0.5532488227, 0.3132550418, 0.381298393, 0.575879693, 0.9011237025, 0.5639500022, 0.9989155531, 0.4252488017, 0.5264706612, 0.1039549336, 0.5333061218, 0.0940899178, 0.6125734448, 0.7496387362, 0.3744670749, 0.5200789571, 0.7560089827, 0.2080084532, 0.1001026705, 0.9458412528, 0.5415499806, 0.3668878973, 0.9828520417, 0.999561131, 0.763890028, 0.562782526, 0.1718402356, 0.2598179877, 0.9996442199, 0.9997321963, 0.5161181092, 0.5751026273, 0.0757289082, 0.9247543812, 0.7006901503, 0.303823173, 0.8562679291, 0.0440575555, 0.8500502706, 0.1521456838, 0.7765128613, 0.8845826387, 0.7974487543, 0.2751914263, 0.9235986471, 0.5010297894, 0.415225029, 0.1891870201, 0.7493785024, 0.0502499864, 0.5299572349, 0.5484668016, 0.8940036297, 0.5997685194, 0.1751283556, 0.2929151058, 0.509487927, 0.9900570512, 0.2730788291, 0.3252712786, 0.5088200569, 0.9107674956, 0.2064258009, 0.9254841805, 0.9736527801, 0.5173871517, 0.5805056691, 0.2224412262, 0.4251921177, 0.2448307574, 0.5402419567, 0.0911679268, 0.1550231129, 0.1503494382, 0.1772428006, 0.5361026525, 0.9279728532, 0.6084936857, 0.7732584476, 0.0000354978, 0.5147289634, 0.6864467859, 0.7499171495, 0.6498963237, 0.4004913867, 0.8100335598, 0.1245280132, 0.1258932203, 0.5502613187, 0.4755345285, 0.5397840738, 0.6746035814, 0.5899897218, 0.4761830568, 0.4503525496, 0.3006536961, 0.2664533257, 0.7806874514, 0.5977367759, 0.4497195184, 0.5591698289, 0.6015981436, 0.8595799804, 0.3999920785, 0.7755410671, 0.5221899748, 0.6598505378, 0.5304762721, 0.7009853125, 0.0497843474, 0.275854528, 0.0503295958, 0.7405276895, 0.5497202277, 0.5502256155, 0.7878061533, 0.1018271223, 0.1266049147, 0.800562799, 0.8237455487, 0.5462722182, 0.3760555983, 0.0753159896, 0.1035231426, 0.1497556567, 0.751811564, 0.5082446337, 0.8875021935, 0.8202154636, 0.4002920389, 0.5513230562, 0.8215457201, 0.9464796782, 0.1498018503, 0.3711400032, 0.7981531024, 0.6742455959, 0.5438446999, 0.425768882, 0.9712520838, 0.7746434808, 0.8302544951, 0.4448617995, 0.9000604749, 0.5749567151, 0.5313487053, 0.3104019463, 0.6124757528, 0.2243317217, 0.7251231074, 0.5542970896, 0.6156340837, 0.3250629902, 0.0455734171, 0.6751070619, 0.2728859782, 0.5120468736, 0.5437161326, 0.5001484156, 0.6025904417, 0.5296363235, 0.1155260205, 0.3393405974, 0.6501275897, 0.0747039318, 0.5519939661, 0.188834846, 0.7275009155, 0.4955745339, 0.7000873089, 0.5423910618, 0.9416359067, 0.3536934853, 0.6755961776, 0.6561246514, 0.7678679824, 0.3357191682, 0.4943229258, 0.7998280525, 0.075196363, 0.5529671907, 0.7376633286, 0.899972558, 0.0996982306, 0.0253865514, 0.5709270239, 0.1597508341, 0.2412546128, 0.8247569799, 0.8734449148, 0.5225820541, 0.688325882, 0.0724279657, 0.2996210754, 0.4001732767, 0.5182953477, 0.7831487656, 0.8166896105, 0.0233779121, 0.3021736741, 0.5398937464, 0.4776594043, 0.0058054971, 0.8610946536, 0.2251330763, 0.5136775374, 0.9498023391, 0.8130799532, 0.8136752248, 0.9504834414, 0.5410513878, 0.3925128579, 0.2980484068, 0.9516111016, 0.3005914092, 0.5590465665, 0.6285298467, 0.1961681694, 0.748911798, 0.6507989764, 0.5339702368, 0.6700567007, 0.2800427377, 0.6983140707, 0.52496773, 0.5195064545, 0.2980390489, 0.16067864, 0.2987805009, 0.7251967788, 0.5361614227, 0.7935696244, 0.5575941205, 0.7740447521, 0.9302762151, 0.544528842, 0.0952188447, 0.1136509851, 0.2246903181, 0.1248656958, 0.264377594, 0.2228783816, 0.6161629558, 0.6998116374, 0.8493226767, 0.5245594382, 0.2978401184, 0.3333850503, 0.3490571976, 0.0750670508, 0.5391489267, 0.9486908317, 0.7237961888, 0.099751398, 0.7861223817, 0.5464121103, 0.8507101536, 0.3045574427, 0.5250537992, 0.775069654, 0.5293450952, 0.4792307317, 0.7873080373, 0.4325400293, 0.553779006, 0.5130739212, 0.0449095294, 0.917511642, 0.1997812688, 0.4596541226, 0.5292966962, 0.1815126389, 0.2876657248, 0.2660025358, 0.831805706, 0.5373314619, 0.8614996076, 0.2404779047, 0.1249781027, 0.5496615171, 0.5288793445, 0.9512536526, 0.7106238604, 0.2499334365, 0.4168019295, 0.2690057755, 0.1374810934, 0.5880811214, 0.1499096006, 0.0976217687, 0.5357709527, 0.7261719108, 0.3562320471, 0.8003937006, 0.1736645848, 0.5000972152, 0.9106252789, 0.1092447415, 0.9346538782, 0.6255768538, 0.5611312985, 0.375063926, 0.3079939485, 0.3747005463, 0.5494291782, 0.5426376462, 0.3295607567, 0.9194047451, 0.6838009357, 0.1845372915, 0.7969882488, 0.0567502901, 0.4751828611, 0.5001500249, 0.2690117657, 0.7505946755, 0.1000960097, 0.8821128607, 0.3651940227, 0.2250199467, 0.3017239273, 0.727419436, 0.5936693549, 0.7753910422, 0.8929878473, 0.7661802173, 0.2630929947, 0.3632211089, 0.0372290835, 0.8369566798, 0.5336752534, 0.8983758688, 0.2219576985, 0.0444791801, 0.7921099067, 0.5526638031, 0.5702645183, 0.0122680143, 0.7757485509, 0.2998821437, 0.5375289917, 0.2801386118, 0.5837280154, 0.5242258906, 0.8832383156, 0.5370056033, 0.6608048081, 0.4363793731, 0.7999209762, 0.775095284, 0.2846296728, 0.8795508146, 0.1608684063, 0.4233184755, 0.2804969549, 0.7526665926, 0.2038259506, 0.8353402615, 0.9511299729, 0.87478441, 0.5510716438, 0.320658505, 0.1963020414, 0.0725258663, 0.4753859341, 0.7775045633, 0.7826504111, 0.6878070235, 0.1721748561, 0.6749533415, 0.5287784338, 0.5452747941, 0.3972863555, 0.7004129291, 0.7248691916, 0.8003051877, 0.2005801052, 0.6780173182, 0.9035027623, 0.4600081444, 0.7805774808, 0.2603481114, 0.9447153807, 0.6034649611, 0.6747562289, 0.5285315514, 0.9772263765, 0.4650842845, 0.3115386069, 0.4627543688, 0.7548241019, 0.0751347989, 0.933818996, 0.7353200316, 0.1745953262, 0.7850107551, 0.4074598849, 0.0395092294, 0.3747457266, 0.7407103181, 0.7702561021, 0.2608159781, 0.2204758972, 0.9142432809, 0.0300660655, 0.2951912582, 0.6118893027, 0.8346792459, 0.9975226521, 0.6114969254, 0.5368096828, 0.3778877556, 0.860881269, 0.1997035146, 0.9059427381, 0.2862283587, 0.6603853106, 0.6420208216, 0.4752921164, 0.1196575463, 0.5135126114, 0.9023658037, 0.6486666799, 0.2795032263, 0.9888322949, 0.4357944131, 0.4658937752, 0.8178166747, 0.408634305, 0.3612650335, 0.5406261086, 0.3329614401, 0.083162345, 0.4390114248, 0.1488649845, 0.3171105981, 0.5422522426, 0.032806851, 0.889762342, 0.8997618556, 0.5169444084, 0.6603409648, 0.9383791089, 0.9743193388, 0.2395078838, 0.531948328, 0.5203607678, 0.138084203, 0.261980325, 0.2162847072, 0.8036819696, 0.4048399329, 0.6602196693, 0.8711836338, 0.466175437, 0.540915072, 0.0809135213, 0.898427248, 0.0596349053, 0.0117377304, 0.3062259555, 0.6711297035, 0.267337501, 0.8356544971, 0.6613228321, 0.7973790765, 0.2280260473, 0.8149731755, 0.0408365093, 0.0750936046, 0.7854781747, 0.4383783937, 0.1533345282, 0.1119991168, 0.3134014308, 0.799225688, 0.7203811407, 0.7091453671, 0.175561741, 0.8496134877, 0.5280808806, 0.3259921372, 0.7993033528, 0.6418301463, 0.9250168204, 0.5502291322, 0.1222573742, 0.5057234764, 0.1000155732, 0.9000147581, 0.7919905782, 0.8671909571, 0.0284288563, 0.6801979542, 0.2846042514, 0.782882154, 0.4448051751, 0.1685207933, 0.4005309045, 0.8637186289, 0.5495784283, 0.0345784724, 0.6030176878, 0.8173489571, 0.2388448864, 0.5430321097, 0.9160596728, 0.5306850672, 0.0388270207, 0.9002864361, 0.532563746, 0.7880895138, 0.7949716449, 0.288038522, 0.5987402797, 0.7523050308, 0.6136860847, 0.2506010234, 0.5284342766, 0.0743304119, 0.5607281327, 0.0826105773, 0.434252888, 0.9920173287, 0.8997177482, 0.3068070412, 0.8243589401, 0.1300874949, 0.2239975929, 0.659799397, 0.5129216313, 0.4075867236, 0.4422813058, 0.6123604774, 0.3333697319, 0.7742974162, 0.5759977102, 0.6168429852, 0.7250822783, 0.3105677962, 0.5385826826, 0.7408080697, 0.3263380826, 0.5629963279, 0.3624468744, 0.7915677428, 0.2120130956, 0.366368264, 0.9386667013, 0.9385758042, 0.7667163014, 0.1570772976, 0.1708049625, 0.1093291715, 0.6379883885, 0.772313714, 0.549703002, 0.624430716, 0.5008698702, 0.5245783329, 0.5530485511, 0.6864647865, 0.582688272, 0.4386887848, 0.7588463426, 0.5207459927, 0.8803467751, 0.2860114872, 0.7752911448, 0.7224058509, 0.2763405144, 0.1926852316, 0.1651296169, 0.8698518872, 0.0626572743, 0.7763509154, 0.8382780552, 0.4174584746, 0.4605165422, 0.6877903938, 0.300114274, 0.1704382151, 0.9506057501, 0.0413748622, 0.1246928498, 0.4211828113, 0.9457256198, 0.2883197963, 0.5626202226, 0.2997952104, 0.30193156, 0.4052161276, 0.3289777935, 0.1378460377, 0.8693628907, 0.277734369, 0.8913806081, 0.245193392, 0.6290415525, 0.7323547602, 0.5262699127, 0.6497017741, 0.6197906137, 0.6127650142, 0.9004053473, 0.8138029575, 0.5513033271, 0.379837364, 0.9634651542, 0.5130774975, 0.7811911106, 0.5899270773, 0.3152047694, 0.5744165182, 0.0001871195, 0.5706067681, 0.7560129762, 0.4177090228, 0.8113030791, 0.5146631598, 0.7545950413, 0.0771946386, 0.7100368142, 0.0633007288, 0.6079054475, 0.7574558258, 0.703551054, 0.6323798299, 0.2636410594, 0.2591147423, 0.7913017273, 0.504630208, 0.7218750715, 0.4110842943, 0.1116999313, 0.8085526228, 0.9592315555, 0.6070178747, 0.2127826959, 0.3852916658, 0.7689697742, 0.5475053191, 0.9814865589, 0.4718229175, 0.8848004341, 0.5540108085, 0.7498770356, 0.5739431381, 0.1898969859, 0.9750541449, 0.2718774974, 0.4377221763, 0.4282991588, 0.0034452199, 0.9634109735, 0.7646242976, 0.0675212964, 0.2389044762, 0.6095223427, 0.5148304701, 0.3070017993, 0.0609804951, 0.9367491603, 0.8380074501, 0.7437092066, 0.2881639302, 0.6731401086, 0.925747931, 0.6335731745, 0.960519731, 0.787201345, 0.8635986447, 0.7912477255, 0.125237897, 0.984414041, 0.5324501991, 0.1294085979, 0.9112638235, 0.8145045042, 0.2843495309, 0.775765717, 0.7959787846, 0.5845375061, 0.4706402719, 0.5751262307, 0.7647804022, 0.8158777952, 0.3960022926, 0.3003020585, 0.0616735183, 0.7738249898, 0.5302147865, 0.6218560934, 0.5896311402, 0.1081295907, 0.5352211595, 0.1017315537, 0.6753742695, 0.7027110457, 0.9697492719, 0.7844030261, 0.117111899, 0.3106798232, 0.250456214, 0.0859673023, 0.5458080173, 0.5280211568, 0.6978164315, 0.5276758671, 0.849994421, 0.2938606143, 0.7426661849, 0.7418406606, 0.5153419971, 0.4916026592, 0.8018440008, 0.030782545, 0.5341912508, 0.0836942196, 0.2176079899, 0.7615510821, 0.480861634, 0.7122395039, 0.2144380808, 0.5090511441, 0.2972461581, 0.1086695045, 0.7769420147, 0.5746155381, 0.937499404, 0.3132429719, 0.2976965904, 0.7660832405, 0.6761261821, 0.4500373602, 0.5095434189, 0.5840551257, 0.2035022974, 0.4737493396, 0.3882605433, 0.7622998953, 0.0092825871, 0.2572658658, 0.4130029976, 0.662155509, 0.8094986677, 0.2627421319, 0.0946138427, 0.490260601, 0.6374538541, 0.2821718752, 0.6151838303, 0.0784768164, 0.0167285688, 0.0250962991, 0.2846912742, 0.4282787442, 0.1700391173, 0.8876488805, 0.6409283876, 0.8048554063, 0.8539528251, 0.4121233225, 0.2251935303, 0.9394209981, 0.5498843193, 0.3765726388, 0.3822593093, 0.1384685785, 0.7643449903, 0.790938139, 0.0896739662, 0.3571909964, 0.4823709726, 0.8112801909, 0.2614620328, 0.6088703275, 0.1068607867, 0.8092662096, 0.7131049037, 0.7882003188, 0.0500102006, 0.5385617614, 0.2635365427, 0.7084999084, 0.8051757216, 0.5753301978, 0.0005160624, 0.8489185572, 0.1240955219, 0.2577161491, 0.8503218889, 0.4499092698, 0.9996731281, 0.5500799417, 0.7929956913, 0.4484986961, 0.2998239696, 0.8912776709, 0.2883389592, 0.5388507247, 0.9632484913, 0.811290741, 0.8502166867, 0.3997798264, 0.5555904508, 0.4219462276, 0.3296247125, 0.9898644686, 0.3138978481, 0.8086916804, 0.0744073465, 0.1059252173, 0.3706417382, 0.4202817976, 0.5342596173, 0.781045258, 0.0852209106, 0.5590644479, 0.6252070069, 0.5264827013, 0.3523439169, 0.509884119, 0.9554960728, 0.4086942375, 0.2714860737, 0.6909407377, 0.4901607335, 0.6392166615, 0.6937839389, 0.7804899216, 0.8526608348, 0.951646626, 0.1991148293, 0.2340947986, 0.557251215, 0.0562805459, 0.045324333, 0.6750744581, 0.9095993042, 0.2970505059, 0.4754351974, 0.7000186443, 0.1316584945, 0.2620893419, 0.7990656495, 0.2484972477, 0.181103155, 0.6253730059, 0.174858585, 0.527304709, 0.3286120594, 0.6072568893, 0.7362372279, 0.9358738065, 0.3073558509, 0.4165186286, 0.8981802464, 0.3001219034, 0.3351886868, 0.2710070312, 0.1095422283, 0.3549511433, 0.6977123022, 0.112402685, 0.5433037281, 0.8624612093, 0.7299483418, 0.5569099784, 0.7132778764, 0.2751158774, 0.6061931252, 0.6541576982, 0.0001218671, 0.8438360691, 0.2859224677, 0.4624030888, 0.2270945013, 0.7498405576, 0.495765537, 0.5488407016, 0.2605675459, 0.0614596605, 0.9457700253, 0.7732230425, 0.5581467748, 0.1797589958, 0.9994236827, 0.2865118086, 0.7720754743, 0.7814735174, 0.3624053895, 0.7065202594, 0.2256019861, 0.6252601743, 0.2569191754, 0.9069035053, 0.3790998161, 0.3208078444, 0.4973346889, 0.2825217545, 0.4639153481, 0.6000622511, 0.9945076108, 0.1314353794, 0.4284003675, 0.950085938, 0.8687666059, 0.4296155274, 0.7254772186, 0.77067101, 0.8460306525, 0.7345523238, 0.9994496107, 0.3506086767, 0.7760996819, 0.7378966808, 0.2598538697, 0.8751109242, 0.8503549695, 0.2687365115, 0.9418107271, 0.5758903623, 0.5956566334, 0.0602373593, 0.5487769246, 0.0542028658, 0.4060555696, 0.0226368401, 0.2745754123, 0.7857446074, 0.5217471123, 0.475898087, 0.1905053407, 0.7318531871, 0.8043738008, 0.624835968, 0.8252434731, 0.7414038181, 0.7869729996, 0.5266615152, 0.6692519188, 0.4764635563, 0.4744595289, 0.2408789396, 0.7754648924, 0.4600417316, 0.7893798351, 0.5392030478, 0.950119853, 0.6797338128, 0.8395846486, 0.959082067, 0.1691662073, 0.9207706451, 0.7862272859, 0.2203316838, 0.5409872532, 0.1763838232, 0.6097521782, 0.2858668864, 0.8091250658, 0.4302299321, 0.7918794751, 0.1101478338, 0.2941585779, 0.8141484857, 0.4729580283, 0.4355879724, 0.1765970439, 0.5436180234, 0.208168596, 0.0995367989, 0.408916831, 0.3111028373, 0.2592484355, 0.4544049203, 0.4789769351, 0.5260415077, 0.2998954356, 0.5259347558, 0.9072730541, 0.4073594809, 0.1410185099, 0.7003865838, 0.281593293, 0.7142217755, 0.803301394, 0.8457406163, 0.5240047574, 0.2827538252, 0.480553329, 0.0624564886, 0.9768877625, 0.9293188453, 0.4134830534, 0.5720592141, 0.1760986447, 0.9329249263, 0.197711125, 0.5100764036, 0.3891465664, 0.0091627166, 0.6256566644, 0.2875197232, 0.6641430855, 0.7309313416, 0.76728791, 0.8860545754, 0.9564353824, 0.5440785885, 0.6018192172, 0.1687208861, 0.0745749623, 0.1774723679, 0.4165121317, 0.0244933479, 0.9739898443, 0.7893202305, 0.3419615924, 0.7864072919, 0.6683464646, 0.6738077998, 0.7579115033, 0.8344991803, 0.5448824167, 0.7964057922, 0.3579272926, 0.6661602855, 0.5143686533, 0.7644002438, 0.5755745173, 0.7065804005, 0.4502511919, 0.0750880912, 0.7614418864, 0.2898681462, 0.3729478717, 0.6439507008, 0.0250395555, 0.3022561967, 0.1900106966, 0.2208629847, 0.9743952155, 0.7110337019, 0.5477516651, 0.4334086776, 0.2265555561, 0.9340953231, 0.3495745957, 0.2966069579, 0.1040182561, 0.0153717613, 0.7753479481, 0.650398016, 0.2883664668, 0.0782936737, 0.1556585431, 0.9369826913, 0.8211395741, 0.5255106688, 0.7216694951, 0.2655977309, 0.4939062595, 0.985076189, 0.2891822755, 0.4406910837, 0.8576093316, 0.3409891725, 0.5496462584, 0.7996324301, 0.3746490479, 0.3689315617, 0.715531826, 0.3934908509, 0.7617766261, 0.250256151, 0.2582918108, 0.2725115716, 0.524661541, 0.8038206697, 0.1215173379, 0.9531595111, 0.3749415576, 0.1633504033, 0.5093793869, 0.0775244907, 0.2248118222, 0.4619115591, 0.9243010283, 0.8006494641, 0.3813991249, 0.272359997, 0.7801956534, 0.1414201558, 0.7675882578, 0.3985167444, 0.0777013674, 0.0832739323, 0.4089244902, 0.5608979464, 0.9120648503, 0.3564301431, 0.4358764291, 0.6246863008, 0.2917339802, 0.6748359203, 0.8100230098, 0.7214345336, 0.4336005151, 0.7674770951, 0.1289839298, 0.8295099139, 0.1411042064, 0.4006635547, 0.7801882625, 0.8009476662, 0.3393412828, 0.3386042118, 0.5950755477, 0.5583661795, 0.4575778842, 0.3825599551, 0.509259522, 0.3311366737, 0.302585125, 0.0787324086, 0.299010694, 0.1220708191, 0.3456930816, 0.2981326282, 0.1732985675, 0.0506457649, 0.8253732324, 0.4598790705, 0.2902397215, 0.6003482938, 0.0133542782, 0.6858534217, 0.075014554, 0.2948904932, 0.5293439627, 0.4628251493, 0.7639911175, 0.4484609962, 0.5474563241, 0.1789518744, 0.9198279977, 0.1933730245, 0.0871127918, 0.6426331997, 0.9601479173, 0.3560474515, 0.3957444727, 0.0169553291, 0.7837250829, 0.9497953057, 0.2531274259, 0.0782000795, 0.8508540392, 0.2906319499, 0.8910681009, 0.0400970206, 0.9442071319, 0.2259038985, 0.2931440175, 0.4078338146, 0.6724775434, 0.8335361481, 0.0069740796, 0.792668879, 0.4450193048, 0.0904317498, 0.8448672891, 0.910820961, 0.544988215, 0.2355297804, 0.9682732821, 0.6588913798, 0.5752074122, 0.7905238271, 0.9339547753, 0.1112099066, 0.5902088284, 0.7717949748, 0.5253858566, 0.2382190526, 0.6141679883, 0.6852118969, 0.8193714023, 0.7637542486, 0.3638478518, 0.871527791, 0.6003316045, 0.6048004031, 0.7847290635, 0.94981426, 0.6895409822, 0.0497272238, 0.5658306479, 0.5247703195, 0.1598428339, 0.47953403, 0.7133460045, 0.2800622582, 0.3059506714, 0.0821619332, 0.9653497934, 0.2650574744, 0.4688487649, 0.5459523201, 0.7050676346, 0.9935357571, 0.5994047523, 0.7361437678, 0.7716812491, 0.4253230095, 0.0386153422, 0.2245454937, 0.791311264, 0.5232684016, 0.0133250756, 0.2724117637, 0.2549408078, 0.183833316, 0.6727284193, 0.0073994482, 0.8394752145, 0.9202122688, 0.399884671, 0.7695948482, 0.4187813401, 0.1450325996, 0.1993959546, 0.3500203788, 0.4006854594, 0.0414465889, 0.787003994, 0.6396826506, 0.3506583869, 0.4046313763, 0.6890106797, 0.1043194309, 0.9647856355, 0.6123890877, 0.2973951697, 0.7624385953, 0.9991747737, 0.9002122283, 0.0998907015, 0.7890358567, 0.0819713324, 0.6053829193, 0.5372489691, 0.1499465853, 0.283590287, 0.5306325555, 0.43345806, 0.3860293329, 0.9300792217, 0.7587786317, 0.7449499965, 0.1269662082, 0.7750867009, 0.5759402514, 0.5544554591, 0.9125486612, 0.0779895484, 0.0228035692, 0.7002257109, 0.6478238702, 0.2508028746, 0.2992904782, 0.5029975176, 0.4323965907, 0.806083858, 0.5273122191, 0.2564524412, 0.1581190675, 0.7286189795, 0.1566729099, 0.3622593284, 0.1165340096, 0.9549772739, 0.1355334967, 0.230662778, 0.2894310057, 0.7520320415, 0.1920721531, 0.2880801558, 0.3180584013, 0.4580792487, 0.3651930392, 0.0336011872, 0.9515703917, 0.2855015397, 0.5509393811, 0.3329965174, 0.8071669936, 0.0343504399, 0.2977145612, 0.9450189471, 0.0395925194, 0.7499812841, 0.5422456861, 0.6263286471, 0.4647623003, 0.2473599166, 0.3326048255, 0.8780121803, 0.5231653452, 0.4300028682, 0.6038040519, 0.5393199921, 0.4013643563, 0.4338366687, 0.5753194094, 0.7920855284, 0.2375757396, 0.3116320968, 0.2751671374, 0.8140007257, 0.6709600091, 0.4242839515, 0.0822508037, 0.4377377331, 0.5109994411, 0.838122189, 0.7325818539, 0.600030005, 0.7534617186, 0.8508836031, 0.518609345, 0.8201930523, 0.3503412306, 0.2912582457, 0.1698331535, 0.3433961272, 0.8749606609, 0.3452144861, 0.55967623, 0.8859229088, 0.6866813302, 0.4001246989, 0.8080029488, 0.2799992263, 0.0225006696, 0.9885226488, 0.0745726526, 0.2693292797, 0.7819388509, 0.6689161658, 0.0571094677, 0.5274602175, 0.0322797894, 0.8106626868, 0.8286591172, 0.9012759328, 0.3437840044, 0.1065286398, 0.2962122262, 0.9999867678, 0.2837511003, 0.4418636858, 0.5903841853, 0.1568869501, 0.1432511508, 0.2637755871, 0.9879755974, 0.4104428589, 0.7735606432, 0.2709191144, 0.7334169745, 0.2811683416, 0.0954814851, 0.3043693006, 0.0461132452, 0.8634625673, 0.0475427881, 0.4099179804, 0.5548568964, 0.2144707888, 0.6792877316, 0.8108834624, 0.4308766127, 0.7912250161, 0.9003937244, 0.5373287201, 0.3971642256, 0.2246182263, 0.6540088654, 0.1797845364, 0.2128595561, 0.6696526408, 0.3364855051, 0.7198640704, 0.388620466, 0.5648565292, 0.9445192814, 0.0433134884, 0.7659504414, 0.0136004789, 0.5625730753, 0.3796073496, 0.1178845093, 0.2440009862, 0.6823272109, 0.1710589379, 0.4426908791, 0.427455008, 0.272172004, 0.9906947017, 0.2536124289, 0.7432353497, 0.6915289164, 0.2979070246, 0.9431248903, 0.0567763224, 0.8850826025, 0.2047438473, 0.7649860978, 0.7903056145, 0.2861865163, 0.1094466895, 0.700704515, 0.648494482, 0.650083065, 0.2995134294, 0.7315405607, 0.3454598486, 0.2782539129, 0.2504938841, 0.199461326, 0.2425443232, 0.8532289863, 0.7899130583, 0.3757571876, 0.5348195434, 0.6415081024, 0.8681899905, 0.2723032534, 0.4902763665, 0.9859597087, 0.7578067183, 0.866566062, 0.3088432848, 0.734277606, 0.925080955, 0.2001357079, 0.5717392564, 0.5198030472, 0.6827158928, 0.6138558388, 0.5705425739, 0.4998483658, 0.2985683978, 0.2754984796, 0.0385792106, 0.5412657857, 0.6709792614, 0.2747735679, 0.0215833541, 0.2621179521, 0.6292054057, 0.4245176017, 0.3098716438, 0.6401355267, 0.6350391507, 0.3451481462, 0.8001451492, 0.2736293972, 0.6688865423, 0.3832850754, 0.0026290112, 0.4926379919, 0.2810564935, 0.5791549683, 0.3252087831, 0.0431423411, 0.5124416947, 0.154622972, 0.1480508, 0.428286463, 0.7129493952, 0.9046078324, 0.7815018892, 0.0465084948, 0.3294332922, 0.1153969169, 0.2188278437, 0.289832294, 0.3131091893, 0.2157217115, 0.2949057519, 0.8871413469, 0.7510847449, 0.4598563313, 0.6131973267, 0.0551494882, 0.9805501699, 0.7621988654, 0.2043998092, 0.2610918283, 0.2401759624, 0.569493413, 0.7611207366, 0.6130263209, 0.2001665235, 0.1906743795, 0.5295569897, 0.7834599018, 0.7504947186, 0.0149052497, 0.4556769729, 0.8574418426, 0.7936969995, 0.4731632173, 0.0743378848, 0.9822815657, 0.8694450855, 0.7822141051, 0.1557161659, 0.5248658061, 0.3995839357, 0.4086642265, 0.7906468511, 0.2836396396, 0.9961770773, 0.1578908861, 0.9831036925, 0.7753174305, 0.7032369971, 0.1702057719, 0.143247366, 0.5245524645, 0.7873648405, 0.9909790754, 0.1941808164, 0.0496347249, 0.3230103552, 0.2880098224, 0.9254404306, 0.7993409634, 0.3677969873, 0.4502792656, 0.7550968528, 0.0685292333, 0.032212656, 0.3681726754, 0.8964610696, 0.7657590508, 0.7328995466, 0.1225480959, 0.8237461448, 0.1054824442, 0.4235413671, 0.0693489239, 0.1772005558, 0.107229121, 0.7561171651, 0.3078683913, 0.6704639196, 0.7376510501, 0.3759997189, 0.6078967452, 0.3140520155, 0.9231520891, 0.3376911283, 0.517896235, 0.576236546, 0.2839297652, 0.6083318591, 0.6300873756, 0.6741157174, 0.1322117001, 0.7947505713, 0.9863089919, 0.2355235219, 0.8684127927, 0.9994758964, 0.2966772914, 0.3675712347, 0.6119997501, 0.2690464854, 0.8008992076, 0.29267627, 0.2993549407, 0.3847996891, 0.0799442455, 0.1301993132, 0.4116391838, 0.2668008506, 0.3495041728, 0.3540006578, 0.8356643319, 0.7733381987, 0.0168998744, 0.7282013893, 0.4001987875, 0.5594797134, 0.7570883632, 0.4522481859, 0.7742182016, 0.9329667687, 0.8500671983, 0.3011783361, 0.376812309, 0.6565785408, 0.3168726861, 0.3728050888, 0.6381832957, 0.6217818856, 0.2103196532, 0.0577781945, 0.3512331843, 0.2998010516, 0.5259774923, 0.2699679136, 0.3751579523, 0.5097513199, 0.3058879375, 0.8346223235, 0.9135133624, 0.3425334692, 0.9813879728, 0.2871009409, 0.2774653733, 0.7453799844, 0.3311858475, 0.6496451497, 0.2896683514, 0.6599283814, 0.485567987, 0.868604064, 0.6005551815, 0.3034152985, 0.3422373831, 0.9028821588, 0.9752067327, 0.0568868406, 0.771296978, 0.2428506464, 0.4984464943, 0.472656399, 0.3266831934, 0.5197536349, 0.1191676483, 0.3807988167, 0.6258342266, 0.0560569949, 0.7892054319, 0.9146646857, 0.5138988495, 0.1590599418, 0.64719069, 0.776796639, 0.2798080444, 0.9099245071, 0.1376058757, 0.4660386443, 0.7878762484, 0.2609682083, 0.4249886572, 0.3760030568, 0.6414309144, 0.9376666546, 0.6352919936, 0.8449454308, 0.9226124883, 0.5036137104, 0.5559523106, 0.9124451876, 0.3199864924, 0.8545216322, 0.7763401866, 0.8065479398, 0.9042024016, 0.3665791154, 0.4878125489, 0.7499691248, 0.2955771983, 0.4796212614, 0.4156348705, 0.6559888124, 0.6315625906, 0.5192046165, 0.8499541879, 0.1051700935, 0.9450867772, 0.4511101842, 0.296112448, 0.5963520408, 0.397336334, 0.7462157011, 0.2181172967, 0.4330155253, 0.3855430186, 0.699704349, 0.2809849977, 0.6741006374, 0.2998252511, 0.0636042878, 0.4877717197, 0.7193673849, 0.4908526838, 0.7790867686, 0.4130373001, 0.5244644284, 0.0297955684, 0.2241734713, 0.779959321, 0.6138396263, 0.5591472387, 0.5931682587, 0.1496370882, 0.2843722999, 0.5422986746, 0.412481755, 0.1552470773, 0.7898083925, 0.3097908497, 0.6143966317, 0.8178458214, 0.4004067481, 0.7174136639, 0.2705074549, 0.3836323619, 0.1506795883, 0.3407859504, 0.0169898923, 0.7652972937, 0.6428847313, 0.4794446826, 0.6281296611, 0.8367557526, 0.6374989748, 0.9902649522, 0.1328423768, 0.1195605472, 0.4906466901, 0.303648293, 0.7694002986, 0.9438231587, 0.9209344387, 0.2833660543, 0.2958782911, 0.3583146632, 0.0124914162, 0.0271478444, 0.1830938458, 0.2442035973, 0.1633568406, 0.3582551479, 0.8930487633, 0.5255863667, 0.8074785471, 0.6203823686, 0.8806639314, 0.2001634985, 0.6789721847, 0.2585816979, 0.4858850539, 0.9488404989, 0.3169507384, 0.2749398351, 0.8015854955, 0.2543512881, 0.1484814733, 0.1998170912, 0.8312829137, 0.7717654705, 0.8164418936, 0.7098048925, 0.7556194067, 0.0246483423, 0.268122673, 0.192021057, 0.8246628046, 0.8932147026, 0.7755023241, 0.1769630313, 0.8796217442, 0.8670396209, 0.5000835657, 0.0189713724, 0.4199432731, 0.3441577852, 0.4229801595, 0.4427429438, 0.0248884745, 0.2632511556, 0.9104922414, 0.4624014497, 0.7883923054, 0.2305282801, 0.7785071135, 0.3134030998, 0.2291310728, 0.8975443244, 0.8703170419, 0.758957088, 0.3501161635, 0.7770552635, 0.9095908403, 0.1499762684, 0.2830392122, 0.1100165471, 0.6619458199, 0.8309295774, 0.1749436557, 0.2662031651, 0.0523720607, 0.4569765925, 0.635777235, 0.1103235036, 0.4204445481, 0.3873434067, 0.5234110951, 0.1915344, 0.0344007909, 0.275598377, 0.2998128831, 0.4259296954, 0.6235763431, 0.4671169519, 0.2951315641, 0.162186265, 0.0188597385, 0.8248400688, 0.6117950678, 0.2987766862, 0.7614855766, 0.5666823983, 0.5245591998, 0.2441071421, 0.1280356497, 0.6743686199, 0.4623979926, 0.5807595253, 0.8561789393, 0.2936735153, 0.1840087622, 0.1762438715, 0.5563666224, 0.1075055376, 0.7844430208, 0.9785437584, 0.1414445788, 0.3631467223, 0.3552234471, 0.555084765, 0.6623201966, 0.0853134543, 0.0339226574, 0.3735741973, 0.6598557234, 0.1995836496, 0.9044551253, 0.8097031116, 0.4850362241, 0.5187754631, 0.156273365, 0.3030130565, 0.1345720589, 0.1231942996, 0.2517258823, 0.1202225164, 0.4748232067, 0.4270858169, 0.2148948759, 0.3049951792, 0.637558043, 0.2902436256, 0.8424873948, 0.2945866585, 0.424770087, 0.2093853354, 0.7201608419, 0.8232980967, 0.8431973457, 0.2790549099, 0.0113046262, 0.4176355004, 0.1039084941, 0.0762564987, 0.7687200904, 0.3767068684, 0.2080375701, 0.5334433317, 0.1993771642, 0.7769105434, 0.7445071936, 0.5376464128, 0.5751659274, 0.192881912, 0.7927742004, 0.0072807316, 0.482412219, 0.2706641555, 0.3944533765, 0.7626729608, 0.1882020086, 0.0971265957, 0.5991012454, 0.2689918578, 0.8020467758, 0.9417535067, 0.7980589867, 0.6967203021, 0.7917937636, 0.4136724174, 0.6591844559, 0.4597135484, 0.8457469344, 0.3348135352, 0.8026527166, 0.5511280298, 0.4867303371, 0.6642525792, 0.975501895, 0.4057386816, 0.1340638846, 0.3767580688, 0.1703029424, 0.3458243012, 0.2280157655, 0.2941951752, 0.1464271843, 0.256821394, 0.3496943712, 0.7570667863, 0.4027655125, 0.1918564886, 0.2208168209, 0.4802232385, 0.786904037, 0.6237490177, 0.1836518049, 0.7052675486, 0.458227396, 0.2731816173, 0.6869538426, 0.8212174177, 0.0819405094, 0.2999734282, 0.2923023105, 0.5043700933, 0.409861654, 0.3174582422, 0.6751154661, 0.7704699636, 0.8110410571, 0.8169452548, 0.2432855666, 0.5290631652, 0.1721301377, 0.3494029939, 0.5463349819, 0.4247282147, 0.3365479112, 0.7773292661, 0.9833340645, 0.2161256075, 0.2500047982, 0.9927572012, 0.7508751154, 0.8931486607, 0.3399498165, 0.8889269233, 0.727556169, 0.8053399324, 0.2233743221, 0.6903525591, 0.3913807869, 0.8359543085, 0.4148309231, 0.6523172855, 0.231556192, 0.6431411505, 0.6001188159, 0.1654544473, 0.1936159134, 0.3616076112, 0.6380267143, 0.5220745206, 0.1704850197, 0.242775321, 0.3764709532, 0.6472204328, 0.81421417, 0.3527438939, 0.4917648435, 0.2372246832, 0.595227778, 0.5499820113, 0.806815505, 0.4955188632, 0.4707650244, 0.2944735289, 0.177176252, 0.3095451593, 0.8617234826, 0.3881261647, 0.3247082829, 0.3174749315, 0.3960589468, 0.8632043004, 0.6118923426, 0.5451740026, 0.8264210224, 0.7780685425, 0.386596173, 0.3740692735, 0.071042344, 0.7798178196, 0.797966063, 0.5147284865, 0.5785826445, 0.3499533832, 0.7061065435, 0.2562947571, 0.0197522454, 0.5232437849, 0.1162245199, 0.8499556184, 0.9027334452, 0.2406211197, 0.9040595889, 0.4712712765, 0.0545752756, 0.2625442445, 0.8004454374, 0.9199656844, 0.5907141566, 0.3528652191, 0.2805064619, 0.8477231264, 0.3509507775, 0.7206040025, 0.6591496468, 0.886505425, 0.9694709778, 0.4983907044, 0.1598182172, 0.2047161758, 0.7987730503, 0.3996876478, 0.8058558702, 0.0989774689, 0.7282789946, 0.8318630457, 0.9660419822, 0.0363835655, 0.8671738505, 0.1756909341, 0.9045026302, 0.5637825727, 0.866381526, 0.2319063693, 0.7536413074, 0.8000506759, 0.5863604546, 0.7992135882, 0.4219932258, 0.481436789, 0.7629017234, 0.0260796417, 0.3073845506, 0.5232524276, 0.9749398828, 0.4844135642, 0.2303099632, 0.3507592678, 0.9227046371, 0.0019649405, 0.1564766616, 0.7261878848, 0.2516813278, 0.7154665589, 0.5749522448, 0.8140199184, 0.3457842469, 0.6453396082, 0.6868181825, 0.3892825544, 0.3984824121, 0.7887382507, 0.8365982771, 0.3248549104, 0.9360063076, 0.250998646, 0.5284421444, 0.7992022038, 0.0579416603, 0.5381578803, 0.7750003934, 0.1343874484, 0.958194077, 0.6147286892, 0.0008553811, 0.7740504742, 0.7823941112, 0.9342224598, 0.566947341, 0.6531718969, 0.7747102976, 0.7425286174, 0.5242463946, 0.2042782456, 0.0084363222, 0.7720063329, 0.7291170359, 0.0140062124, 0.4290650189, 0.5248267651, 0.2691887319, 0.7684779763, 0.8913392425, 0.2861766219, 0.625176847, 0.7682936788, 0.5762428045, 0.4206987023, 0.9714790583, 0.9922801852, 0.7669212222, 0.5052084923, 0.645051837, 0.4985497594, 0.4682227671, 0.6760318875, 0.8983184099, 0.1391719133, 0.6179335713, 0.2258358598, 0.1724694967, 0.0220160931, 0.3808035553, 0.9283209443, 0.0941520035, 0.2797054648, 0.0121329706, 0.0326453708, 0.0866272449, 0.9710868597, 0.2622629702, 0.5545566678, 0.5643898845, 0.5713929534, 0.5999991894, 0.4126140773, 0.9695659876, 0.6285355687, 0.5692995787, 0.454194814, 0.7901089787, 0.9660837054, 0.8277012706, 0.0928914025, 0.3484353125, 0.6736137867, 0.8765351772, 0.3386749029, 0.7252441049, 0.1114370301, 0.2990854383, 0.4538967013, 0.9787045121, 0.3990883231, 0.988239944, 0.277962178, 0.0663654953, 0.7550785542, 0.9265934825, 0.5644822121, 0.7671328783, 0.8755191565, 0.1012659818, 0.5898082852, 0.8015443087, 0.7964060307, 0.1627581716, 0.2277553678, 0.9264091253, 0.9120311737, 0.4145444632, 0.6489874721, 0.1752695739, 0.002717824, 0.4640338421, 0.7796453238, 0.9751948118, 0.5849672556, 0.3068727255, 0.4288714826, 0.2617074847, 0.7182069421, 0.3882696331, 0.0427591577, 0.454965353, 0.5183761716, 0.3918886781, 0.6594117284, 0.6001002192, 0.8340002894, 0.4951757193, 0.23659271, 0.6956700087, 0.14972049, 0.5904799104, 0.2989979088, 0.3457302153, 0.116319336, 0.3254196644, 0.3999947309, 0.3009833395, 0.7907041907, 0.6257662773, 0.2113198787, 0.1751640886, 0.7867451906, 0.8027440906, 0.7817027569, 0.6641870737, 0.4249112606, 0.1674920321, 0.1883893609, 0.6185988188, 0.0362182185, 0.6194028854, 0.3953706324, 0.5091269612, 0.2814692259, 0.2867180109, 0.2754775286, 0.2186837494, 0.8755689263, 0.0850193575, 0.0821465775, 0.6301913857, 0.2572468817, 0.1999669373, 0.1279871762, 0.4453506172, 0.9502550364, 0.2893290818, 0.1907250434, 0.6880247593, 0.3379973471, 0.199829489, 0.2608736753, 0.9429882169, 0.7425290346, 0.9008249044, 0.6850529313, 0.8091363907, 0.6383458972, 0.5397336483, 0.4999698997, 0.1050286591, 0.264852196, 0.5500307083, 0.1077635065, 0.7545816302, 0.153767854, 0.2850513756, 0.925503552, 0.5411737561, 0.1518809497, 0.043320626, 0.895241797, 0.887319386, 0.4580318034, 0.327632755, 0.1463776231, 0.7795293331, 0.2669896483, 0.8222080469, 0.2039921284, 0.2620699406, 0.8143118024, 0.4861954451, 0.8213962913, 0.5840394497, 0.4247839153, 0.3092982173, 0.3642277718, 0.2982022166, 0.7004087567, 0.0212051533, 0.6487102509, 0.5274438262, 0.9092481732, 0.730384171, 0.7487973571, 0.2889667749, 0.7865768671, 0.2437812686, 0.7743490934, 0.3881141245, 0.7998576164, 0.1551619917, 0.9330435991, 0.6870658994, 0.5746767521, 0.6458526254, 0.7466739416, 0.6684733629, 0.5012472272, 0.7902867198, 0.7698841095, 0.0425139926, 0.6290299892, 0.7240006328, 0.2354215831, 0.2400828749, 0.6598005891, 0.9678072333, 0.4088793397, 0.9475491047, 0.9047468901, 0.0505281314, 0.983884573, 0.1737497002, 0.4704473317, 0.2794604301, 0.3008873165, 0.8608435988, 0.3551756144, 0.3274177611, 0.2876883149, 0.4380708635, 0.4668641388, 0.6630249619, 0.4752038717, 0.3399631381, 0.0004695649, 0.0158080906, 0.1541123688, 0.89447999, 0.9143199921, 0.5618377328, 0.0265781935, 0.0014133439, 0.1717019975, 0.6744863391, 0.6051113009, 0.6700525284, 0.8717252612, 0.9211322069, 0.7788960338, 0.9970455766, 0.3824445307, 0.6535704732, 0.7191313505, 0.2670966089, 0.2343741208, 0.6560382843, 0.8189513683, 0.9779990911, 0.2920952141, 0.1606268585, 0.7335300446, 0.1817885339, 0.4276250899, 0.7730876207, 0.7524567842, 0.4017331004, 0.8607296944, 0.7277715206, 0.4210158288, 0.8780418038, 0.3567401469, 0.1249847785, 0.1677636951, 0.2262524515, 0.9928002954, 0.9429923296, 0.0928178728, 0.4386635423, 0.8069884777, 0.7290409207, 0.8104345202, 0.6501662135, 0.7694789171, 0.7665093541, 0.1464402676, 0.5142594576, 0.0059239352, 0.5772430897, 0.2253716886, 0.8281903267, 0.8057222366, 0.7727349401, 0.4749777913, 0.291275382, 0.3198481798, 0.5055068731, 0.4836567044, 0.2031805664, 0.3143343329, 0.7941797376, 0.0478825159, 0.0725190639, 0.6679832339, 0.7568237185, 0.8410646915, 0.7609511614, 0.9343419671, 0.7267388701, 0.8061711192, 0.2502336502, 0.5761574507, 0.540882051, 0.7522531748, 0.2887668312, 0.2322072834, 0.2661544383, 0.6527605057, 0.2828822732, 0.3687557876, 0.8335109949, 0.2332811803, 0.4580220282, 0.7980357409, 0.7631003261, 0.057026118, 0.8262161613, 0.655844152, 0.1842970848, 0.2874549031, 0.0934311897, 0.9872899652, 0.0171927176, 0.0529784523, 0.6494998932, 0.6903494596, 0.9372444153, 0.8937577605, 0.0486983582, 0.9107431173, 0.1919635534, 0.2335986793, 0.2497835904, 0.9269321561, 0.7939439416, 0.8614564538, 0.3511635363, 0.9440903664, 0.6518594623, 0.3127450645, 0.559984684, 0.9434761405, 0.8918107152, 0.3233214617, 0.7946133614, 0.4216216207, 0.6283529401, 0.0179141425, 0.7844362259, 0.3101776242, 0.6566930413, 0.5672486424, 0.7889158726, 0.6126962304, 0.7859390974, 0.0923882723, 0.7710054517, 0.0468924157, 0.9273314476, 0.8858300447, 0.3495823741, 0.0502963737, 0.7265440822, 0.8806681633, 0.5553485155, 0.4007360041, 0.1497067511, 0.1965579838, 0.791478157, 0.7826305628, 0.2658583522, 0.5140508413, 0.6845291853, 0.629997611, 0.280148536, 0.5622635484, 0.8259903789, 0.5244660378, 0.6150796413, 0.7782981396, 0.3102792501, 0.8696761727, 0.3956299722, 0.2814948559, 0.1310305297, 0.8118636608, 0.2594062388, 0.8649273515, 0.5036535263, 0.5557423234, 0.0601539686, 0.284835875, 0.0737424418, 0.0352903791, 0.8056985736, 0.0751454905, 0.8200211525, 0.4664432406, 0.1455803216, 0.7607629895, 0.6063881516, 0.4569575191, 0.0977691114, 0.5421596169, 0.2784540951, 0.5368484259, 0.7131535411, 0.9732908607, 0.7721309066, 0.3137148321, 0.7179317474, 0.279797852, 0.1720841527, 0.2310317606, 0.3149380684, 0.7369439006, 0.297901094, 0.3471178412, 0.7441020608, 0.6383051872, 0.6432772279, 0.4653419554, 0.2948729694, 0.5528818369, 0.2871345282, 0.0375724137, 0.9314796329, 0.3659904301, 0.0274818614, 0.2774145305, 0.3779206276, 0.7330094576, 0.6690718532, 0.8675441742, 0.8203707337, 0.3039523363, 0.6855219007, 0.3739557564, 0.7847412229, 0.7726964951, 0.1901528984, 0.8707709908, 0.8261426687, 0.8141835332, 0.6765087247, 0.7053523064, 0.1085284501, 0.0744494647, 0.8915129304, 0.7695001364, 0.3059226274, 0.7864413261, 0.6495617032, 0.2287500948, 0.6643590927, 0.6807377338, 0.6854281425, 0.1251755953, 0.602183342, 0.1738262922, 0.1027485281, 0.3681707382, 0.8752848506, 0.3725059032, 0.300298512, 0.2861676812, 0.7838917971, 0.9753560424, 0.5377818942, 0.280867964, 0.0948558152, 0.8135243654, 0.2024883628, 0.0596460216, 0.8992331624, 0.4445746839, 0.788334012, 0.7991656661, 0.5622891784, 0.785182476, 0.7671946883, 0.5833725333, 0.9053542614, 0.3771561086, 0.8870622516, 0.7011025548, 0.9261990786, 0.1318989843, 0.1970869601, 0.6673611403, 0.6814309359, 0.1583046764, 0.400138855, 0.6895772815, 0.6834002137, 0.991366744, 0.8109951615, 0.350156337, 0.1740820706, 0.6443064213, 0.5699039698, 0.2332659215, 0.6794521809, 0.7680356503, 0.590195179, 0.9282895327, 0.2421162277, 0.7080360055, 0.1728440672, 0.4241924286, 0.9003916979, 0.9509291649, 0.0724767447, 0.2422906607, 0.2617212534, 0.0941282958, 0.1398678869, 0.2615314722, 0.9000369906, 0.2696160972, 0.126913175, 0.8667003512, 0.610011518, 0.1999786347, 0.6599969268, 0.0733514354, 0.9472167492, 0.7983407378, 0.8789130449, 0.1767313331, 0.8358648419, 0.4992512167, 0.8810734153, 0.1525073349, 0.6489398479, 0.780087471, 0.311172843, 0.6840517521, 0.1576130092, 0.6094434857, 0.7155513763, 0.6123347282, 0.1409282237, 0.4274391234, 0.4048481286, 0.5570979714, 0.0876027569, 0.872781992, 0.2688118815, 0.769074142, 0.8936365843, 0.3085227311, 0.4744861424, 0.8377560973, 0.3973178864, 0.9845040441, 0.5582486391, 0.4626818001, 0.5196817517, 0.7685114741, 0.5016750693, 0.6052305698, 0.7585555315, 0.9520831704, 0.7883883119, 0.9973391891, 0.6165248752, 0.4734658003, 0.65855515, 0.7961063385, 0.5074180365, 0.6195576191, 0.2928566635, 0.833915174, 0.7823464274, 0.7758680582, 0.7892392874, 0.9123880863, 0.9501414299, 0.2680390179, 0.5070078969, 0.7021949887, 0.2686080337, 0.5800030828, 0.1445639879, 0.3041823208, 0.6666110158, 0.5487381816, 0.010362681, 0.2453777939, 0.5664753318, 0.6912289858, 0.002260793, 0.3771244586, 0.2759346068, 0.5143600702, 0.5078810453, 0.3671621978, 0.2517361045, 0.7787028551, 0.3381624818, 0.9658800364, 0.8251711726, 0.6861642003, 0.299412787, 0.696067512, 0.8954024315, 0.2410800159, 0.0543312579, 0.2713386416, 0.7497317195, 0.107312493, 0.7433992624, 0.0763910487, 0.7654787302, 0.9832741022, 0.7660050392, 0.7869641781, 0.5255016685, 0.379486531, 0.2267197818, 0.3679463863, 0.2114219069, 0.3062874675, 0.7886129022, 0.8245838284, 0.2977400422, 0.335645467, 0.4515637755, 0.1333121061, 0.3818921745, 0.220414117, 0.771540463, 0.0715401918, 0.2907829285, 0.7844450474, 0.3635170162, 0.3178709447, 0.9713793993, 0.9272905588, 0.2381104082, 0.1068030596, 0.7252637744, 0.0393355526, 0.8350849152, 0.3327754438, 0.3939851224, 0.5291517973, 0.4294093847, 0.2476225793, 0.1966315061, 0.1115974709, 0.6157343984, 0.6511664987, 0.2789514065, 0.4601100683, 0.4930445254, 0.4983032346, 0.8884671926, 0.3046303689, 0.0650740638, 0.425262779, 0.5891890526, 0.3792130053, 0.5577308536, 0.6345244646, 0.866689384, 0.5378469825, 0.7984157205, 0.8907515407, 0.8150723577, 0.8964385986, 0.319796145, 0.0434126519, 0.258354634, 0.0901802927, 0.0315441154, 0.860037148, 0.649969101, 0.4297827482, 0.6067852974, 0.1548785567, 0.1768916547, 0.1774273813, 0.2866801918, 0.8928667903, 0.1905252934, 0.4660939574, 0.2989724576, 0.5122604966, 0.1267326325, 0.791595161, 0.5922329426, 0.8804706931, 0.4289196432, 0.4957201183, 0.8686517477, 0.45140481, 0.4022825658, 0.8919409513, 0.4644826949, 0.7638366222, 0.2141635716, 0.963513732, 0.4108440578, 0.5553762317, 0.9142369628, 0.4031233788, 0.0664307624, 0.7233988047, 0.3373790681, 0.4812686443, 0.660007596, 0.6775253415, 0.3990524411, 0.1097663045, 0.2192985564, 0.8470165133, 0.855263114, 0.7640679479, 0.1831330806, 0.946549356, 0.332384944, 0.8508573174, 0.2944486439, 0.6928911209, 0.7978152633, 0.7658269405, 0.3536170125, 0.6615781784, 0.9547168612, 0.4701850712, 0.54965204, 0.0584536009, 0.3157524765, 0.6936239004, 0.267331332, 0.584505856, 0.0244565476, 0.2943458855, 0.1873316169, 0.3394116461, 0.1235968247, 0.2895309627, 0.4208563864, 0.9907463193, 0.4523299932, 0.8486821055, 0.0960422605, 0.6420364976, 0.3939413726, 0.8774323463, 0.6714023352, 0.3098714352, 0.2211168855, 0.1400515735, 0.3537302017, 0.2504135072, 0.1442802697, 0.6670401692, 0.0758291036, 0.5461344719, 0.3282198906, 0.2514461279, 0.9266825318, 0.9895117283, 0.8716566563, 0.7472376823, 0.9956616163, 0.391559124, 0.3979108632, 0.5343204737, 0.5599702597, 0.5746458769, 0.6002621055, 0.3463972807, 0.8279570937, 0.2360358536, 0.8784773946, 0.5179415941, 0.7606269717, 0.5087393522, 0.3202143312, 0.7918854952, 0.6523981094, 0.9877961874, 0.6059661508, 0.9434994459, 0.3252754211, 0.7943350077, 0.4317415059, 0.8919587731, 0.9502399564, 0.7011834383, 0.3029349148, 0.8641203642, 0.3685676455, 0.2850028276, 0.2284352183, 0.3039897978, 0.8638410568, 0.3296080232, 0.216091007, 0.1000289619, 0.8285583258, 0.649539113, 0.0505601168, 0.23284702, 0.0129147898, 0.4100807309, 0.2322385162, 0.8453789353, 0.5249089003, 0.5421145558, 0.2933630943, 0.4185113013, 0.8834992647, 0.7073133588, 0.9953604341, 0.2309181988, 0.9861024022, 0.7863622308, 0.5735582113, 0.2762266099, 0.6771513224, 0.1898045987, 0.0519864261, 0.32608518, 0.5279992223, 0.3073732853, 0.8896305561, 0.9859982133, 0.8819665313, 0.8249764442, 0.5579964519, 0.582374692, 0.1648006439, 0.0936817676, 0.4903237224, 0.9035113454, 0.1783384979, 0.4548709989, 0.529083848, 0.3491431475, 0.9245797992, 0.5866407752, 0.8879506588, 0.7381102443, 0.6270953417, 0.3013087511, 0.8165183663, 0.9136554003, 0.4437074661, 0.9058420062, 0.3077934682, 0.1481266022, 0.5974704027, 0.4117953777, 0.5051417351, 0.6378746629, 0.3662781417, 0.275219053, 0.4622029066, 0.4735332727, 0.4884818196, 0.5640743375, 0.9933480024, 0.7740606666, 0.7776194215, 0.7635287046, 0.3643266261, 0.2588997483, 0.5159329176, 0.9296320677, 0.2787033319, 0.3738671839, 0.0344980955, 0.4350320101, 0.6755834818, 0.4286924899, 0.7871493101, 0.3364413679, 0.5013414025, 0.3748833239, 0.7356345654, 0.8916242123, 0.0117606986, 0.1521019638, 0.0712500066, 0.4059727788, 0.0710976794, 0.8347967863, 0.6400067806, 0.3765201569, 0.6073310971, 0.4271332026, 0.3422194719, 0.1249704808, 0.891577661, 0.6594917774, 0.3747678697, 0.9558723569, 0.7219854593, 0.7106966376, 0.9313089848, 0.4832553566, 0.4667213559, 0.5824468136, 0.7162278295, 0.5177717209, 0.0977057889, 0.7590029836, 0.1714690924, 0.9571123123, 0.4020383954, 0.7261196971, 0.7496134043, 0.7017532587, 0.222539112, 0.9218833447, 0.8255798817, 0.250017494, 0.9624128938, 0.2770902216, 0.3105332255, 0.473443687, 0.6705613136, 0.1048703417, 0.0505746193, 0.3031838834, 0.0764986053, 0.6700251698, 0.1248878166, 0.9387741685, 0.4017695785, 0.1040696278, 0.745906651, 0.6877798438, 0.6785060167, 0.6491712332, 0.4595741928, 0.0832384899, 0.7447783947, 0.8123399615, 0.2865788639, 0.1072481871, 0.5880768299, 0.2012768984, 0.6164584756, 0.6531744599, 0.3689600825, 0.2244419754, 0.8485900164, 0.8012405634, 0.4264014959, 0.0631803498, 0.1144074276, 0.919865191, 0.247777611, 0.5172892809, 0.3793236613, 0.1089572832, 0.9954030514, 0.6386104226, 0.7809863687, 0.293407768, 0.3600515127, 0.8255298734, 0.3752827644, 0.800978899, 0.7946528792, 0.5165820718, 0.1997372955, 0.7077269554, 0.3950786293, 0.1632033885, 0.5593788624, 0.4266054332, 0.8571543097, 0.2293199748, 0.2288575917, 0.3166252375, 0.0253840014, 0.7290859818, 0.3571533263, 0.6263707876, 0.5841494799, 0.3236172795, 0.0720305741, 0.8912050724, 0.7814262509, 0.349355638, 0.1000752002, 0.5756855607, 0.6530312896, 0.3211900294, 0.7120269537, 0.4889923334, 0.7246489525, 0.7894634604, 0.8173778057, 0.7406228185, 0.0533824638, 0.7616798282, 0.2118356079, 0.1358659267, 0.691570878, 0.3010347188, 0.9254361987, 0.6774628758, 0.8114458919, 0.0461394414, 0.4491851926, 0.2361025512, 0.6578386426, 0.2781579494, 0.4753561616, 0.7263519764, 0.5516431332, 0.3764113784, 0.7071894407, 0.7581717372, 0.7504419684, 0.304141283, 0.4077625573, 0.9041445851, 0.9798993468, 0.3132814467, 0.5969519019, 0.8985749483, 0.5371615887, 0.8166791201, 0.9128910303, 0.6386086345, 0.9291878939, 0.9010465741, 0.0515856557, 0.8312644362, 0.9322059155, 0.3082694411, 0.2631652951, 0.6171346903, 0.3248440325, 0.69941324, 0.8882280588, 0.3161205649, 0.2990267575, 0.0209084526, 0.2487299591, 0.2852843404, 0.0490375198, 0.0792967454, 0.134388715, 0.6421871185, 0.3512936831, 0.9005096555, 0.7998893261, 0.1272028685, 0.0864170641, 0.8854416609, 0.4485999346, 0.5290466547, 0.459644109, 0.9713689089, 0.8959669471, 0.6499913335, 0.1614189446, 0.6365318894, 0.7912567258, 0.5595306158, 0.4526388943, 0.815866828, 0.9839783311, 0.7433025241, 0.9149154425, 0.2130972743, 0.7002832294, 0.9018979073, 0.5495696068, 0.3047397137, 0.9602315426, 0.7303099036, 0.6514343619, 0.0494217165, 0.9204797745, 0.5995004773, 0.7999229431, 0.2446528822, 0.8066373467, 0.7633868456, 0.4997910857, 0.8171027303, 0.2998119891, 0.7505546212, 0.2840596735, 0.6801810265, 0.8937376142, 0.9920930266, 0.7891113758, 0.8012133241, 0.3600580096, 0.943956852, 0.5752746463, 0.1673168838, 0.1591576487, 0.2836316526, 0.6767866015, 0.9760351777, 0.0820318013, 0.2834108174, 0.7059906125, 0.3513303399, 0.6475701332, 0.1324364245, 0.2339693159, 0.8474177718, 0.7218640447, 0.4495049715, 0.7103233933, 0.8957070708, 0.4991365373, 0.5135029554, 0.9469348788, 0.986531496, 0.6421780586, 0.0111757731, 0.9658465385, 0.0449516922, 0.0997762382, 0.239306286, 0.6519269347, 0.4265230596, 0.1593539566, 0.1272390336, 0.7581902146, 0.849483192, 0.0624137856, 0.5568189621, 0.8487882018, 0.4189198315, 0.4743472636, 0.9843426943, 0.836260736, 0.2222026736, 0.2823732793, 0.7828052044, 0.175578177, 0.4174544513, 0.4262937307, 0.5167069435, 0.1060983315, 0.6379290819, 0.9572992325, 0.1776689142, 0.2620716393, 0.8248003125, 0.1567030102, 0.6008511782, 0.2440356314, 0.4270541966, 0.1630697548, 0.0636614934, 0.3432453871, 0.9009386301, 0.387185961, 0.9745897055, 0.3582904339, 0.0773086995, 0.5866941214, 0.2677324414, 0.038794253, 0.3836332858, 0.8752986193, 0.5724390745, 0.68050915, 0.7012855411, 0.3378408253, 0.8861531019, 0.2298797965, 0.2611677945, 0.1331158578, 0.5366979241, 0.7606591582, 0.5197066665, 0.8155182004, 0.8734754324, 0.1757362485, 0.8255903125, 0.5745301843, 0.7841017842, 0.4302405417, 0.0268313363, 0.996658802, 0.6995847821, 0.908472538, 0.513992548, 0.7311407924, 0.9382262826, 0.6791692972, 0.6785366535, 0.1941221654, 0.4609523714, 0.3504243493, 0.4049642384, 0.6625856757, 0.5049493313, 0.2176340818, 0.2272735685, 0.4055925608, 0.1439441442, 0.7996239066, 0.2481847256, 0.7855584621, 0.0217855163, 0.7607150078, 0.5862695575, 0.0883487016, 0.1676670462, 0.5200256109, 0.3054049313, 0.2125623375, 0.7533867359, 0.2767126858, 0.1956664324, 0.4313074648, 0.7840225697, 0.0665216669, 0.983897388, 0.8195846081, 0.5587249994, 0.9586064816, 0.2105056942, 0.4114686549, 0.1693456471, 0.7834180593, 0.0783827752, 0.5129904747, 0.5240935087, 0.1287233979, 0.7831305861, 0.2181428373, 0.962063849, 0.9016481638, 0.4185965955, 0.3055139482, 0.7837233543, 0.5465862155, 0.7979394197, 0.2068720907, 0.3083855808, 0.7539358139, 0.0757107139, 0.9212577343, 0.7691110373, 0.3675687313, 0.6103746295, 0.1860474497, 0.7511492968, 0.1935962141, 0.6090257168, 0.0654017106, 0.8881178498, 0.4985419214, 0.8312378526, 0.6632387042, 0.2347040772, 0.7991008162, 0.7281176448, 0.2602107823, 0.6662689447, 0.1679297984, 0.6103778481, 0.1163734198, 0.3966202736, 0.3159880936, 0.32800138, 0.2707208991, 0.9195216894, 0.4787626565, 0.4261068702, 0.1933896691, 0.572740972, 0.5263438821, 0.1722705066, 0.413194865, 0.3029941022, 0.250980407, 0.5455015302, 0.8958268762, 0.2819412351, 0.162937969, 0.6425027847, 0.0120480489, 0.3251642585, 0.1538381279, 0.3856068552, 0.5091619492, 0.2493483424, 0.2791167498, 0.4195877314, 0.1697363257, 0.4883224368, 0.1246340126, 0.8237965703, 0.3087759316, 0.2666756511, 0.3167749643, 0.4507784247, 0.3383319676, 0.7603561878, 0.9380596876, 0.8256477118, 0.7961603999, 0.7992694378, 0.4155633748, 0.7002693415, 0.5806440711, 0.4182555079, 0.0275410898, 0.3987272382, 0.5506650805, 0.861379087, 0.7958818078, 0.4013074934, 0.3107832372, 0.4954425097, 0.1367432624, 0.1233286485, 0.4443088472, 0.2378848493, 0.538841188, 0.5641937852, 0.8892932534, 0.0776660889, 0.2765585482, 0.5762675405, 0.8628262281, 0.7891501784, 0.9504091144, 0.1619831175, 0.7198655605, 0.1133061275, 0.1723057777, 0.3025299907, 0.7976503968, 0.0072937668, 0.8960158825, 0.0315585323, 0.8132331967, 0.6752576828, 0.1808201671, 0.0632313415, 0.8969068527, 0.0126592619, 0.7279679179, 0.9549113512, 0.5302991867, 0.9083233476, 0.1969243586, 0.2628656924, 0.1486128867, 0.3155753016, 0.4649995863, 0.6356135607, 0.5602090955, 0.1236990616, 0.1019494906, 0.5449941754, 0.9861999154, 0.8628482819, 0.1814590693, 0.7753313184, 0.8170027137, 0.0565828048, 0.824673593, 0.8248749375, 0.4647269845, 0.0503409542, 0.1745345891, 0.7440862656, 0.5324017406, 0.9395241141, 0.9426752925, 0.7974939346, 0.8027789593, 0.9593043923, 0.5680775642, 0.2788208425, 0.8538242579, 0.3109075129, 0.1325492114, 0.7572354078, 0.3708338439, 0.2757935226, 0.316834271, 0.5410025716, 0.5047875643, 0.4934052527, 0.1667081267, 0.3859228194, 0.6246893406, 0.8557038903, 0.822098732, 0.7622995973, 0.7972608209, 0.1990088075, 0.5000911355, 0.1486209333, 0.5659176111, 0.9267964363, 0.9206584692, 0.1615228206, 0.3245853186, 0.1215075403, 0.9093947411, 0.5747628212, 0.584387362, 0.847179234, 0.5482380986, 0.9225259423, 0.6037865281, 0.550549686, 0.2792744637, 0.9645184278, 0.5603542328, 0.4866510332, 0.4041455984, 0.4026151597, 0.3846546412, 0.311201334, 0.1198368594, 0.5647251606, 0.8492454886, 0.6815847158, 0.663033545, 0.9351033568, 0.1822353601, 0.0542719588, 0.2261167914, 0.1366736442, 0.3123262823, 0.4076761305, 0.1226021498, 0.0342418142, 0.7951807976, 0.6466630101, 0.2780374885, 0.2562767267, 0.4415720701, 0.7895520926, 0.3055075705, 0.9376997352, 0.5907462239, 0.0839731321, 0.2812598646, 0.4252110124, 0.3137876689, 0.5340557098, 0.7213253379, 0.7600395679, 0.214539513, 0.2726213932, 0.4629644156, 0.7556714416, 0.165727675, 0.194753781, 0.1462160945, 0.430647403, 0.1258661151, 0.19213067, 0.286329776, 0.2456044555, 0.4276483953, 0.3762872815, 0.1896154583, 0.7289283872, 0.0281404834, 0.0572299622, 0.6962128282, 0.8861011863, 0.1007233784, 0.0842091218, 0.3553883433, 0.6536983848, 0.751683712, 0.163914755, 0.5001323819, 0.9223991036, 0.6045851707, 0.3113570809, 0.455088824, 0.8555629849, 0.8712018728, 0.9753783345, 0.420363605, 0.6919427514, 0.7681412697, 0.9369074106, 0.7508563399, 0.1912885755, 0.0488978103, 0.2743213475, 0.8294526935, 0.6378447413, 0.9181020856, 0.0207253229, 0.2460011095, 0.9463785887, 0.1102090627, 0.6609685421, 0.6241750717, 0.3926430941, 0.2022247612, 0.1335944831, 0.5613848567, 0.9954510331, 0.2715858817, 0.6894689202, 0.7462707758, 0.4290166795, 0.757671237, 0.8266029954, 0.7332335711, 0.1426250041, 0.9101426601, 0.6721584797, 0.2937390506, 0.7919439077, 0.3180099428, 0.2347182333, 0.3101541102, 0.1496052593, 0.6221362948, 0.3111922741, 0.2805654109, 0.1779901832, 0.627972424, 0.678191185, 0.2603260577, 0.661203742, 0.617806077, 0.5715984106, 0.1071078628, 0.922952354, 0.2220921516, 0.141263634, 0.3300559819, 0.0548924245, 0.4914132357, 0.3363906443, 0.5005406141, 0.9501827955, 0.1177470461, 0.9617888927, 0.7922086716, 0.7557209134, 0.0914994776, 0.0798678845, 0.1541324258, 0.5801106095, 0.2038975805, 0.6908184886, 0.4942097068, 0.5793737173, 0.1503309906, 0.8724965453, 0.9717769623, 0.7213614583, 0.9545400739, 0.9041411877, 0.6803680062, 0.7212558985, 0.5946334004, 0.9160152078, 0.9386318922, 0.9252097607, 0.9924756289, 0.897264123, 0.8065363765, 0.4323031604, 0.6466017962, 0.5974913239, 0.2889424562, 0.4705303907, 0.4141258597, 0.858124733, 0.6880973577, 0.6264872551, 0.3961832225, 0.9171339273, 0.8472799063, 0.3797605038, 0.1174795404, 0.0094451653, 0.276768446, 0.3742263317, 0.5159526467, 0.1536156237, 0.2517654598, 0.9240382314, 0.4080337584, 0.7883666754, 0.0191498268, 0.5097766519, 0.7922783494, 0.8297792673, 0.0704369396, 0.5159924626, 0.9056462049, 0.7600080967, 0.0250729267, 0.074649632, 0.8448827863, 0.5982452035, 0.1587237418, 0.9601131082, 0.266018182, 0.9463102818, 0.9610263705, 0.3926327229, 0.8793945312, 0.3192653358, 0.7450480461, 0.4337556958, 0.9021731615, 0.09209878, 0.2523356378, 0.0258540474, 0.5639489889, 0.3752073944, 0.6409106851, 0.2234590799, 0.9407078624, 0.519752562, 0.9200838804, 0.7753949761, 0.048582308, 0.7261092663, 0.3716974854, 0.1573868096, 0.7386546135, 0.7995461226, 0.9846478701, 0.2161029279, 0.7940491438, 0.5405111909, 0.5354738832, 0.0175896753, 0.125873208, 0.2390264273, 0.4795934558, 0.0188046489, 0.6767147779, 0.7249081135, 0.1647282541, 0.7956055403, 0.1440360397, 0.2799735367, 0.0126588326, 0.9017798305, 0.153516084, 0.6107380986, 0.8476133347, 0.4680338502, 0.1649422646, 0.402397722, 0.7237221599, 0.4168302119, 0.4580890238, 0.8868865967, 0.5238973498, 0.065226905, 0.0153818708, 0.90410465, 0.7092889547, 0.0111663546, 0.4621684551, 0.0902491584, 0.6523821354, 0.1322941184, 0.9199751616, 0.4080085754, 0.4400327206, 0.2632351518, 0.2606683373, 0.807777524, 0.5973885655, 0.6986188293, 0.6506662965, 0.1713581234, 0.1490210444, 0.7423495054, 0.5049230456, 0.0724501386, 0.1832771748, 0.6878976226, 0.5974779129, 0.3058165908, 0.1561415344, 0.9164251089, 0.5644869208, 0.6269791126, 0.5522856712, 0.248397097, 0.4036790729, 0.0354237705, 0.2951531112, 0.8220069408, 0.261985749, 0.2251121104, 0.5344994068, 0.7805863023, 0.3655418158, 0.9763858914, 0.9089639783, 0.716889739, 0.8183358908, 0.9113172293, 0.7199918032, 0.1787553579, 0.610899806, 0.8505340219, 0.0235511158, 0.6668973565, 0.6518573165, 0.2543254197, 0.9970578551, 0.5384492278, 0.4958584011, 0.9289419651, 0.3781471848, 0.3958327174, 0.7881753445, 0.7029209733, 0.145436421, 0.5860641599, 0.9053874612, 0.2266070247, 0.3658647835, 0.2602710128, 0.969856143, 0.7805164456, 0.9979770184, 0.2569667101, 0.9147117138, 0.1744126827, 0.4092676342, 0.7785791755, 0.745890379, 0.4073179066, 0.9460712075, 0.8895652294, 0.5188017488, 0.6643666625, 0.7596962452, 0.4671040475, 0.4623226821, 0.2402814925, 0.1071826592, 0.3894088566, 0.9619060755, 0.8857082725, 0.6125600338, 0.1127229929, 0.7593019009, 0.2643416226, 0.9604693651, 0.3696739376, 0.4868840277, 0.8987175822, 0.6166923046, 0.662982583, 0.2814643383, 0.415207088, 0.389919579, 0.0908245593, 0.6337742209, 0.6660229564, 0.0168991759, 0.6627727747, 0.9359357953, 0.6843416691, 0.5728343129, 0.0547134019, 0.685659945, 0.5507382751, 0.9939987659, 0.2345321774, 0.1719274223, 0.9141665697, 0.3132954836, 0.0179193784, 0.9960456491, 0.4326222539, 0.5165576339, 0.886708796, 0.2333941758, 0.9952901006, 0.0446933284, 0.1494547427, 0.6022816896, 0.5697607994, 0.385386765, 0.3632143736, 0.8947452903, 0.9174077511, 0.9135496616, 0.2308936268, 0.4312505126, 0.407698065, 0.5322026014, 0.5938063264, 0.6172964573, 0.4926365316, 0.6648594141, 0.6481961608, 0.6685955524, 0.5235430598, 0.2206870019, 0.6387106776, 0.1486610174, 0.9072556496, 0.0401729867, 0.0251173992, 0.1631743759, 0.0747975558, 0.3981306553, 0.1973253936, 0.8821077347, 0.4138412476, 0.5068641901, 0.3525366187, 0.5587912202, 0.7680332661, 0.650534153, 0.8928561807, 0.5482527018, 0.8525030613, 0.0207585543, 0.1790263206, 0.654986918, 0.3725682199, 0.4448303878, 0.2896177173, 0.8816843629, 0.0501009487, 0.2392381728, 0.5724250078, 0.554754734, 0.2343842834, 0.6771595478, 0.7919211388, 0.2475765347, 0.7252397537, 0.3116749525, 0.2228567451, 0.4254527688, 0.4732843339, 0.7073062062, 0.16599527, 0.8754320741, 0.0422150232, 0.5892957449, 0.9554278851, 0.7951545119, 0.9398952127, 0.0016460768, 0.7696458101, 0.2773800194, 0.8399140239, 0.7641743422, 0.6685501337, 0.1700147092, 0.0859233364, 0.1606788784, 0.3248689175, 0.1749015599, 0.1241669506, 0.2402480394, 0.9337751269, 0.7104728222, 0.3777848184, 0.3443015516, 0.572535336, 0.6791664958, 0.7653573751, 0.2869972587, 0.2914162278, 0.5757843852, 0.6274257302, 0.3609881699, 0.0656926185, 0.1774376929, 0.8991229534, 0.1645248085, 0.971152246, 0.7378920913, 0.7183789015, 0.7837990522, 0.9019348621, 0.3406390846, 0.3585455716, 0.1978515834, 0.4827848375, 0.6580856442, 0.9271910191, 0.0634329617, 0.1452655494, 0.3483816087, 0.4230147898, 0.9212183356, 0.3086003661, 0.7094407082, 0.3381393552, 0.7592514157, 0.0466459319, 0.9443041086, 0.3657453954, 0.0994238853, 0.7956072092, 0.4494190216, 0.6249750257, 0.788384676, 0.9120051861, 0.3607588708, 0.3643571138, 0.7760267854, 0.8128287792, 0.6568604112, 0.1636924148, 0.3170692921, 0.4483211637, 0.1938449144, 0.5941886306, 0.8367087245, 0.8368217945, 0.0035205879, 0.573941648, 0.4770686924, 0.664731741, 0.0334105305, 0.2560984492, 0.8930671215, 0.6633207202, 0.2470958382, 0.2723561823, 0.1203128025, 0.8624477386, 0.2482250333, 0.6392576694, 0.6223504543, 0.8426845074, 0.5030641556, 0.7673287392, 0.6497668028, 0.838163197, 0.2775277495, 0.3833058774, 0.8791123033, 0.2771086097, 0.394184798, 0.4843804538, 0.2845208645, 0.1185088307, 0.4250343442, 0.0023946362, 0.2106015831, 0.6604475379, 0.2069336474, 0.4172060788, 0.316054523, 0.7236531973, 0.0827618986, 0.3691194057, 0.8608131409, 0.974889636, 0.799705565, 0.2435884625, 0.4771180451, 0.1623293608, 0.3136681616, 0.4357536137, 0.3707086146, 0.0670966059, 0.4082645476, 0.5677208304, 0.1632437259, 0.0399077833, 0.4316281974, 0.2769917846, 0.8198401332, 0.0051376601, 0.4502624869, 0.5391125679, 0.896712482, 0.5494186282, 0.2151868194, 0.5544868708, 0.3837798238, 0.9139256477, 0.9917652607, 0.6647973657, 0.9810667634, 0.1827602386, 0.4053958654, 0.4926604629, 0.0187435448, 0.758720696, 0.5928065181, 0.2180640846, 0.3847024143, 0.359958142, 0.1978143454, 0.4026862085, 0.2745231688, 0.1516407728, 0.6969855428, 0.7653558254, 0.230665192, 0.1905230731, 0.9833192825, 0.3286725581, 0.606672883, 0.4284333587, 0.6850233078, 0.8764329553, 0.3780399263, 0.1258152425, 0.1446966678, 0.3769092262, 0.7866101861, 0.6098955274, 0.3473505676, 0.2391392738, 0.426815331, 0.9702208042, 0.3427807689, 0.8359431624, 0.9565569758, 0.7956938744, 0.9251024723, 0.4239948094, 0.9743397236, 0.2967027128, 0.1855548471, 0.3840411603, 0.9848009348, 0.607657969, 0.7870281935, 0.2100580633, 0.7229981422, 0.9958847165, 0.7850106955, 0.4386725724, 0.9116359353, 0.1110212803, 0.2471448928, 0.3857101202, 0.1838507354, 0.2601014376, 0.1416177005, 0.8650175929, 0.8732871413, 0.623083055, 0.6802329421, 0.0996893495, 0.650197804, 0.9553357959, 0.5717819333, 0.4062424302, 0.2195142955, 0.5251868963, 0.8651615381, 0.2904576063, 0.2491702288, 0.6506875157, 0.8565377593, 0.2186982781, 0.2216417491, 0.4146128595, 0.3996264637, 0.8225415349, 0.546789825, 0.4502311051, 0.4192685485, 0.3646653295, 0.7288874388, 0.069471091, 0.7293733954, 0.594553709, 0.7067605257, 0.2717151046, 0.280637145, 0.346878469, 0.1379666179, 0.1567456573, 0.8819831014, 0.9803464413, 0.4977178872, 0.1560947001, 0.2045936584, 0.916230917, 0.0600311048, 0.8369666934, 0.8623803854, 0.5504769683, 0.724615097, 0.1883597821, 0.5521970987, 0.2744043469, 0.395413667, 0.0458976068, 0.1272772998, 0.3680867255, 0.6731156111, 0.4167750478, 0.8066455126, 0.3769917488, 0.1405894309, 0.3766871691, 0.3292651474, 0.8986744881, 0.2548906505, 0.2380404323, 0.9344167113, 0.2000645846, 0.3750537634, 0.449852258, 0.046583049, 0.8664452434, 0.0916056186, 0.1723448634, 0.1202788427, 0.5274640322, 0.6582357883, 0.7431231737, 0.4443565309, 0.5510696173, 0.6913768649, 0.8997213244, 0.3973141909, 0.9220381975, 0.3874337375, 0.46272102, 0.3119893074, 0.7152445912, 0.3245284259, 0.3801714182, 0.7628766298, 0.2708151042, 0.0212438125, 0.4925932884, 0.4191493392, 0.64023, 0.6853370667, 0.2417253405, 0.4153464735, 0.9706567526, 0.8890759349, 0.9221964478, 0.0850019157, 0.8838173747, 0.1457756907, 0.8103173375, 0.5617719889, 0.8932931423, 0.2907245755, 0.2658019066, 0.6155971289, 0.3797874153, 0.0294378158, 0.0609415583, 0.7916467786, 0.2828751504, 0.6566563249, 0.0338012911, 0.3472755253, 0.7622926235, 0.7038429976, 0.7583386302, 0.4775670469, 0.5229033232, 0.0740877017, 0.9934150577, 0.637316525, 0.7957789898, 0.7632263303, 0.6507166028, 0.9457629323, 0.1677881777, 0.2133068144, 0.072077632, 0.3274128735, 0.2949723899, 0.1843675226, 0.1939653456, 0.4882145226, 0.467441231, 0.0979263186, 0.3892448843, 0.0015220752, 0.3349666595, 0.8280725479, 0.8958793879, 0.2740472257, 0.7528444529, 0.6455445886, 0.1103217825, 0.1282761842, 0.8768145442, 0.834253788, 0.2627376318, 0.3873414695, 0.5884376764, 0.5160834193, 0.0325106718, 0.7335627079, 0.7235043645, 0.0617941245, 0.1420445889, 0.6843103766, 0.1855074316, 0.2105052769, 0.7432459593, 0.1830675304, 0.950529635, 0.1581544578, 0.0524407662, 0.5883249044, 0.8929544687, 0.9219861627, 0.8933918476, 0.6961153746, 0.7027171254, 0.7246829867, 0.0311612673, 0.9148760438, 0.6262444258, 0.6753783822, 0.9055992365, 0.6350241899, 0.2108185589, 0.9661568403, 0.317761749, 0.9335716367, 0.7393125296, 0.4963877797, 0.8014323115, 0.9316043854, 0.670258522, 0.9558092356, 0.7424262166, 0.2797902524, 0.0351170786, 0.6409977078, 0.842458725, 0.7864570618, 0.3171681464, 0.5488686562, 0.4319936633, 0.2542414665, 0.673638463, 0.4197515249, 0.6089794636, 0.8115475178, 0.5550845861, 0.5174214244, 0.2807508409, 0.0728380606, 0.1486964524, 0.233274892, 0.6294175386, 0.6225250363, 0.8801549077, 0.1474074274, 0.7764623165, 0.6719228625, 0.4223499298, 0.7741437554, 0.1457236856, 0.5318447948, 0.0769671202, 0.9814693928, 0.6644887328, 0.2739057839, 0.6445885301, 0.3141367137, 0.2762872875, 0.726888299, 0.4102705717, 0.7965539694, 0.2357157469, 0.2096191943, 0.3290013671, 0.5948249102, 0.2858313024, 0.200560689, 0.8308608532, 0.4202457368, 0.3120578229, 0.322106272, 0.8646596074, 0.4526916444, 0.776292026, 0.38634938, 0.3756863773, 0.880133152, 0.7549504042, 0.6724306345, 0.7578244805, 0.4483213127, 0.6669061184, 0.8297504783, 0.7228450179, 0.9131419063, 0.3085200489, 0.2644110918, 0.6776450276, 0.5335254073, 0.3853515685, 0.0415925086, 0.5043134689, 0.1502651274, 0.9326584339, 0.5940889716, 0.4335834086, 0.0816059038, 0.277962327, 0.6517646313, 0.4175403714, 0.8457265496, 0.2253156602, 0.421695292, 0.9016408324, 0.6336846948, 0.3655908406, 0.1339345127, 0.5112591982, 0.716275394, 0.9189779758, 0.6235325933, 0.0686960071, 0.7317407727, 0.8305719495, 0.7963162661, 0.376308918, 0.2900558412, 0.4539898634, 0.1895425618, 0.7576664686, 0.9677003622, 0.3269715607, 0.6987845898, 0.2969448566, 0.9047911167, 0.6835853457, 0.9134425521, 0.4491491318, 0.5688306093, 0.3349467814, 0.1624736637, 0.596809566, 0.4422278404, 0.9865394831, 0.1403383464, 0.6019929647, 0.7631724477, 0.4821002185, 0.282273531, 0.2637169063, 0.0629151836, 0.3392986059, 0.8162535429, 0.1576626301, 0.63392663, 0.7746828198, 0.738846004, 0.0366244018, 0.8592647314, 0.4098013639, 0.9437143207, 0.6170257926, 0.778269887, 0.8248697519, 0.8932003975, 0.0028138529, 0.8005768061, 0.7718992233, 0.1201800406, 0.1735441536, 0.4964210093, 0.6338633895, 0.5204722285, 0.2782363296, 0.3948111236, 0.3842954338, 0.1762899011, 0.9185162187, 0.17715469, 0.1382024288, 0.0785585418, 0.0221158117, 0.236541912, 0.9691518545, 0.2383108288, 0.2399678081, 0.0698488131, 0.1705540568, 0.1464137286, 0.6299777627, 0.4087302387, 0.6929829121, 0.6227343082, 0.9799892902, 0.1593679488, 0.5159394145, 0.6728126407, 0.1613411754, 0.4187045693, 0.9052704573, 0.068343848, 0.0806437209, 0.994374454, 0.9430711865, 0.2377529293, 0.8877018094, 0.8982362747, 0.0628433526, 0.0795353726, 0.6034497023, 0.2245612144, 0.6433573365, 0.5621058345, 0.9191433191, 0.7513613701, 0.5223335624, 0.3583497703, 0.5554248095, 0.2030288726, 0.9177957177, 0.2604083419, 0.7229249477, 0.8674602509, 0.899328053, 0.1407557875, 0.7070519924, 0.2579062581, 0.4066617191, 0.9219773412, 0.16925928, 0.9367558956, 0.3897538483, 0.0023197513, 0.2951805592, 0.4129855335, 0.7490902543, 0.2227606177, 0.2080491632, 0.8106707335, 0.2692914009, 0.7514678836, 0.0471416153, 0.4828400612, 0.0049115932, 0.796680212, 0.6464766264, 0.2469250858, 0.6870105267, 0.5058383942, 0.1847783476, 0.6010066271, 0.0280457847, 0.6835210919, 0.353749752, 0.2168741673, 0.7643010616, 0.3083560765, 0.1191221401, 0.7753403187, 0.9169752598, 0.3312447071, 0.6547005773, 0.9233077168, 0.0502437577, 0.4198615253, 0.3854964972, 0.618688345, 0.235300526, 0.2620733976, 0.2423845083, 0.8080005646, 0.5128461123, 0.9230268598, 0.4494173825, 0.9232423902, 0.8044607639, 0.004345566, 0.1539704055, 0.8541145921, 0.6568136215, 0.1612754613, 0.4538104832, 0.8606331944, 0.0418969467, 0.3622143567, 0.7007989287, 0.8103873134, 0.6201249361, 0.9213223457, 0.2733407021, 0.2659450471, 0.1974497885, 0.9474107623, 0.4292281568, 0.6510161757, 0.0553921796, 0.2013494074, 0.7537032962, 0.9218379855, 0.8922259212, 0.7969861627, 0.8842226863, 0.5074092746, 0.3536762297, 0.180143863, 0.324855417, 0.5243495107, 0.8030092716, 0.5405832529, 0.6296108961, 0.7541767359, 0.8891962767, 0.6212946773, 0.598218739, 0.4153193235, 0.8618081808, 0.0975739434, 0.9169347286, 0.3354103863, 0.1634404808, 0.0774655789, 0.4144199491, 0.1697692275, 0.0305127427, 0.6473826766, 0.0559284762, 0.1740518808, 0.9584801793, 0.3608543277, 0.6506474614, 0.7437055111, 0.6545598507, 0.5460421443, 0.1271338165, 0.6584819555, 0.7702636719, 0.6501505971, 0.0096557727, 0.7443832159, 0.2116404474, 0.897896409, 0.7366517186, 0.5457256436, 0.0882219896, 0.9202632904, 0.2240703702, 0.9268023372, 0.839187324, 0.2440102398, 0.8974300027, 0.2471573353, 0.4037082493, 0.621555388, 0.4451818466, 0.934975028, 0.9120126367, 0.8305487633, 0.2451698333, 0.6540192962, 0.8015082479, 0.1273851246, 0.6529533863, 0.1507285237, 0.6806657314, 0.8031535745, 0.2254239768, 0.040461611, 0.8686904311, 0.1341269612, 0.4574179351, 0.4359958768, 0.7218812108, 0.2074009925, 0.92648983, 0.6719136834, 0.0693204552, 0.6947955489, 0.2404444963, 0.2200752497, 0.2397666872, 0.6543200612, 0.3302212954, 0.3973362744, 0.6467256546, 0.1898995638, 0.8515286446, 0.6217008829, 0.4965752065, 0.5030667782, 0.4232194424, 0.9286808372, 0.978176713, 0.3428289592, 0.4960512519, 0.6297627091, 0.1246587634, 0.5947698355, 0.5881645679, 0.6585828662, 0.1542954892, 0.9628793597, 0.9022038579, 0.1555876136, 0.7502764463, 0.4300754666, 0.9101669788, 0.6334246993, 0.9918186069, 0.1093794703, 0.7305037379, 0.1660741866, 0.1111549363, 0.1338825822, 0.3090497553, 0.9241870642, 0.5034430623, 0.4333055913, 0.5386890769, 0.5691626072, 0.9126147628, 0.3506309986, 0.3669624031, 0.370898366, 0.9459529519, 0.210996747, 0.1695951372, 0.722022891, 0.3855873942, 0.2058136463, 0.477850765, 0.5975036621, 0.1925799251, 0.8079403043, 0.8593161106, 0.8881294727, 0.4832123816, 0.8646829128, 0.045002114, 0.2717565596, 0.654596746, 0.740993619, 0.712767005, 0.0536489561, 0.8121938705, 0.2726101279, 0.201740548, 0.4252589345, 0.9599416256, 0.9440070391, 0.8914710283, 0.2804166079, 0.8410710096, 0.8708735704, 0.5246590376, 0.418957144, 0.2666073143, 0.586630106, 0.8477293849, 0.0594590642, 0.179307729, 0.5777279139, 0.1884094626, 0.0238688868, 0.9711610675, 0.6403006315, 0.8423227668, 0.5357096791, 0.7835069895, 0.0897694305, 0.6887326241, 0.1242933348, 0.7735361457, 0.4951869845, 0.2474716753, 0.8933708668, 0.3120188117, 0.1654740274, 0.0457435772, 0.7408176661, 0.8978531957, 0.4177000821, 0.7712976336, 0.2174149454, 0.8904352784, 0.6536405087, 0.3068143725, 0.9719513059, 0.4117776453, 0.882306695, 0.8472982645, 0.4625660479, 0.8050373197, 0.6702994108, 0.0600084476, 0.4273302555, 0.9303762317, 0.9641988873, 0.5589072108, 0.3410102129, 0.669210732, 0.899477303, 0.0259494763, 0.1760968715, 0.7839687467, 0.8990438581, 0.3484356999, 0.034977302, 0.1674957275, 0.2806791067, 0.5621151924, 0.2108184397, 0.5541005135, 0.0912834033, 0.0941558704, 0.4533232152, 0.8271482587, 0.284833312, 0.5222066641, 0.0534446649, 0.6859184504, 0.4062723815, 0.4238585532, 0.2513298988, 0.3285494745, 0.6328689456, 0.6720162034, 0.996681273, 0.4865611792, 0.4061975181, 0.3122657835, 0.2608599961, 0.0360945873, 0.989610672, 0.9801153541, 0.2659962475, 0.2279564738, 0.9064323306, 0.64223665, 0.5613036752, 0.2223269939, 0.2006824315, 0.562020421, 0.0167060327, 0.8294845819, 0.1624858826, 0.7587867379, 0.9084835649, 0.0810662434, 0.0144402096, 0.1442496926, 0.4372602999, 0.9424352646, 0.0777170062, 0.4542703331, 0.5623986721, 0.8255488873, 0.3118360639, 0.6332219243, 0.1546555907, 0.4071251154, 0.6449183226, 0.4380641878, 0.3588815629, 0.7259109616, 0.8949323893, 0.0310435332, 0.8665700555, 0.4032739699, 0.3401636183, 0.3998365998, 0.3091824353, 0.760176599, 0.8782159686, 0.8804634809, 0.3928438425, 0.9785805345, 0.8952303529, 0.4265696108, 0.5748035908, 0.6350638866, 0.7704594731, 0.7251192927, 0.0821672976, 0.7988390326, 0.6722599268, 0.6567916274, 0.0610449426, 0.6711975932, 0.4044577777, 0.7087682486, 0.3872709274, 0.8910403252, 0.2452526689, 0.6968676448, 0.1313157529, 0.8255284429, 0.3837303519, 0.6059313416, 0.7568653226, 0.3676816523, 0.9447989464, 0.4323852658, 0.0950854868, 0.1700586975, 0.3190297186, 0.4781437814, 0.5663873553, 0.5921857953, 0.5017104149, 0.1776745617, 0.7146577835, 0.2253703773, 0.7989724278, 0.9696672559, 0.4163217843, 0.6855589747, 0.4756537676, 0.6429971457, 0.7487652898, 0.8873785138, 0.6627467871, 0.0111746527, 0.6880887151, 0.2055517435, 0.6718572378, 0.365061909, 0.1937220991, 0.6632122397, 0.9281525612, 0.423776716, 0.9447239041, 0.2356662154, 0.4056119919, 0.0449440032, 0.1486060917, 0.2460376322, 0.8845275044, 0.5975536704, 0.1284107715, 0.4094949663, 0.7570086718, 0.6579572558, 0.072208643, 0.1990416944, 0.8961207867, 0.8151916265, 0.2128580809, 0.490698427, 0.9360303283, 0.6462264061, 0.7495074272, 0.8169018626, 0.8900119662, 0.476947844, 0.2296860665, 0.6628353, 0.7692196369, 0.3276960552, 0.4769940078, 0.393767029, 0.3482863307, 0.8662155271, 0.626218915, 0.7110581994, 0.6555246115, 0.4248665571, 0.4261446297, 0.2971760631, 0.9768515229, 0.2526108325, 0.6574644446, 0.0995754302, 0.8846825361, 0.4494028389, 0.6608137488, 0.0787991062, 0.2857209146, 0.4740692377, 0.9063662291, 0.9237411618, 0.6824497581, 0.2829234302, 0.6688630581, 0.8890810013, 0.6712776423, 0.8890388012, 0.5011259317, 0.4517498016, 0.1297598332, 0.8847675323, 0.9259518385, 0.3250522614, 0.5810523629, 0.6190810204, 0.221688062, 0.2125811428, 0.175629437, 0.6121792793, 0.9578194022, 0.3417336345, 0.3919051886, 0.2609726787, 0.6801815629, 0.8407352567, 0.270652771, 0.6578662992, 0.317260921, 0.6947216988, 0.4393965602, 0.8963797688, 0.2064710557, 0.2251489758, 0.0126833487, 0.4193360507, 0.8995458484, 0.4652849734, 0.996522665, 0.1726991236, 0.6309124827, 0.6526710391, 0.530271709, 0.7298354506, 0.0204058811, 0.0812477916, 0.9214099646, 0.9160807133, 0.5754440427, 0.372495234, 0.84642452, 0.8983617425, 0.3619753718, 0.6741123199, 0.9161174297, 0.8163927794, 0.679979682, 0.4092884064, 0.8607659936, 0.2220835984, 0.8452451825, 0.3982852101, 0.278275609, 0.1027002558, 0.8696690202, 0.4094341099, 0.1890173852, 0.6893680096, 0.8828161359, 0.8367606997, 0.3150655925, 0.932281971, 0.045194827, 0.0074513466, 0.0823246688, 0.6867864728, 0.3197860122, 0.4163556099, 0.8237211108, 0.3670961261, 0.5294805765, 0.1739652604, 0.1212077737, 0.627476871, 0.9344421625, 0.1420627087, 0.8371850848, 0.9862938523, 0.0466496162, 0.4052397311, 0.0913202167, 0.5805484653, 0.3732404113, 0.1624829918, 0.3037349284, 0.3561063409, 0.8215609193, 0.7996636629, 0.94925946, 0.6057854295, 0.5836023688, 0.9080621004, 0.6684545279, 0.8334238529, 0.0231123008, 0.2039128095, 0.9188492894, 0.7504552603, 0.2526971698, 0.9760959744, 0.2608017921, 0.658737421, 0.8090463281, 0.9347877502, 0.2722188234, 0.9445360899, 0.9160112143, 0.4180462658, 0.7208918333, 0.2895027399, 0.9076516032, 0.1260608137, 0.0600589439, 0.3237433434, 0.3174104393, 0.1950612813, 0.7346307635, 0.2903274894, 0.8510568738, 0.1247075722, 0.6234763265, 0.9235235453, 0.3917286694, 0.3930013478, 0.5962136984, 0.3196406364, 0.9130704403, 0.8777415156, 0.7164982557, 0.2132440954, 0.4433366656, 0.8953370452, 0.5229977965, 0.9834817052, 0.957844615, 0.8181498051, 0.3126172125, 0.3691214323, 0.478398025, 0.9724182487, 0.396281153, 0.1378229409, 0.5460863113, 0.9529812336, 0.7043054104, 0.8286221027, 0.9211901426, 0.6903455853, 0.6702198982, 0.551228106, 0.7339170575, 0.1466924548, 0.5918322206, 0.3278500438, 0.513263762, 0.8653480411, 0.905811727, 0.5126808882, 0.0351459347, 0.9121012688, 0.8552727103, 0.1450043321, 0.6231027842, 0.3432948589, 0.1883990914, 0.6612223387, 0.3855815828, 0.9724083543, 0.5299458504, 0.4795577526, 0.594492197, 0.4068101048, 0.4792802334, 0.2116247863, 0.5698096156, 0.2297195345, 0.6769658923, 0.1775925905, 0.0194287039, 0.1139837131, 0.6585344076, 0.639734745, 0.438911289, 0.3355108798, 0.4957669675, 0.1260170937, 0.1376509964, 0.2432282716, 0.2809645832, 0.0897794887, 0.3889560401, 0.7109050155, 0.4456769824, 0.589841485, 0.455955267, 0.4442132413, 0.1469720155, 0.2309683412, 0.4611694217, 0.2127885222, 0.6419813037, 0.1400190741, 0.4074942768, 0.8746674657, 0.6800274849, 0.5546683669, 0.1405323297, 0.3087230921, 0.3108388782, 0.4684635401, 0.3670452237, 0.3547304273, 0.4452068806, 0.2501153052, 0.1818600297, 0.4486742914, 0.4042747319, 0.5299410224, 0.6349546909, 0.0964704156, 0.3275614381, 0.1729331613, 0.3874901533, 0.7976809144, 0.7245351076, 0.4126122892, 0.5798994303, 0.4871999323, 0.5768399239, 0.9808243513, 0.5988185406, 0.9243234992, 0.1002269238, 0.0668101907, 0.5576942563, 0.1547056288, 0.9134264588, 0.7999120951, 0.2232726514, 0.5103706717, 0.6306093931, 0.4064202011, 0.6162929535, 0.7642644644, 0.3543204367, 0.433966279, 0.8976281285, 0.8275479674, 0.674218297, 0.7274590731, 0.9887321591, 0.1506728083, 0.3050062954, 0.0947229713, 0.5183111429, 0.5123482347, 0.6777183414, 0.1473470032, 0.7955759764, 0.2448808253, 0.8324652314, 0.6503762007, 0.7213102579, 0.5583073497, 0.0153511642, 0.6225735545, 0.6590080261, 0.1195797697, 0.6417117715, 0.7954779863, 0.7288566232, 0.648191452, 0.8784126043, 0.1893307716, 0.4797648489, 0.2614610791, 0.6313613057, 0.7609228492, 0.9807720184, 0.4273985028, 0.3011860549, 0.1374281645, 0.7859547138, 0.5002349615, 0.6124469042, 0.1579888612, 0.9053065777, 0.3004028201, 0.2322366834, 0.9418653846, 0.2821920514, 0.7463891506, 0.9389582276, 0.877441287, 0.5484405756, 0.643230617, 0.1492760628, 0.6636828184, 0.1349965781, 0.6846762896, 0.0960200503, 0.8032522202, 0.5674996972, 0.7586348057, 0.2204396129, 0.5765968561, 0.1476237327, 0.125220567, 0.4377010167, 0.3201996088, 0.7443005443, 0.903943181, 0.0650240481, 0.9854292274, 0.3199845552, 0.0192854386, 0.1524990797, 0.3533820808, 0.2842772901, 0.7961959243, 0.054587502, 0.4254358411, 0.4807631075, 0.658485949, 0.9548473954, 0.6311061978, 0.9193943143, 0.1140224487, 0.0753248259, 0.2469710708, 0.549726069, 0.4086890817, 0.8121051192, 0.9592389464, 0.0892099589, 0.7681341171, 0.4275183976, 0.1507211328, 0.3834882379, 0.4134389758, 0.2619946003, 0.3815563321, 0.4726091623, 0.09177614, 0.5443322062, 0.2896725535, 0.1511472017, 0.3457608521, 0.6623216867, 0.7363665104, 0.3905221224, 0.3386698365, 0.5143055916, 0.3104698956, 0.7101206779, 0.7432330847, 0.3589529097, 0.9071243405, 0.5633781552, 0.2478924245, 0.3961749673, 0.3940633833, 0.4096750915, 0.3424012661, 0.0617133453, 0.1200992018, 0.9136456847, 0.1307758391, 0.9852566719, 0.7767199874, 0.6296752095, 0.5157176852, 0.8008569479, 0.8990735412, 0.3058244586, 0.482845813, 0.8979612589, 0.8620452285, 0.1399817318, 0.1294701844, 0.5088728666, 0.1795148104, 0.2281204611, 0.4375269413, 0.1420404017, 0.9967051148, 0.6542924047, 0.3547791839, 0.1780012995, 0.9740327597, 0.1273075789, 0.1317660809, 0.8746281862, 0.6012553573, 0.8944063783, 0.7546340823, 0.6810714602, 0.1449845731, 0.1058138311, 0.5945718288, 0.0061858799, 0.9088662863, 0.0364964306, 0.659319222, 0.4754303396, 0.8641412854, 0.1688663661, 0.7769435048, 0.8632110357, 0.1978442222, 0.370746702, 0.9008491039, 0.4117237628, 0.5911692977, 0.414293766, 0.5437353849, 0.1355583221, 0.0121418666, 0.2880280316, 0.1683413535, 0.830060184, 0.4028870165, 0.2162528634, 0.1172972098, 0.9046423435, 0.4391779602, 0.1809546649, 0.5494115353, 0.7870641351, 0.7402432561, 0.0971550494, 0.8864669204, 0.1557355523, 0.9877199531, 0.9709496498, 0.5582349896, 0.6483392119, 0.3776219189, 0.0213725585, 0.9192963243, 0.5838835239, 0.1824482828, 0.0227799509, 0.7876009941, 0.6253976822, 0.9414482117, 0.668708086, 0.3885524273, 0.6440524459, 0.0235392302, 0.4634030759, 0.9037769437, 0.7047700286, 0.5639411211, 0.0797672644, 0.8715515733, 0.1718950272, 0.8510921001, 0.3665633202, 0.9105977416, 0.8985737562, 0.8899857998, 0.190374881, 0.4420548379, 0.777911067, 0.8723896742, 0.6555142403, 0.5234972835, 0.5375967026, 0.9539933205, 0.2442766577, 0.1733209044, 0.1835743636, 0.9667642117, 0.8312539458, 0.5093300343, 0.1718380898, 0.7006902099, 0.2413630486, 0.0014654149, 0.1509610564, 0.9248156548, 0.8946156502, 0.5608989596, 0.7108150125, 0.8669762611, 0.3975015581, 0.9709920883, 0.0024339973, 0.2460548133, 0.6222757101, 0.8269061446, 0.5813835263, 0.4670407474, 0.9863980412, 0.3343105614, 0.3470014334, 0.2081110477, 0.8207169175, 0.9644153714, 0.8585681319, 0.1764064282, 0.610262692, 0.4040272832, 0.1060658619, 0.8057425022, 0.1892712712, 0.9302367568, 0.62426579, 0.1917841882, 0.8622600436, 0.2701641619, 0.7951965928, 0.4226970375, 0.7190234065, 0.9243289232, 0.1728080213, 0.827131927, 0.5604746938, 0.9233171344, 0.3672805727, 0.6523117423, 0.375238508, 0.4378993511, 0.3796490133, 0.7206484675, 0.3956534564, 0.6423272491, 0.6525249481, 0.9342370629, 0.0251514204, 0.6400496364, 0.9884830117, 0.957752645, 0.5597369075, 0.9522598386, 0.4964574277, 0.8011842966, 0.4690652788, 0.1251467615, 0.6872444153, 0.4052522182, 0.3470003009, 0.7000844479, 0.6824920177, 0.9659762979, 0.6638742089, 0.3225129247, 0.687972486, 0.4053599238, 0.968595922, 0.5156210661, 0.5128187537, 0.443690449, 0.3054828048, 0.2305809557, 0.6767401695, 0.6256210208, 0.6912963986, 0.0165719297, 0.3622584343, 0.8970501423, 0.5225399137, 0.9967964292, 0.2790033519, 0.6947363615, 0.1822600812, 0.3191750944, 0.6650258899, 0.8257966638, 0.5291721821, 0.8534001112, 0.3419867754, 0.310248822, 0.6930023432, 0.8994190097, 0.5153676867, 0.2931976616, 0.0122786015, 0.1052334905, 0.9797928333, 0.4045354426, 0.5881813765, 0.3011051416, 0.296538651, 0.0004573388, 0.3471882939, 0.6470041871, 0.530200243, 0.4859737754, 0.6174158454, 0.896969378, 0.0058193682, 0.6505814195, 0.8059725165, 0.0950807557, 0.9160533547, 0.2175524086, 0.4627268016, 0.5596550703, 0.8113400936, 0.1713882685, 0.9571608901, 0.4924174547, 0.1450736821, 0.5452455878, 0.4172867239, 0.6108496785, 0.7823422551, 0.0386712477, 0.652962923, 0.1452127993, 0.5473229289, 0.1835960746, 0.0783243477, 0.535086453, 0.9015673995, 0.0844866112, 0.3359190524, 0.9643784761, 0.4581473172, 0.836325407, 0.3940873742, 0.1640149802, 0.4877164662, 0.9655038118, 0.162691623, 0.1304658651, 0.6785253286, 0.9600315094, 0.0298520178, 0.3318853676, 0.6742720604, 0.0945525169, 0.9036905766, 0.2719343007, 0.8741890192, 0.7281681895, 0.1554527879, 0.9616663456, 0.5914126635, 0.1760296226, 0.9976099133, 0.7520726323, 0.1688483655, 0.3248471022, 0.6795883179, 0.8341190815, 0.6166484356, 0.8056626916, 0.3027607203, 0.3298122585, 0.460275501, 0.886164248, 0.8865209222, 0.5903875232, 0.866979897, 0.0391226187, 0.2200651318, 0.5297188163, 0.4769316614, 0.1774325967, 0.533714354, 0.9587566853, 0.9997043014, 0.8805023432, 0.4294218719, 0.8598889709, 0.7086170912, 0.9648718238, 0.2213305384, 0.6635443568, 0.1361998469, 0.3925404847, 0.5864224434, 0.696239531, 0.651730597, 0.904695034, 0.1784210205, 0.6329058409, 0.3313221335, 0.5627108812, 0.8287445307, 0.4045689404, 0.4543702602, 0.3818875849, 0.6417444348, 0.235222131, 0.5107812881, 0.7521730661, 0.4750962853, 0.6823205948, 0.0880354643, 0.750305295, 0.4425649941, 0.4795944691, 0.1397001445, 0.0751060024, 0.643936038, 0.4449377656, 0.7391952276, 0.6456022263, 0.1680421382, 0.4670319557, 0.90364784, 0.968644321, 0.1434570551, 0.2034571916, 0.5173873305, 0.4233805239, 0.7449593544, 0.0830473825, 0.0587290116, 0.0174372904, 0.8638056517, 0.0822573155, 0.3921276033, 0.1190436408, 0.1396870911, 0.6370073557, 0.2700611353, 0.8451071978, 0.4612392187, 0.9389430285, 0.4808869064, 0.685505569, 0.421490103, 0.1914810985, 0.6049960256, 0.5583952665, 0.5163834691, 0.4186472595, 0.9761022329, 0.8153747916, 0.7579475641, 0.9782888889, 0.6370413899, 0.1821785122, 0.3533138931, 0.7604292035, 0.7364311218, 0.8843147159, 0.832449615, 0.5752988458, 0.283691138, 0.1390051246, 0.2438068986, 0.2202897519, 0.8939470053, 0.954957366, 0.720932126, 0.1797874421, 0.6687067151, 0.028746251, 0.2628550231, 0.9769717455, 0.6559457183, 0.7245097756, 0.7859728336, 0.3450601101, 0.2188907415, 0.8735473156, 0.5475753546, 0.2021894306, 0.3001955152, 0.7872609496, 0.9030789137, 0.9642545581, 0.1495675743, 0.9555051923, 0.1562586278, 0.6548725367, 0.6379058361, 0.7781556249, 0.9736641645, 0.9092848897, 0.5979778767, 0.1667932272, 0.514901042, 0.2302491963, 0.6791695356, 0.3860677183, 0.7851263881, 0.727565825, 0.0813269317, 0.9373574853, 0.666754961, 0.5001932979, 0.2624501884, 0.7798120975, 0.3684160411, 0.1640051901, 0.4761397541, 0.9312823415, 0.8645301461, 0.4468482733, 0.8502453566, 0.7807247043, 0.5296833515, 0.8604176641, 0.4838578105, 0.8039761782, 0.984085381, 0.6276180744, 0.3977661133, 0.127048105, 0.1253633201, 0.9693322778, 0.9231203198, 0.8149178028, 0.015094324, 0.4160184562, 0.646725297, 0.7587155104, 0.8969345093, 0.7054623961, 0.6793894172, 0.2178113759, 0.3546513021, 0.2665496767, 0.4899263978, 0.6756172776, 0.6280219555, 0.3134118617, 0.7398167253, 0.7667517662, 0.1642062664, 0.9851156473, 0.9228929877, 0.2422635853, 0.0341797844, 0.5910451412, 0.0382496603, 0.0711566508, 0.7964251041, 0.1534774601, 0.1599242538, 0.167764619, 0.3120250106, 0.5375077128, 0.867708981, 0.1629583985, 0.0997991487, 0.0999266431, 0.1491451561, 0.2721735239, 0.1916758716, 0.7117168903, 0.6837921143, 0.6700974703, 0.4945374131, 0.8876660466, 0.8474770784, 0.4904349744, 0.5954986215, 0.5295796394, 0.9318428636, 0.2431325018, 0.2251081169, 0.3525544703, 0.8830800056, 0.6442528367, 0.0919857621, 0.73688972, 0.8346413374, 0.1389365047, 0.1288894117, 0.4958013892, 0.1749054343, 0.9606493711, 0.4930073023, 0.6563494205, 0.3004741073, 0.5815390944, 0.0585923716, 0.904558897, 0.269973278, 0.1810047328, 0.4249069095, 0.9539546371, 0.9245915413, 0.1500610411, 0.8949918747, 0.4106957316, 0.2811679542, 0.8173474669, 0.4115311205, 0.5708447695, 0.551047802, 0.3119313419, 0.8762995601, 0.8760988116, 0.9171943069, 0.0340503976, 0.6438157558, 0.4692310691, 0.1652504057, 0.2901431024, 0.4536658525, 0.3589393497, 0.596744597, 0.872954309, 0.2474726439, 0.0587516092, 0.2985112369, 0.0822437108, 0.6593500972, 0.3413878977, 0.9465652704, 0.6105484366, 0.5631908178, 0.6818451881, 0.1601658612, 0.8971045613, 0.9795738459, 0.3555393815, 0.4363043606, 0.0050256136, 0.0734817758, 0.3814918697, 0.2374612391, 0.1523045599, 0.9003127217, 0.9376186728, 0.9815377593, 0.623914361, 0.4169765115, 0.6183004975, 0.299852103, 0.8537096381, 0.7562656999, 0.9315516353, 0.6085984707, 0.5989226699, 0.4334717989, 0.8152624965, 0.1586142182, 0.6697410941, 0.1658185571, 0.6954014301, 0.2710048854, 0.1332066804, 0.9186689258, 0.6678466797, 0.4265735149, 0.1948410124, 0.4244428575, 0.4671714008, 0.9187193513, 0.7071329355, 0.506911397, 0.8943161368, 0.9237628579, 0.1427617073, 0.3982107043, 0.6053983569, 0.4150694311, 0.8683232665, 0.072871916, 0.5080881119, 0.2074956149, 0.4066801369, 0.4900521338, 0.7531351447, 0.7347860336, 0.6732413173, 0.1802725792, 0.3157454133, 0.3624019921, 0.2683413625, 0.7635646462, 0.9230060577, 0.4070904255, 0.0910319611, 0.7302482724, 0.2909857333, 0.1742155701, 0.3506374657, 0.2501560152, 0.6942669749, 0.1322372556, 0.2435873747, 0.1984533668, 0.8072303534, 0.9401080608, 0.3957302272, 0.421649754, 0.0129361553, 0.1987362653, 0.6652001143, 0.8229570985, 0.8834961653, 0.1215176657, 0.6130769253, 0.0352021232, 0.7741879225, 0.6961135268, 0.2316779792, 0.055512581, 0.329754144, 0.9553067684, 0.4184217155, 0.5293486714, 0.1265911311, 0.7875778675, 0.1896398067, 0.8343408108, 0.4115246236, 0.0595137887, 0.1582321525, 0.3894644678, 0.1535483003, 0.7393954992, 0.9608636498, 0.4286241531, 0.3562712669, 0.9227654338, 0.5660175681, 0.8127071261, 0.2985581756, 0.4470497668, 0.1396178901, 0.4777880609, 0.6422897577, 0.737506628, 0.326285392, 0.8815809488, 0.4984120131, 0.9997048974, 0.9831953645, 0.6845543385, 0.4124499559, 0.2337611765, 0.7102365494, 0.7786266804, 0.595597744, 0.4266300797, 0.66648072, 0.245085597, 0.7969213724, 0.5006770492, 0.1295739561, 0.8208860755, 0.5081101656, 0.9844864011, 0.455870986, 0.3992567658, 0.9340557456, 0.8567868471, 0.0450148731, 0.9980211854, 0.1490179896, 0.1693647057, 0.6558867097, 0.2664994597, 0.3672462404, 0.8838720322, 0.0873681605, 0.4685999453, 0.4295307398, 0.4425379336, 0.7042992711, 0.2025313526, 0.9999275804, 0.3326367438, 0.0899679363, 0.1674279571, 0.2296723127, 0.9397018552, 0.3025586605, 0.5058240294, 0.1710092276, 0.1714102179, 0.126736179, 0.0917770192, 0.1141286641, 0.2273677588, 0.573271811, 0.5326727033, 0.2547509074, 0.1637577116, 0.8045812845, 0.3985255063, 0.5129899979, 0.3820587695, 0.9105479121, 0.3931562603, 0.6405611038, 0.3770503402, 0.8133808374, 0.2194528282, 0.6605672836, 0.0524763614, 0.8783487082, 0.7164062262, 0.6115906835, 0.1426462531, 0.2933609784, 0.4702317417, 0.7032451034, 0.192125693, 0.2354733795, 0.6382959485, 0.8865978718, 0.0192057732, 0.8496630788, 0.8999813795, 0.6268237829, 0.5313404799, 0.0641189441, 0.3086328804, 0.8465796709, 0.6358977556, 0.0649170876, 0.8283549547, 0.4401649535, 0.6714228392, 0.9972767234, 0.2249906659, 0.4198299646, 0.1431726515, 0.9378727674, 0.7163347006, 0.7697145939, 0.3455986679, 0.1547204256, 0.3851391673, 0.8393955827, 0.4326666296, 0.7566757202, 0.8864159584, 0.4580723643, 0.9676396847, 0.1817990094, 0.3892149627, 0.3138799071, 0.6276299357, 0.4725767374, 0.1044836417, 0.6377963424, 0.0904172435, 0.2334369123, 0.1571315974, 0.2801299691, 0.189508155, 0.9949304461, 0.1458076686, 0.0432589389, 0.7181853056, 0.5023262501, 0.6533163786, 0.8917517662, 0.2692360282, 0.0019706525, 0.9202683568, 0.9309409857, 0.8927053213, 0.3768476248, 0.9711019993, 0.4748935401, 0.2210260481, 0.1874148101, 0.6747671962, 0.5749003291, 0.4283550382, 0.1019738615, 0.670748353, 0.2130030543, 0.7748587132, 0.482275635, 0.5167794228, 0.1707672775, 0.6849746704, 0.8548030853, 0.2235736698, 0.5266553164, 0.9154382348, 0.9482907057, 0.5067411661, 0.0289856698, 0.9186859131, 0.4012750685, 0.5432290435, 0.4675513506, 0.0368444994, 0.3931633234, 0.4279684722, 0.9741680622, 0.2949175537, 0.5810667872, 0.3069746792, 0.1663627774, 0.4290866554, 0.8663643599, 0.1683333367, 0.1055471376, 0.0875001401, 0.0989790633, 0.8275893331, 0.0992719159, 0.2301808, 0.6367070079, 0.2370247543, 0.8747205138, 0.4514143169, 0.1646448672, 0.65007025, 0.9903281927, 0.7983329296, 0.518735528, 0.5959643126, 0.6576367021, 0.7959789038, 0.3748928607, 0.1737102121, 0.7423228621, 0.6705230474, 0.95727247, 0.0487582646, 0.6198499203, 0.3517143428, 0.1527780294, 0.1328037828, 0.0332689509, 0.883949399, 0.9367565513, 0.4081926942, 0.9256343842, 0.0810200796, 0.2912037671, 0.3175346255, 0.9003556967, 0.4580399394, 0.6945976019, 0.8740369678, 0.7800629735, 0.2418091893, 0.1369917989, 0.6090449691, 0.7959111333, 0.1295394897, 0.8837180138, 0.1572343409, 0.8273808956, 0.0055001434, 0.6556593776, 0.3431199193, 0.8167563081, 0.7749109268, 0.9453995228, 0.6090634465, 0.740285635, 0.2649319768, 0.6009775996, 0.4589247704, 0.2533712089, 0.1359140277, 0.5452744961, 0.5499470234, 0.202189222, 0.1139321178, 0.1392383277, 0.4750790298, 0.3616923094, 0.5432898998, 0.3631372452, 0.4251794517, 0.4017430842, 0.1326609254, 0.2797758877, 0.247649923, 0.1850706935, 0.775434792, 0.9962185621, 0.0104077756, 0.5964711308, 0.1409658194, 0.5563566685, 0.6112495065, 0.0144342883, 0.9469462633, 0.148224026, 0.2809222639, 0.4099670053, 0.096935682, 0.8448896408, 0.6533840299, 0.5754798055, 0.0238633119, 0.509487927, 0.3114691377, 0.7252626419, 0.882818222, 0.0272231102, 0.3033470511, 0.1127346382, 0.8444536328, 0.2579497099, 0.5005813837, 0.2244332433, 0.7717435956, 0.6684685946, 0.862062037, 0.5720012188, 0.804349184, 0.2534753978, 0.3250861168, 0.6674904227, 0.3079463542, 0.1014064252, 0.2966237962, 0.6742354631, 0.9994797707, 0.9290922284, 0.7931342721, 0.6584977508, 0.8856663108, 0.2655850053, 0.9129021168, 0.6259304881, 0.0171551164, 0.8471147418, 0.4754230976, 0.0494167134, 0.4918880761, 0.3221666217, 0.8877533078, 0.5579791069, 0.840195477, 0.0526487865, 0.4718564153, 0.1661192477, 0.564080894, 0.4317242205, 0.2746406198, 0.1762529612, 0.152957052, 0.107828021, 0.5601892471, 0.704836309, 0.0690748543, 0.6475112438, 0.8392729759, 0.4782755971, 0.2455220222, 0.2011910379, 0.3270663917, 0.426615864, 0.1257507801, 0.0745866075, 0.494720906, 0.6699306965, 0.9005715847, 0.965647161, 0.9319583774, 0.2998386919, 0.4346162081, 0.3470741808, 0.379745841, 0.5868629217, 0.7525513768, 0.8942037225, 0.5881661773, 0.6908829212, 0.7696894407, 0.2496570498, 0.9029788375, 0.1449566782, 0.940549314, 0.4535817206, 0.876893878, 0.4309327304, 0.4748589396, 0.5439139009, 0.4109740853, 0.7917355895, 0.7563589215, 0.3225246966, 0.7839621902, 0.1879760027, 0.9260431528, 0.1582225859, 0.6899860501, 0.3005719185, 0.7586849332, 0.5602801442, 0.1096993685, 0.2853884399, 0.7707833052, 0.0994566008, 0.6209869981, 0.1324964464, 0.4502699375, 0.9661148787, 0.5732976794, 0.0974852666, 0.1685871929, 0.8425189853, 0.8500508666, 0.7247543335, 0.7300504446, 0.6574591398, 0.4762884378, 0.774965167, 0.7547982931, 0.1737373769, 0.4105111063, 0.66130054, 0.807613194, 0.9561764002, 0.0931298584, 0.9024232626, 0.9078714848, 0.6997975707, 0.3599743247, 0.1181411669, 0.6603565216, 0.3643483222, 0.3171017468, 0.1548973918, 0.4753058255, 0.9083060026, 0.5500577688, 0.1667237729, 0.0826494992, 0.610611558, 0.3874568343, 0.774923861, 0.3882563412, 0.8583701253, 0.3821409941, 0.6783229113, 0.1268156916, 0.4928922355, 0.6696636081, 0.2424270362, 0.2684422731, 0.0114330519, 0.3125860095, 0.4406300783, 0.8437696099, 0.9155861735, 0.2646900117, 0.8090519905, 0.6283949018, 0.0367765725, 0.1772430986, 0.3054746389, 0.4599150717, 0.8190104365, 0.7394275069, 0.7182311416, 0.4610926211, 0.6376371384, 0.4085309207, 0.8459060192, 0.7325575948, 0.760098815, 0.8547167778, 0.0650310591, 0.4013541341, 0.929390192, 0.1427175701, 0.9910490513, 0.4855956435, 0.1426406205, 0.5818157792, 0.0753199831, 0.498369962, 0.5131756663, 0.6832227111, 0.1547905803, 0.4889817238, 0.7748047709, 0.2072787732, 0.1941394508, 0.6637356877, 0.1102272943, 0.6016145945, 0.1908121705, 0.7514318228, 0.9765977263, 0.7000197172, 0.080152519, 0.6067320108, 0.6231771708, 0.6623160839, 0.2423846424, 0.8593481183, 0.1949041188, 0.51039505, 0.4818463624, 0.4942823052, 0.8545402884, 0.2300429791, 0.4972362816, 0.4219648838, 0.9282656908, 0.1979885995, 0.3346379697, 0.9192470908, 0.1100370437, 0.4820858538, 0.3073306084, 0.7130808234, 0.1265769452, 0.15359433, 0.0496447124, 0.3125340939, 0.6444661617, 0.9765006304, 0.2505088151, 0.0226930995, 0.0922836587, 0.3347234726, 0.3649637997, 0.4281927645, 0.3127455711, 0.1122071669, 0.0545345657, 0.6254195571, 0.8825021386, 0.0881243125, 0.870521009, 0.93177706, 0.0682048425, 0.1616327316, 0.2368701845, 0.3042016029, 0.3014261425, 0.6132721305, 0.4239659607, 0.0478611402, 0.3440237641, 0.8644068837, 0.8166940212, 0.9210947156, 0.3142153919, 0.3384123147, 0.1293078214, 0.327807039, 0.1385754943, 0.5252557397, 0.2037834078, 0.1355125308, 0.8481654525, 0.1084564179, 0.8895837069, 0.9297063947, 0.6626101732, 0.9949202538, 0.1371307671, 0.7483708858, 0.1548348367, 0.9817621708, 0.8498107195, 0.4318315685, 0.1167622134, 0.914514482, 0.5134156346, 0.0897483453, 0.8054890037, 0.8641226292, 0.9845616221, 0.6691633463, 0.1699157953, 0.9217935205, 0.2860171795, 0.2862279415, 0.6314294934, 0.9053294659, 0.926130712, 0.7745748758, 0.9740136266, 0.5819452405, 0.9823573828, 0.6724982858, 0.2563684285, 0.9017974138, 0.2216677815, 0.0559061207, 0.1497624665, 0.0987473577, 0.7248274088, 0.0998611301, 0.2070419639, 0.8288671374, 0.7161344886, 0.9194735289, 0.9933570027, 0.9189748168, 0.8072370291, 0.1076514125, 0.1849746555, 0.7228713036, 0.1596566886, 0.5150070786, 0.1441474855, 0.066157043, 0.049965743, 0.9619827271, 0.3996433318, 0.653080225, 0.0733937249, 0.1254796386, 0.7117719054, 0.917435348, 0.1034498066, 0.4031996131, 0.444887042, 0.0056870449, 0.7002051473, 0.2498449981, 0.5136056542, 0.8998672962, 0.3057129085, 0.4178559184, 0.9258152246, 0.1282432377, 0.1412497461, 0.9733054042, 0.2212451696, 0.4173105955, 0.6131963134, 0.3894228041, 0.4253168106, 0.1805790663, 0.1834900081, 0.3250872791, 0.2628329098, 0.1012361422, 0.864908874, 0.3292372823, 0.3081247211, 0.7906532288, 0.4821045399, 0.4038228095, 0.3939401209, 0.9954417944, 0.7555449605, 0.392860204, 0.9311004281, 0.1790024638, 0.2462277859, 0.2807508409, 0.7482221127, 0.6572058797, 0.1095788851, 0.510463357, 0.1752972603, 0.719843626, 0.9060332179, 0.8441591263, 0.6085563302, 0.4834625125, 0.5609233975, 0.2171468735, 0.1443241388, 0.1755244881, 0.4814448357, 0.4771549404, 0.9263590574, 0.5750821829, 0.3008694649, 0.3622517586, 0.755866766, 0.39648965, 0.3350126743, 0.5759840012, 0.3580656052, 0.5591519475, 0.411999613, 0.0696884617, 0.3114795089, 0.3437252045, 0.8193073273, 0.1479767114, 0.4128408432, 0.1243752688, 0.5946728587, 0.040931005, 0.4223316312, 0.0090654586, 0.1084287986, 0.9984366298, 0.0191844888, 0.6414379478, 0.9009640217, 0.7663844228, 0.5437956452, 0.7800726891, 0.4090618789, 0.4398626983, 0.4832190275, 0.9708737135, 0.4200861752, 0.8891196847, 0.8342605829, 0.7395022511, 0.8493605852, 0.9961255193, 0.6666922569, 0.1235389113, 0.2227306813, 0.4470238686, 0.609081924, 0.4258388579, 0.38459903, 0.9138085842, 0.9417594075, 0.5006828904, 0.1883970946, 0.2002666444, 0.8500894904, 0.6384903789, 0.6395144463, 0.9077315927, 0.6697617173, 0.8512086272, 0.0087213283, 0.9828585386, 0.8887939453, 0.47850582, 0.6037483811, 0.6680338979, 0.082309477, 0.9250529408, 0.7282754183, 0.2138310671, 0.9064673781, 0.1180551276, 0.4089209139, 0.9295975566, 0.3489661515, 0.4683424234, 0.3454791009, 0.640593946, 0.9373342991, 0.1361351758, 0.1580174714, 0.7095093727, 0.6009737849, 0.4219673872, 0.4093854129, 0.036500439, 0.8813204765, 0.8885269165, 0.1298466623, 0.073265478, 0.364998877, 0.0468754247, 0.6433752775, 0.145909816, 0.0063077481, 0.4853258431, 0.1841042191, 0.8832054734, 0.4282297492, 0.1934542954, 0.3117605448, 0.8383365273, 0.6514744163, 0.9749878645, 0.0530770086, 0.5436596274, 0.6135886312, 0.9009683728, 0.3213257194, 0.1563519239, 0.9562898278, 0.5308704972, 0.1094931588, 0.8474324942, 0.5754844546, 0.6424849033, 0.5405859351, 0.8939579725, 0.8778976202, 0.6169037223, 0.030479528, 0.3198828697, 0.6932471991, 0.7065448165, 0.5434570909, 0.6822314858, 0.9275956154, 0.9713617563, 0.4064881206, 0.4100089371, 0.1566009223, 0.7706454396, 0.2333302498, 0.5164099336, 0.5639109612, 0.9107143879, 0.5185158253, 0.6819518209, 0.7086067796, 0.4933575988, 0.9691743255, 0.0112421671, 0.8904764652, 0.2794344425, 0.4883012772, 0.9812871814, 0.519503057, 0.4033726454, 0.3408876359, 0.1691515744, 0.5729548335, 0.1170704216, 0.8523078561, 0.6926349401, 0.152277723, 0.2914416492, 0.8682878613, 0.190088734, 0.5545155406, 0.299916923, 0.7042110562, 0.6688691378, 0.4181954861, 0.5907233953, 0.5364931822, 0.3178125024, 0.4444721937, 0.8797751665, 0.9706348181, 0.2150214314, 0.125421986, 0.7503415346, 0.853925705, 0.6752343774, 0.0771152377, 0.7424693704, 0.5134959817, 0.3131100833, 0.0930811092, 0.4196280837, 0.3641713262, 0.684728384, 0.8790692091, 0.3057268262, 0.129959181, 0.6240565181, 0.7508354783, 0.6656332016, 0.4449041486, 0.3647877574, 0.9470384717, 0.8373682499, 0.8402828574, 0.0330159701, 0.3996124566, 0.5197124481, 0.756849885, 0.1689542085, 0.5623566508, 0.0999487787, 0.231736362, 0.3860290051, 0.6407940984, 0.3881893754, 0.7424958944, 0.6955646873, 0.9519188404, 0.318382591, 0.5039559603, 0.9640315175, 0.5231477022, 0.411370188, 0.620013237, 0.9583541751, 0.7986480594, 0.5066821575, 0.4510830939, 0.4847787321, 0.5880331993, 0.5773647428, 0.1079605669, 0.5582280159, 0.1478275061, 0.6387441158, 0.1026407704, 0.8686447144, 0.1952173114, 0.401524961, 0.1868240237, 0.8393335342, 0.475237757, 0.9821380377, 0.6739950776, 0.219691813, 0.0606318936, 0.5516039133, 0.9350891113, 0.1880293638, 0.5697935224, 0.6502375007, 0.457108736, 0.6692596078, 0.9151550531, 0.4090929627, 0.309753567, 0.2993274927, 0.6691052318, 0.6662060618, 0.5693559647, 0.1284941137, 0.1559078097, 0.8756325841, 0.7216137052, 0.4017215967, 0.7726922631, 0.8325593472, 0.2783419192, 0.5969438553, 0.4422997236, 0.5024647117, 0.1190249324, 0.8693013191, 0.4092141688, 0.3497573137, 0.2997525036, 0.8078672886, 0.6940232515, 0.4159009755, 0.5166391134, 0.6364046335, 0.4608441889, 0.5915109515, 0.0833236277, 0.5827288032, 0.524207294, 0.5170875788, 0.8344153166, 0.4785903692, 0.9900897145, 0.486466378, 0.6633359194, 0.3870778978, 0.5059018135, 0.0476362333, 0.8434661627, 0.2138791233, 0.2459290624, 0.6862183809, 0.1308473796, 0.3426493704, 0.7578674555, 0.6342275143, 0.6435787082, 0.1195597425, 0.5193337202, 0.3810512424, 0.4044907689, 0.4123164713, 0.8873084188, 0.3656779528, 0.5191016793, 0.7962290645, 0.090267539, 0.2011779994, 0.8783323169, 0.5048565865, 0.0004847192, 0.1470967978, 0.9501753449, 0.1743204892, 0.1420024931, 0.4472053051, 0.6552674174, 0.000488665, 0.5994753838, 0.382699281, 0.5664912462, 0.6513465047, 0.3832733929, 0.476341933, 0.7680711746, 0.8505775332, 0.9013278484, 0.0955141038, 0.5956310034, 0.7478993535, 0.8505282402, 0.6758541465, 0.4612446129, 0.5324606299, 0.7694770694, 0.9109046459, 0.6616698503, 0.0614098608, 0.7205293775, 0.1296790987, 0.1050485075, 0.4393767416, 0.0802602097, 0.2120990753, 0.2436205149, 0.1266466826, 0.4755751789, 0.7592602372, 0.5264926553, 0.8939450383, 0.8498769999, 0.3504982293, 0.7799086571, 0.9001188278, 0.2059695423, 0.9848666191, 0.6470401287, 0.7182145119, 0.6424472332, 0.0587065592, 0.0607641377, 0.9254674315, 0.8149735928, 0.9880042076, 0.9194400907, 0.6821730733, 0.936714828, 0.9106260538, 0.3409099281, 0.9331636429, 0.4657026827, 0.3609704077, 0.8818121552, 0.4431084394, 0.8020241857, 0.3559144735, 0.6619566083, 0.9978672266, 0.967349112, 0.8489344716, 0.180418238, 0.1672132164, 0.5263836384, 0.3994589746, 0.0287381634, 0.1107078493, 0.6943463087, 0.2395181954, 0.362642467, 0.928147912, 0.2158501446, 0.8348618746, 0.6657570004, 0.4487101734, 0.4169028699, 0.6810869575, 0.168085739, 0.33869344, 0.7856830955, 0.3930340111, 0.5037709475, 0.4256667793, 0.6027138233, 0.0930257961, 0.3480600119, 0.999445498, 0.6560352445, 0.799813211, 0.1585894078, 0.2549083531, 0.0676986575, 0.8440742493, 0.487491101, 0.3456216156, 0.7144336104, 0.5369933844, 0.7299476266, 0.7242155671, 0.3749023378, 0.8245159984, 0.3005877435, 0.1504479945, 0.8338340521, 0.8718520403, 0.5468881726, 0.967474103, 0.9544656873, 0.9600237012, 0.2268186808, 0.8583984375, 0.9616797566, 0.1850372404, 0.3228692412, 0.9504075646, 0.5561596155, 0.4097749293, 0.7365884185, 0.3003263474, 0.6284620762, 0.0035583398, 0.8621560931, 0.65440166, 0.3989845216, 0.4595173299, 0.1566463709, 0.0086835399, 0.4000524879, 0.8635722995, 0.939352572, 0.2184841931, 0.4614948928, 0.2673926055, 0.1875871122, 0.7921754122, 0.2353162766, 0.5879690051, 0.2635296285, 0.8797479272, 0.2997823358, 0.9490447044, 0.2076890171, 0.4010803103, 0.139462769, 0.6628655791, 0.2707166076, 0.7822429538, 0.6469106078, 0.0504862033, 0.1232508495, 0.6208113432, 0.5297733545, 0.4315978289, 0.7746199965, 0.9176148176, 0.5735706687, 0.8824555874, 0.8449642062, 0.7323825955, 0.6090137362, 0.6787286401, 0.1138057783, 0.6691028476, 0.8794246316, 0.9944544435, 0.9590182304, 0.7599397302, 0.4360883832, 0.4345399737, 0.3566042483, 0.5040525198, 0.2876239717, 0.8192380667, 0.8512843251, 0.6990298629, 0.2681503594, 0.27765733, 0.6658552885, 0.2643640041, 0.0171834268, 0.9907699823, 0.3918241262, 0.3559646606, 0.0335422903, 0.4839356244, 0.0600461066, 0.85569942, 0.9708179832, 0.2128672898, 0.506002903, 0.8269757032, 0.5930796862, 0.4295219481, 0.6134305, 0.2837088406, 0.1868558377, 0.2195377052, 0.9196808934, 0.614552319, 0.0224817824, 0.1637152284, 0.1638418883, 0.8936216235, 0.1830255538, 0.3708207607, 0.6877121329, 0.4648887813, 0.1414472908, 0.4056530297, 0.9507917166, 0.6584733129, 0.3516145647, 0.8184752464, 0.4552969933, 0.8712670207, 0.4879920185, 0.0632367358, 0.9106399417, 0.6763438582, 0.2545655966, 0.3354371488, 0.613499999, 0.719379127, 0.259948045, 0.6374192834, 0.5459974408, 0.3083664477, 0.2264615297, 0.6127052307, 0.5290982723, 0.1375788748, 0.783110261, 0.6753757596, 0.3794361949, 0.9984954596, 0.8989933133, 0.6260385513, 0.1556160003, 0.6783794761, 0.6539263129, 0.0100090979, 0.2173147351, 0.6651876569, 0.8369060159, 0.8341432214, 0.7952558994, 0.4205495715, 0.1869979799, 0.521456182, 0.786886692, 0.426864773, 0.9521651268, 0.6465340257, 0.3335846066, 0.0395368077, 0.4426506758, 0.6929479241, 0.9862581491, 0.7791219354, 0.6375953555, 0.747053206, 0.3558909297, 0.4302069545, 0.6914501786, 0.5334445238, 0.7177165747, 0.4723176956, 0.3912888765, 0.8674814701, 0.0588688217, 0.1745981872, 0.9388600588, 0.9075108767, 0.1771204025, 0.8766767383, 0.7872450352, 0.9876473546, 0.9102281332, 0.0356241427, 0.0852076039, 0.1130689159, 0.2634152472, 0.8666511774, 0.5163245201, 0.9000962377, 0.3857123554, 0.0012086437, 0.7136164904, 0.7027332187, 0.4787892103, 0.2255398631, 0.9207963347, 0.3938958645, 0.5700179338, 0.1459939331, 0.3002436459, 0.381508708, 0.1841450483, 0.9755260944, 0.2721963823, 0.7860645056, 0.7627891302, 0.1462470591, 0.579647541, 0.9866490364, 0.2338331044, 0.6083744168, 0.7401463389, 0.641833961, 0.143690452, 0.6205012798, 0.6930510998, 0.3980046809, 0.7106813192, 0.6699492931, 0.776545763, 0.328389287, 0.9113801718, 0.4589560628, 0.4300134182, 0.3934683502, 0.1645728201, 0.8604982495, 0.8263462782, 0.3688060939, 0.3331750631, 0.7786345482, 0.8378946781, 0.5906920433, 0.6261325479, 0.5661553741, 0.0168611892, 0.1579812914, 0.5492501259, 0.1289457828, 0.7631620169, 0.4299164712, 0.7248778343, 0.8724287748, 0.7588217854, 0.4151751101, 0.2290642858, 0.830294013, 0.2409950495, 0.8310200572, 0.3934896886, 0.1056550518, 0.7282423377, 0.8008365035, 0.3993280828, 0.641693294, 0.8496999741, 0.1698106676, 0.2010347843, 0.3334994018, 0.9605640173, 0.6602769494, 0.1665142179, 0.9381275773, 0.3133260608, 0.6109694839, 0.7216079831, 0.2165700942, 0.3999683261, 0.7567145228, 0.2962780595, 0.0435902178, 0.4306307137, 0.3411400318, 0.8858901262, 0.8652980328, 0.1155079082, 0.8249346614, 0.0917863026, 0.7120097876, 0.5722182393, 0.2111754119, 0.1511156708, 0.7542660832, 0.8388788104, 0.2662346661, 0.4258652329, 0.6677465439, 0.0139555167, 0.0004739496, 0.7597358823, 0.7892562151, 0.6452015042, 0.4347984195, 0.6189417839, 0.2430407703, 0.9443444014, 0.1519926041, 0.7088004351, 0.5980795026, 0.6512131691, 0.3345483243, 0.9272377491, 0.4298903942, 0.2581492662, 0.7997309566, 0.8973907828, 0.5888721943, 0.3186417818, 0.0904048309, 0.391372025, 0.7918083072, 0.8923842311, 0.8701627254, 0.7434403896, 0.0905955732, 0.4714503586, 0.4493075013, 0.0799918622, 0.1845664531, 0.6881728172, 0.3358751535, 0.4706131816, 0.7471582294, 0.9739037156, 0.1017585918, 0.4079837799, 0.9391186237, 0.9765675068, 0.0263471883, 0.6413670182, 0.2973709404, 0.5145442486, 0.8976982236, 0.524328053, 0.1422182322, 0.7193863988, 0.7368603349, 0.9693444967, 0.6586734653, 0.6579256654, 0.6502546072, 0.1010703519, 0.5885951519, 0.5621953011, 0.1680923849, 0.5930988193, 0.6734765172, 0.1098441258, 0.8375173211, 0.646768868, 0.4310235977, 0.4349831641, 0.539032042, 0.3829804361, 0.6328964829, 0.2367146462, 0.5631510615, 0.9513992071, 0.8278053999, 0.6178335547, 0.2708016634, 0.9486758113, 0.26146999, 0.5559518933, 0.8066895008, 0.6080886722, 0.6698721051, 0.4653573334, 0.7357473969, 0.2607144713, 0.8500569463, 0.9294748902, 0.1860525012, 0.2754299045, 0.3034132123, 0.6319553256, 0.9066848755, 0.7306192517, 0.824960053, 0.5916018486, 0.2015920728, 0.8553565145, 0.7298870087, 0.2292208374, 0.4898203015, 0.0343113467, 0.3411170542, 0.2187033147, 0.1873072982, 0.0390702896, 0.1601516157, 0.3303611577, 0.4489412904, 0.4218544662, 0.2624753118, 0.6617366672, 0.9006288052, 0.2701307535, 0.2544170916, 0.9371020198, 0.8970537782, 0.7438231707, 0.7882292271, 0.9120438099, 0.3836613595, 0.6246667504, 0.7484745383, 0.3733002543, 0.8213787079, 0.6606358886, 0.1194297746, 0.1390251815, 0.0641699359, 0.5383107662, 0.6989690065, 0.6185290217, 0.6464617252, 0.6420792937, 0.3911742866, 0.7028435469, 0.3800960779, 0.8826861978, 0.0952752978, 0.9624297619, 0.8092130423, 0.1167537272, 0.3588655591, 0.787512362, 0.190058127, 0.3969855309, 0.6713926792, 0.375826776, 0.9156392813, 0.2398073077, 0.643366456, 0.1709136367, 0.1411291361, 0.5585072637, 0.8004847169, 0.7030475736, 0.094840616, 0.4112376273, 0.1812635958, 0.5112304091, 0.9566822052, 0.0574831404, 0.4228295088, 0.6620184779, 0.8219641447, 0.4642787278, 0.8152669668, 0.0818825886, 0.0987984538, 0.2002992034, 0.6733680367, 0.5868890285, 0.9167151451, 0.1864406765, 0.8994914889, 0.807133615, 0.3371865749, 0.4333070219, 0.085025467, 0.6565349698, 0.3711113334, 0.318253845, 0.891107738, 0.1244663969, 0.1738931388, 0.5745149851, 0.63624686, 0.4004335403, 0.2862538397, 0.8227635026, 0.3641233444, 0.3736288249, 0.7244967818, 0.9711794257, 0.2511951029, 0.9590284228, 0.3837921917, 0.2047621608, 0.4209816754, 0.4912522435, 0.3666148186, 0.4686942399, 0.8263337612, 0.8343328238, 0.1030248851, 0.063413851, 0.7966393232, 0.9208257794, 0.8128236532, 0.6137861013, 0.7312135696, 0.6441291571, 0.8222352266, 0.9601475, 0.193141073, 0.8020985126, 0.842040062, 0.1575811058, 0.240723148, 0.5854346752, 0.6898014545, 0.9830086827, 0.5120115876, 0.1920706928, 0.0139490385, 0.0747568533, 0.3444298506, 0.4224318862, 0.249416545, 0.2130750567, 0.8533776402, 0.4178678393, 0.4339362383, 0.0111655975, 0.8133564591, 0.6119635701, 0.0685145333, 0.6695259809, 0.2546260953, 0.8285387158, 0.312804997, 0.7133177519, 0.333489418, 0.5241565704, 0.0107328463, 0.3183773458, 0.3350363076, 0.2044413835, 0.2082778066, 0.6074838042, 0.2767891586, 0.8898346424, 0.6261834502, 0.6542112231, 0.8752353787, 0.8254892826, 0.7045267224, 0.161468029, 0.4182889163, 0.022108715, 0.1131518707, 0.5885184407, 0.7256597281, 0.0343230143, 0.8792519569, 0.8066859841, 0.1908041388, 0.9513005018, 0.7850510478, 0.4657150507, 0.5251334906, 0.3207691312, 0.5975010395, 0.6800830364, 0.2313966155, 0.133847326, 0.215200156, 0.1785591096, 0.0999648795, 0.9366772771, 0.5005745292, 0.8090450764, 0.1758912057, 0.7367401719, 0.3668246865, 0.4100497663, 0.2929191887, 0.8173804283, 0.9562621117, 0.9764734507, 0.4828430712, 0.7929611802, 0.8903346062, 0.3020727634, 0.442117691, 0.568352282, 0.7277359962, 0.4031055272, 0.824354887, 0.8226563334, 0.6432737708, 0.6184990406, 0.1030192897, 0.6947470903, 0.3996037543, 0.5164917707, 0.2604589164, 0.3293188214, 0.6517642736, 0.2140082717, 0.5220531225, 0.9566025734, 0.3867221773, 0.4390546679, 0.5610719919, 0.0391775891, 0.6922944784, 0.4326307774, 0.2539777458, 0.700518012, 0.2863841653, 0.7115677595, 0.2580014765, 0.563192904, 0.7391983867, 0.0284078829, 0.0109637557, 0.4719158411, 0.9242167473, 0.0944740772, 0.6865310669, 0.8619411588, 0.1601572484, 0.7063269019, 0.9508878589, 0.1181359291, 0.908513546, 0.9176949859, 0.3647930622, 0.5507701039, 0.8933278322, 0.0304874647, 0.636772573, 0.34973827, 0.9845890999, 0.2813156545, 0.5406025648, 0.6808233261, 0.6041739583, 0.3164665699, 0.5587679744, 0.2653927803, 0.9062872529, 0.6394948363, 0.5580250025, 0.5873030424, 0.4647721946, 0.1778300405, 0.456466943, 0.2894083858, 0.0513518043, 0.368275553, 0.9402056336, 0.8427602649, 0.0494848564, 0.9241726398, 0.8340312839, 0.9196015596, 0.304197818, 0.2783410251, 0.5432807207, 0.0412899218, 0.9308462739, 0.0627118871, 0.7068531513, 0.7357839346, 0.4832003117, 0.1682239175, 0.5368898511, 0.2093475908, 0.5198550224, 0.15533337, 0.4974581599, 0.9676081538, 0.8497615457, 0.9911837578, 0.5660502315, 0.7206923366, 0.7096755505, 0.1248403564, 0.8108434081, 0.449005574, 0.4308193028, 0.6498060822, 0.4099439085, 0.0305016227, 0.416002363, 0.7270969152, 0.6877042055, 0.2469553053, 0.8816401958, 0.3038872778, 0.9122524261, 0.1799594462, 0.6789157391, 0.7397534847, 0.8676870465, 0.1907271743, 0.2236480266, 0.9832514524, 0.5055263042, 0.9711384773, 0.5652813911, 0.6370265484, 0.182553038, 0.8266869783, 0.4781101942, 0.9109632373, 0.468072921, 0.3929909766, 0.6008589268, 0.8158760071, 0.9320793748, 0.7751792669, 0.3289398551, 0.9922301769, 0.0912288204, 0.1703053415, 0.4577171803, 0.1787350327, 0.938062191, 0.4138315022, 0.5861997604, 0.2016209513, 0.9696668386, 0.6058498621, 0.3870098889, 0.7085344195, 0.3498209119, 0.8449696898, 0.1842520237, 0.2444705516, 0.1938156784, 0.1163077801, 0.749943614, 0.230992794, 0.6426023245, 0.5831053257, 0.8690395951, 0.630815804, 0.924063623, 0.2654021084, 0.642537415, 0.7697630525, 0.5416702032, 0.6263902783, 0.508294642, 0.238931343, 0.2679293454, 0.6879761219, 0.6314243674, 0.0733269751, 0.8547760844, 0.4395237565, 0.1854390651, 0.7209459543, 0.1856156737, 0.3298576474, 0.1205248684, 0.7189801931, 0.8141445518, 0.8007050753, 0.8076544404, 0.5967723131, 0.8467640877, 0.9726544023, 0.7290840149, 0.6843637824, 0.9106625915, 0.8134277463, 0.8635859489, 0.3311145902, 0.6779747605, 0.5588562489, 0.1384872645, 0.2485618293, 0.297216475, 0.9278965592, 0.8001593947, 0.9885622263, 0.0369857028, 0.1422076225, 0.5633337498, 0.1424964666, 0.7102304101, 0.8189394474, 0.9962999225, 0.2269549221, 0.3746351898, 0.5649494529, 0.3327106535, 0.5111281276, 0.7147293687, 0.5896724463, 0.1772960871, 0.0696003288, 0.286867857, 0.4734672606, 0.3201722503, 0.8205572367, 0.6493142247, 0.5078513622, 0.1021946296, 0.5274136066, 0.4142716825, 0.0141518442, 0.4787433147, 0.6653147936, 0.8284615874, 0.3456978202, 0.2655246556, 0.5080031753, 0.9325185418, 0.4208618104, 0.0506246462, 0.3445186615, 0.8642750382, 0.1808891147, 0.4670973718, 0.2968982756, 0.0686587915, 0.968565464, 0.0809030086, 0.8395389318, 0.3273274601, 0.0880047157, 0.1903434992, 0.4982347488, 0.1346488297, 0.4266943634, 0.6035117507, 0.0966935828, 0.130099237, 0.9324336648, 0.029708188, 0.1309058964, 0.3857354224, 0.4325630069, 0.0283364169, 0.5884478688, 0.0347402692, 0.2881790996, 0.1613280624, 0.1500120312, 0.5497354865, 0.0285012387, 0.0389477536, 0.3889817297, 0.8007153273, 0.5705042481, 0.265934974, 0.0010570318, 0.1609654278, 0.1462721825, 0.2926569581, 0.2858861685, 0.5125892162, 0.3573589921, 0.815656662, 0.7254964113, 0.7005371451, 0.8094868064, 0.6454237103, 0.9892581105, 0.2908501625, 0.1424738616, 0.7378989458, 0.0941486955, 0.4891970158, 0.9065564871, 0.4339940846, 0.0668817908, 0.9380901456, 0.9236553311, 0.6359699965, 0.5167078972, 0.558201313, 0.4722582698, 0.1355872601, 0.8772071004, 0.8593617082, 0.6964372993, 0.4334558249, 0.7329850793, 0.5092103481, 0.1499313265, 0.6627041101, 0.1942798495, 0.855651021, 0.1749084294, 0.2495054752, 0.7571764588, 0.4111095667, 0.8502652645, 0.8892777562, 0.5684210658, 0.69939816, 0.3964086771, 0.3613114655, 0.519841969, 0.7356907129, 0.9176354408, 0.095657669, 0.7030841112, 0.2986163199, 0.4681179225, 0.0725374371, 0.6352795959, 0.6171233058, 0.6124462485, 0.2037614733, 0.2117670327, 0.8531679511, 0.8580448627, 0.5006189346, 0.4058943093, 0.4722923934, 0.6105757952, 0.874437809, 0.9505182505, 0.1943543851, 0.181650728, 0.1669910997, 0.0268503428, 0.952767849, 0.2039880008, 0.8487119079, 0.1559415609, 0.1029749215, 0.4526468217, 0.2616906762, 0.6895283461, 0.982663095, 0.3306657672, 0.9354221225, 0.5582979321, 0.5344530344, 0.6940716505, 0.4938591719, 0.0580471046, 0.6556633115, 0.7009186745, 0.0863900259, 0.4495719671, 0.8028429747, 0.4457241297, 0.9321414828, 0.4026821554, 0.8325545192, 0.7769343853, 0.3827864826, 0.8611300588, 0.1701369584, 0.0021155092, 0.2999592125, 0.8664929271, 0.8345423341, 0.1517637521, 0.7718462944, 0.3676919937, 0.0870517269, 0.0474235229, 0.4385928214, 0.9065920115, 0.4381890893, 0.6570346355, 0.530020833, 0.3139534593, 0.0058077499, 0.9511523247, 0.270085305, 0.5979244709, 0.9125925303, 0.9729918838, 0.6157622337, 0.9815089107, 0.1436649263, 0.3338150978, 0.4791634679, 0.3831810951, 0.4124719203, 0.7307018638, 0.8332329988, 0.7855702043, 0.0048999563, 0.4295491874, 0.6549654007, 0.2341672331, 0.8596075177, 0.0836934224, 0.934171617, 0.8679772615, 0.4342018962, 0.4922784269, 0.9355442524, 0.284232229, 0.2937251925, 0.1297459006, 0.2162142843, 0.4766207635, 0.0687699541, 0.4193355739, 0.1604968458, 0.2525405586, 0.3903907835, 0.3836767077, 0.0303397048, 0.9095519185, 0.8019656539, 0.0196414758, 0.4093062878, 0.2114653438, 0.9183588028, 0.9276442528, 0.502981782, 0.4427781999, 0.0913025662, 0.1694462895, 0.6199722886, 0.0954813659, 0.7222938538, 0.4514240324, 0.6676730514, 0.8516663909, 0.656840384, 0.8855976462, 0.5578103065, 0.4024848044, 0.6999971867, 0.6150228381, 0.0558919497, 0.0335506909, 0.688362658, 0.4106868505, 0.3968059719, 0.8370631933, 0.7725564837, 0.1515578181, 0.1355218887, 0.0965696499, 0.2061236054, 0.6590722203, 0.6921544075, 0.2580949962, 0.1657614261, 0.4687497914, 0.406940341, 0.4022993147, 0.7116939425, 0.5114153028, 0.1530843526, 0.9127361774, 0.4781102538, 0.9606519938, 0.4396675825, 0.3828580379, 0.98080194, 0.155510366, 0.3834106922, 0.7655656934, 0.6892883182, 0.2358525991, 0.8080509305, 0.2543847859, 0.4141985178, 0.523763001, 0.3927200437, 0.8692634106, 0.7796307802, 0.597253263, 0.3918390572, 0.7336037159, 0.6449653506, 0.5304521918, 0.3729677498, 0.5095614195, 0.0340902284, 0.4854550958, 0.3145000041, 0.6774025559, 0.6864208579, 0.3714465499, 0.6128278375, 0.0291901436, 0.5145798922, 0.5950428843, 0.8980699778, 0.667994082, 0.1750890762, 0.7357109189, 0.9596466422, 0.78450948, 0.9358209372, 0.1966813803, 0.7135280967, 0.517800808, 0.0173361078, 0.6123137474, 0.6547294855, 0.4717650414, 0.3369775116, 0.7588766813, 0.2113792002, 0.4504565001, 0.9997866154, 0.9297376275, 0.9543070197, 0.0810764581, 0.718213439, 0.9580960274, 0.3335441649, 0.6319159865, 0.1744812578, 0.7624543309, 0.1609711796, 0.0907729939, 0.915543139, 0.1144289672, 0.7248440385, 0.6789140701, 0.6996889114, 0.4020989537, 0.2669022977, 0.5844626427, 0.134822458, 0.8918195367, 0.365626961, 0.4345599413, 0.1545763612, 0.0310143251, 0.8769407272, 0.6558710337, 0.6811839342, 0.475115031, 0.8751748204, 0.2593674958, 0.5370489955, 0.0872693956, 0.8934871554, 0.4328126311, 0.4056480229, 0.8251649141, 0.8240369558, 0.7671280503, 0.4962546229, 0.8575278521, 0.3483728468, 0.1870178878, 0.8497405052, 0.3999809623, 0.8633293509, 0.8636456132, 0.8893032074, 0.1341328174, 0.2871872187, 0.7100675106, 0.8871203661, 0.9068968892, 0.0692605898, 0.6812825799, 0.9397863746, 0.1812347472, 0.7493067384, 0.4513051212, 0.2774569094, 0.6819339991, 0.801881969, 0.1597965062, 0.1734782755, 0.0756019801, 0.3288019896, 0.8074708581, 0.3977744281, 0.4172227979, 0.3795339465, 0.5714755654, 0.3786454797, 0.1577659249, 0.8111919761, 0.0794956163, 0.8613734841, 0.5612139106, 0.2668287456, 0.2859205902, 0.637853384, 0.7570714355, 0.2645949125, 0.3640748262, 0.7036595345, 0.389921695, 0.8352665305, 0.3902190626, 0.9257256389, 0.8727458119, 0.2317052633, 0.5590778589, 0.6693051457, 0.8371434808, 0.3273995221, 0.2169155031, 0.6425605416, 0.5820997357, 0.3529684544, 0.4491079152, 0.3503600359, 0.4263430536, 0.3188545406, 0.3294929862, 0.6248637438, 0.7757378817, 0.2334027141, 0.0908245742, 0.6870774031, 0.8244200945, 0.5250817537, 0.1963138431, 0.4380604625, 0.1462402195, 0.796556592, 0.1289349049, 0.7202720046, 0.9723337293, 0.7241522074, 0.891189456, 0.1096275747, 0.2065416723, 0.7243855, 0.6788081527, 0.2475246936, 0.135287419, 0.7407495379, 0.9530645609, 0.9872140288, 0.7841304541, 0.43687585, 0.3915253282, 0.5440089703, 0.8794558048, 0.8249010444, 0.6420225501, 0.738112092, 0.0268214736, 0.4001717567, 0.1846323162, 0.1310052723, 0.2781134844, 0.4566048682, 0.4801229239, 0.1882273853, 0.7020823359, 0.2595421672, 0.0385477692, 0.7424936891, 0.8389952779, 0.3613405526, 0.5802870989, 0.7866603136, 0.4464701712, 0.3926239908, 0.9616327286, 0.9162272215, 0.6212651134, 0.4366322756, 0.6135808229, 0.1274108142, 0.5895784497, 0.2841680646, 0.4352363348, 0.7186092734, 0.0466427058, 0.0170223247, 0.6835466027, 0.8407039046, 0.9057896137, 0.2855497897, 0.0934990421, 0.7450328469, 0.7398988008, 0.8828210235, 0.523081243, 0.2071357518, 0.0259825513, 0.681430757, 0.0072371885, 0.3722944856, 0.8310766816, 0.1215560585, 0.7335487604, 0.7004206777, 0.6623370647, 0.2583527267, 0.3123250604, 0.3474857211, 0.7388727069, 0.4073099196, 0.7627908587, 0.1381584555, 0.6446782351, 0.912872076, 0.7933068871, 0.6060509086, 0.4652822614, 0.8101439476, 0.3185670674, 0.7687624693, 0.3617153466, 0.3912070096, 0.183849141, 0.2410293519, 0.4311380386, 0.2887026966, 0.9380396605, 0.384894222, 0.1811760962, 0.5795959234, 0.0440914482, 0.5491430759, 0.6439480782, 0.4507356584, 0.9021841884, 0.208783403, 0.1570031643, 0.3838095963, 0.4434178174, 0.6896343827, 0.6827750206, 0.0229131542, 0.8081738949, 0.3498229682, 0.6070718169, 0.3627763093, 0.7984055877, 0.6431685686, 0.0156709664, 0.1227724552, 0.183342129, 0.3576773405, 0.4977785647, 0.1026713997, 0.4667890668, 0.4451530576, 0.5176401138, 0.3916107416, 0.023324348, 0.0170923267, 0.1561067849, 0.3095591068, 0.86096102, 0.2972145975, 0.838896215, 0.1897151023, 0.3870201409, 0.6429683566, 0.7384036779, 0.6419062018, 0.2360361814, 0.7120126486, 0.8898612261, 0.4831516445, 0.6283032298, 0.4591472447, 0.8968883157, 0.6745625734, 0.5177986026, 0.8107450008, 0.041805353, 0.3063744605, 0.9330237508, 0.6453488469, 0.7959765792, 0.6992160082, 0.9159058332, 0.6077382565, 0.6991832256, 0.9109363556, 0.1860307455, 0.3378934562, 0.1416852921, 0.5650724173, 0.1131229326, 0.0440860912, 0.3396860361, 0.0867897645, 0.1091492698, 0.5744010806, 0.4074540436, 0.0037240139, 0.6170831323, 0.6856091619, 0.2162612975, 0.0805536434, 0.0801788047, 0.6862949729, 0.4118176103, 0.9122155309, 0.3419746161, 0.124123469, 0.4353388846, 0.7382239103, 0.1663474441, 0.8280405402, 0.3344762325, 0.8675277233, 0.322719276, 0.5822569728, 0.045797877, 0.6045931578, 0.5117643476, 0.1247794032, 0.2967178524, 0.2074579448, 0.279479444, 0.6748496294, 0.1948613673, 0.775672555, 0.908628583, 0.4926901758, 0.8503908515, 0.2029168159, 0.2463670224, 0.8378603458, 0.3506077528, 0.3624764085, 0.6620461941, 0.8640121222, 0.1357145458, 0.4835884869, 0.6683739424, 0.4699124098, 0.6225953698, 0.3593974411, 0.5019212961, 0.9705158472, 0.0883378386, 0.2386964858, 0.3500095308, 0.5343665481, 0.108104445, 0.5536872745, 0.7516261935, 0.7465256453, 0.451315552, 0.4694375396, 0.4306558669, 0.8469504118, 0.9364904761, 0.2417010963, 0.7490646243, 0.5876585841, 0.8733353615, 0.31283319, 0.4122265279, 0.6989183426, 0.5105266571, 0.053565491, 0.8299148679, 0.0242418945, 0.9185588956, 0.2082293928, 0.985322535, 0.4913113415, 0.3892986476, 0.2461258769, 0.6064926386, 0.0011067288, 0.1212299541, 0.473182708, 0.1531817317, 0.3342418671, 0.1954117715, 0.488460809, 0.5371435881, 0.0977821499, 0.2985236943, 0.408234328, 0.0633486286, 0.9332410097, 0.7562658191, 0.1462827176, 0.7750024796, 0.0652500018, 0.5739523172, 0.1544017196, 0.8901908994, 0.1490109414, 0.6529577971, 0.8815354109, 0.39714697, 0.2048260272, 0.3529071212, 0.5875724554, 0.592708528, 0.1266954988, 0.5011879206, 0.0910030082, 0.3343248963, 0.0334817953, 0.0805509314, 0.8500270844, 0.7750938535, 0.8772351742, 0.4890280366, 0.1348344982, 0.6879966259, 0.0888044313, 0.0169989243, 0.5271959901, 0.9097088575, 0.4304543734, 0.5892828703, 0.0050274879, 0.273254782, 0.979084909, 0.2645989358, 0.8380880952, 0.1086372435, 0.3569742739, 0.954290092, 0.7056402564, 0.7933056355, 0.7167707682, 0.5924938321, 0.9072985649, 0.0828848258, 0.7621644139, 0.9772328138, 0.9469763637, 0.5058457851, 0.6289201379, 0.9255536795, 0.7286605835, 0.2185642123, 0.7012956738, 0.2237491608, 0.4498312175, 0.7092302442, 0.4210345447, 0.1594479829, 0.1470935941, 0.5360107422, 0.9316938519, 0.7837244868, 0.8694490194, 0.9044463634, 0.0385332815, 0.9328998923, 0.5480153561, 0.8506576419, 0.3514102697, 0.3335549533, 0.8547057509, 0.9253229499, 0.9341187477, 0.9743441939, 0.7508043647, 0.7718179226, 0.1569196582, 0.3478961587, 0.6710835099, 0.5593945384, 0.2419265062, 0.7894306779, 0.1570723206, 0.58223176, 0.5006517172, 0.1849822402, 0.1363085508, 0.4725027978, 0.7396745086, 0.342897743, 0.5591301322, 0.3199107051, 0.8089527488, 0.1712560654, 0.4394634962, 0.4981502891, 0.4856630862, 0.2357862145, 0.2388254106, 0.0351010896, 0.5710847974, 0.4366464615, 0.9259338379, 0.0600329712, 0.3904333413, 0.3421151042, 0.3157694638, 0.6413265467, 0.8104304671, 0.1200235188, 0.0830668062, 0.834066093, 0.5904067159, 0.7680399418, 0.8358713388, 0.2072685659, 0.076436311, 0.578391552, 0.2112138271, 0.3830709755, 0.0601869263, 0.4537220597, 0.9657811522, 0.0833336636, 0.7259430885, 0.4583000541, 0.0169388577, 0.5914511681, 0.5267070532, 0.4983367622, 0.4410881698, 0.2045338005, 0.364636302, 0.8419033885, 0.0842576176, 0.2401530892, 0.3547943234, 0.1362922639, 0.6588394642, 0.2725260854, 0.4588307142, 0.4906029701, 0.5950623751, 0.9093508124, 0.4243634641, 0.3915193081, 0.9465374351, 0.3146939576, 0.4780483544, 0.8329492807, 0.4906239212, 0.8728529215, 0.2367291451, 0.2351625264, 0.2028754056, 0.0626002252, 0.2567110062, 0.9072069526, 0.8151605129, 0.340610832, 0.252204448, 0.8848261237, 0.8597984314, 0.8956258297, 0.0923095495, 0.189149186, 0.7724922299, 0.3699084818, 0.3637740314, 0.7616791725, 0.8415308595, 0.4516580701, 0.3604699373, 0.3181896508, 0.0515080169, 0.0954457223, 0.7111102939, 0.1747000217, 0.7598531246, 0.8066273332, 0.1647458225, 0.3623113036, 0.3150498569, 0.0163353235, 0.054337956, 0.5891324282, 0.3966631889, 0.4356934726, 0.627191186, 0.5625494719, 0.845294416, 0.8934851885, 0.3968222737, 0.2144815773, 0.6305014491, 0.7155290246, 0.8419492245, 0.4611556232, 0.9249689579, 0.750161767, 0.3314435184, 0.056512583, 0.34293136, 0.1730042398, 0.2751477659, 0.4938989282, 0.3394090831, 0.4372532964, 0.8817516565, 0.5378986001, 0.4269252121, 0.1613788009, 0.1004349068, 0.9144166708, 0.0614690818, 0.417506963, 0.8081547022, 0.6270828247, 0.0731840953, 0.3279313743, 0.1751840413, 0.9850287437, 0.8896231055, 0.1453721374, 0.1949591488, 0.2354125381, 0.513664186, 0.6115352511, 0.3465471566, 0.8145347238, 0.5760233402, 0.3436267972, 0.3959923983, 0.4955920577, 0.3700324595, 0.9119005799, 0.0870294422, 0.9118932486, 0.7905231714, 0.6448101997, 0.7781744599, 0.6675111651, 0.9501693845, 0.8006697297, 0.1772782207, 0.351986289, 0.4575143456, 0.2463920265, 0.0222055502, 0.8029623032, 0.4388314188, 0.3895507455, 0.8272166848, 0.071222797, 0.0086836871, 0.05833821, 0.5208097696, 0.4368227422, 0.3917193711, 0.2425224781, 0.0425471961, 0.5299252272, 0.2650638521, 0.8536900878, 0.4376364052, 0.2677355111, 0.0842754617, 0.9467958212, 0.7181984782, 0.8604565859, 0.4427039623, 0.9674515724, 0.2147976309, 0.0458503179, 0.2609435022, 0.6098490357, 0.0492365733, 0.9763779044, 0.7538525462, 0.2662951946, 0.176502198, 0.648522377, 0.911321044, 0.9639800787, 0.1664206088, 0.731251955, 0.8011575341, 0.175025627, 0.1216477081, 0.0419374555, 0.8335712552, 0.1575871557, 0.7052847743, 0.2843056321, 0.3427282274, 0.644711256, 0.8313282132, 0.7289963365, 0.7704250813, 0.9594829679, 0.3326021433, 0.6668556929, 0.3947283626, 0.4203561842, 0.6810554862, 0.2593998611, 0.8157794476, 0.8850485682, 0.4403123558, 0.1217138544, 0.2663836777, 0.1377358437, 0.5714122057, 0.723315239, 0.9704425931, 0.3707490265, 0.8292267323, 0.6394523978, 0.9205230474, 0.0151811857, 0.7781304121, 0.4585623443, 0.1551069915, 0.5581462383, 0.7087328434, 0.3037422001, 0.7703436613, 0.1191074178, 0.5610741973, 0.2212775201, 0.2266217172, 0.3249739408, 0.1444245726, 0.4954843521, 0.4883134663, 0.016531162, 0.7669098377, 0.4550737739, 0.4728942215, 0.3186995387, 0.999892652, 0.8258782029, 0.7184599042, 0.8980119228, 0.450109005, 0.7367163301, 0.2032585442, 0.5111448765, 0.400492996, 0.0225323737, 0.0493962578, 0.944393158, 0.2091137022, 0.5240599513, 0.8398843408, 0.637655735, 0.1873658895, 0.755918324, 0.9759896994, 0.5703735352, 0.0628793016, 0.5546751618, 0.4501508772, 0.2687877715, 0.7107744217, 0.2857188284, 0.7967153192, 0.2016096711, 0.9645403624, 0.8644922972, 0.8842019439, 0.1875291765, 0.3322648108, 0.4761361182, 0.3367213607, 0.7613025904, 0.8173988461, 0.098911345, 0.66873312, 0.908013761, 0.9667162895, 0.6956284642, 0.8096591234, 0.8457599282, 0.6717919111, 0.8705635667, 0.9489148259, 0.6710203886, 0.3002463579, 0.299850136, 0.3160033822, 0.6578463912, 0.6006550193, 0.0363289751, 0.9943091273, 0.1890118122, 0.0703749657, 0.3407917619, 0.5849888325, 0.3387600482, 0.4162254632, 0.9856636524, 0.927693367, 0.8593608141, 0.9642176032, 0.4634823203, 0.5592925549, 0.8305687904, 0.4186003804, 0.8516093493, 0.9270362854, 0.3840446472, 0.0739694536, 0.7066030502, 0.2068160474, 0.5414479375, 0.7055885196, 0.6389597058, 0.8722547889, 0.4726699889, 0.0565524362, 0.6615542173, 0.6320179701, 0.3033626676, 0.3720220625, 0.5759089589, 0.1501083821, 0.4762971103, 0.985751152, 0.7193703055, 0.9492504001, 0.3415102065, 0.3943712413, 0.7835905552, 0.950290978, 0.18917045, 0.2711829245, 0.4374268651, 0.791204989, 0.8699505925, 0.6306788921, 0.8195926547, 0.8105173111, 0.2698025405, 0.0511786118, 0.6671817303, 0.2733749449, 0.4416516423, 0.1568770707, 0.0450827479, 0.2075933069, 0.533229053, 0.6865766644, 0.3394750357, 0.2891942859, 0.8160287738, 0.0811059102, 0.0933496207, 0.3262147307, 0.1257323325, 0.8794260025, 0.2458494306, 0.3873524368, 0.2770903409, 0.813411653, 0.9295834899, 0.642785728, 0.8298889399, 0.5580617785, 0.5519288778, 0.0379861444, 0.9809321761, 0.2174515128, 0.1686883718, 0.9292478561, 0.8038243055, 0.2706521451, 0.1250205636, 0.1165471673, 0.0111545036, 0.0832745507, 0.9543334246, 0.8845676184, 0.2836107612, 0.5429202914, 0.9929301143, 0.4784838259, 0.4672245681, 0.6021637321, 0.0531420857, 0.8136103153, 0.8867183924, 0.1105587557, 0.9744117856, 0.2273890078, 0.7338820696, 0.5361839533, 0.5016311407, 0.5255926847, 0.9699062109, 0.5812864304, 0.0696033984, 0.8309278488, 0.2830432355, 0.561060667, 0.8383012414, 0.5630249977, 0.3481446207, 0.8960926533, 0.5736455321, 0.9144532084, 0.9868558049, 0.8713914156, 0.2994676828, 0.9111017585, 0.3667350113, 0.1784031987, 0.1360322833, 0.1677575111, 0.5294641256, 0.8101564646, 0.4679417312, 0.5953064561, 0.0041121347, 0.8711330891, 0.1849019229, 0.6867338419, 0.1314645261, 0.7478774786, 0.8659111261, 0.1300583631, 0.4138152003, 0.5927445292, 0.5115417838, 0.8252084255, 0.8341360092, 0.9880930781, 0.9846140146, 0.7015816569, 0.0945248976, 0.2514465153, 0.5822964907, 0.0740369856, 0.8085967302, 0.9746395946, 0.7712832689, 0.5332258344, 0.7056349516, 0.008973632, 0.912483573, 0.7920742035, 0.5780259967, 0.8840830326, 0.9795336127, 0.3776562214, 0.0407537147, 0.6358982325, 0.2445732802, 0.530677855, 0.8776224852, 0.877687335, 0.0425837934, 0.9779911041, 0.9589082003, 0.1079860032, 0.4782677293, 0.1582049429, 0.2630234063, 0.8286108375, 0.5946872234, 0.9040866494, 0.39443326, 0.1866375357, 0.1170084104, 0.4502029717, 0.2786411643, 0.2126310468, 0.5640877485, 0.0811040401, 0.1173522845, 0.0272191558, 0.9356313944, 0.946367681, 0.1437636763, 0.021757653, 0.3301321268, 0.5628141165, 0.9827442765, 0.6763537526, 0.5231515765, 0.8283814788, 0.9153424501, 0.8565432429, 0.4869456291, 0.0976596177, 0.0150311012, 0.7154917717, 0.1171679199, 0.6261239648, 0.2845695615, 0.3835113943, 0.5246586204, 0.2396226376, 0.0743172541, 0.9756772518, 0.5552558899, 0.4920856059, 0.8595582247, 0.9239670634, 0.4855814874, 0.0186718721, 0.3817270994, 0.1436758935, 0.77014184, 0.0159273893, 0.4843561649, 0.3735987842, 0.0915456489, 0.710750401, 0.3094100654, 0.2103396654, 0.7813894749, 0.5958394408, 0.2775469422, 0.2737840116, 0.4791265428, 0.923428297, 0.1753854305, 0.9831110835, 0.6923159361, 0.1733113676, 0.1942755878, 0.3934293687, 0.635505259, 0.6115870476, 0.7110312581, 0.2632095516, 0.4379674196, 0.6868646741, 0.3348045647, 0.065459691, 0.163132146, 0.983831346, 0.7933228612, 0.8076031804, 0.8481760025, 0.5067156553, 0.350830853, 0.4742254615, 0.7989317775, 0.0746053755, 0.6456249356, 0.322273463, 0.9467936158, 0.1122535542, 0.3018892109, 0.283125639, 0.3153758049, 0.2754183114, 0.8856149912, 0.8746976256, 0.7178336978, 0.2249367684, 0.9353727698, 0.7245397568, 0.7894397378, 0.6409669518, 0.392496407, 0.5909869671, 0.3518097997, 0.6271018386, 0.8589516878, 0.9280321002, 0.7557398081, 0.2396811247, 0.1658686697, 0.4882411659, 0.3920782506, 0.9502453208, 0.7839587927, 0.4287987947, 0.5076959133, 0.20414792, 0.5182649493, 0.8606436849, 0.4864339232, 0.4363496006, 0.976999104, 0.1470107883, 0.2376187444, 0.1851831824, 0.1019903645, 0.3685579598, 0.9751429558, 0.5995606184, 0.99437356, 0.5076721311, 0.5937624574, 0.8511978388, 0.8245548606, 0.362392664, 0.1518627405, 0.9339181185, 0.6894369125, 0.9985749722, 0.6585057974, 0.0338354632, 0.9860187173, 0.6257272959, 0.509534955, 0.9617368579, 0.9781840444, 0.17511338, 0.7549227476, 0.554728806, 0.0327180512, 0.0599303208, 0.4582598805, 0.1306438744, 0.1135984883, 0.1533396095, 0.5107070208, 0.2424806207, 0.2703402638, 0.0711744428, 0.680213809, 0.4304876029, 0.9608894587, 0.4107354879, 0.3658602536, 0.5136194825, 0.1151609868, 0.390917331, 0.7900308371, 0.3888326585, 0.0395116732, 0.3562890589, 0.7558521032, 0.7811126113, 0.4824492037, 0.3559090793, 0.2841065824, 0.3907046616, 0.8769912124, 0.5726684928, 0.3293185234, 0.5808791518, 0.2414705455, 0.515517056, 0.1191220358, 0.370606631, 0.9229975343, 0.8829728961, 0.9934974313, 0.9956690073, 0.3080435991, 0.3201626837, 0.7061017752, 0.3680316508, 0.1773843914, 0.6431954503, 0.6753837466, 0.463843137, 0.1081115827, 0.8923600316, 0.0838319287, 0.2551401258, 0.3566832542, 0.7253879309, 0.6957392097, 0.4831503332, 0.1040834114, 0.6730811596, 0.6486983895, 0.7294738889, 0.6658418775, 0.2938364744, 0.5878557563, 0.3946224749, 0.4375346303, 0.885355711, 0.0000372552, 0.0856423751, 0.4632995725, 0.2137127072, 0.7650732398, 0.3130430877, 0.1070211083, 0.1473210752, 0.9530454278, 0.5617345572, 0.9885767102, 0.3906081617, 0.424582541, 0.4737696946, 0.3506936133, 0.3437172771, 0.1431273073, 0.7426561117, 0.4721824527, 0.7624740005, 0.4083818197, 0.4430501461, 0.8167119622, 0.4418946505, 0.3301723599, 0.3836306036, 0.9444649816, 0.4999565184, 0.571614325, 0.366941005, 0.6270698309, 0.8446861506, 0.312413156, 0.1835474521, 0.9047849774, 0.2396325767, 0.1429901123, 0.0389769599, 0.050210733, 0.8418549299, 0.8715009689, 0.6386577487, 0.9042218924, 0.884925127, 0.3418840766, 0.9361316562, 0.3192526102, 0.6912338734, 0.518260777, 0.1899265796, 0.017373478, 0.208939001, 0.4606061578, 0.7150601149, 0.5969145894, 0.8508781195, 0.9332725406, 0.9179911613, 0.9683256745, 0.4579477012, 0.4199973643, 0.0844962224, 0.9824535847, 0.5024600625, 0.023764737, 0.6078844666, 0.3199034631, 0.8134011626, 0.5628958344, 0.9588027596, 0.2605622709, 0.8317540884, 0.7054128051, 0.4369589388, 0.4170838892, 0.5606330633, 0.2457968593, 0.7619985938, 0.0341589488, 0.5006690621, 0.4155363739, 0.7130327821, 0.2712416053, 0.664824307, 0.5912088156, 0.3358378112, 0.5966815352, 0.6747763753, 0.8688060641, 0.3815539777, 0.4404865205, 0.9729708433, 0.5631290078, 0.7851571441, 0.4995941818, 0.7379410863, 0.4381160438, 0.1947965622, 0.5504481196, 0.3403409719, 0.6923238039, 0.1318474412, 0.6971157789, 0.5042705536, 0.6147609949, 0.825676322, 0.5663008094, 0.569018364, 0.7246423364, 0.0324248746, 0.4992567897, 0.5960013866, 0.0469658189, 0.1898077428, 0.8522686958, 0.6649093628, 0.9887406826, 0.0252875052, 0.6290403008, 0.0328523293, 0.7139846683, 0.7103829384, 0.7547162175, 0.9542254806, 0.417060107, 0.7140755653, 0.3330325782, 0.5456433296, 0.9399647117, 0.7306978106, 0.583006382, 0.6278259754, 0.7200785279, 0.2016974986, 0.3213150203, 0.8907136917, 0.8135768175, 0.3760290146, 0.9012579322, 0.3641786277, 0.0825980827, 0.9283821583, 0.6921314001, 0.8686619401, 0.1112581566, 0.7397516966, 0.5642287731, 0.4594828188, 0.554276228, 0.2048978359, 0.55537045, 0.603068471, 0.4922237098, 0.8047754169, 0.7408219576, 0.2340663821, 0.6029233336, 0.2060526907, 0.1866772026, 0.2265682518, 0.2986113727, 0.4917030334, 0.2884304523, 0.2630929351, 0.7390643954, 0.7078934908, 0.1757444292, 0.5590769649, 0.0598539114, 0.4706227481, 0.1923512071, 0.9459436536, 0.2502581775, 0.353923291, 0.7448531985, 0.6115530729, 0.3902298212, 0.5567745566, 0.650477767, 0.1128614917, 0.3313013613, 0.6106067896, 0.2649244666, 0.3016350567, 0.3085319996, 0.8217318058, 0.9789041281, 0.1459272057, 0.3668057024, 0.8655315638, 0.15884085, 0.5848766565, 0.988804996, 0.0894221961, 0.3332826793, 0.2789309919, 0.1181809306, 0.9494949579, 0.3430446386, 0.2062487155, 0.0432579592, 0.9632441401, 0.4702299535, 0.1169214919, 0.5384122133, 0.6296311617, 0.6362570524, 0.0417566597, 0.5912191272, 0.9845989943, 0.1991962343, 0.1424074769, 0.0808833241, 0.0490931123, 0.9592280984, 0.4744875133, 0.9286555648, 0.1063276157, 0.7112447023, 0.0670767874, 0.2152061015, 0.3390373588, 0.8407714367, 0.4625172913, 0.5842505693, 0.8396597505, 0.6824946404, 0.2750900686, 0.4497860372, 0.8813002706, 0.5115079284, 0.945268333, 0.3588356376, 0.8357884884, 0.8354519606, 0.1911046505, 0.8405693173, 0.5500881672, 0.1489245892, 0.2501815259, 0.8681357503, 0.4384571016, 0.0615533479, 0.5015689135, 0.6131845713, 0.8447030187, 0.8690897226, 0.987180233, 0.434012562, 0.9867694974, 0.9618659019, 0.3397503197, 0.3236250579, 0.1413733661, 0.65348804, 0.9623055458, 0.879270196, 0.8622050881, 0.5128693581, 0.0369032547, 0.5767930746, 0.9628917575, 0.552251935, 0.9288233519, 0.257267803, 0.5665532351, 0.8364526033, 0.6230912805, 0.5498634577, 0.5407697558, 0.5359740257, 0.1422781348, 0.9193217158, 0.3704392016, 0.3856170177, 0.2676878273, 0.6280194521, 0.1544111967, 0.5832184553, 0.1945493519, 0.3047843277, 0.4401015043, 0.8022740483, 0.0360309221, 0.2359977216, 0.7373479009, 0.4828464389, 0.3620660007, 0.8571884036, 0.5318132639, 0.9350997806, 0.8570907712, 0.0008136479, 0.7000207901, 0.8121096492, 0.3856165111, 0.4496850073, 0.0661716536, 0.6575084925, 0.4410060644, 0.8657597899, 0.3155948818, 0.6615034342, 0.2577296495, 0.742079258, 0.5577799082, 0.4389205575, 0.1031861976, 0.2608876526, 0.7229738832, 0.7676143646, 0.7554867864, 0.2057462782, 0.6458973885, 0.8839143515, 0.6852776408, 0.3689500093, 0.6128994226, 0.2233593166, 0.1574926078, 0.5333741903, 0.6326267719, 0.8821051717, 0.5588636994, 0.5097069144, 0.1709168106, 0.9465764761, 0.4048224092, 0.7366812825, 0.4597676992, 0.9413823485, 0.467428565, 0.5278868079, 0.5498680472, 0.6697951555, 0.6220095754, 0.4390029609, 0.185265094, 0.6468935609, 0.9477636814, 0.8576923609, 0.6362062693, 0.8641003966, 0.1851697266, 0.6700004339, 0.1485266685, 0.3252539337, 0.7413428426, 0.2075637132, 0.2519851923, 0.4584752321, 0.2663576007, 0.4554472268, 0.1294109821, 0.5419273376, 0.418523252, 0.3404965997, 0.4292206168, 0.0063953195, 0.9042156339, 0.5913402438, 0.6057822108, 0.3318530321, 0.1125598103, 0.8107571602, 0.4140805304, 0.1248736978, 0.0863618106, 0.9532760978, 0.4480581284, 0.6362037063, 0.1388506293, 0.8980421424, 0.4660278261, 0.8584802151, 0.5359734893, 0.487493366, 0.8987547159, 0.0682118312, 0.8878780007, 0.9740576148, 0.7552759051, 0.8526294827, 0.4248991013, 0.398809135, 0.5761463642, 0.9476581812, 0.8188049793, 0.5850878358, 0.0180105343, 0.1690450311, 0.8622763157, 0.7330220938, 0.9796077013, 0.8889474869, 0.7919277549, 0.1122894138, 0.8653057218, 0.1189263314, 0.4084248245, 0.244392693, 0.7443601489, 0.5515754223, 0.7709879875, 0.3673099875, 0.3389573693, 0.2154583931, 0.3615200818, 0.742056489, 0.3151056767, 0.2117549628, 0.9700726271, 0.4528015256, 0.4639360309, 0.7585829496, 0.008131275, 0.0860575661, 0.9605270028, 0.5847569704, 0.6709223986, 0.6396714449, 0.3648293316, 0.1234715581, 0.0868903175, 0.06442976, 0.1366702169, 0.8287847638, 0.6706626415, 0.1918775886, 0.1597213596, 0.6075517535, 0.4497085512, 0.5078248978, 0.3656344712, 0.3203390837, 0.3556327522, 0.7300463915, 0.362962991, 0.3622173965, 0.5749477744, 0.7641447186, 0.2175557762, 0.0997704864, 0.9750205278, 0.6072089672, 0.2837329507, 0.7329918742, 0.5933936238, 0.5173432231, 0.2274439782, 0.8076895475, 0.0807430819, 0.298433125, 0.6452993751, 0.9948908687, 0.5898016691, 0.990029335, 0.1963420063, 0.2902719378, 0.2897566557, 0.1611588597, 0.9794832468, 0.0688853338, 0.1645004451, 0.6816020012, 0.7845854163, 0.265853256, 0.5870781541, 0.1510099322, 0.1010521203, 0.9625496864, 0.1306971759, 0.7898432016, 0.7819833755, 0.4105321467, 0.7624241114, 0.3898871839, 0.275139451, 0.1849643886, 0.0323388502, 0.2609303594, 0.3490280509, 0.9759741426, 0.837057054, 0.7335006595, 0.1259791404, 0.714876771, 0.2044129074, 0.7900349498, 0.5788567662, 0.9213893414, 0.4962672591, 0.7827541828, 0.2302873284, 0.0544130541, 0.778347671, 0.350154072, 0.3865097165, 0.8153201342, 0.5859671235, 0.2365583181, 0.2372176796, 0.5250331163, 0.0443457291, 0.8457442522, 0.6412010789, 0.2312082946, 0.2995659709, 0.1753683835, 0.433680892, 0.2301672399, 0.460855335, 0.9934188128, 0.8866185546, 0.8231829405, 0.4947065115, 0.8329749107, 0.2581706643, 0.5288423896, 0.7267872691, 0.6947799921, 0.6358758211, 0.3470119536, 0.9147358537, 0.1160683036, 0.2022097856, 0.3886943161, 0.9786373377, 0.1892386973, 0.2845241427, 0.0562943406, 0.3672907948, 0.9900227189, 0.583333075, 0.1575425267, 0.9664130807, 0.336944133, 0.5078743696, 0.8506065011, 0.7281443477, 0.5049641728, 0.9787535071, 0.3344016969, 0.8094183803, 0.3837445974, 0.6564620733, 0.4685125649, 0.6480392814, 0.1251861602, 0.0107197817, 0.185504958, 0.4773720205, 0.1253501624, 0.5780951977, 0.8945932388, 0.1428237557, 0.1782084852, 0.6178655624, 0.0087716524, 0.5825682282, 0.7363885641, 0.5880399346, 0.6319678426, 0.9568156004, 0.4372547567, 0.4117933214, 0.9570138454, 0.4562333226, 0.014724724, 0.8327901959, 0.8294945955, 0.3523861766, 0.8022853136, 0.6378967166, 0.7279042006, 0.8972856998, 0.2499193847, 0.2757280767, 0.3737303317, 0.4609211087, 0.3148642778, 0.9514909983, 0.3195999563, 0.0761469752, 0.6374220848, 0.8876250982, 0.5965381265, 0.0007383316, 0.1852566302, 0.1487594396, 0.1143126413, 0.6909267902, 0.6222657561, 0.1421835423, 0.2163372189, 0.9070070982, 0.9298444986, 0.3753599524, 0.6777666807, 0.3184583485, 0.638952136, 0.8375228643, 0.3248925507, 0.2856884599, 0.2291556299, 0.8633516431, 0.2655961215, 0.9367564321, 0.7854658961, 0.28091833, 0.5630016923, 0.3595665395, 0.3839953244, 0.4284386635, 0.8873651028, 0.5412272215, 0.178257063, 0.4236218631, 0.365239352, 0.7126258612, 0.321615696, 0.6357123256, 0.226552099, 0.5721607804, 0.4778600931, 0.3107969463, 0.1367669404, 0.3404520452, 0.5942929983, 0.3942337632, 0.2979925871, 0.1951848567, 0.4729828238, 0.7501001954, 0.6589679122, 0.5952326059, 0.7186437249, 0.6826527715, 0.9515743256, 0.2105532438, 0.9471620321, 0.4804215729, 0.1124587655, 0.4335258901, 0.7551532388, 0.7733113766, 0.0783382654, 0.2885888517, 0.895824492, 0.8712418079, 0.3927388787, 0.8634191751, 0.519162178, 0.5919325352, 0.8640490174, 0.5846663117, 0.9602948427, 0.0991103053, 0.9496303201, 0.7012666464, 0.5834546089, 0.0743006617, 0.2192893326, 0.0044159824, 0.8875482678, 0.9161846638, 0.2652477622, 0.2977103889, 0.7025682926, 0.9855603576, 0.0087101785, 0.439671576, 0.9723095894, 0.0659022853, 0.9122033119, 0.1336005032, 0.748950839, 0.3304834366, 0.8549153805, 0.3025889397, 0.2665978968, 0.9892198443, 0.5173229575, 0.3744891286, 0.8874340653, 0.1104984879, 0.628275454, 0.6229367256, 0.3589352965, 0.771216929, 0.0302241705, 0.6347808838, 0.9150835276, 0.9460471869, 0.7598267198, 0.29057464, 0.7529472113, 0.5606840253, 0.0738537386, 0.3570119441, 0.0135366321, 0.388612628, 0.3621165156, 0.3774941266, 0.7559077144, 0.0655572787, 0.1813212931, 0.5657911301, 0.2029305696, 0.8516904116, 0.2806179821, 0.6828679442, 0.7818730474, 0.5800003409, 0.6047840714, 0.2156374902, 0.9419383407, 0.3020962179, 0.7256852388, 0.0609827414, 0.3350419104, 0.4851172268, 0.4306640923, 0.5299456716, 0.6867406368, 0.0583693348, 0.7255308032, 0.347633332, 0.0635933504, 0.9911341071, 0.0611126088, 0.0815501437, 0.1212034225, 0.1592897177, 0.0597240999, 0.1882285774, 0.6781055331, 0.2596292198, 0.1077294052, 0.1352300495, 0.0448611602, 0.5108820796, 0.3657792509, 0.1486221701, 0.7091449499, 0.0353681594, 0.9301335812, 0.8339682817, 0.939226687, 0.1925535202, 0.8164636493, 0.683699131, 0.0249739978, 0.902374804, 0.1218321845, 0.183962211, 0.9348144531, 0.4286737144, 0.9748869538, 0.5097845197, 0.849189043, 0.5711638927, 0.4680051208, 0.6587874889, 0.9002233148, 0.2112870216, 0.6346377134, 0.7902280688, 0.029632628, 0.9171761274, 0.3519519567, 0.5936511159, 0.8897253871, 0.6063346863, 0.0924998298, 0.8609267473, 0.231192559, 0.0959152505, 0.2161154896, 0.1615293473, 0.8053162694, 0.2094037682, 0.0073373597, 0.5269560814, 0.0615060776, 0.6802668571, 0.8214485645, 0.0660875067, 0.8492749929, 0.5870412588, 0.6753711104, 0.9623897076, 0.6564074159, 0.9217193127, 0.3767517209, 0.0150573831, 0.8463239074, 0.1042795032, 0.4882674813, 0.0036249761, 0.4475171566, 0.1816152483, 0.4341139197, 0.3727532327, 0.0205756538, 0.8007926345, 0.9693693519, 0.2170890421, 0.3233875036, 0.3912367523, 0.7034336925, 0.9578071833, 0.042797327, 0.4719061255, 0.3165228069, 0.5144750476, 0.9703150392, 0.1011901572, 0.8679248691, 0.8223432899, 0.0407943204, 0.6343313456, 0.1056611836, 0.6949219108, 0.8749068379, 0.736051023, 0.4877324104, 0.6418207288, 0.1990425885, 0.6515081525, 0.7983100414, 0.9734125137, 0.8395516872, 0.6505805254, 0.4581978917, 0.8411237597, 0.4651216269, 0.5258325338, 0.8255993724, 0.0932482779, 0.4222149253, 0.4398647845, 0.9860431552, 0.6527469754, 0.4647019804, 0.0393914171, 0.1352805942, 0.5043900609, 0.9310443997, 0.0939329118, 0.3112483323, 0.9413509369, 0.9663134813, 0.6922456622, 0.6697505713, 0.1931533962, 0.214313522, 0.8276033401, 0.8858920932, 0.7464785576, 0.7450338602, 0.4487583935, 0.046935387, 0.2878799438, 0.7755366564, 0.1041728631, 0.2338117212, 0.5379500389, 0.3419001698, 0.0938941613, 0.0629621074, 0.1864347607, 0.6573240161, 0.5124857426, 0.9413253069, 0.1264335513, 0.9302647114, 0.3441043496, 0.1859531552, 0.4256654978, 0.5935873985, 0.9305386543, 0.9631909728, 0.1347593218, 0.2154324651, 0.3538596928, 0.3273724318, 0.0041027772, 0.0934103429, 0.2257991731, 0.5610166192, 0.3360533416, 0.2801225483, 0.0188695099, 0.6096316576, 0.5419935584, 0.4941622615, 0.5897194743, 0.7221100926, 0.8308253884, 0.85778898, 0.4596455395, 0.3866485357, 0.1359159946, 0.8164426088, 0.828199327, 0.0968906134, 0.7434515357, 0.3830186129, 0.5761756897, 0.0386156216, 0.2260080725, 0.7623475194, 0.6814588904, 0.351431936, 0.967553854, 0.8338597417, 0.0156834833, 0.4322239757, 0.1978540421, 0.9607005715, 0.0880531222, 0.3144739866, 0.6504595876, 0.0619592033, 0.7440487742, 0.51056844, 0.4522305429, 0.4000442326, 0.105854325, 0.4792780876, 0.3761950135, 0.011288465, 0.7108566165, 0.1537749469, 0.0266981274, 0.1352066547, 0.8747116923, 0.6969444156, 0.1751065552, 0.5347428322, 0.3883734941, 0.8203840852, 0.273675561, 0.6362014413, 0.4096245766, 0.2385546714, 0.8809883595, 0.1217237785, 0.619473815, 0.4113697708, 0.1345291138, 0.3856600523, 0.5819554925, 0.5339958668, 0.8144325018, 0.6828483939, 0.8512167335, 0.1485446244, 0.5331157446, 0.7378240228, 0.5104088187, 0.3281626105, 0.5483035445, 0.343275249, 0.721067071, 0.4403606355, 0.5788609385, 0.740285337, 0.5148429871, 0.4699332118, 0.1141299382, 0.0198406763, 0.8596696258, 0.9190923572, 0.1077200025, 0.1058468446, 0.3524709046, 0.4952397645, 0.5295362473, 0.6823336482, 0.089881368, 0.9296429157, 0.9508863688, 0.1838008314, 0.8354221582, 0.8821309209, 0.5493785739, 0.5963098407, 0.2842168212, 0.3851438761, 0.0946061313, 0.7525454164, 0.4981763661, 0.3869765103, 0.0694613457, 0.5099048018, 0.7751111984, 0.452439189, 0.1479069442, 0.1934044659, 0.4646208286, 0.718305409, 0.8842082024, 0.7150661349, 0.297475487, 0.9721947908, 0.8158836365, 0.1040677354, 0.6557854414, 0.8579548597, 0.3344733417, 0.4862904251, 0.5034834146, 0.6619328856, 0.4588610828, 0.7238252759, 0.6895897985, 0.7830691934, 0.3887063563, 0.819768846, 0.1817125231, 0.3514803946, 0.137630567, 0.3502693176, 0.0915137902, 0.8618733883, 0.1762868315, 0.5926885009, 0.0159674007, 0.5508555174, 0.4503343999, 0.9569186568, 0.6248606443, 0.326584518, 0.9851868153, 0.2197668105, 0.9132761359, 0.6558382511, 0.1590070873, 0.221066609, 0.7333306074, 0.141661182, 0.4143800735, 0.7012246251, 0.5665413737, 0.5648188591, 0.5274944901, 0.5120862126, 0.8858002424, 0.4135948122, 0.9943007231, 0.2888781428, 0.8798441887, 0.0955133662, 0.1354070455, 0.495947063, 0.0209824257, 0.4498231411, 0.765006423, 0.4894126654, 0.6157168746, 0.9058071375, 0.925540626, 0.5323749781, 0.9057061672, 0.6342281699, 0.9844349027, 0.3900440335, 0.3267960846, 0.1053059921, 0.3658140302, 0.8208549619, 0.4848240614, 0.3231238425, 0.8643591404, 0.4406141341, 0.7466545105, 0.5113521814, 0.9286953807, 0.8059811592, 0.1911488026, 0.5330706239, 0.0909626335, 0.6589865088, 0.9123917222, 0.8108007312, 0.6411517859, 0.5061846375, 0.1401813477, 0.8855273724, 0.1327907294, 0.7768970132, 0.7572786808, 0.3620576262, 0.6685598493, 0.6831928492, 0.3181948364, 0.8907656074, 0.8488835692, 0.0757274106, 0.5749354959, 0.575296402, 0.4452306032, 0.1889589578, 0.0504652373, 0.8334448934, 0.5043759942, 0.5595218539, 0.0515798032, 0.8898085952, 0.6334125996, 0.53810215, 0.0010347045, 0.1597247869, 0.9458835721, 0.6902890205, 0.716377914, 0.0197655261, 0.8996863365, 0.8865029216, 0.6332854033, 0.6583458185, 0.6594056487, 0.6951137781, 0.7752588987, 0.5021913648, 0.6187083721, 0.8058285117, 0.1089947, 0.4366185665, 0.3214475513, 0.5644149184, 0.3249928951, 0.9725453854, 0.0408105999, 0.2468603402, 0.1586236507, 0.771378994, 0.9597951174, 0.1194453537, 0.597356379, 0.5355741978, 0.6467792392, 0.7512522936, 0.1091663688, 0.4407377839, 0.988078177, 0.3036382198, 0.8701978326, 0.2114735544, 0.0998489931, 0.7444351912, 0.5905585289, 0.2769057155, 0.3093628585, 0.828347981, 0.9164166451, 0.8449749351, 0.022307504, 0.8893482089, 0.1820281297, 0.4852268696, 0.1288422495, 0.3043598533, 0.900429666, 0.1886506528, 0.1783746779, 0.0880562216, 0.2077170908, 0.6934641004, 0.5955366492, 0.5970172286, 0.215525046, 0.6623733044, 0.441169709, 0.6323363185, 0.9843344688, 0.8477121592, 0.5396968722, 0.2380565107, 0.8279913068, 0.3993844092, 0.3761107922, 0.9137117863, 0.8715309501, 0.0830032527, 0.1437654346, 0.6770006418, 0.6913329959, 0.0367433205, 0.3516072333, 0.1324456632, 0.311532855, 0.7668557763, 0.1891957819, 0.935059309, 0.5624659657, 0.2871337533, 0.5827600956, 0.1353468448, 0.6321440935, 0.9487624168, 0.4500167966, 0.2647919357, 0.4096116722, 0.8818699718, 0.5759581327, 0.0538389124, 0.9059103131, 0.6533465385, 0.4650319815, 0.9372612834, 0.6696007252, 0.3554721475, 0.0600751266, 0.7197126746, 0.4189397395, 0.3530926406, 0.8329718113, 0.0920599028, 0.687813282, 0.4325293005, 0.6437871456, 0.5340192914, 0.017356813, 0.7114211321, 0.231429249, 0.1877427846, 0.4141532779, 0.1278582811, 0.4719299674, 0.3102020025, 0.4923864901, 0.2105416358, 0.4928782582, 0.8812971711, 0.3619814217, 0.0837717578, 0.8824574351, 0.6092460752, 0.7426846027, 0.6008812189, 0.418055743, 0.9838443398, 0.7598111629, 0.1344215125, 0.9633333683, 0.456779182, 0.5808681846, 0.5132725835, 0.1173246875, 0.329280138, 0.7500274777, 0.2492450327, 0.9107430577, 0.3316108882, 0.1339779347, 0.1828310192, 0.7911765575, 0.0374624245, 0.9327452183, 0.0589537658, 0.3001240492, 0.0855284408, 0.283852905, 0.1826589704, 0.4163714051, 0.1758664101, 0.2196706831, 0.2664064765, 0.9963974357, 0.5459251404, 0.0950668007, 0.0900135115, 0.8869558573, 0.8550109863, 0.0372654907, 0.8010394573, 0.9088296294, 0.7798512578, 0.958483696, 0.1617002636, 0.7462898493, 0.3375258148, 0.8354582191, 0.8358682394, 0.7142186761, 0.1502233893, 0.8161059618, 0.6727679968, 0.7303199172, 0.0075955139, 0.5751823783, 0.6335357428, 0.2204233855, 0.8489583731, 0.4292674065, 0.3852149248, 0.140742898, 0.1640124023, 0.1336183548, 0.1801067889, 0.1159457639, 0.6652910709, 0.7758769393, 0.6840639114, 0.4032720625, 0.5570705533, 0.5599435568, 0.832836628, 0.6131256819, 0.6266252398, 0.4926441312, 0.8959797025, 0.1590007693, 0.9684049487, 0.7161019444, 0.5822111368, 0.7390566468, 0.1586971283, 0.8475266695, 0.2790088654, 0.3047635257, 0.5757278204, 0.809677422, 0.3161999285, 0.017190814, 0.94063586, 0.3323770761, 0.003234887, 0.8377987742, 0.0286723543, 0.2757017612, 0.3810116053, 0.2213836759, 0.56609869, 0.8849477172, 0.2123749107, 0.6509358287, 0.0104319341, 0.5874458551, 0.8807432055, 0.4075576365, 0.0296776071, 0.0945936143, 0.3302911222, 0.3617616296, 0.8985818624, 0.0672378764, 0.3647645712, 0.236339286, 0.4530104697, 0.0280950461, 0.5405143499, 0.1119930521, 0.4619932175, 0.2404984832, 0.3364930153, 0.845841229, 0.7214118838, 0.9757335782, 0.2733468115, 0.4997842014, 0.2196719348, 0.0033935609, 0.3427042663, 0.7041660547, 0.2852859497, 0.6518928409, 0.7352138162, 0.3479509056, 0.8747956157, 0.4917884767, 0.5791017413, 0.3640214503, 0.2190613002, 0.3163473606, 0.5945124626, 0.2400048673, 0.1566741019, 0.2226224095, 0.3369036615, 0.2598891556, 0.746540308, 0.3397649229, 0.3434500694, 0.4686655104, 0.374291271, 0.0895045251, 0.8132685423, 0.4481364191, 0.9891664982, 0.0339491703, 0.0423345231, 0.1885800809, 0.1342749447, 0.3767119348, 0.6284828186, 0.8631264567, 0.4307189286, 0.7542389631, 0.6370449662, 0.3033391833, 0.5593363643, 0.2838163376, 0.3682669103, 0.9592128992, 0.0637939498, 0.0881183147, 0.5055900812, 0.134016335, 0.2795638442, 0.7212033272, 0.7197009325, 0.3564022481, 0.0801254809, 0.0061451457, 0.2375537306, 0.5419400334, 0.842468977, 0.8418055177, 0.9790504575, 0.8613957167, 0.984756887, 0.8034096956, 0.6317728758, 0.7207365036, 0.1682742834, 0.2284196019, 0.9551849365, 0.3246108294, 0.8061655164, 0.0622744374, 0.5614647865, 0.8936647177, 0.3613034487, 0.2679057419, 0.4133438766, 0.9373534322, 0.7108463645, 0.4410406351, 0.3049180806, 0.9229277968, 0.437074244, 0.7806338668, 0.8810411692, 0.7186604738, 0.6573174, 0.3585429192, 0.2101356983, 0.7539672852, 0.3990959525, 0.9771047831, 0.3499864638, 0.0303151328, 0.5823196769, 0.8352752328, 0.0330622271, 0.1605356485, 0.6936785579, 0.467022866, 0.5163946748, 0.0871832594, 0.2151990235, 0.673275888, 0.3221806288, 0.5438848138, 0.6597198248, 0.5375214219, 0.183799237, 0.3309822679, 0.0041797226, 0.4072039723, 0.1410609484, 0.6040471196, 0.1111649722, 0.6163387895, 0.990786314, 0.7735633254, 0.9464170337, 0.2350548208, 0.2136842757, 0.3965293169, 0.5376062393, 0.6553274989, 0.9616764784, 0.8119949102, 0.3124815822, 0.2487912029, 0.2529064417, 0.3311287165, 0.8549385071, 0.2516104281, 0.3843016028, 0.687392652, 0.602001071, 0.8498594761, 0.002498864, 0.186970517, 0.6236429214, 0.3680001199, 0.8916360736, 0.6753105521, 0.3512377441, 0.1900529414, 0.3229677379, 0.6994846463, 0.6495521069, 0.1122881621, 0.9941564798, 0.7231782675, 0.032251101, 0.1577460021, 0.8889950514, 0.3813840449, 0.3696404397, 0.6655992866, 0.2321232259, 0.700073421, 0.1588107198, 0.986892283, 0.4453627467, 0.7543982863, 0.2691113949, 0.2306683958, 0.6842470169, 0.2703482211, 0.898994267, 0.0121822748, 0.009674482, 0.7537097931, 0.3252431154, 0.4124893248, 0.5688163042, 0.4196397364, 0.8253999352, 0.9125783443, 0.8752539158, 0.9069935083, 0.2914037406, 0.1835056394, 0.6422432065, 0.8277579546, 0.5990942717, 0.3666738272, 0.8527797461, 0.3489917517, 0.1525890976, 0.8823184371, 0.8649030328, 0.8242565989, 0.4307527244, 0.059185449, 0.0342851058, 0.2395575494, 0.4413515329, 0.308675617, 0.0644474924, 0.5168740749, 0.5283330679, 0.9846208096, 0.5072614551, 0.1457142681, 0.3547078371, 0.85165447, 0.9829388857, 0.807903409, 0.5265082717, 0.1526004821, 0.4594575763, 0.2128100395, 0.5326172113, 0.8612877727, 0.6328709126, 0.1260940731, 0.6312543154, 0.8444578052, 0.9790022373, 0.3889540732, 0.3475797772, 0.4702761769, 0.6669821143, 0.7565659285, 0.7595517635, 0.7196069956, 0.080054529, 0.2127159387, 0.4909484088, 0.0033205582, 0.4057670236, 0.6309975982, 0.0869123191, 0.9404982328, 0.5116655231, 0.986012876, 0.0965213627, 0.8937316537, 0.7201290727, 0.1486718953, 0.6349852681, 0.8498548269, 0.2738034427, 0.6460675001, 0.6294287443, 0.3644131422, 0.2646060288, 0.7742468715, 0.8052113652, 0.8815364838, 0.1684703976, 0.8409839869, 0.9413342476, 0.4865612984, 0.2367703021, 0.1877286583, 0.978159368, 0.7963556647, 0.0708820969, 0.8610283136, 0.7909523845, 0.7435487509, 0.1387254149, 0.8519986272, 0.4294517636, 0.0161501523, 0.3307070136, 0.9879044294, 0.7054966092, 0.5582140684, 0.5907460451, 0.5063688159, 0.8520300388, 0.3246189952, 0.1063985974, 0.4999367595, 0.9665479064, 0.5503758192, 0.3585774302, 0.3141995966, 0.2438623309, 0.7391360402, 0.3353982866, 0.8666503429, 0.91065979, 0.5628968477, 0.9354690909, 0.0864307433, 0.4837855697, 0.3575817943, 0.9084280133, 0.945679009, 0.7300344706, 0.8756796718, 0.0627546683, 0.7112050653, 0.0986539721, 0.9588924646, 0.2920324206, 0.1126644388, 0.6120675802, 0.5796947479, 0.065082863, 0.6106427312, 0.6074388623, 0.885348618, 0.7408217192, 0.2658755481, 0.4856550694, 0.7822978497, 0.7912334204, 0.215637967, 0.9274978042, 0.4397214353, 0.9381591678, 0.9227067828, 0.2639899552, 0.4685123265, 0.4078754485, 0.6575052738, 0.6114271879, 0.9782764316, 0.9106327295, 0.8625913262, 0.8558455706, 0.6101471186, 0.3666706383, 0.4018512964, 0.6479181647, 0.9207193851, 0.161416173, 0.4416292608, 0.8584919572, 0.8091099858, 0.6615940332, 0.322480619, 0.9934113026, 0.1739115119, 0.7504195571, 0.1157584339, 0.6743510365, 0.9435926676, 0.1545098871, 0.8688474298, 0.715046525, 0.9398179054, 0.4420393705, 0.191443488, 0.0326377451, 0.4120532274, 0.3268280923, 0.702562511, 0.1996662915, 0.3905383945, 0.5729266405, 0.5840837359, 0.6943033934, 0.844776094, 0.0144008398, 0.9386386871, 0.0002243735, 0.4859568775, 0.0586826168, 0.2571247816, 0.5092034936, 0.2398022264, 0.5654715896, 0.9001114964, 0.6657202244, 0.1338600814, 0.5887948275, 0.3743414283, 0.6042672396, 0.7137978077, 0.1104032099, 0.7170971632, 0.4850760102, 0.3490588367, 0.1988735497, 0.2973527312, 0.4160914421, 0.592880547, 0.5131810904, 0.2957490087, 0.601557374, 0.9918369651, 0.442358613, 0.2893592715, 0.5733824968, 0.8718593121, 0.6390318274, 0.4930015206, 0.0591595396, 0.9997956753, 0.7617285252, 0.2150458843, 0.99995929, 0.6327126026, 0.8118473291, 0.7057132125, 0.482837081, 0.6083679795, 0.0587826483, 0.9548948407, 0.4787119031, 0.7368876338, 0.3668374121, 0.5363883972, 0.6838585734, 0.2969213426, 0.0981562138, 0.2267682254, 0.8281888366, 0.0498473495, 0.5847372413, 0.1802515835, 0.384575814, 0.7568612099, 0.5419732332, 0.9395964146, 0.5739356875, 0.4684714973, 0.6320396066, 0.2544209659, 0.8097112775, 0.5742420554, 0.7068752646, 0.1715442985, 0.7959094644, 0.0168016627, 0.2332548648, 0.1837963909, 0.5056391358, 0.233201474, 0.4081544578, 0.4895038605, 0.7006309032, 0.5027516484, 0.5000659227, 0.5839354992, 0.26402843, 0.6145825386, 0.6977632046, 0.3110732734, 0.2615603805, 0.2004319727, 0.8688012362, 0.7412906289, 0.6822055578, 0.2076299042, 0.585973978, 0.9355570078, 0.3478323519, 0.5619545579, 0.8974535465, 0.0640840903, 0.1853112131, 0.6816211939, 0.11496564, 0.138396889, 0.2473840714, 0.5649874806, 0.4116217196, 0.5084484816, 0.4974224567, 0.0893179625, 0.0995039046, 0.2082732916, 0.0543951131, 0.0839584097, 0.7227418423, 0.2475279421, 0.5749147534, 0.0388351567, 0.8974410295, 0.9450010061, 0.3381021619, 0.7286146879, 0.9115239382, 0.2934806943, 0.6838433743, 0.1233035997, 0.8173927665, 0.5362653732, 0.1595509052, 0.0571826808, 0.9823575616, 0.2818324566, 0.708268404, 0.3605043292, 0.6125229597, 0.6308466792, 0.1706397533, 0.3916153908, 0.1341548562, 0.2777822614, 0.3164154291, 0.4997781515, 0.1627987176, 0.3505487442, 0.3648134768, 0.8111594319, 0.5003600717, 0.2473016679, 0.8895004392, 0.3389880657, 0.9711527824, 0.7164833546, 0.8985875249, 0.9126531482, 0.014188868, 0.3881369233, 0.3607708812, 0.5681939125, 0.0056669842, 0.3106762469, 0.6164679527, 0.3158658743, 0.2425299138, 0.8327383399, 0.054487735, 0.2382235229, 0.1739102155, 0.9040178061, 0.5898420215, 0.9327718616, 0.6847351193, 0.0030442751, 0.7230296731, 0.7431026101, 0.011432223, 0.741809845, 0.5972414017, 0.2529012859, 0.7586994767, 0.6880294681, 0.4425160885, 0.9543884397, 0.4084641933, 0.309864223, 0.1807775795, 0.1860131323, 0.5633924007, 0.8983878493, 0.6125662327, 0.1844114959, 0.2258224785, 0.0209375322, 0.2123383433, 0.6231752038, 0.1008179262, 0.8807303309, 0.7672935724, 0.2301377356, 0.3846559823, 0.8949285746, 0.7048419118, 0.1913291216, 0.408264786, 0.5372482538, 0.2536475062, 0.2272657752, 0.3890919089, 0.9411203265, 0.8043738604, 0.9846765995, 0.6039310098, 0.9101876616, 0.7753551006, 0.711419642, 0.7980414033, 0.8325216174, 0.8614086509, 0.6663145423, 0.8518819213, 0.3203050196, 0.3335241079, 0.3518493772, 0.9558016062, 0.4489892125, 0.8110271692, 0.2194582373, 0.4013445675, 0.1789831519, 0.1117102578, 0.0900359228, 0.6109364033, 0.7894284725, 0.9664831161, 0.7519912124, 0.9377236962, 0.4804982543, 0.3369966447, 0.1355315894, 0.5390704274, 0.4640378952, 0.9938179255, 0.7938830853, 0.0836521983, 0.3594265878, 0.8181815743, 0.7077993155, 0.9233137369, 0.4639542103, 0.9924058914, 0.3647743165, 0.961424768, 0.4376363754, 0.7425180078, 0.0934674665, 0.4547329843, 0.5054649115, 0.3461502194, 0.7163566351, 0.8879771233, 0.2729289234, 0.0745265633, 0.5380026102, 0.3289803863, 0.5222221613, 0.1877923757, 0.1328493357, 0.0496345311, 0.1499144733, 0.3467061222, 0.6405905485, 0.9760402441, 0.9165933728, 0.6199049354, 0.7768987417, 0.2197535187, 0.4428177476, 0.2261802107, 0.4996104538, 0.7293562889, 0.5672805309, 0.3172640204, 0.2026030868, 0.4785240591, 0.4913944006, 0.7779044509, 0.5808085203, 0.7753463984, 0.8481456041, 0.4185773432, 0.0636490583, 0.2597759962, 0.5669569969, 0.6010169983, 0.2516151369, 0.5157063603, 0.2595796883, 0.1936789155, 0.2085859925, 0.3346258402, 0.3297136128, 0.9562583566, 0.6215136647, 0.6502712369, 0.2481307685, 0.0084344987, 0.8677152991, 0.4063928127, 0.6221209168, 0.3143794537, 0.3887699544, 0.8804819584, 0.0703434497, 0.9605405927, 0.9578213096, 0.4416987598, 0.1304423511, 0.5404391885, 0.7425362468, 0.0978558287, 0.6900287867, 0.3879061937, 0.5578132868, 0.5812071562, 0.9349294901, 0.4391316772, 0.4432170093, 0.7729845047, 0.2459201217, 0.7654583454, 0.3748521805, 0.5990301371, 0.9123783112, 0.0015843224, 0.1684563607, 0.2466392815, 0.6305578947, 0.9636501074, 0.2792312503, 0.8585432172, 0.7121519446, 0.7422158718, 0.5092861056, 0.6871256232, 0.9511637688, 0.1920464933, 0.5825737119, 0.3723974526, 0.7501792908, 0.3154392242, 0.9485397935, 0.8645617366, 0.2213997692, 0.8308188319, 0.4566854239, 0.0607529506, 0.5722083449, 0.1499218643, 0.5635485053, 0.5197700262, 0.4420594871, 0.8801415563, 0.760013938, 0.3799042404, 0.5031815171, 0.5662955046, 0.7226250768, 0.360550195, 0.6452532411, 0.3513295352, 0.2542692125, 0.7034443021, 0.4753168821, 0.2306824178, 0.816362679, 0.926774323, 0.9443190694, 0.0058742445, 0.1496275514, 0.0118881967, 0.3408871889, 0.2208471, 0.7757240534, 0.0296530053, 0.4139153659, 0.5206468105, 0.575594008, 0.2113564312, 0.4428433478, 0.3051337004, 0.5834974647, 0.8254798055, 0.7833608985, 0.018166922, 0.240349099, 0.0737338066, 0.3866648376, 0.303478986, 0.5941126347, 0.5588826537, 0.6095137596, 0.8114073873, 0.6450126171, 0.7001381516, 0.8186420202, 0.6263337135, 0.5924562812, 0.8774192333, 0.3935771585, 0.6096420884, 0.2573115826, 0.3642942011, 0.1805870235, 0.8106171489, 0.0540286563, 0.4247581661, 0.3522080183, 0.7224126458, 0.5399610996, 0.788870573, 0.8132427335, 0.3499590456, 0.119820483, 0.0559551194, 0.4177697003, 0.6245722771, 0.6233429313, 0.1478041112, 0.9678903222, 0.4913440645, 0.4542281926, 0.3845035136, 0.5083712339, 0.7815141678, 0.1192287952, 0.0725990012, 0.9776978493, 0.1138687432, 0.9672344923, 0.6535125971, 0.0900786519, 0.3577122092, 0.1582210958, 0.9457894564, 0.3660543263, 0.7710797191, 0.1157049015, 0.8386038542, 0.2983358502, 0.1096769497, 0.1643242836, 0.8145321012, 0.9719124436, 0.7222680449, 0.9247113466, 0.231299758, 0.938360393, 0.2620245516, 0.3362186253, 0.9061502814, 0.5343630314, 0.6183997393, 0.1343059689, 0.2738068998, 0.1643908918, 0.5637273788, 0.1862617731, 0.1463156343, 0.4017370045, 0.8155725002, 0.1778775156, 0.3755882382, 0.5740320683, 0.8760424256, 0.7082151175, 0.2367805988, 0.3366532028, 0.8647821546, 0.8833859563, 0.7119086981, 0.0102619529, 0.5810371041, 0.7102273703, 0.697625339, 0.113107428, 0.834549129, 0.9653796554, 0.3620071411, 0.6602659822, 0.4560212493, 0.6226450205, 0.685089469, 0.1572125405, 0.8515325785, 0.6337410808, 0.4552631676, 0.0999221653, 0.3569681644, 0.2102586776, 0.1856330782, 0.4125151336, 0.3394840062, 0.0394442603, 0.4163199365, 0.9662784338, 0.0697449967, 0.8360053897, 0.2896710932, 0.0359874591, 0.786765337, 0.8380057216, 0.4434750378, 0.3650088608, 0.3339615464, 0.841945529, 0.1101514176, 0.193276003, 0.6056220531, 0.9751375914, 0.6409477592, 0.060976781, 0.4897474349, 0.824686408, 0.7614607811, 0.5389257669, 0.3856091499, 0.2594721615, 0.0367720872, 0.2024967223, 0.9304299355, 0.4899468124, 0.9995617867, 0.5433477163, 0.8025810719, 0.987095654, 0.8349505067, 0.4915114045, 0.5112369061, 0.0056635598, 0.136632517, 0.0737384856, 0.2319887877, 0.2104884982, 0.4120398164, 0.651378572, 0.3657837212, 0.1258129627, 0.9503030777, 0.1412268579, 0.5740091801, 0.9589503407, 0.5845239162, 0.5547816157, 0.9706026316, 0.5319734216, 0.5832948685, 0.1303028017, 0.5718185902, 0.4020925462, 0.5447438359, 0.3475812078, 0.9912302494, 0.8306050897, 0.7230103016, 0.99115026, 0.5369269252, 0.1953288317, 0.0794127807, 0.0636800006, 0.741055429, 0.8864943385, 0.9625645876, 0.597484827, 0.7411218286, 0.3124462068, 0.6898980737, 0.9473048449, 0.0530501865, 0.761092484, 0.0374028832, 0.2104890943, 0.83815521, 0.5363779664, 0.7638151646, 0.69572258, 0.0061193723, 0.7355313301, 0.4099118412, 0.2053324133, 0.6216631532, 0.2103295773, 0.4950518608, 0.7491188645, 0.9204540253, 0.7864974737, 0.0669203326, 0.7533058524, 0.4840839207, 0.9197073579, 0.0098696332, 0.039250955, 0.8801055551, 0.3021447361, 0.8860538602, 0.9670569897, 0.8739258051, 0.986667037, 0.3653389215, 0.4252314568, 0.8417608142, 0.8153506517, 0.6112138033, 0.5409707427, 0.2828131914, 0.1746225804, 0.2098007351, 0.980373919, 0.3456439972, 0.093225956, 0.3656488955, 0.9607333541, 0.4857932627, 0.0540026277, 0.0309639461, 0.4139657617, 0.4425235689, 0.1147096083, 0.3207749128, 0.7377182245, 0.5659776926, 0.1802824289, 0.6868826747, 0.2534175217, 0.0101310452, 0.9892764688, 0.2440845817, 0.3840390742, 0.1323882639, 0.6377233863, 0.3155703247, 0.0583552234, 0.9497178793, 0.3537640274, 0.4335217476, 0.0797655135, 0.4302970171, 0.6873253584, 0.7047187686, 0.0676008165, 0.6867033839, 0.306924969, 0.8439173698, 0.4000784159, 0.8992196321, 0.2155394256, 0.7116828561, 0.7415392399, 0.1127741858, 0.8006007671, 0.866417408, 0.766297996, 0.9940198064, 0.3937835097, 0.0996102542, 0.5758724213, 0.2917481959, 0.4936659038, 0.4889099896, 0.0807329416, 0.7622966766, 0.658827424, 0.0972428247, 0.7306827307, 0.5750696063, 0.3164197206, 0.9228847623, 0.9389179945, 0.7374790907, 0.2787623107, 0.1098381355, 0.8879435658, 0.7260176539, 0.5998212099, 0.1403766572, 0.8413100839, 0.7874947786, 0.4863704443, 0.9021820426, 0.619512856, 0.8403536081, 0.6130164862, 0.8119343519, 0.6748429537, 0.7750338316, 0.6284690499, 0.4818571508, 0.5027428269, 0.5123698115, 0.9755698442, 0.0920620412, 0.5276015997, 0.3574312627, 0.7350004911, 0.8633834124, 0.7308514118, 0.2754515707, 0.2403506488, 0.4963224828, 0.5496905446, 0.3678574562, 0.8803086877, 0.5837444663, 0.4420125782, 0.9142297506, 0.2338100374, 0.5414126515, 0.464271307, 0.8458287716, 0.1897608638, 0.6672560573, 0.8075864315, 0.1115928218, 0.9206107259, 0.3868331611, 0.0620223954, 0.5052169561, 0.8395518661, 0.5886182785, 0.4294970036, 0.2574808598, 0.7904385328, 0.4711658657, 0.9760697484, 0.4254173636, 0.145273909, 0.1344710141, 0.5664320588, 0.7476805449, 0.850381434, 0.3368009031, 0.1843090653, 0.4472481608, 0.9580815434, 0.992572248, 0.4382192492, 0.3289498687, 0.8497692347, 0.0160838012, 0.5981659293, 0.0213400461, 0.5788072944, 0.8587673903, 0.3360802829, 0.617746532, 0.7836791873, 0.5629882216, 0.9517893195, 0.5061355233, 0.5904608965, 0.6512061357, 0.4160226882, 0.0962378383, 0.9110269547, 0.6063472033, 0.6786859632, 0.323594749, 0.1291635931, 0.6824570298, 0.4486574531, 0.5658966303, 0.8614020348, 0.1033774912, 0.9621068835, 0.4241328239, 0.9065781236, 0.7641761899, 0.4628043473, 0.5470159054, 0.828140676, 0.6051493883, 0.3470966518, 0.6876112223, 0.1222088411, 0.3250820935, 0.5467187762, 0.0261743814, 0.8707129955, 0.0428438261, 0.9649776816, 0.9087430835, 0.0445340574, 0.8385478854, 0.6599641442, 0.585340023, 0.1669427752, 0.8626984954, 0.3403065801, 0.3652212322, 0.5059336424, 0.0763827264, 0.1150694489, 0.319414854, 0.8091986775, 0.5464925766, 0.5441807508, 0.0728710964, 0.3835804164, 0.1930861175, 0.1869702488, 0.9345911145, 0.6641216874, 0.24052912, 0.6489296556, 0.2630651593, 0.6894470453, 0.6631412506, 0.7083969116, 0.625393033, 0.2718397081, 0.2755969465, 0.6364558339, 0.1876875758, 0.3867566586, 0.6713857651, 0.614757061, 0.7384813428, 0.1290114969, 0.8446626067, 0.7999385595, 0.7899394631, 0.3870192766, 0.7309619188, 0.7668225765, 0.6994328499, 0.7905895114, 0.2458200008, 0.8412302732, 0.4817615151, 0.0345448442, 0.1440443546, 0.0575356744, 0.7082183361, 0.6574723125, 0.6297582388, 0.6852607131, 0.5967175961, 0.3452194631, 0.0422707126, 0.3618138134, 0.7588474154, 0.0806893334, 0.9697507024, 0.8915631175, 0.0795703456, 0.9414138794, 0.5351119041, 0.9970599413, 0.518850565, 0.6056861877, 0.8986028433, 0.7396928072, 0.8685028553, 0.0610375293, 0.9054767489, 0.0686211884, 0.7645062208, 0.1286374032, 0.7891623378, 0.8546707034, 0.8971526623, 0.8220834732, 0.4947240949, 0.8800817132, 0.6376647949, 0.5345884562, 0.554066062, 0.8494138122, 0.130911991, 0.4054251015, 0.787062943, 0.1657799035, 0.2226566374, 0.6938433051, 0.0596604198, 0.5089665651, 0.6152022481, 0.2162503302, 0.3299781084, 0.5625262856, 0.2163345665, 0.6128764749, 0.475786984, 0.1991271377, 0.0431080796, 0.4841201305, 0.8944839835, 0.366966784, 0.2307933569, 0.954387486, 0.005774321, 0.115806751, 0.8536692858, 0.6796045899, 0.7620867491, 0.6416705847, 0.7092313766, 0.593256712, 0.8697406054, 0.2132903486, 0.6728556156, 0.568484664, 0.4631045163, 0.449326694, 0.7338997722, 0.5376614928, 0.2144454867, 0.0748951212, 0.7730345726, 0.1944203526, 0.352948159, 0.7865818143, 0.9558824897, 0.434599787, 0.7765372396, 0.8037161231, 0.2317197472, 0.7192084193, 0.0153634753, 0.3003410101, 0.6400128603, 0.2504938841, 0.0992698446, 0.7063420415, 0.0099773267, 0.7390035987, 0.0615290441, 0.4707089961, 0.541441381, 0.6103296876, 0.3876440227, 0.7493652105, 0.707572937, 0.8746657968, 0.6761112213, 0.9280777574, 0.3244438767, 0.6302939057, 0.9078069925, 0.191685766, 0.6700091958, 0.8522417545, 0.4562306702, 0.0559391901, 0.6790363789, 0.8358801007, 0.4056897163, 0.2502582967, 0.2603704035, 0.1371598393, 0.2917786539, 0.1924762577, 0.2479661852, 0.6426951885, 0.3451469839, 0.4626781642, 0.4580256045, 0.8152709603, 0.9253610969, 0.8740119338, 0.1653442681, 0.6612082124, 0.2589413226, 0.2781197727, 0.3580009043, 0.9173426628, 0.5489230752, 0.1186219305, 0.4879653752, 0.0466545671, 0.7891098857, 0.6873882413, 0.6292541027, 0.4851434827, 0.1927900463, 0.0179721322, 0.4936065972, 0.2188114375, 0.3742282391, 0.4090329111, 0.0127426684, 0.1404912472, 0.1283657849, 0.2888801098, 0.8650583029, 0.6060962677, 0.1412445754, 0.6956457496, 0.5314219594, 0.1088551357, 0.7804940343, 0.4022661746, 0.629039228, 0.8669286966, 0.1982601136, 0.9571256638, 0.9981527328, 0.9534710646, 0.4901667237, 0.424059689, 0.1593286097, 0.5785304308, 0.7360011339, 0.1323255152, 0.0603630766, 0.8328416944, 0.8003894091, 0.8644387722, 0.8853911161, 0.0547731891, 0.130480051, 0.9531883597, 0.9741320014, 0.7511789203, 0.4847228527, 0.0036087602, 0.7787177563, 0.2231317014, 0.8908236027, 0.839841783, 0.9895917773, 0.7132139802, 0.9796285629, 0.2885993123, 0.9813839793, 0.7872307301, 0.0064284578, 0.8356505036, 0.6256528497, 0.3742916584, 0.0523047522, 0.3924313784, 0.4971599877, 0.2718709409, 0.1670233756, 0.5745553374, 0.6665002704, 0.4626360834, 0.5488221645, 0.6938694119, 0.9108516574, 0.9139137268, 0.1279039085, 0.8663606048, 0.4086821973, 0.8364224434, 0.206553027, 0.2246541679, 0.1123322621, 0.0945468321, 0.5835648775, 0.4890106022, 0.9410333037, 0.5644700527, 0.9592372775, 0.1224060804, 0.9236732721, 0.3174877167, 0.9467978477, 0.5198745728, 0.0485831536, 0.8266622424, 0.7527025342, 0.6687675118, 0.1173956916, 0.0601795502, 0.274664551, 0.9714960456, 0.4920203388, 0.65232867, 0.5817349553, 0.5424330831, 0.9945071936, 0.9854079485, 0.175066784, 0.1041650176, 0.7712997198, 0.2010931075, 0.5643197298, 0.3105701506, 0.6160590649, 0.2411288321, 0.7326831222, 0.8359069228, 0.5147955418, 0.7042996883, 0.2073970437, 0.1275481135, 0.8247780204, 0.6077878475, 0.4602186382, 0.1170402169, 0.95021981, 0.7957844734, 0.9325250983, 0.3157202899, 0.3050266802, 0.4586791992, 0.1108791456, 0.112492837, 0.3644186556, 0.7116021514, 0.32608518, 0.5575646162, 0.0133089861, 0.7624040246, 0.4636411071, 0.8134638071, 0.01328988, 0.5121221542, 0.8495969176, 0.214733839, 0.457746923, 0.1550133526, 0.624940455, 0.7996145487, 0.0154999942, 0.6986239552, 0.3063335121, 0.0806614831, 0.7876155972, 0.5409100056, 0.8788184524, 0.6057672501, 0.3525770903, 0.6737350225, 0.6845631599, 0.3328086436, 0.7934619188, 0.7132768631, 0.5827698708, 0.4467804134, 0.4437303245, 0.739441812, 0.0858435482, 0.3042074442, 0.5407271385, 0.8784964085, 0.4904243052, 0.6883462071, 0.663007319, 0.7607935667, 0.1878093034, 0.1727387756, 0.824218154, 0.6557357907, 0.4891088903, 0.6216499209, 0.9459804893, 0.2746068537, 0.3103235662, 0.9846129417, 0.9898667932, 0.7004886866, 0.8533517122, 0.0875477716, 0.2399024665, 0.1991463155, 0.9756264687, 0.909705162, 0.9844086766, 0.5507794023, 0.3435892463, 0.6975043416, 0.3778296709, 0.9768900275, 0.7871194482, 0.7164797783, 0.1035963073, 0.9966811538, 0.016131863, 0.2886805832, 0.4763332307, 0.9340108633, 0.374758482, 0.6156099439, 0.6358549595, 0.3833848536, 0.8874871135, 0.1775773466, 0.6076810956, 0.0144416057, 0.5983795524, 0.4989981949, 0.2998563051, 0.1397931427, 0.9007832408, 0.9800312519, 0.4623484015, 0.3303070068, 0.1568520963, 0.3382826447, 0.6101305485, 0.797008872, 0.8208984137, 0.7174112797, 0.2492059469, 0.9842574, 0.2528163195, 0.8717679977, 0.1330204457, 0.5358535647, 0.8569151759, 0.4248799086, 0.5758572221, 0.2576922476, 0.9399523139, 0.6880307198, 0.9472165704, 0.5887063146, 0.3130824268, 0.7306442857, 0.7189573646, 0.9321358204, 0.7711728811, 0.4314511418, 0.0353943147, 0.0751349255, 0.3468002081, 0.0769719854, 0.81446141, 0.3647552729, 0.2275924683, 0.253076911, 0.0799076408, 0.624533236, 0.1952098161, 0.5933178067, 0.2895852029, 0.9435052276, 0.477363348, 0.7610867023, 0.9627574682, 0.7952138186, 0.5373384953, 0.8328925371, 0.9714542031, 0.8651910424, 0.6556310058, 0.3876988292, 0.8613392711, 0.7431043983, 0.3542761803, 0.895998776, 0.1267197281, 0.6910918951, 0.1712021381, 0.702223599, 0.558870554, 0.3900049925, 0.7235428691, 0.3325441778, 0.6974832416, 0.0704269409, 0.7410370708, 0.7909677625, 0.2982308567, 0.9362434149, 0.0376744531, 0.6909531355, 0.3316640556, 0.1610975266, 0.8481178284, 0.2934847772, 0.1013458446, 0.5397228599, 0.1649630219, 0.2080588192, 0.5333530307, 0.1599848717, 0.2619313896, 0.3819122016, 0.4560312331, 0.9565147758, 0.0253188051, 0.006528419, 0.7945774794, 0.8782905936, 0.4303889275, 0.7094818354, 0.6978183389, 0.3478265405, 0.3459337056, 0.6579891443, 0.7187235951, 0.6364232898, 0.762421906, 0.4469431341, 0.7514004707, 0.2800546587, 0.9099124074, 0.6974939704, 0.745126605, 0.3748708367, 0.6414527893, 0.9883816838, 0.7743804455, 0.3747880459, 0.5890847445, 0.0526064523, 0.5049400926, 0.7521902323, 0.7097460628, 0.0133493152, 0.0833647102, 0.2128605694, 0.4006058574, 0.7058876753, 0.894615531, 0.8722225428, 0.1559185386, 0.4045276046, 0.8426536322, 0.3118899763, 0.9879300594, 0.621379137, 0.7936516404, 0.7308436036, 0.0356463343, 0.705611825, 0.4863812327, 0.2313183397, 0.2509463727, 0.2516500652, 0.6078686118, 0.8682948351, 0.3590525687, 0.7395040393, 0.1889497191, 0.2628301382, 0.6305530667, 0.610234499, 0.2281642556, 0.9519263506, 0.3817784786, 0.6842796803, 0.6145751476, 0.2107230723, 0.3641068339, 0.2403616309, 0.4144880176, 0.4114216268, 0.6100968719, 0.8568821549, 0.7609243989, 0.7093672156, 0.4434010983, 0.8321857452, 0.1048112959, 0.0360628292, 0.2742269933, 0.9084026217, 0.9770795703, 0.4224666655, 0.9528692365, 0.68355757, 0.7113526464, 0.8657730222, 0.2597964108, 0.4025377631, 0.8820057511, 0.7653574944, 0.6186743379, 0.6942235231, 0.9867048264, 0.4002628922, 0.1797582656, 0.188781023, 0.4196100831, 0.5604269505, 0.3068850935, 0.0115590133, 0.7105202675, 0.8668804169, 0.4384834766, 0.9664412141, 0.1454813033, 0.4807569981, 0.8667165041, 0.2904396355, 0.9420385957, 0.087446101, 0.3442692161, 0.7635858059, 0.1445941478, 0.2934573591, 0.8491559029, 0.7168706656, 0.6976367831, 0.0318241194, 0.2881803215, 0.2604030967, 0.4439538121, 0.8615469933, 0.5918800235, 0.4154109955, 0.8675551414, 0.626760006, 0.3865536749, 0.0840766579, 0.9852864146, 0.8851239085, 0.24478212, 0.6427243352, 0.9368599057, 0.9069287181, 0.3239406347, 0.0971427709, 0.8410053849, 0.5610182285, 0.1890131533, 0.4704453349, 0.5942676067, 0.0422278903, 0.5234427452, 0.7600780129, 0.5776534677, 0.6907634139, 0.1705881208, 0.0085717291, 0.628303051, 0.9940350652, 0.9520592093, 0.2493636608, 0.0954099447, 0.8150551915, 0.775793314, 0.9748542309, 0.2951864898, 0.7933490872, 0.9063792825, 0.0002953771, 0.2243842334, 0.6186184883, 0.0568240546, 0.6053550243, 0.7720879316, 0.9695298076, 0.1935105622, 0.3159848452, 0.3655947149, 0.4058556259, 0.7265959978, 0.9902883768, 0.9081606865, 0.2359461635, 0.139774248, 0.7361820936, 0.7937223315, 0.7442050576, 0.9850770235, 0.6497853398, 0.8510286808, 0.4860012829, 0.5907452106, 0.2167189121, 0.1377938092, 0.6289006472, 0.087133795, 0.0762696937, 0.471552372, 0.6736221313, 0.688690424, 0.928080678, 0.837112844, 0.401591301, 0.4574222565, 0.4443146288, 0.40984267, 0.267077893, 0.0694016591, 0.6219701171, 0.628634572, 0.4461866319, 0.5418575406, 0.0135321096, 0.0677327588, 0.5886047482, 0.8423889875, 0.1192927733, 0.600147903, 0.6895483732, 0.8432075381, 0.7416180372, 0.4256332815, 0.3968738914, 0.885818541, 0.3350656331, 0.2864353955, 0.695881784, 0.1205930412, 0.1171584278, 0.1149816886, 0.2236678749, 0.7210913897, 0.434987992, 0.5387935638, 0.4522722363, 0.2054409534, 0.1394047439, 0.9162051082, 0.4145580232, 0.2460494637, 0.8880847096, 0.7661312222, 0.0692350566, 0.0498695225, 0.8656570911, 0.2401022017, 0.5986857414, 0.4742872715, 0.5297006965, 0.7017870545, 0.8131196499, 0.1880405247, 0.7624046803, 0.0425453596, 0.345682621, 0.1948477179, 0.5889691114, 0.4063898921, 0.7032834291, 0.2197003365, 0.1332048476, 0.2356624156, 0.1127961352, 0.5407912731, 0.7228294015, 0.1118651405, 0.9419350028, 0.7622610331, 0.5045526028, 0.4526423514, 0.2535529435, 0.5909439325, 0.95535326, 0.8894069791, 0.4924957156, 0.2825604975, 0.9615020156, 0.6506593227, 0.1076390743, 0.7318255305, 0.8115561604, 0.4576620162, 0.2357361615, 0.9980915189, 0.5082566142, 0.1415290833, 0.5745783448, 0.4344147444, 0.7112027407, 0.4928105474, 0.6305655241, 0.1600139737, 0.133831799, 0.5621593595, 0.9909422398, 0.8261014223, 0.9591542482, 0.0873595551, 0.9861614704, 0.9482286572, 0.1440095901, 0.8397452235, 0.1696817428, 0.0457092971, 0.5855281949, 0.0714847669, 0.5959162116, 0.9181247354, 0.4636716247, 0.5860897303, 0.0811086595, 0.7844895124, 0.4872695506, 0.6522870064, 0.490835011, 0.8570812941, 0.2767620683, 0.8551632166, 0.3027701676, 0.4815404415, 0.0709288567, 0.4738177061, 0.6032003164, 0.6594517231, 0.7161087394, 0.2173037231, 0.2599665225, 0.3804168105, 0.476133734, 0.5078952312, 0.8699969649, 0.5516405702, 0.8603464365, 0.9857818484, 0.3585600555, 0.0500799641, 0.7745358348, 0.4608804584, 0.2265810668, 0.834212482, 0.9297932386, 0.3621640205, 0.5930344462, 0.8654689193, 0.2204990834, 0.4176615179, 0.2209315449, 0.77527982, 0.5158697963, 0.9415253401, 0.2958724797, 0.8061077595, 0.5304133892, 0.0893381014, 0.9878226519, 0.3377200365, 0.6867077351, 0.4476513565, 0.5538997054, 0.5739765167, 0.3571768701, 0.4131403267, 0.0929111168, 0.55651021, 0.9651411772, 0.3798374832, 0.0632320791, 0.54989326, 0.1417344362, 0.1210399419, 0.017762851, 0.4034406841, 0.0922165886, 0.5885695815, 0.8250400424, 0.1410054564, 0.1222052276, 0.5145093203, 0.3669571579, 0.6265506744, 0.5228474736, 0.6551961899, 0.9257059097, 0.5194458961, 0.3653381765, 0.0294633694, 0.0354222544, 0.4401383102, 0.248149097, 0.5992058516, 0.7401285768, 0.885884583, 0.7719102502, 0.015121961, 0.5746850967, 0.4455586076, 0.8436070681, 0.4173793197, 0.3875162601, 0.7000482678, 0.1844448447, 0.3057107329, 0.2676621377, 0.3392877877, 0.4444096684, 0.4012240767, 0.9351375699, 0.3178731203, 0.1349570155, 0.6891089678, 0.5363838673, 0.9238854051, 0.4843406081, 0.8264052272, 0.3290589154, 0.2438129783, 0.4649564922, 0.4032748044, 0.0300827958, 0.4542402923, 0.376775831, 0.7134159207, 0.1657409966, 0.9967322946, 0.463362366, 0.2063730508, 0.4553405643, 0.2845554352, 0.4003728032, 0.9496721029, 0.5719822645, 0.8392899036, 0.0304997861, 0.5205277801, 0.0911632702, 0.049989339, 0.7010195255, 0.9202510715, 0.7321734428, 0.9610123634, 0.5609013438, 0.5010135174, 0.4444954097, 0.219840318, 0.2466250658, 0.4549592137, 0.1495590806, 0.9709001184, 0.7507070899, 0.2522841096, 0.7290827632, 0.5225729942, 0.8766907454, 0.3237386048, 0.618966043, 0.4427610636, 0.3849479258, 0.1568824649, 0.8203613758, 0.4653980434, 0.7652044892, 0.4826052189, 0.9296943545, 0.988021791, 0.7044270039, 0.8996956944, 0.7534894347, 0.2450878918, 0.6374186873, 0.0752013028, 0.1555137783, 0.4394538105, 0.5105174184, 0.7012284994, 0.2241654992, 0.3767915666, 0.0934778824, 0.6147289872, 0.2979862392, 0.2234163731, 0.1969837844, 0.3035095632, 0.3574070036, 0.9383932352, 0.6258143783, 0.938316226, 0.7566910982, 0.9049782753, 0.4750487506, 0.4910390675, 0.4398009479, 0.576213479, 0.6256769896, 0.3810784221, 0.9718868136, 0.0816104934, 0.3740687072, 0.743901968, 0.5902351737, 0.9540218115, 0.7133101225, 0.9791391492, 0.0507985614, 0.4420216084, 0.6248494387, 0.5034208298, 0.9062337279, 0.4590478539, 0.9563519359, 0.9566506743, 0.1338829398, 0.4563919008, 0.9957278371, 0.1856461763, 0.3339993954, 0.4809197485, 0.2929502726, 0.717679441, 0.0985678285, 0.2182638049, 0.3093981743, 0.7474626303, 0.9061188698, 0.671023488, 0.9993618727, 0.8222120404, 0.8543561101, 0.217311874, 0.756762445, 0.2481429428, 0.1177003682, 0.0282668062, 0.4208782613, 0.1810830086, 0.7177898884, 0.6889427304, 0.5673372149, 0.7197733521, 0.6740778685, 0.9462325573, 0.9223800898, 0.7216035128, 0.7357454896, 0.6583784223, 0.359680146, 0.5852091312, 0.0120691061, 0.3554546535, 0.4189505279, 0.5985988975, 0.0133819943, 0.1601126641, 0.3970699608, 0.3265931308, 0.077675879, 0.1438793987, 0.9221845269, 0.8603001237, 0.8481134772, 0.2103779465, 0.209949255, 0.5709760785, 0.6750032306, 0.9859799743, 0.9644153118, 0.7434251904, 0.9419956803, 0.9512263536, 0.6862620115, 0.6133762002, 0.1747208834, 0.1991396695, 0.5563628078, 0.4616844356, 0.7273113728, 0.1822764874, 0.8541821241, 0.4850552082, 0.0484853722, 0.9807727337, 0.9844093323, 0.7370347977, 0.9904833436, 0.1611956805, 0.7372457981, 0.3390260041, 0.5344291925, 0.7474996448, 0.5275216699, 0.1902983338, 0.279664427, 0.061049629, 0.2386909723, 0.7674853802, 0.7342913747, 0.363619864, 0.6287329197, 0.0470547155, 0.8481873274, 0.4714873433, 0.9730053544, 0.9766517878, 0.8406447768, 0.3762824237, 0.9858224392, 0.5772919059, 0.1027430445, 0.4636325538, 0.5047873259, 0.8323110938, 0.8190895915, 0.6579908133, 0.5425127745, 0.4359837472, 0.1914416552, 0.3090336025, 0.3940243423, 0.3814967573, 0.2863974869, 0.5668816566, 0.0048141344, 0.3945276141, 0.4284969866, 0.4679206312, 0.3583089411, 0.6822469234, 0.316054672, 0.3729407489, 0.5919202566, 0.8121685386, 0.5080659389, 0.6589282751, 0.3328192234, 0.9700210094, 0.1273731291, 0.229668811, 0.4794546366, 0.167547822, 0.4324451685, 0.9676478505, 0.5311928988, 0.3113810718, 0.7129261494, 0.6461684704, 0.0756587908, 0.3368423283, 0.8374305964, 0.2220462412, 0.1855718642, 0.4783749282, 0.6551553011, 0.6076968312, 0.3363366127, 0.4101237953, 0.4448086321, 0.5928441882, 0.8119885921, 0.4445488453, 0.7243288755, 0.3810153306, 0.9638563395, 0.54083848, 0.5058643818, 0.5885255337, 0.9752150178, 0.5600872636, 0.88301754, 0.0798128396, 0.9053880572, 0.4712941051, 0.6497660875, 0.4507645965, 0.6673766971, 0.7133527994, 0.2159910053, 0.0084344158, 0.6858344078, 0.9443193078, 0.7377422452, 0.8780963421, 0.1384434849, 0.7856494784, 0.5152956843, 0.4240128696, 0.5068760514, 0.5287197828, 0.5258048177, 0.1662804037, 0.5033773184, 0.1168889403, 0.3436156511, 0.2719661295, 0.8476766348, 0.2318153679, 0.9616276622, 0.4859198332, 0.4795930386, 0.277155906, 0.4795325994, 0.6116051674, 0.347063452, 0.3930682242, 0.6133131385, 0.4782887995, 0.5835899711, 0.8871667981, 0.4774041176, 0.9090421796, 0.2580033839, 0.8123038411, 0.8245674372, 0.3271803856, 0.7480770946, 0.1403973401, 0.2290938646, 0.6817570329, 0.0546809845, 0.315982312, 0.2598330081, 0.8642247915, 0.4841615558, 0.1427160501, 0.8543668389, 0.1379592121, 0.3617588878, 0.2347296178, 0.9176930189, 0.5909702182, 0.4116297066, 0.2329913378, 0.4446891844, 0.0723623484, 0.2920983136, 0.4300553501, 0.3281433284, 0.9396935105, 0.4636707604, 0.5373799205, 0.766669333, 0.9547126293, 0.6674847007, 0.6217921972, 0.2800422311, 0.6113741994, 0.2581831217, 0.8107113838, 0.4138760567, 0.4890097976, 0.9507597089, 0.8125252128, 0.9345319867, 0.256477356, 0.182751745, 0.7972067595, 0.1270797104, 0.816975832, 0.8379308581, 0.7362793684, 0.4217238426, 0.2488209456, 0.4310501218, 0.830722034, 0.3932117522, 0.850622654, 0.4821075797, 0.41166839, 0.2897019088, 0.6916832924, 0.5381910205, 0.962092638, 0.249994874, 0.9155715704, 0.4886517525, 0.8423064947, 0.7285782695, 0.7464314699, 0.6170300245, 0.2314840555, 0.4685018957, 0.3374244273, 0.8669199347, 0.7746947408, 0.793156445, 0.5985640287, 0.3626371622, 0.7060728073, 0.8677656651, 0.095016852, 0.931620121, 0.60414505, 0.5664063096, 0.8524709344, 0.3141123354, 0.8056180477, 0.587333262, 0.2671475708, 0.5725752115, 0.8379953504, 0.5832053423, 0.0888812169, 0.2255203873, 0.1762754768, 0.656938374, 0.3056329489, 0.6257125139, 0.9745829105, 0.8757616282, 0.2457380444, 0.431099385, 0.4766687751, 0.3253744543, 0.3752191365, 0.865837574, 0.0141341379, 0.4831534326, 0.8672434092, 0.3036774695, 0.838550508, 0.8431173563, 0.9773830175, 0.0220353529, 0.6942073703, 0.2914274335, 0.7381055355, 0.1923779398, 0.5319308639, 0.4835444391, 0.333610028, 0.7379875779, 0.5724130273, 0.0294773132, 0.1880078316, 0.433944732, 0.6408196688, 0.4933020771, 0.6970547438, 0.3242316246, 0.4152032733, 0.93419981, 0.8396334648, 0.3977614939, 0.6332161427, 0.2081637979, 0.4721533656, 0.9604850411, 0.1380777955, 0.048243966, 0.5506162643, 0.9098795652, 0.0957558826, 0.2242902368, 0.0983351544, 0.5391968489, 0.882432878, 0.4490297139, 0.4489945471, 0.7209504843, 0.1355364323, 0.1784058809, 0.6016484499, 0.4410499632, 0.4408858716, 0.6682451367, 0.9612405896, 0.7276591659, 0.637840569, 0.6854436398, 0.9506758451, 0.6711990237, 0.4868029654, 0.3220705986, 0.9669231772, 0.0850694478, 0.7843524218, 0.7350974679, 0.2146740556, 0.9742834568, 0.2213732302, 0.8762681484, 0.8600668907, 0.066833593, 0.4596683085, 0.9433848858, 0.361041069, 0.7110331059, 0.8381390572, 0.3911342025, 0.7709762454, 0.9853550196, 0.328812778, 0.9515877962, 0.8525200486, 0.2900376618, 0.639418602, 0.1162578017, 0.9362347722, 0.7002198696, 0.6981595755, 0.6356016994, 0.582822144, 0.6320328712, 0.0423277356, 0.2105759829, 0.7961422205, 0.4677138627, 0.7609971166, 0.3446505666, 0.6791944504, 0.8783214092, 0.9797452092, 0.8128815293, 0.2441538572, 0.5962013602, 0.7215726376, 0.3357588947, 0.1584632695, 0.0808582976, 0.7421919107, 0.2647459209, 0.1067559794, 0.9396389723, 0.5399952531, 0.242075935, 0.3401932418, 0.94829458, 0.1740137339, 0.8906546235, 0.5897881389, 0.1642927974, 0.0961570516, 0.7805370688, 0.8832169175, 0.489446044, 0.2167413831, 0.698323369, 0.6962680817, 0.8386267424, 0.0313055888, 0.6795799136, 0.9550771117, 0.4919249415, 0.7872869968, 0.4157477915, 0.3483664393, 0.1983267218, 0.6012227535, 0.3024815917, 0.535122633, 0.0609250739, 0.249480024, 0.9480771422, 0.2198663801, 0.2126268446, 0.3705193996, 0.8346916437, 0.8270356655, 0.9727078676, 0.0323539302, 0.4445431232, 0.4450592101, 0.9611444473, 0.3080556691, 0.2617457509, 0.7292874455, 0.1193473339, 0.1001462117, 0.7902913094, 0.0596965998, 0.9968909621, 0.5749673843, 0.4251702726, 0.1569124013, 0.3395343721, 0.3950080276, 0.3652063906, 0.0174267907, 0.5359101295, 0.1195266396, 0.0486422442, 0.877869308, 0.8146002293, 0.0167063754, 0.3572813869, 0.3127619028, 0.706422925, 0.6038604975, 0.2698771656, 0.6805381775, 0.5190973282, 0.1073414385, 0.8062596917, 0.8032501936, 0.1856200695, 0.9114516973, 0.0944496095, 0.2546859086, 0.2401405871, 0.4728344977, 0.9648797512, 0.5893321037, 0.5576858521, 0.3481232822, 0.0945585072, 0.6381896138, 0.1949055195, 0.6527691483, 0.9095736146, 0.3607141376, 0.5445485115, 0.4842854738, 0.2827373147, 0.1348775625, 0.2789441347, 0.8388562799, 0.1268759817, 0.5527347326, 0.8142587543, 0.4092592895, 0.2760647833, 0.6904397011, 0.2268581539, 0.0737444758, 0.5233128667, 0.3356019258, 0.8127546906, 0.167638123, 0.0961625129, 0.4309432209, 0.4931345284, 0.0758187175, 0.3106442094, 0.7043816447, 0.1580911875, 0.2360448688, 0.2543705702, 0.5382861495, 0.2221642137, 0.0146207483, 0.2620170116, 0.8492237329, 0.4924086034, 0.7259045243, 0.1783511043, 0.1624470055, 0.0984077081, 0.4531139433, 0.2366993427, 0.685026288, 0.6448300481, 0.8274722099, 0.0897763893, 0.3065722883, 0.8206403255, 0.9633809328, 0.4788635075, 0.3187713921, 0.003222829, 0.771397531, 0.7631881833, 0.9470386505, 0.1535011232, 0.0942638963, 0.6044945717, 0.8014805317, 0.9991723299, 0.5837679505, 0.4806862175, 0.538859725, 0.9995372295, 0.3176338971, 0.3117991686, 0.9587724209, 0.1803224087, 0.5125344992, 0.5671827793, 0.3978010416, 0.5753285885, 0.6354757547, 0.4403678179, 0.3724274039, 0.1003797725, 0.3434965014, 0.437376529, 0.3443910182, 0.4598889649, 0.1338540614, 0.9342237711, 0.2481911033, 0.9781090617, 0.9438737631, 0.5074093342, 0.1323044747, 0.037756972, 0.4687357843, 0.8416351676, 0.140180558, 0.4396491051, 0.8875662684, 0.0923208296, 0.7026885152, 0.8824400902, 0.9131188989, 0.1884187758, 0.5805519819, 0.084210217, 0.6626949906, 0.1777051538, 0.6922248006, 0.7608190179, 0.1256106198, 0.1444312185, 0.2503958642, 0.8018246889, 0.5259380937, 0.5674023628, 0.9871163964, 0.3510495424, 0.0578156598, 0.2405378968, 0.0759974495, 0.2578216195, 0.6539394855, 0.7198444009, 0.0253831148, 0.2085484713, 0.2555891275, 0.8574421406, 0.8061947823, 0.7883300185, 0.7374021411, 0.4412709773, 0.518255949, 0.1814599186, 0.4829825163, 0.7223602533, 0.8123971224, 0.3735327721, 0.5997964144, 0.2294329703, 0.0976012796, 0.9362025261, 0.0727647766, 0.1982873082, 0.2486504018, 0.4970142245, 0.6135889292, 0.5866930485, 0.7806620598, 0.35382092, 0.3620573282, 0.427770406, 0.6942183375, 0.3908770382, 0.3935398459, 0.9744939208, 0.3427796066, 0.7350586057, 0.5315275192, 0.8318429589, 0.3563607037, 0.3339850008, 0.1535255462, 0.7680259347, 0.0571767911, 0.1175855249, 0.7937267423, 0.5988506079, 0.6767882109, 0.7536016703, 0.2283532917, 0.0489633419, 0.0630292743, 0.2855349481, 0.3330864012, 0.0763960108, 0.7449605465, 0.7582602501, 0.8074395061, 0.7624371052, 0.8774601817, 0.3936000466, 0.2269419134, 0.1247892454, 0.4588497579, 0.7377902269, 0.9872066975, 0.9756523371, 0.2382634282, 0.666928947, 0.4485808313, 0.8125393391, 0.1628699899, 0.2217127383, 0.1648612767, 0.8512941003, 0.5740059018, 0.934302032, 0.7131489515, 0.5580295324, 0.8603314161, 0.4995054305, 0.7676098943, 0.5554981232, 0.7536829114, 0.7116505504, 0.9476801157, 0.3018324375, 0.8664983511, 0.9348188639, 0.4759433568, 0.4701786041, 0.5058752894, 0.5095126629, 0.1311616153, 0.8654143214, 0.3166510463, 0.5378813744, 0.2013948709, 0.0993477255, 0.4519537091, 0.9983737469, 0.1207369864, 0.6530140638, 0.7837896347, 0.7238932252, 0.3284585476, 0.3622599542, 0.0752364397, 0.3907876611, 0.6253241897, 0.2432800531, 0.6425753832, 0.3214516342, 0.429987818, 0.8175384998, 0.3163611591, 0.9293256402, 0.8103592992, 0.7277007103, 0.4727446139, 0.8018363714, 0.6558837295, 0.8454443812, 0.1660367996, 0.216480419, 0.0496755987, 0.6659568548, 0.4616822302, 0.6498546004, 0.3592532575, 0.1597846895, 0.4006915689, 0.3373423219, 0.4660783708, 0.6921073794, 0.9315503836, 0.4527882934, 0.7930449843, 0.6267275214, 0.4539354146, 0.2994103432, 0.2003165781, 0.0871245041, 0.6667624712, 0.5696305037, 0.682433784, 0.360532105, 0.161556378, 0.2643332481, 0.7145193219, 0.2466212362, 0.9364427328, 0.4457659125, 0.8910381198, 0.9924890399, 0.1392472088, 0.8901849389, 0.3864786029, 0.1517654657, 0.0765987635, 0.32660532, 0.2312912792, 0.0069322316, 0.0878866166, 0.9894841909, 0.2040011138, 0.733763814, 0.2110845, 0.6273645163, 0.1985735446, 0.0254147574, 0.8889908791, 0.0073242798, 0.5627350807, 0.5844052434, 0.8754569292, 0.0123460963, 0.6318338513, 0.8050666451, 0.4450735152, 0.5133627653, 0.0196723938, 0.9419804215, 0.0577819645, 0.9805383086, 0.952837944, 0.3217454851, 0.6840943694, 0.1429686695, 0.8581956029, 0.6390916705, 0.9005090594, 0.5938857794, 0.4355608523, 0.3769831061, 0.7763158679, 0.6176721454, 0.220953688, 0.0212988835, 0.0865329951, 0.8693550229, 0.8441941142, 0.5100947618, 0.8796753883, 0.8336679935, 0.3645589054, 0.4451568723, 0.8358271718, 0.6758773327, 0.6004961729, 0.6701435447, 0.1521773338, 0.1673108637, 0.8883163333, 0.8515177965, 0.9166519046, 0.9826393127, 0.5249327421, 0.9182383418, 0.9364526272, 0.7881016135, 0.2090890706, 0.756629467, 0.8035737276, 0.9582333565, 0.1049007997, 0.2908365726, 0.5890104175, 0.8243371844, 0.1194223389, 0.4081142545, 0.2338810265, 0.6160389185, 0.611948669, 0.4776177406, 0.0227558762, 0.9259954095, 0.1666756123, 0.0716510937, 0.4589239061, 0.2758954763, 0.9412941337, 0.5593962073, 0.0932300612, 0.6230918765, 0.8459309936, 0.5486456156, 0.0464796945, 0.9127272367, 0.3356038034, 0.7685136199, 0.5551348925, 0.6268597245, 0.6607300043, 0.6237701774, 0.2467627674, 0.6620935798, 0.5111476183, 0.7794272304, 0.3487963974, 0.3341582417, 0.062405698, 0.3957013488, 0.7614648938, 0.4593580365, 0.6479206681, 0.8111057281, 0.9376099706, 0.6937710047, 0.3772794604, 0.4229111671, 0.4413614571, 0.1265666485, 0.4300340414, 0.4679362178, 0.7703757286, 0.606009841, 0.1987234205, 0.1677688062, 0.9635212421, 0.4137647152, 0.4632101953, 0.2615934312, 0.9184596539, 0.2104500234, 0.5944142938, 0.3657301962, 0.1276734024, 0.9990953207, 0.8774257898, 0.0335525461, 0.6755540371, 0.7107648849, 0.7014051676, 0.9966768622, 0.7137983441, 0.4623017013, 0.7589473724, 0.9008278251, 0.829320848, 0.613184154, 0.0364639089, 0.361007899, 0.265086323, 0.8528714776, 0.0846442133, 0.1303368062, 0.7339023948, 0.2469002753, 0.8481484056, 0.570977211, 0.5678458214, 0.7875075936, 0.9358733296, 0.7294030786, 0.4321549237, 0.5476644635, 0.0062022726, 0.5369589329, 0.8516149521, 0.2920427024, 0.7357532382, 0.2664783895, 0.6757333875, 0.7338925004, 0.848256588, 0.9381582141, 0.3306468129, 0.6813066006, 0.1940691769, 0.5831599236, 0.262194097, 0.8393519521, 0.7582423687, 0.6250113845, 0.1029042825, 0.3049384058, 0.114788115, 0.277890116, 0.1158706546, 0.2541174591, 0.441350013, 0.4687660635, 0.8511252999, 0.8545516133, 0.4600425065, 0.3129352927, 0.4309563637, 0.9128248096, 0.2374057472, 0.1449033916, 0.2247983068, 0.1139339134, 0.7892076373, 0.9811329842, 0.7229756713, 0.4996600151, 0.3327669501, 0.2376016527, 0.192488268, 0.9562231302, 0.638376236, 0.7746983171, 0.6095607877, 0.1264629215, 0.3252653182, 0.6244151592, 0.8594142795, 0.9114995003, 0.2029479444, 0.4649728835, 0.8383985758, 0.9478753209, 0.4653606117, 0.7175844312, 0.0369942226, 0.9802376628, 0.8346555829, 0.5406475663, 0.9916311502, 0.2031923532, 0.0845073089, 0.5141957998, 0.3817309737, 0.936907351, 0.2497378141, 0.3190106452, 0.3978219926, 0.3709410429, 0.6247541904, 0.5197868347, 0.9216369987, 0.1635272056, 0.1833685786, 0.2327118516, 0.1730478704, 0.6909444928, 0.0854606628, 0.5745798945, 0.5908014774, 0.2927988172, 0.4878441393, 0.8586933613, 0.5167756677, 0.6894454956, 0.8916371465, 0.3964881003, 0.9860044718, 0.9942120314, 0.095366843, 0.7742109895, 0.2737941444, 0.8385732174, 0.6917213202, 0.3581351638, 0.9537432194, 0.9525402188, 0.6977182031, 0.4957823455, 0.4505446553, 0.1610960215, 0.4250429869, 0.3574729562, 0.9883974791, 0.9719611406, 0.2679769099, 0.9791812301, 0.570961535, 0.8454045057, 0.481387645, 0.4942132235, 0.7109752893, 0.7994604707, 0.4398852289, 0.3708130419, 0.1553531587, 0.683996439, 0.5957900286, 0.5644886494, 0.3234615326, 0.2455180883, 0.560402751, 0.6479611397, 0.2143692672, 0.1001929939, 0.4399291277, 0.1362857223, 0.4006000757, 0.9352084398, 0.9691118002, 0.2800741792, 0.4347353876, 0.6775333881, 0.4759157002, 0.9522026777, 0.6314189434, 0.4368703961, 0.730632484, 0.6146345735, 0.5676653981, 0.6176615953, 0.4205251038, 0.5016265512, 0.9025579095, 0.7031668425, 0.2271645963, 0.2319591343, 0.1156300306, 0.5132398605, 0.6020544171, 0.7331430316, 0.195632115, 0.4690348804, 0.437746793, 0.5987631679, 0.4761746526, 0.4909768701, 0.46061939, 0.0851616934, 0.8352513909, 0.8645496368, 0.1553876549, 0.4663003385, 0.1310831159, 0.4509260356, 0.2993837595, 0.0253132004, 0.3018710017, 0.5657193065, 0.4945896268, 0.0871900693, 0.267522037, 0.1069414318, 0.861140132, 0.3497680724, 0.9007937312, 0.5912517905, 0.3611748219, 0.6403226256, 0.1201638058, 0.8576251268, 0.8542069793, 0.381444633, 0.4951846004, 0.3692566752, 0.3071427643, 0.8993784189, 0.5468031168, 0.5076970458, 0.4790928364, 0.4134563208, 0.6398875117, 0.452014327, 0.3022944033, 0.2004839629, 0.378529191, 0.3368770182, 0.8978018165, 0.511844635, 0.7467024922, 0.1707707047, 0.9671769738, 0.5305405855, 0.9875631928, 0.8132194877, 0.1337793171, 0.5579952598, 0.637620151, 0.7767909169, 0.5033586621, 0.6321769953, 0.7027930021, 0.7520409226, 0.9649431109, 0.848831296, 0.2216664106, 0.7385339737, 0.4746312201, 0.7217161059, 0.1007732823, 0.2756705582, 0.2097121328, 0.3803449869, 0.0996471271, 0.1247078553, 0.1910810173, 0.9140561223, 0.9149492979, 0.2098353654, 0.0767227113, 0.8985806108, 0.5108911395, 0.057973519, 0.0932726488, 0.8484842181, 0.6559702754, 0.1479938924, 0.5624613762, 0.0650652051, 0.4862146974, 0.3929865956, 0.1172559559, 0.3398821056, 0.138484478, 0.1928209513, 0.0195196439, 0.6771742702, 0.0458020084, 0.7051184177, 0.3182299137, 0.2961904705, 0.9633932114, 0.9399008155, 0.9739258885, 0.4551944137, 0.3778558969, 0.2500957251, 0.8838933706, 0.0593246184, 0.1153664067, 0.4514839947, 0.1898387372, 0.87777704, 0.2831133604, 0.957149148, 0.1251278818, 0.001161312, 0.9415122271, 0.3109248579, 0.8637772799, 0.1987070292, 0.7606064677, 0.8804537654, 0.9864602089, 0.624268055, 0.9054766297, 0.0135219246, 0.4445034862, 0.7930389047, 0.4553536177, 0.9931444526, 0.5695111156, 0.9076140523, 0.3628516495, 0.2413775772, 0.2246656269, 0.2492729127, 0.2140420377, 0.8332853317, 0.4634194374, 0.3134782612, 0.3238672316, 0.1031284779, 0.0113073327, 0.2099336833, 0.6925781369, 0.5516031384, 0.5016957521, 0.9267175198, 0.3327459395, 0.4775586426, 0.8115748763, 0.9885401726, 0.2994841039, 0.7220330834, 0.730132401, 0.7197967172, 0.7332207561, 0.4420665503, 0.9687745571, 0.3987165093, 0.2138202488, 0.3549204767, 0.488162756, 0.5687426925, 0.4792328179, 0.4545526505, 0.7456848025, 0.8266603351, 0.736366272, 0.5405669808, 0.1186807007, 0.5594927669, 0.1221431792, 0.7213705182, 0.3600413799, 0.1001317799, 0.4034047723, 0.4291865528, 0.838875711, 0.7330092788, 0.1052424833, 0.2259417027, 0.1105057597, 0.2018852979, 0.3272077143, 0.8765095472, 0.0674096793, 0.8788019419, 0.7016536593, 0.6269735098, 0.222511217, 0.4780000448, 0.6294401884, 0.1244457513, 0.6985848546, 0.4502319098, 0.3785289526, 0.7983933687, 0.8313836455, 0.5055503845, 0.3313944042, 0.6351121068, 0.1403211802, 0.4739008844, 0.0747067481, 0.8008176088, 0.715456605, 0.0499024726, 0.0813915581, 0.1123222411, 0.5307773948, 0.1312803179, 0.8110383153, 0.8392069936, 0.5230840445, 0.28363657, 0.0054080924, 0.8937095404, 0.0980529264, 0.130206272, 0.8063662648, 0.3854928613, 0.7761619687, 0.3354136944, 0.1252057105, 0.6662501097, 0.3357446194, 0.7088520527, 0.0770222023, 0.4251736403, 0.5111199021, 0.6855781674, 0.4052618742, 0.3323065042, 0.8265476227, 0.116719164, 0.6723505259, 0.670193851, 0.9685565233, 0.0711848959, 0.5260928273, 0.6076920629, 0.3108952641, 0.8435906768, 0.9416271448, 0.9846994877, 0.1855924129, 0.5663276911, 0.4537580013, 0.8979920745, 0.7847290039, 0.7361888885, 0.1889137328, 0.1929481924, 0.023226507, 0.3375096023, 0.6617968082, 0.2212614119, 0.9393060803, 0.5212082863, 0.8870098591, 0.353792429, 0.583262682, 0.1242193878, 0.8544337153, 0.8400560617, 0.0959598795, 0.3635807037, 0.1118642092, 0.6802095771, 0.5064644217, 0.9823185205, 0.6989775896, 0.7123054862, 0.404560715, 0.4966390133, 0.8842440248, 0.8391990066, 0.6193109155, 0.8753837347, 0.1364841759, 0.447566241, 0.2754028141, 0.6013192534, 0.1445985585, 0.5003407001, 0.1361014396, 0.9297602177, 0.8518981934, 0.0815051123, 0.0945660397, 0.0012459117, 0.6253946424, 0.937194705, 0.0474925898, 0.8939760327, 0.6494599581, 0.1971486658, 0.3466871679, 0.7588170767, 0.6341680288, 0.1042030975, 0.3886485994, 0.2138887793, 0.5676799417, 0.2615441382, 0.9391229749, 0.8828005791, 0.8169338703, 0.8846142888, 0.6647264957, 0.1761172116, 0.9707154036, 0.2150721848, 0.9363744259, 0.924474895, 0.5471165776, 0.5807911158, 0.3485389054, 0.9248163104, 0.8228940368, 0.0052462667, 0.3914928734, 0.2096524388, 0.0005516103, 0.7375964522, 0.2354965359, 0.417676121, 0.3314989209, 0.8970170617, 0.4880024791, 0.0816915706, 0.7369010448, 0.9373006225, 0.36960572, 0.8428009748, 0.0736789331, 0.2280396521, 0.5821270943, 0.058471933, 0.3581435382, 0.1616331041, 0.6217598915, 0.9673713446, 0.3144538701, 0.4228736758, 0.050174538, 0.1365508884, 0.1239498556, 0.3767664135, 0.1245062351, 0.941139102, 0.559743464, 0.2432802618, 0.1177022383, 0.9828823805, 0.5732818246, 0.5690141916, 0.741057992, 0.7377525568, 0.5536352992, 0.312779665, 0.0813401341, 0.5995092988, 0.6044751406, 0.8976248503, 0.8933287859, 0.4303652644, 0.3695982993, 0.3806284964, 0.1915928125, 0.3295152187, 0.2113520205, 0.6142043471, 0.2390473187, 0.2425870448, 0.4643111229, 0.7850609422, 0.6896291971, 0.2183747143, 0.6610050201, 0.813567698, 0.5605117083, 0.2067536861, 0.4337595701, 0.8145171404, 0.6546877623, 0.6641609669, 0.2240635902, 0.3341553807, 0.2463578731, 0.3477292061, 0.6060934067, 0.3568925858, 0.9741356373, 0.1253962219, 0.9572333097, 0.3292025626, 0.1934153736, 0.3506695628, 0.3197994232, 0.7673865557, 0.3394889832, 0.9738976359, 0.0118315266, 0.2237675339, 0.987000227, 0.7293080688, 0.8434551954, 0.4114209414, 0.5717520118, 0.7320540547, 0.0851389915, 0.8259694576, 0.262365967, 0.1792937368, 0.2053468823, 0.6026678085, 0.696639955, 0.6216934919, 0.7105730176, 0.3972368538, 0.0794398263, 0.3343624175, 0.9353908896, 0.9383234382, 0.685888052, 0.6926443577, 0.5899420381, 0.2411883324, 0.0054839212, 0.627769053, 0.5622318387, 0.1236412749, 0.1567172706, 0.2633028924, 0.3694952726, 0.6559251547, 0.2420992255, 0.3786820769, 0.4614876509, 0.6046964526, 0.0808842182, 0.9537930489, 0.6488133669, 0.4923732281, 0.3406393826, 0.4382499754, 0.3532691002, 0.396445483, 0.5908070207, 0.1699593812, 0.4565968812, 0.8477159739, 0.2887396812, 0.0889187157, 0.3336563408, 0.2646266222, 0.4892828465, 0.5698387623, 0.9159831405, 0.3048604727, 0.9648923278, 0.7392615676, 0.0243725926, 0.1714320779, 0.108499907, 0.0367825441, 0.371009618, 0.9211341739, 0.2153574228, 0.5695092678, 0.7773594856, 0.589655757, 0.5982893705, 0.0694507286, 0.9977914691, 0.3256978691, 0.7132851481, 0.9346677065, 0.811414063, 0.5519405007, 0.6570034027, 0.7136706114, 0.5569085479, 0.4026521444, 0.2814316452, 0.586151123, 0.6899533868, 0.2677451372, 0.873093307, 0.3686316013, 0.4344552159, 0.0909462199, 0.2535964251, 0.7624672055, 0.8116710782, 0.8147524595, 0.939498961, 0.2248317301, 0.2147198766, 0.5063940883, 0.5379254818, 0.3599090576, 0.6583744884, 0.3434786797, 0.424459666, 0.7596738935, 0.2084387541, 0.5009082556, 0.6744301915, 0.5992817879, 0.1896120608, 0.7406286597, 0.248678714, 0.4530976117, 0.6744608879, 0.2095753551, 0.4823930264, 0.7823876739, 0.3765383661, 0.9853712916, 0.2303975374, 0.4578667283, 0.2903458178, 0.1877734661, 0.6396134496, 0.3907129467, 0.455760628, 0.4524177611, 0.1143905967, 0.4972776771, 0.1982475221, 0.5681200027, 0.7287925482, 0.3329362273, 0.1402145177, 0.7971151471, 0.3701738715, 0.8660424352, 0.9241887331, 0.6609226465, 0.137549594, 0.9839039445, 0.1976160854, 0.0645802096, 0.2378273159, 0.2878572941, 0.7316655517, 0.9580275416, 0.8398702741, 0.1477702707, 0.2122959942, 0.8661295772, 0.8981107473, 0.8248787522, 0.9845820069, 0.4242613018, 0.4454645216, 0.6181744933, 0.2368302345, 0.903054893, 0.793505013, 0.257386744, 0.3478713036, 0.2280597687, 0.7250045538, 0.8665587306, 0.6154014468, 0.0533810966, 0.3748954833, 0.4587683678, 0.286778003, 0.7520769835, 0.0273093954, 0.0042338748, 0.1857025921, 0.7098686099, 0.3267929554, 0.3929757178, 0.6830078363, 0.5508182645, 0.1895754188, 0.6147466898, 0.5261494517, 0.7503330112, 0.6770864725, 0.7391172647, 0.5067530274, 0.5356315374, 0.1920151412, 0.2963668108, 0.1455132812, 0.3366815448, 0.8031961918, 0.4450727999, 0.5501939058, 0.8613340259, 0.9883643985, 0.6972109675, 0.9742780924, 0.1099400893, 0.2395523489, 0.9988744259, 0.1077969074, 0.415316999, 0.0588932708, 0.9196064472, 0.8149036169, 0.8517987728, 0.0252866689, 0.0953830108, 0.2633779049, 0.7283058763, 0.8969675303, 0.16720891, 0.3223496377, 0.6078441143, 0.4913718998, 0.175703153, 0.1439203322, 0.5155597329, 0.9438691735, 0.2287101299, 0.4516201913, 0.3377495408, 0.4717217982, 0.8018072844, 0.8219818473, 0.8504306674, 0.3374880254, 0.2135060281, 0.2922736406, 0.8710723519, 0.3306492865, 0.0082137948, 0.369856298, 0.1283289045, 0.5767781734, 0.4584751427, 0.5883739591, 0.1277351826, 0.6547388434, 0.115970999, 0.7972878218, 0.4853661358, 0.3138843179, 0.29071486, 0.5912071466, 0.6736337543, 0.6416894197, 0.0878887698, 0.03327794, 0.5049689412, 0.4261991978, 0.7340114713, 0.8835486174, 0.8107994795, 0.8632270098, 0.5172512531, 0.4250636101, 0.924592495, 0.0804544538, 0.8521693349, 0.2593485713, 0.8861954808, 0.9965476394, 0.7498392463, 0.5007619262, 0.4783139229, 0.8900547028, 0.9759549499, 0.9762283564, 0.5782196522, 0.6812186837, 0.836945653, 0.1108711287, 0.9366273284, 0.7295014858, 0.8142197132, 0.2871185243, 0.4120090902, 0.1552238762, 0.6241229773, 0.5901588798, 0.2742916346, 0.1171537116, 0.382486403, 0.5003535748, 0.4441032708, 0.0590588301, 0.6863034964, 0.9412550926, 0.1030604541, 0.0928372443, 0.5788758993, 0.860093832, 0.2622856796, 0.3243178129, 0.8198421597, 0.0608036108, 0.1628451347, 0.8431297541, 0.9489488006, 0.6022754312, 0.8219873309, 0.4523790479, 0.1439618915, 0.8226832747, 0.432598561, 0.7620059252, 0.923332274, 0.7550235391, 0.7420312762, 0.4091481268, 0.0080681676, 0.2857249677, 0.9518624544, 0.3186929524, 0.7156636715, 0.4819736481, 0.5875384808, 0.9693861008, 0.9397718906, 0.0921026245, 0.2843349874, 0.5598794818, 0.048646789, 0.9986028671, 0.500031054, 0.449287653, 0.4568943977, 0.9110516906, 0.7378745675, 0.7045658231, 0.0468285158, 0.8894015551, 0.462718457, 0.9816171527, 0.8598627448, 0.3145548701, 0.436226964, 0.8303482533, 0.9762394428, 0.267931819, 0.5415852666, 0.5135583282, 0.6443652511, 0.3441093564, 0.0424862392, 0.0372759365, 0.4417820573, 0.3755637109, 0.2501712143, 0.2316745967, 0.7696728706, 0.6399767399, 0.7234238982, 0.7173735499, 0.4333938062, 0.2061416209, 0.2962370515, 0.2198407352, 0.4978379905, 0.913132906, 0.588127315, 0.0274527725, 0.6304520369, 0.0822640583, 0.7789397836, 0.2952448726, 0.9690179825, 0.630638659, 0.9882766008, 0.055966381, 0.7868189812, 0.475271672, 0.4644761384, 0.7389196754, 0.7591849566, 0.9672090411, 0.7063110471, 0.3089451194, 0.5869594216, 0.0322247148, 0.3714854717, 0.5593369603, 0.5605016947, 0.4590870738, 0.1472124606, 0.759714663, 0.113770023, 0.0231368188, 0.0824881941, 0.8750936389, 0.8093255758, 0.8402462602, 0.9431380033, 0.3831848502, 0.801948607, 0.2096938789, 0.1450119019, 0.384465456, 0.374266535, 0.2803847492, 0.5975660086, 0.361436516, 0.238648802, 0.3639670908, 0.461366266, 0.6767667532, 0.3152884841, 0.7785329819, 0.7170776725, 0.1606929004, 0.0003200504, 0.1895649135, 0.8482950926, 0.5920988917, 0.5268387794, 0.0284580551, 0.4860107303, 0.0186922047, 0.8770759702, 0.6451025009, 0.7139035463, 0.9079555869, 0.1674161255, 0.5850836635, 0.5902752876, 0.7807475924, 0.132802844, 0.3550823927, 0.8763128519, 0.1409061104, 0.816932559, 0.9549198747, 0.8043766618, 0.2520909905, 0.2921890914, 0.2164543271, 0.1631576717, 0.3762800395, 0.9681814313, 0.5349851847, 0.1762493998, 0.1457073689, 0.4141866267, 0.7167933583, 0.0741236061, 0.3502106965, 0.49942559, 0.6865019798, 0.6151999831, 0.6936876774, 0.4316572845, 0.8288618326, 0.3615471125, 0.1165324077, 0.1875971407, 0.8852591515, 0.9565691352, 0.6450730562, 0.6239424944, 0.0546527803, 0.5138095617, 0.3606646657, 0.739915967, 0.8311212659, 0.2305879593, 0.995737493, 0.7951257825, 0.8651072383, 0.3753368855, 0.9134725332, 0.7602509856, 0.9706268311, 0.8244435787, 0.3721625209, 0.6374471784, 0.5216542482, 0.3955391943, 0.2386873513, 0.0774426162, 0.5409342647, 0.4465825558, 0.4333544374, 0.605427146, 0.223706916, 0.7153035998, 0.0594313666, 0.0070756031, 0.2461550236, 0.1136701703, 0.9059683681, 0.3941738605, 0.1404842287, 0.0317301974, 0.7502588034, 0.5847977996, 0.0649694577, 0.1061957181, 0.5282829404, 0.4730309546, 0.2068706751, 0.1621830612, 0.1909047812, 0.8948611617, 0.9865431786, 0.7400736213, 0.1817373633, 0.4399060607, 0.1900535673, 0.8541012406, 0.2264830172, 0.8624314666, 0.5312672853, 0.6027213335, 0.5833280683, 0.4415327907, 0.0209361687, 0.8725429177, 0.2334536612, 0.5764690638, 0.9340544939, 0.5233708024, 0.1558216959, 0.0848767087, 0.5894972086, 0.8474051356, 0.8646258712, 0.1642981768, 0.9041957855, 0.3494294882, 0.4702101052, 0.5831885934, 0.870003581, 0.687251091, 0.4935644567, 0.9922966361, 0.4028345346, 0.4728413522, 0.9360169172, 0.355086267, 0.9761881232, 0.9902327657, 0.2360545397, 0.9305037856, 0.854444623, 0.4889979362, 0.5349009037, 0.5605379939, 0.0027216305, 0.4967855513, 0.778866291, 0.1598034203, 0.7722503543, 0.2635759115, 0.4510564208, 0.9028128386, 0.8464687467, 0.0689743459, 0.0221440047, 0.0927997679, 0.6848770976, 0.0185078271, 0.4341053963, 0.9401435256, 0.1077991053, 0.3218205273, 0.8370077014, 0.4700568318, 0.2065735161, 0.1232072338, 0.482139498, 0.4384912848, 0.2750694156, 0.1081104428, 0.7501275539, 0.8727841973, 0.6592043638, 0.5953353643, 0.5154623985, 0.236922428, 0.5137948394, 0.2640386522, 0.4883022904, 0.4222793877, 0.4547099471, 0.8611297011, 0.0144379279, 0.2389405966, 0.819467783, 0.8239278793, 0.7628059387, 0.7923669815, 0.5518986583, 0.7996187806, 0.8428180814, 0.0249920711, 0.7157523036, 0.0713605061, 0.6955949664, 0.4699112177, 0.0088879559, 0.6098486781, 0.6564207077, 0.5613965392, 0.8421915174, 0.6314644814, 0.4711484611, 0.3293690085, 0.5417262316, 0.2409638166, 0.8098592758, 0.7550401688, 0.6757278442, 0.3804965019, 0.9431912899, 0.4660125971, 0.346999526, 0.049549982, 0.1130461022, 0.4922482669, 0.8316611052, 0.0151698245, 0.0455924571, 0.0121565908, 0.950856626, 0.9071891904, 0.2990972698, 0.1534688324, 0.4337702692, 0.0883032233, 0.0341987051, 0.8537461758, 0.9790410399, 0.0959524885, 0.3532785475, 0.4711985588, 0.4264074564, 0.6033026576, 0.4930888712, 0.3830340505, 0.808139503, 0.8650298715, 0.3055000603, 0.9386534095, 0.618591547, 0.7397578359, 0.8365952373, 0.1950814277, 0.4230749309, 0.4665976763, 0.3757816553, 0.7839651704, 0.2714221776, 0.0238825232, 0.9983488917, 0.2932229638, 0.1275342405, 0.2862882614, 0.5271909833, 0.6195485592, 0.7636455894, 0.0629235059, 0.7156965733, 0.2240773588, 0.382779181, 0.9618224502, 0.1208055168, 0.7182992101, 0.8265799284, 0.9834881425, 0.8465484977, 0.5064244866, 0.733488977, 0.3593994975, 0.2179753631, 0.2499547899, 0.483287096, 0.8165280819, 0.6433015466, 0.1011388898, 0.2491493225, 0.6251221895, 0.8351825476, 0.8837730885, 0.7009636164, 0.9816825986, 0.6400768161, 0.1942286044, 0.4964185357, 0.3493340313, 0.5624901056, 0.4142114818, 0.6982345581, 0.0816430375, 0.8636327982, 0.3288758397, 0.3235695958, 0.0303881895, 0.7907371521, 0.6138248444, 0.7707505822, 0.2155624926, 0.3126775026, 0.0312359128, 0.2055072635, 0.57894665, 0.2451235205, 0.6063526869, 0.9235547185, 0.3514375687, 0.494853735, 0.1510845274, 0.6556584239, 0.2413987219, 0.3424600959, 0.9098784328, 0.094034031, 0.1902333796, 0.6079003215, 0.6011973619, 0.5664134622, 0.9802165627, 0.4605019987, 0.7017213702, 0.2302764356, 0.0650736094, 0.1494943053, 0.6371325254, 0.0086101834, 0.7200685143, 0.0810939893, 0.5592622757, 0.4485433698, 0.6802972555, 0.6205402613, 0.165334031, 0.6748952866, 0.4643500447, 0.1593366861, 0.7041004896, 0.7166278362, 0.1366539598, 0.5593001246, 0.444014281, 0.622951746, 0.5157993436, 0.5213665962, 0.1731904, 0.1288991719, 0.8259183168, 0.5144808292, 0.9389974475, 0.78816998, 0.7169192433, 0.3419306278, 0.2688764632, 0.8584477901, 0.6510105729, 0.2690030634, 0.2007313818, 0.6019917727, 0.3356880546, 0.0651813149, 0.5939823985, 0.6929972768, 0.9691227674, 0.6415561438, 0.7519631386, 0.4215687215, 0.1228209287, 0.584718883, 0.5488744974, 0.6373246908, 0.047434248, 0.1138400808, 0.9913181067, 0.162934795, 0.4973835349, 0.6254672408, 0.6227023005, 0.8053219914, 0.0934493616, 0.7392053604, 0.0407494158, 0.6953820586, 0.1026247442, 0.3242538273, 0.9589509368, 0.0437330976, 0.5770876408, 0.5448153615, 0.3181137741, 0.7390189171, 0.312196672, 0.4732785225, 0.9423683882, 0.5617355704, 0.9677296281, 0.1870141178, 0.9401267767, 0.8919708729, 0.3776246309, 0.9423304796, 0.6372370124, 0.3747296929, 0.1637496799, 0.3287710547, 0.1781536341, 0.2898077965, 0.1956719011, 0.2145705819, 0.286423862, 0.9346353412, 0.7648710012, 0.6211333275, 0.4202655554, 0.6675941944, 0.3724445105, 0.2103198916, 0.9429937005, 0.6409393549, 0.9144501686, 0.9311948419, 0.0387277342, 0.7028912902, 0.8848278522, 0.7504281998, 0.7315697074, 0.816655457, 0.3738918602, 0.1557686031, 0.7847886682, 0.4125709236, 0.5739986897, 0.8182309866, 0.4204152524, 0.9961208105, 0.1337789744, 0.8342238665, 0.7159512043, 0.0682141855, 0.78180933, 0.6113092899, 0.1265794486, 0.3459638655, 0.1549623311, 0.4131218791, 0.4264710248, 0.2668181062, 0.9455268383, 0.7712184191, 0.132066682, 0.4694555104, 0.0086664017, 0.4457104802, 0.7159432769, 0.0337547176, 0.2647216618, 0.4527841508, 0.8764959574, 0.5165018439, 0.874920547, 0.3994765878, 0.2661662698, 0.9404622316, 0.7213953137, 0.0779966936, 0.7699434161, 0.9601191878, 0.5917244554, 0.743603766, 0.7265306115, 0.5331710577, 0.9649403095, 0.7461229563, 0.1577638239, 0.1233422831, 0.4796034992, 0.2960034311, 0.5717763305, 0.0491046421, 0.5753382444, 0.4763813615, 0.6436579823, 0.9660188556, 0.4250706732, 0.1054467559, 0.7750216722, 0.6982519031, 0.2201368511, 0.9212501645, 0.9318611622, 0.8586993217, 0.4595151246, 0.4544635117, 0.8432085514, 0.9247248173, 0.0365047753, 0.9654330015, 0.8264771104, 0.0376608036, 0.4492781758, 0.1058536917, 0.3432896435, 0.2352729738, 0.9503269792, 0.0749945343, 0.223455593, 0.9738846421, 0.7322180271, 0.2067189217, 0.8659912348, 0.964232564, 0.5460907817, 0.958563745, 0.0354396738, 0.616974175, 0.7099645734, 0.9816644788, 0.4517419636, 0.0953767225, 0.5571715236, 0.6565949321, 0.0623320453, 0.6225028038, 0.6433296204, 0.0129790707, 0.7715957165, 0.8371360898, 0.4941186309, 0.9075725675, 0.1588838398, 0.4867556989, 0.7108978629, 0.7019207478, 0.0364425257, 0.7733047605, 0.2023717612, 0.3168994784, 0.3704363108, 0.9331393242, 0.4755581915, 0.8266717196, 0.9457639456, 0.6074644327, 0.9668362737, 0.9510031939, 0.5254657865, 0.1426365823, 0.5963256955, 0.7344507575, 0.8503690958, 0.2499096096, 0.7108363509, 0.94082582, 0.9992586374, 0.5567165017, 0.9616196156, 0.2910158932, 0.1227196753, 0.5921880007, 0.9253353477, 0.461474508, 0.7173299789, 0.8424515724, 0.6755405664, 0.9408789873, 0.9209164381, 0.1908068508, 0.2003200054, 0.3124685287, 0.8087954521, 0.524261117, 0.6289529204, 0.6980254054, 0.1620536894, 0.7590764761, 0.6776715517, 0.416780442, 0.4525309503, 0.6873601079, 0.6441275477, 0.2402851582, 0.8918765187, 0.7217081785, 0.6020851731, 0.6847493052, 0.8492304683, 0.7355428934, 0.0947460234, 0.3588216007, 0.8229489326, 0.8866733909, 0.3527204394, 0.4839482009, 0.9514900446, 0.9171634316, 0.5798678398, 0.8700700402, 0.2567514181, 0.2472462505, 0.9536755085, 0.5097897053, 0.0595137477, 0.6220785975, 0.6314375401, 0.0052603451, 0.4557119012, 0.3513344228, 0.5795360208, 0.2327984571, 0.165709883, 0.7886769772, 0.8890479207, 0.2429098487, 0.4871490598, 0.2671397626, 0.7175374031, 0.7549058199, 0.9726084471, 0.3851055205, 0.551384747, 0.4111255705, 0.0779726356, 0.8733567595, 0.7498862743, 0.7931258082, 0.2799656093, 0.8763404489, 0.3736275733, 0.6477729678, 0.0880915597, 0.8108944893, 0.8728898764, 0.8266988993, 0.161042735, 0.1892506182, 0.1411487609, 0.0869028941, 0.8278047442, 0.8747546077, 0.5107010007, 0.4084055722, 0.3980386257, 0.4770012796, 0.3506475389, 0.4807008505, 0.7788491845, 0.3133334816, 0.5976699591, 0.6842749715, 0.3748018146, 0.8610635996, 0.1022957861, 0.9418399334, 0.8243051767, 0.1967420876, 0.9247750044, 0.7166752219, 0.2410049587, 0.1345794052, 0.1353064775, 0.9325634241, 0.1108572036, 0.9813696146, 0.135146454, 0.209386006, 0.9749392271, 0.2828991413, 0.24847956, 0.2666292191, 0.1520102471, 0.4139654338, 0.3740066886, 0.1225339025, 0.8656436205, 0.4221470952, 0.0319013111, 0.7414957881, 0.9600464106, 0.27536273, 0.5269204378, 0.7114865184, 0.1122055501, 0.4771135151, 0.8740446568, 0.4567165673, 0.2876826823, 0.6616845131, 0.4751175344, 0.058658842, 0.2287436724, 0.0853352547, 0.2039020509, 0.720445931, 0.7545861006, 0.6928667426, 0.8831790686, 0.0137837529, 0.5853300095, 0.1472780704, 0.4519954026, 0.0097109666, 0.6952510476, 0.2078256607, 0.0373575352, 0.8211422563, 0.0558194369, 0.7313686609, 0.4689704478, 0.095679231, 0.896363318, 0.1120448038, 0.8181142807, 0.2486581802, 0.1398879588, 0.5254757404, 0.4015758932, 0.5145997405, 0.9422720075, 0.8330059052, 0.1405406892, 0.2055794895, 0.5196123719, 0.2358682454, 0.9054501653, 0.7132432461, 0.5218886137, 0.206994459, 0.9510710835, 0.9345709682, 0.8948713541, 0.7883835435, 0.5115756392, 0.1945326626, 0.8407603502, 0.7063624263, 0.8107746243, 0.5006308556, 0.6917774081, 0.0947859362, 0.9130716324, 0.6934458017, 0.837133348, 0.5858495235, 0.4684022069, 0.1297370195, 0.8348796368, 0.2570964694, 0.8386361599, 0.622671783, 0.1130922958, 0.9165218472, 0.9632377028, 0.205608815, 0.6110759974, 0.4853537083, 0.7115112543, 0.5202045441, 0.2516072392, 0.5528147221, 0.6722636223, 0.0857901201, 0.3362386525, 0.7351680994, 0.1903360337, 0.7454760075, 0.1719599664, 0.387124151, 0.0932018459, 0.5050786138, 0.3789227903, 0.4801812768, 0.3383860588, 0.2529097497, 0.1465537101, 0.7296524048, 0.8325640559, 0.6243760586, 0.7460099459, 0.5149294138, 0.465175271, 0.6389155388, 0.283739984, 0.4793967307, 0.4775217175, 0.7251787782, 0.5939979553, 0.7855195999, 0.2565509081, 0.2451145947, 0.8145719767, 0.9989110231, 0.4190405905, 0.7036142945, 0.2327067256, 0.5372658372, 0.3613760471, 0.1656554788, 0.7119393349, 0.6189714074, 0.454146713, 0.185133934, 0.9553622603, 0.963711381, 0.6177098155, 0.4731043875, 0.1212384477, 0.3031343222, 0.8617272973, 0.6502091885, 0.9532495141, 0.1428751349, 0.5784316063, 0.8611226678, 0.7624854445, 0.3929765522, 0.3805690408, 0.2545896173, 0.446682483, 0.0148397582, 0.7657743096, 0.2754941881, 0.2660249472, 0.3798875213, 0.0561728552, 0.2154681683, 0.7341149449, 0.0007955993, 0.9754754901, 0.7575864196, 0.4401446283, 0.3954862356, 0.9139688015, 0.0888266265, 0.9475591183, 0.1982856691, 0.3180034757, 0.1625751108, 0.620973587, 0.0859823376, 0.3882405758, 0.9705940485, 0.1734909266, 0.0772138909, 0.0918193385, 0.5063413978, 0.5866190791, 0.6064302921, 0.5918045044, 0.0902755186, 0.4035459459, 0.2529979944, 0.4870192409, 0.7385742664, 0.5739389658, 0.5148332715, 0.3613711298, 0.6982057691, 0.8151579499, 0.0558659509, 0.8067486882, 0.8757463098, 0.0754071176, 0.5679771304, 0.5892222524, 0.6132609844, 0.4841753244, 0.6670720577, 0.220300436, 0.6152839661, 0.2635495067, 0.638931334, 0.9386772513, 0.4869751036, 0.1686008424, 0.7793906927, 0.9790409207, 0.3224077225, 0.8712618351, 0.579662025, 0.3888646662, 0.2546674609, 0.0513000451, 0.088577345, 0.4971133173, 0.1139139161, 0.5330253839, 0.4458592236, 0.3802547753, 0.0015436492, 0.1718741059, 0.136111483, 0.2954665422, 0.48384884, 0.9782880545, 0.1594657898, 0.7138190269, 0.7218046784, 0.2323043793, 0.6022443771, 0.613276124, 0.5647003055, 0.24240008, 0.3284954727, 0.0589503162, 0.5575588346, 0.6864364147, 0.2493986487, 0.7412534356, 0.0820376799, 0.5341425538, 0.0063022207, 0.9143952727, 0.6206943989, 0.729739964, 0.3183074892, 0.5311909318, 0.5075007677, 0.2363121957, 0.7450247407, 0.7809490561, 0.5307874084, 0.2871339321, 0.077972129, 0.0620434582, 0.6296265125, 0.8584765792, 0.6359632611, 0.617978096, 0.8185879588, 0.1748676598, 0.3249195814, 0.4600475132, 0.201197952, 0.841853261, 0.8995137215, 0.003933276, 0.0563738309, 0.7099885941, 0.7007045746, 0.7458211184, 0.9885305166, 0.3783204854, 0.0826100335, 0.9335113168, 0.2823200822, 0.6438007951, 0.9114531279, 0.8699083328, 0.9901625514, 0.6779408455, 0.9690108299, 0.5257256627, 0.4997349977, 0.8986558914, 0.3242087662, 0.9182067513, 0.2991752625, 0.3558880091, 0.2111450881, 0.2120029628, 0.0263157599, 0.429089874, 0.1083222777, 0.7784960866, 0.7758093476, 0.6886820197, 0.7317797542, 0.4681655765, 0.595400095, 0.992978096, 0.3185992241, 0.8502960205, 0.952506423, 0.2416978776, 0.1468276083, 0.8019496799, 0.648035109, 0.3450838625, 0.1173318177, 0.4027911425, 0.0391170271, 0.7285984159, 0.830416739, 0.9850556254, 0.5423062444, 0.0818975791, 0.5483108163, 0.2151320577, 0.9997138381, 0.5160960555, 0.5859099627, 0.1212509349, 0.4737671018, 0.3530995548, 0.5802864432, 0.7772214413, 0.2383177727, 0.6023976207, 0.4735913873, 0.4751731753, 0.3340452313, 0.7923023105, 0.4606459439, 0.9486450553, 0.9033490419, 0.8815308213, 0.1388822794, 0.2302107215, 0.5003027916, 0.1892398, 0.2944695354, 0.8203642964, 0.3520234227, 0.5205004215, 0.3420150578, 0.1313518733, 0.2285410017, 0.4750854969, 0.181199342, 0.6650058031, 0.8825643659, 0.2593260407, 0.4513739347, 0.5593579412, 0.0403011777, 0.2482140511, 0.7435663342, 0.6120058298, 0.7297807932, 0.1407711208, 0.3960608542, 0.0546920225, 0.2039171457, 0.0254108403, 0.4188559055, 0.4640986621, 0.8288553953, 0.5997421741, 0.0178059582, 0.8276942372, 0.2168370485, 0.0862968042, 0.0785248429, 0.4705827832, 0.1424753219, 0.1090355963, 0.063556008, 0.1221310049, 0.9232905507, 0.7839717269, 0.3394386172, 0.5255436897, 0.6179113984, 0.6680825353, 0.9542113543, 0.6983990669, 0.6871361732, 0.4743655324, 0.6466472745, 0.9830511808, 0.1112656891, 0.6871949434, 0.8293682337, 0.1073063388, 0.1485439688, 0.4966143668, 0.3621051908, 0.6897413731, 0.5554760695, 0.4509290159, 0.6146492958, 0.6667609215, 0.0924460217, 0.4585912824, 0.7487086058, 0.1128270552, 0.5709548593, 0.0877091512, 0.1401374191, 0.6482701898, 0.760825932, 0.9945762753, 0.2145056576, 0.3915721476, 0.3191218972, 0.4560193419, 0.9845030308, 0.0788487345, 0.120894596, 0.880230546, 0.2661793828, 0.2456931919, 0.9981367588, 0.4506645203, 0.4504982829, 0.9565261602, 0.8473084569, 0.1133293286, 0.8762695193, 0.9337145686, 0.2534602284, 0.3628862202, 0.3275935054, 0.2089666277, 0.2992331684, 0.664921999, 0.7315315008, 0.9478498697, 0.6084333658, 0.4357850254, 0.1365931928, 0.4972289801, 0.4691647291, 0.9750099778, 0.4458443522, 0.2258721441, 0.252276659, 0.1220288649, 0.728967607, 0.7348276377, 0.3755582571, 0.3497219086, 0.9531602859, 0.8352612853, 0.6633071899, 0.045689173, 0.3805855215, 0.823582828, 0.4252410829, 0.749383688, 0.1456706375, 0.6497740746, 0.7125581503, 0.1624079943, 0.1373025924, 0.1279350668, 0.9708826542, 0.0857626721, 0.3923688829, 0.411709249, 0.1969340444, 0.5416286588, 0.9817547202, 0.9610751867, 0.0845267698, 0.3368629813, 0.0690044612, 0.4572432637, 0.9595646858, 0.241859749, 0.9865912199, 0.4423881471, 0.3373891115, 0.0673551485, 0.3699241579, 0.4154234529, 0.9594244957, 0.5812380314, 0.511546433, 0.1990439892, 0.8013362885, 0.9563085437, 0.1061981991, 0.7063205838, 0.7125397921, 0.6885972619, 0.2192605138, 0.6091698408, 0.6059626341, 0.2404647619, 0.6032620668, 0.6457625031, 0.8460487127, 0.4852031171, 0.2487026453, 0.0366728604, 0.1735072583, 0.6197302938, 0.0397418551, 0.1751434356, 0.4093625247, 0.0172295254, 0.2076015025, 0.5433748364, 0.0509383641, 0.5896348953, 0.2516341507, 0.8555691838, 0.6506301761, 0.7745659947, 0.876655221, 0.1228426024, 0.9877105951, 0.7690671682, 0.469373256, 0.3430191576, 0.2883387506, 0.2496049404, 0.4174309671, 0.7055002451, 0.3456101716, 0.6632670164, 0.4655898809, 0.9639615417, 0.3936365247, 0.5241488218, 0.711967051, 0.9832746983, 0.0365021713, 0.1418611556, 0.5869303346, 0.9949745536, 0.2289099246, 0.7857643366, 0.7014958262, 0.885640204, 0.7443384528, 0.1151549369, 0.05708104, 0.5269777775, 0.2219097316, 0.4180500209, 0.9574242234, 0.1995432675, 0.8916079998, 0.9351537824, 0.336073041, 0.4645262659, 0.4120020866, 0.110422194, 0.5611331463, 0.6386611462, 0.3377301395, 0.7225644588, 0.9313002229, 0.2981921136, 0.4605979621, 0.9575611353, 0.165322423, 0.152888298, 0.123656787, 0.1312875301, 0.942546308, 0.3917533755, 0.0589572191, 0.6515007019, 0.6880768538, 0.8231864572, 0.6149953008, 0.7472731471, 0.9031752348, 0.3369258046, 0.3466275632, 0.6369885206, 0.1158203036, 0.5125613809, 0.2982789874, 0.4604129195, 0.1476354748, 0.1393106431, 0.1006692275, 0.6609869599, 0.4564038217, 0.4572893977, 0.0572066456, 0.7080409527, 0.957270205, 0.6036813855, 0.8634923697, 0.6499301791, 0.6245829463, 0.8936629891, 0.0847953558, 0.4449445307, 0.6379930377, 0.7438736558, 0.2923384011, 0.7096884251, 0.3461559117, 0.0198387168, 0.1270768046, 0.0211520232, 0.9564839005, 0.36474213, 0.7926282287, 0.7122219801, 0.4070749581, 0.6913565993, 0.9376250505, 0.6553639174, 0.5594186783, 0.2159312665, 0.4742873609, 0.9990153313, 0.7695833445, 0.8024565578, 0.1413995922, 0.568457067, 0.4031882882, 0.8406370878, 0.390298754, 0.1381790936, 0.3201354444, 0.155181542, 0.7198241949, 0.235166207, 0.8418413997, 0.7066733241, 0.5653064251, 0.3583040237, 0.4102395177, 0.9087673426, 0.5705324411, 0.9249805212, 0.5928071141, 0.0126413815, 0.996088028, 0.6977165937, 0.6824188232, 0.631808877, 0.1370527446, 0.6809042692, 0.343877703, 0.8870877624, 0.9437358975, 0.363491714, 0.5165042877, 0.8414770365, 0.83693856, 0.2037138492, 0.7863583565, 0.4692445099, 0.2232517451, 0.4170775115, 0.2558470666, 0.6936772466, 0.2843486071, 0.7230042219, 0.4351403713, 0.6764482856, 0.8232243061, 0.146152705, 0.9427404404, 0.9088268876, 0.897926867, 0.2267044932, 0.4442048669, 0.2051906139, 0.569881022, 0.3392190933, 0.0771049634, 0.3125287592, 0.3603034914, 0.7278358936, 0.4766102135, 0.7205414176, 0.1379755288, 0.361346662, 0.1172247231, 0.5505853891, 0.8976436257, 0.1885688454, 0.7072427273, 0.5713613033, 0.0896134153, 0.110899277, 0.4499467611, 0.8732603192, 0.4181646109, 0.9823195338, 0.6648517251, 0.0476900302, 0.2431214452, 0.1597129554, 0.9605688453, 0.873586297, 0.9620782137, 0.2449910343, 0.4972401857, 0.836096108, 0.9318570495, 0.0118331537, 0.0871321484, 0.9110755324, 0.1245511919, 0.0120295202, 0.730927527, 0.255885005, 0.8504547477, 0.2086956203, 0.5944172144, 0.6177854538, 0.9679172039, 0.6963319778, 0.4652388096, 0.1282349527, 0.8594450355, 0.204907462, 0.6912082434, 0.3491280377, 0.5212653875, 0.7254321575, 0.8557592034, 0.533065021, 0.8922915459, 0.4428530931, 0.4409148991, 0.2075135857, 0.2139482945, 0.2372723818, 0.1344977617, 0.3403683305, 0.4871248007, 0.6766581535, 0.3431895375, 0.8300520778, 0.2341357917, 0.3823474646, 0.4674374461, 0.28069821, 0.5980251431, 0.0239732657, 0.8454552889, 0.4936358929, 0.8911316395, 0.2736046016, 0.1264330149, 0.121774815, 0.520314455, 0.956381321, 0.6798967719, 0.896681428, 0.2325180471, 0.8903793097, 0.8114367723, 0.2934849858, 0.0136003289, 0.8234140277, 0.3610075712, 0.5958183408, 0.9930573106, 0.0314410664, 0.9526392221, 0.0255242772, 0.5699372292, 0.0087598842, 0.6366280913, 0.7207630873, 0.9496116638, 0.3954304457, 0.3128762841, 0.5304647088, 0.1213271618, 0.1467175335, 0.48603338, 0.4939534664, 0.1531855166, 0.2000542432, 0.6310173869, 0.6595714092, 0.7309086919, 0.778562963, 0.4514578879, 0.6676999331, 0.2192534953, 0.7403250337, 0.9841399193, 0.6916406155, 0.7269148827, 0.943816781, 0.6998386383, 0.4706457257, 0.2070418447, 0.4841609299, 0.7389830351, 0.2683275938, 0.067693837, 0.4881869853, 0.245456472, 0.1602723002, 0.5296664834, 0.7877382636, 0.4697082043, 0.2750242352, 0.6280722618, 0.908460021, 0.9373245239, 0.6219260097, 0.7891891003, 0.6690227985, 0.1422366947, 0.7514579296, 0.4901350737, 0.8721100092, 0.2750261426, 0.5114755034, 0.8930193186, 0.586600244, 0.5487608314, 0.2491485775, 0.1582965553, 0.1406119913, 0.1947881579, 0.199767381, 0.6640841365, 0.4515717924, 0.7628028989, 0.2299791127, 0.7113984227, 0.0862207487, 0.4640478194, 0.7691074014, 0.1014884338, 0.9796831608, 0.0766738132, 0.9116546512, 0.4276819825, 0.8561990261, 0.5936996341, 0.1075137705, 0.0239505097, 0.3316314518, 0.487944454, 0.1845136583, 0.388779223, 0.139185369, 0.9428163767, 0.2558288574, 0.2862555385, 0.2294884175, 0.0425246134, 0.7538257241, 0.7470843792, 0.0413450673, 0.1121925861, 0.289190948, 0.7587980032, 0.3463464975, 0.6197323799, 0.6763352156, 0.2324884683, 0.0440495051, 0.2137145698, 0.6355563402, 0.7238734961, 0.9867273569, 0.0739541277, 0.4701449871, 0.4313713908, 0.6602859497, 0.6086152196, 0.4417156279, 0.9974262714, 0.0975009874, 0.8445842862, 0.5522742867, 0.3969660699, 0.62141186, 0.7788109183, 0.7136057615, 0.2289288491, 0.2130244672, 0.6027131677, 0.6124268174, 0.925157845, 0.0616566502, 0.8236808181, 0.19588992, 0.4427541792, 0.2653938234, 0.1808390319, 0.5971671939, 0.2315298319, 0.9344127774, 0.2182364315, 0.7783111334, 0.4874379933, 0.3447670937, 0.623842299, 0.941100359, 0.9611390829, 0.7089878917, 0.1187877357, 0.66276443, 0.4982549846, 0.6327852607, 0.5914241076, 0.5998700857, 0.6847869754, 0.2001991421, 0.2943502367, 0.2379508168, 0.2451606393, 0.5758971572, 0.9493308067, 0.211288631, 0.1238107979, 0.9436278343, 0.4755471647, 0.6834369302, 0.5818591714, 0.0113358516, 0.7210019231, 0.9679825306, 0.3710557818, 0.2515459955, 0.2659612596, 0.8592920899, 0.3314473331, 0.6388500333, 0.9415346384, 0.9097257853, 0.3393050432, 0.9217511415, 0.115951322, 0.7385159731, 0.1135490239, 0.5887776613, 0.6945705414, 0.7332811356, 0.2237532437, 0.3118081689, 0.0983192325, 0.039174825, 0.6431609988, 0.7369810939, 0.7353634238, 0.6044911742, 0.5575240254, 0.2729411125, 0.4577404559, 0.7433678508, 0.588363111, 0.2749655843, 0.800334692, 0.0185033157, 0.8160027266, 0.1016062647, 0.4272126555, 0.4561058283, 0.4552623928, 0.0299864579, 0.1988892108, 0.402033329, 0.710562706, 0.7255421877, 0.6319249272, 0.4746235013, 0.4684766531, 0.1954155117, 0.950129807, 0.2715771794, 0.9850295186, 0.8014503121, 0.195997268, 0.4614772499, 0.3934194148, 0.7261785865, 0.7577277422, 0.7315858603, 0.175858438, 0.5568647981, 0.3278964758, 0.71470505, 0.4275215864, 0.9476006031, 0.0250451006, 0.9447517395, 0.7898845673, 0.4516260624, 0.5857234597, 0.0512867458, 0.3506784439, 0.0615031905, 0.6430190802, 0.7824978828, 0.1282590479, 0.7053239942, 0.2010644525, 0.5349711776, 0.1372918785, 0.6280158162, 0.4919610918, 0.7425698638, 0.6999062896, 0.2883373201, 0.921392858, 0.4459832311, 0.3443984687, 0.4061470926, 0.7968639731, 0.2202416509, 0.2530643046, 0.9734023213, 0.0877880007, 0.2693817914, 0.3541754484, 0.1994337142, 0.9290516973, 0.5692538023, 0.9975730181, 0.2123656869, 0.7291432023, 0.6331786513, 0.7425414324, 0.9666696787, 0.9205757976, 0.9922174215, 0.6824410558, 0.3949363232, 0.4523568451, 0.3250179291, 0.8157433867, 0.7998639941, 0.6998991966, 0.9239279032, 0.8988652229, 0.9555116296, 0.1968290061, 0.9351155758, 0.1396250725, 0.8221547604, 0.6174406409, 0.9926145077, 0.1054789126, 0.2044666409, 0.8935524821, 0.5867761374, 0.0919070765, 0.9262919426, 0.8059595227, 0.6214087009, 0.9671977758, 0.3435967267, 0.9270213246, 0.7631459832, 0.5441656709, 0.56900388, 0.7316193581, 0.0488156527, 0.6897270083, 0.4517463148, 0.0790012106, 0.6756342053, 0.0092511894, 0.8497228622, 0.2521197498, 0.0792140812, 0.3596895635, 0.9127144217, 0.8415563107, 0.9236878157, 0.8178555965, 0.7622930408, 0.4520805478, 0.7207684517, 0.0002339473, 0.8758230209, 0.9918480515, 0.0707794428, 0.960699141, 0.4286506176, 0.1999435574, 0.4169917405, 0.9239530563, 0.9947629571, 0.6634295583, 0.112485379, 0.6303933263, 0.9871919751, 0.0817595869, 0.355719775, 0.3711491525, 0.9300679564, 0.5547308326, 0.2435157299, 0.0209109467, 0.4599942267, 0.487806797, 0.8793050051, 0.0423153229, 0.805275321, 0.713989079, 0.9856292605, 0.4745872319, 0.5374484658, 0.6929543614, 0.3381887376, 0.8924344778, 0.7035735846, 0.0163216051, 0.9601459503, 0.4612768292, 0.974562943, 0.6749196649, 0.897294879, 0.4060208797, 0.4955765009, 0.1287103891, 0.0165866725, 0.2238298953, 0.7431547642, 0.1179674938, 0.4836426973, 0.1631947905, 0.6472587585, 0.1457427144, 0.5792192221, 0.4989259541, 0.3163287044, 0.8858006001, 0.62773031, 0.8673131466, 0.1005147174, 0.3907134831, 0.5618023872, 0.1673547477, 0.9736580849, 0.0937287509, 0.1883356422, 0.2679286599, 0.8614320755, 0.9980326891, 0.1604878306, 0.9749154449, 0.7830008268, 0.7333298326, 0.2121554017, 0.0217836369, 0.3229865432, 0.9212281108, 0.1436148435, 0.3445620239, 0.1202699766, 0.8970475197, 0.3069497943, 0.9134603143, 0.570212543, 0.9975665808, 0.8581698537, 0.1285094619, 0.8788124323, 0.6045054197, 0.0238512605, 0.7748757005, 0.439840138, 0.1355615109, 0.3822240233, 0.0692974851, 0.2045793086, 0.9858217835, 0.1212140545, 0.6925217509, 0.7451168895, 0.0625852048, 0.362511903, 0.2956384718, 0.8160207868, 0.7297493219, 0.4369413555, 0.4427506328, 0.9191280007, 0.5053682923, 0.0208856091, 0.7545157671, 0.4905830324, 0.7630480528, 0.8163150549, 0.045990672, 0.3951961696, 0.0753518045, 0.9801540375, 0.4568540156, 0.2488125265, 0.0453826711, 0.8161067367, 0.5382704139, 0.4462370872, 0.3017324209, 0.5584515929, 0.1887043715, 0.2579388916, 0.377871573, 0.7925445437, 0.0965660885, 0.2905142903, 0.3557309806, 0.5700449944, 0.9479649663, 0.7678772211, 0.0886231884, 0.6995251775, 0.7007929087, 0.8652918935, 0.0007268046, 0.5928665996, 0.7081015706, 0.7118461132, 0.9706901908, 0.5527791381, 0.8002860546, 0.9183729291, 0.466396451, 0.5793769956, 0.8500337601, 0.583304286, 0.6461704373, 0.9975832701, 0.1549375802, 0.6594515443, 0.1252454221, 0.7635897398, 0.7337523103, 0.3376353979, 0.3710575402, 0.6128252149, 0.9710690975, 0.8680807352, 0.6498346329, 0.1112478748, 0.8256502151, 0.214338541, 0.327781707, 0.8420673013, 0.9919103384, 0.8114714026, 0.0686456636, 0.4891083837, 0.8183916807, 0.2314342111, 0.0107376315, 0.6101437807, 0.6048409939, 0.4214161038, 0.07405442, 0.4440822899, 0.6659262776, 0.7429590821, 0.5334573984, 0.1436345279, 0.8273325562, 0.6509962678, 0.8577843904, 0.4713813365, 0.8589822054, 0.2995867729, 0.7118763328, 0.4795556664, 0.5618416667, 0.2473500222, 0.2611320019, 0.1521219313, 0.8589732051, 0.3526566029, 0.7523092628, 0.162906602, 0.2931720316, 0.9873413444, 0.7275877595, 0.4169563055, 0.7788833976, 0.2867764533, 0.7046756148, 0.3725337386, 0.3487041295, 0.4292491376, 0.9839559793, 0.8297261596, 0.3751640618, 0.8055593371, 0.7824987769, 0.2732902467, 0.0794270039, 0.3340784907, 0.8225383759, 0.7576157451, 0.3639462888, 0.0950459167, 0.9562528729, 0.6696684957, 0.2531193495, 0.1102652326, 0.9973129034, 0.5259512067, 0.4486361742, 0.121716626, 0.2532446086, 0.2533878684, 0.5227922797, 0.6851757765, 0.0456724465, 0.0627416968, 0.1024873331, 0.839153111, 0.3122954071, 0.4181184471, 0.0407995172, 0.5753110647, 0.7601435184, 0.7494844198, 0.4329914153, 0.8947479129, 0.3733733296, 0.8037199974, 0.8332307339, 0.612393558, 0.1712171882, 0.9597785473, 0.7852883339, 0.2586878538, 0.0667347908, 0.6348582506, 0.8200544119, 0.9943733811, 0.6395456791, 0.378857404, 0.5369496942, 0.7073846459, 0.9713602662, 0.4833183289, 0.950420022, 0.510699749, 0.7156969309, 0.4145727456, 0.9691243768, 0.7705577016, 0.0867787153, 0.3629156053, 0.0385666601, 0.5566432476, 0.8073791862, 0.0475577898, 0.1199062988, 0.865707159, 0.8219990134, 0.4498991966, 0.4685618281, 0.9492120743, 0.5188637972, 0.7686650753, 0.9533615708, 0.3956490159, 0.82291013, 0.3728880882, 0.0523726046, 0.3930147588, 0.1948387921, 0.3819127083, 0.949092567, 0.9356982112, 0.7871661782, 0.7788950205, 0.4811519682, 0.6680958867, 0.3531906009, 0.9469300508, 0.146231696, 0.7090854049, 0.765384078, 0.1048402339, 0.3884967566, 0.6369208694, 0.9961783886, 0.459294349, 0.040100649, 0.8780415058, 0.907074213, 0.5693956017, 0.5113674402, 0.168045491, 0.737282753, 0.842587769, 0.846696794, 0.5854989886, 0.3763777018, 0.3345259428, 0.8910778761, 0.6998677254, 0.2376101613, 0.4466179311, 0.4397892356, 0.0550868772, 0.3258031011, 0.4882633686, 0.3589040041, 0.4302520752, 0.42307657, 0.3555707932, 0.79247123, 0.305147171, 0.8035071492, 0.3244303465, 0.9959524274, 0.5242580175, 0.1691230237, 0.9817291498, 0.6370483637, 0.2214593142, 0.6237680912, 0.7317706943, 0.2123642564, 0.5662378669, 0.8755405545, 0.0382173099, 0.9036038518, 0.4578294754, 0.5786895156, 0.9733422399, 0.0495842174, 0.4375197589, 0.4351761937, 0.1135349572, 0.254642576, 0.0248554032, 0.8161369562, 0.2190146297, 0.6860049963, 0.196045205, 0.0352771319, 0.2413027585, 0.7161464691, 0.3802536428, 0.8222718835, 0.3158311844, 0.0334501863, 0.3936675787, 0.0391162671, 0.9727173448, 0.1614153534, 0.2138577998, 0.6744181514, 0.4630596936, 0.8166452646, 0.2091270983, 0.0185563192, 0.4274769127, 0.8440701962, 0.3554680645, 0.8421376944, 0.6874022484, 0.1224175766, 0.6366341114, 0.9902863503, 0.3611939251, 0.8088998199, 0.8627935052, 0.0289100613, 0.8563232422, 0.5871095657, 0.6004161835, 0.8465287089, 0.0090341298, 0.7314211726, 0.3766885102, 0.3236398697, 0.0295174047, 0.8263036013, 0.353517592, 0.7824463844, 0.4067432582, 0.2425942421, 0.9574813843, 0.1088294163, 0.021327734, 0.139037326, 0.3716480732, 0.9880857468, 0.6051029563, 0.5667526722, 0.6627444625, 0.7452079058, 0.6381437778, 0.6991891861, 0.0915775225, 0.8574279547, 0.4486729205, 0.177569747, 0.4835519195, 0.4997417033, 0.7389014363, 0.0297268983, 0.1309955716, 0.3774424195, 0.0679163635, 0.4449722469, 0.5063613057, 0.1582536995, 0.7153995037, 0.4372690916, 0.9653238058, 0.1947146654, 0.6954976916, 0.0796119571, 0.7796846628, 0.098283954, 0.7249370217, 0.9101967812, 0.6947941184, 0.9772434235, 0.1000230387, 0.0627140701, 0.3216978014, 0.609705925, 0.2297454327, 0.0119149787, 0.1160531417, 0.94871521, 0.3632621765, 0.1822129339, 0.9330781102, 0.5299761295, 0.3621833026, 0.3637073338, 0.3499561548, 0.8000932932, 0.7873043418, 0.9634428024, 0.3726097643, 0.9717751145, 0.408886373, 0.5839247108, 0.8906176686, 0.6159471869, 0.0071535492, 0.6307464838, 0.3992320895, 0.9570859671, 0.3818312287, 0.7671108246, 0.40707919, 0.8651296496, 0.6620508432, 0.7383896112, 0.4500457048, 0.6506568193, 0.9673782587, 0.2506396174, 0.605376184, 0.0333377346, 0.1263488084, 0.5372824073, 0.13685821, 0.3385664225, 0.581692934, 0.6568664312, 0.94896698, 0.1676198393, 0.8753718138, 0.3355306089, 0.5114132762, 0.6217404008, 0.3242197037, 0.981955111, 0.0864357278, 0.8356361389, 0.3123811781, 0.7548118234, 0.9649080634, 0.3195282519, 0.4657706618, 0.1659842879, 0.0179208852, 0.3410169184, 0.6629857421, 0.4000360668, 0.603998661, 0.872736454, 0.3633773029, 0.7532644868, 0.4613541663, 0.3372956514, 0.3035933971, 0.353928566, 0.8623511195, 0.8679077625, 0.4180698097, 0.0938651934, 0.3813124001, 0.2187110335, 0.3081974387, 0.8026303649, 0.2900233269, 0.4799141288, 0.9359755516, 0.1660941094, 0.9102481604, 0.8046797514, 0.7432105541, 0.303237915, 0.038334582, 0.5777049065, 0.0851248205, 0.2318288535, 0.176134944, 0.1863940507, 0.0926936939, 0.1571556032, 0.365537852, 0.5580291152, 0.3688516319, 0.9562922716, 0.2313475013, 0.1131516993, 0.3747984171, 0.9255852103, 0.653136313, 0.3787752688, 0.8681831956, 0.3708764017, 0.6930493712, 0.8526188731, 0.4943924546, 0.6201373935, 0.2607451975, 0.3788252771, 0.1772005558, 0.3147800863, 0.4998929501, 0.5430523753, 0.5828727484, 0.5276942253, 0.2671915293, 0.6172901392, 0.8603032827, 0.2252665609, 0.0025494958, 0.7112596631, 0.5840349793, 0.770706892, 0.4372451305, 0.9639129043, 0.3048937321, 0.9957541227, 0.0169848576, 0.3490648568, 0.6452852488, 0.1195521131, 0.089132376, 0.4797008038, 0.7618827224, 0.751190424, 0.3172937036, 0.5042762756, 0.7574118972, 0.1239449978, 0.0675380528, 0.1497418135, 0.8718197346, 0.413974762, 0.7576328516, 0.4542947114, 0.0975281075, 0.4528908134, 0.6023204923, 0.9132833481, 0.8874340653, 0.7145345211, 0.6168897748, 0.4055404365, 0.2497811913, 0.1992354542, 0.3368881047, 0.9666627645, 0.5256541371, 0.3254370987, 0.324804455, 0.8387818336, 0.4825591147, 0.9431799054, 0.6354573369, 0.9499405026, 0.7504870892, 0.1213849634, 0.642133534, 0.9956735373, 0.9023224711, 0.0781245828, 0.4833248258, 0.2823326588, 0.0766531751, 0.976834178, 0.3095526993, 0.3804157078, 0.9668009281, 0.9641554952, 0.6013793945, 0.9502558708, 0.6086623669, 0.8903332949, 0.2578724027, 0.3313767016, 0.4894917905, 0.4484708905, 0.225916326, 0.4085065126, 0.8818717003, 0.2174347192, 0.8455646634, 0.6382569671, 0.4248079062, 0.5699709058, 0.7125941515, 0.2122523934, 0.4254791141, 0.2413930446, 0.9907722473, 0.8595077395, 0.3662498891, 0.0858681425, 0.2003610432, 0.732067287, 0.7189976573, 0.7126919627, 0.1260681152, 0.9237770438, 0.2121254355, 0.2329794019, 0.7497869134, 0.2305739373, 0.5531195402, 0.8613305688, 0.804032445, 0.7141299248, 0.2954059541, 0.049326621, 0.2381578684, 0.9175969362, 0.0937628448, 0.8792830706, 0.827940166, 0.2427871525, 0.2329107076, 0.5039531589, 0.0249296203, 0.6457495093, 0.8977932334, 0.2240513712, 0.4567748308, 0.5897205472, 0.669918716, 0.8265719414, 0.7500471473, 0.1965749115, 0.6302676797, 0.7611974478, 0.8504530191, 0.0336682461, 0.3204943836, 0.9087586999, 0.7265447378, 0.7310765386, 0.0510477982, 0.5815448761, 0.5994582772, 0.3822634518, 0.3697357774, 0.5650444031, 0.3549293876, 0.0434908234, 0.0979609266, 0.0154667785, 0.4530055225, 0.9662120938, 0.1614695638, 0.7071575522, 0.113230817, 0.1410227716, 0.6164314747, 0.2150831223, 0.9072050452, 0.7162016034, 0.8550454378, 0.3414458334, 0.10845083, 0.1664104909, 0.428172946, 0.870185554, 0.1207372472, 0.9941589236, 0.3148859143, 0.2372272313, 0.9850754142, 0.5776262283, 0.5698000789, 0.4583282173, 0.6283044815, 0.6476567984, 0.5762419701, 0.6628118753, 0.04290713, 0.7270650268, 0.3997713923, 0.3806994855, 0.126276657, 0.7418123484, 0.3250063658, 0.4168527722, 0.489549309, 0.2272565812, 0.1438979208, 0.1117988452, 0.6251049638, 0.8167061806, 0.8875539899, 0.9729827046, 0.7656977773, 0.8770171404, 0.5038051605, 0.7887247801, 0.1168617383, 0.3116078675, 0.122797519, 0.9747693539, 0.2202394605, 0.1609618664, 0.6544929147, 0.9847650528, 0.1964287907, 0.1128766015, 0.7317509651, 0.9587103128, 0.9569885731, 0.821287632, 0.3012783229, 0.5396449566, 0.0822739154, 0.1669502407, 0.4535298944, 0.1045399308, 0.2326706797, 0.7211957574, 0.1725761443, 0.1090020388, 0.9110841155, 0.7424035072, 0.0952135399, 0.7983450294, 0.6084074974, 0.1354191899, 0.1631673425, 0.7506678104, 0.6232589483, 0.9955670834, 0.9209811687, 0.7083567381, 0.9326409101, 0.6125705242, 0.4989732206, 0.9193303585, 0.2860678136, 0.0823112875, 0.4839625955, 0.2536306381, 0.5479493737, 0.6388376951, 0.0453141741, 0.482655108, 0.7265326977, 0.6185632348, 0.7928264737, 0.8148653507, 0.5979046226, 0.4907150567, 0.4259094596, 0.2750523984, 0.5032152534, 0.9398130774, 0.1177121177, 0.6255344748, 0.6250491142, 0.4064733982, 0.637517035, 0.8745219111, 0.8796836138, 0.8532630205, 0.4660728276, 0.8731740117, 0.4991939068, 0.8051498532, 0.3857492208, 0.4393017888, 0.5774713159, 0.8751817346, 0.2497480214, 0.122535713, 0.5686126947, 0.542340219, 0.3715670407, 0.1960609108, 0.949837625, 0.9286199808, 0.5931366682, 0.0895980597, 0.6700481772, 0.7122668624, 0.7852167487, 0.2095805556, 0.1205843836, 0.0965914205, 0.6631560922, 0.4250650704, 0.6672289968, 0.1019007564, 0.453484863, 0.953576982, 0.998745501, 0.7370687723, 0.726877749, 0.1901751608, 0.5218352079, 0.4628792405, 0.5360019207, 0.9595204592, 0.6740662456, 0.4350104034, 0.2011793107, 0.1465158463, 0.6928260922, 0.1001470163, 0.4388425946, 0.568826735, 0.3112915158, 0.7445172071, 0.1193323582, 0.2360310256, 0.4373345375, 0.0794776529, 0.5034395456, 0.2514289916, 0.9695624113, 0.2928332388, 0.4828954339, 0.112816304, 0.8096698523, 0.3271968663, 0.0070475815, 0.5048404336, 0.3420736194, 0.5957426429, 0.503420949, 0.0467573777, 0.0866089314, 0.3781569898, 0.0511842147, 0.4236863256, 0.4832280278, 0.1298995316, 0.325494498, 0.4886581004, 0.2808347344, 0.1632497162, 0.9324332476, 0.7381750941, 0.9247043729, 0.6494550109, 0.284203589, 0.9766307473, 0.4984682202, 0.2164747268, 0.8801805377, 0.2317802459, 0.0640138686, 0.3264730871, 0.8873134255, 0.9579545259, 0.3043885827, 0.369107306, 0.4993454218, 0.5357220769, 0.986928463, 0.1675363928, 0.7938717604, 0.9448657632, 0.1998690665, 0.1756056696, 0.9188715219, 0.6501764655, 0.6160176992, 0.0469477884, 0.1634267867, 0.5466885567, 0.8115056753, 0.9506032467, 0.2070759833, 0.3146564662, 0.9475520253, 0.948107779, 0.6936659217, 0.5450612307, 0.8787096143, 0.0365482643, 0.6658070683, 0.5773863792, 0.7063529491, 0.9643990397, 0.6712903976, 0.3493689299, 0.5029823184, 0.2275436223, 0.5883646011, 0.4191149771, 0.9181865454, 0.4477844238, 0.5201436281, 0.2364486158, 0.4923554659, 0.5922198892, 0.354180187, 0.8049176335, 0.738253355, 0.2164010257, 0.2086770684, 0.1126588583, 0.2506896257, 0.0253463313, 0.614718318, 0.6813946366, 0.9952555895, 0.9241989851, 0.7347947955, 0.8986344337, 0.9093507528, 0.7320833802, 0.0637358129, 0.5786748528, 0.2041351497, 0.9720759988, 0.3660450578, 0.3743502498, 0.9402874112, 0.4614389241, 0.2404455245, 0.4987286925, 0.2129998207, 0.9457387328, 0.0680792481, 0.8658601642, 0.1114604697, 0.594427824, 0.4896151125, 0.9095861912, 0.5056038499, 0.7152558565, 0.9873967171, 0.5209948421, 0.1580729932, 0.35117957, 0.7343806624, 0.1190539822, 0.2643718123, 0.1854335517, 0.6738094687, 0.8574145436, 0.7591252923, 0.6000130177, 0.6562792659, 0.1711489111, 0.0935755372, 0.359118551, 0.9283712506, 0.9310843945, 0.7392662168, 0.9951130748, 0.0500456542, 0.606205523, 0.9735014439, 0.8118783832, 0.9933413863, 0.5091601014, 0.7534648776, 0.4702884257, 0.4837325811, 0.8748822212, 0.3242496252, 0.4819259048, 0.3093471229, 0.3443407416, 0.8627332449, 0.9251258969, 0.2689518034, 0.3046764731, 0.1928446591, 0.1198169291, 0.1495826542, 0.6378797293, 0.2686856985, 0.9570152164, 0.9947019815, 0.1990495622, 0.2749607563, 0.5109820962, 0.9176478386, 0.4903918505, 0.8261681199, 0.5460631251, 0.2360353917, 0.274969548, 0.6143262386, 0.6701139808, 0.3681367338, 0.953145206, 0.3165539205, 0.4957964122, 0.3156306744, 0.5551447272, 0.984552443, 0.6112276912, 0.466090858, 0.5778311491, 0.963132441, 0.6188763976, 0.43257007, 0.74739182, 0.0001590878, 0.5029233098, 0.8169631958, 0.5849395394, 0.6122626066, 0.081753321, 0.5868864655, 0.4827097654, 0.6982395649, 0.3717678189, 0.2450601608, 0.7834322453, 0.2144843638, 0.3409645855, 0.6935594082, 0.364882797, 0.0000875066, 0.887437284, 0.5773923993, 0.1110025197, 0.8355071545, 0.1763495505, 0.428499341, 0.6867538691, 0.9493530989, 0.0053610913, 0.3553719223, 0.3044171035, 0.1689673513, 0.4888363183, 0.5148839951, 0.1849452853, 0.897713542, 0.5622053742, 0.7448571324, 0.4181466997, 0.8386263847, 0.0828802586, 0.1039325222, 0.3719890416, 0.1263474673, 0.1929699481, 0.3933362365, 0.9732549787, 0.6950267553, 0.9268715382, 0.2290516049, 0.3549911082, 0.8957679272, 0.8208107948, 0.9116737843, 0.6784629226, 0.5388345718, 0.0991296545, 0.1107911542, 0.0892379582, 0.7999423742, 0.5470073819, 0.721572876, 0.699465096, 0.1151193008, 0.4629767239, 0.9143349528, 0.3864607811, 0.8207213879, 0.4732268155, 0.9044671059, 0.6332444549, 0.3183722496, 0.1102230772, 0.6502102017, 0.0288210697, 0.2329647243, 0.4846595526, 0.0926136672, 0.0725705847, 0.3844283521, 0.194354251, 0.7195215821, 0.9552853107, 0.0029267881, 0.4404609799, 0.8157118559, 0.8993971348, 0.9530659914, 0.0251294896, 0.4696230888, 0.2433969826, 0.4437613487, 0.6069117188, 0.0249261167, 0.2878941894, 0.7518885136, 0.2064859122, 0.3729958832, 0.8526729345, 0.8765500188, 0.1196160987, 0.1560146213, 0.9917750955, 0.6061599851, 0.6992319226, 0.3257593513, 0.593475163, 0.1969375014, 0.6941183209, 0.7192718983, 0.7439805865, 0.7995327711, 0.5814304352, 0.6509905457, 0.6821700931, 0.924081862, 0.8600212932, 0.2069315761, 0.4911104143, 0.2240150869, 0.7310242653, 0.0722467005, 0.6079446077, 0.3617984653, 0.0263829455, 0.5297412276, 0.5292071104, 0.1026685387, 0.8852197528, 0.6495633125, 0.1348335296, 0.6153002977, 0.2536665499, 0.9145803452, 0.450029701, 0.9723751545, 0.4874490798, 0.2541497052, 0.8461133838, 0.2418480068, 0.7919373512, 0.3639681041, 0.857442677, 0.7154712677, 0.4449679255, 0.2921220064, 0.963280201, 0.1971003264, 0.4514510334, 0.2025432736, 0.5638692379, 0.9063289762, 0.967027247, 0.1134938151, 0.9271347523, 0.6158794761, 0.4567608237, 0.8724793196, 0.9493952394, 0.1250747442, 0.7632551789, 0.6459383965, 0.6055327654, 0.5985218287, 0.834141314, 0.578111589, 0.4106989801, 0.4886804819, 0.1700046062, 0.1751469672, 0.0712313876, 0.0060056001, 0.2552906871, 0.5950299501, 0.4510626197, 0.3425444663, 0.3547513783, 0.1053880081, 0.130931586, 0.1485359371, 0.6286115646, 0.3000409007, 0.3247758448, 0.4307258427, 0.9875839949, 0.3725546896, 0.3639473915, 0.8579477072, 0.7508904934, 0.2939893901, 0.6965373755, 0.1464508772, 0.198120147, 0.4385713041, 0.238675639, 0.7043921947, 0.7125582695, 0.1093184352, 0.0525701419, 0.6196929812, 0.9083886743, 0.0573458448, 0.3793531358, 0.2368870378, 0.5250951648, 0.5019509792, 0.725256741, 0.1076457128, 0.6533917785, 0.3564069569, 0.5055052042, 0.5126312971, 0.6135913134, 0.0554074161, 0.1367645413, 0.9312745333, 0.2536841035, 0.6951342225, 0.0748187751, 0.631195128, 0.0188628323, 0.314162761, 0.5778902173, 0.3528655767, 0.6846556664, 0.7535302639, 0.2358576357, 0.9556433558, 0.8498365879, 0.2634832561, 0.9960318208, 0.6866603494, 0.4476959407, 0.7637553215, 0.1790231019, 0.5332064629, 0.3107205927, 0.8719856739, 0.406046927, 0.88761729, 0.9628082514, 0.0821799263, 0.2135345787, 0.1705842763, 0.8398225904, 0.5999576449, 0.1157513708, 0.5789451003, 0.0749146342, 0.8721115589, 0.1720396131, 0.6878544092, 0.6958033442, 0.126324594, 0.8466808796, 0.6459790468, 0.0377204679, 0.3731245995, 0.7613993883, 0.615044117, 0.3008291125, 0.6000047922, 0.3232116997, 0.2798737884, 0.462187022, 0.9881314635, 0.265250802, 0.569317162, 0.3449803889, 0.5217292309, 0.9983772635, 0.9307537079, 0.105012998, 0.7995977402, 0.1074760333, 0.8598355055, 0.0546879917, 0.4472883344, 0.0554624051, 0.5906053185, 0.1967779547, 0.8042863011, 0.0837237984, 0.1196473241, 0.6863863468, 0.8187760115, 0.0936076418, 0.870362699, 0.0070706848, 0.5882076621, 0.1541550457, 0.5542744994, 0.5786755681, 0.0510488749, 0.6514968872, 0.3789161146, 0.1947258264, 0.8200846314, 0.9011314511, 0.685672164, 0.5712757111, 0.2621073425, 0.7450839877, 0.8122548461, 0.6465995312, 0.0416614637, 0.2290412486, 0.7455627918, 0.6397697926, 0.3629002571, 0.822871685, 0.1884628832, 0.5719586015, 0.6196064353, 0.6371018291, 0.1819969118, 0.0812063366, 0.6993542314, 0.7633036971, 0.3576462567, 0.5038872957, 0.2568106651, 0.6964512467, 0.6638218164, 0.6864572167, 0.5060910583, 0.8209236264, 0.2132483572, 0.5150474906, 0.2505054772, 0.5849402547, 0.5576609373, 0.8584353328, 0.2709881067, 0.3911837339, 0.0717428178, 0.806386888, 0.985450089, 0.2922576964, 0.6165569425, 0.5360495448, 0.3380460441, 0.1066793203, 0.8847293854, 0.2702046037, 0.0845943391, 0.1421237141, 0.6967819929, 0.293910116, 0.5227125883, 0.6093758345, 0.3591115773, 0.089839831, 0.9364658594, 0.1500737965, 0.5283372402, 0.1166105419, 0.2130886614, 0.1770049036, 0.1603613347, 0.4738532305, 0.7488376498, 0.19794783, 0.7045380473, 0.3662438393, 0.0240056049, 0.8615483046, 0.9587606192, 0.3142572939, 0.6351529956, 0.4874440134, 0.6046891809, 0.4658892155, 0.3537878692, 0.3472965956, 0.9004520178, 0.641736865, 0.1063744947, 0.3013700545, 0.9507634044, 0.1984396875, 0.6292235255, 0.083963722, 0.7518445253, 0.1709179282, 0.9580810666, 0.5593107939, 0.5777112246, 0.8203430176, 0.8708991408, 0.2535334229, 0.6119022369, 0.3215396404, 0.3635187447, 0.4651461542, 0.2674832046, 0.1868050992, 0.7456719279, 0.2249475718, 0.3843463361, 0.4775032401, 0.0381310806, 0.7469258308, 0.4766734838, 0.1781844497, 0.2872119546, 0.0247516911, 0.5743784308, 0.8435814977, 0.1614839584, 0.7057003975, 0.782484293, 0.69783324, 0.6601962447, 0.9840054512, 0.4877744317, 0.1160784662, 0.2020426691, 0.061597988, 0.8641144633, 0.6781823635, 0.2974123359, 0.2550798953, 0.7159431577, 0.7229922414, 0.5250487328, 0.8703799248, 0.697162807, 0.1131960899, 0.2792929709, 0.6081331968, 0.52762568, 0.7477125525, 0.7101683021, 0.409784317, 0.4817813039, 0.8531027436, 0.1036189422, 0.774512887, 0.1178154647, 0.4748421907, 0.9949620962, 0.379139334, 0.8383822441, 0.8166930676, 0.1728985459, 0.4132170677, 0.2125788927, 0.2135537416, 0.149234727, 0.8608900309, 0.369479686, 0.6126662493, 0.0871528462, 0.6817799807, 0.4815687537, 0.5816547275, 0.6061651707, 0.8967537284, 0.2043928504, 0.3496925533, 0.7584263086, 0.3207936883, 0.804633379, 0.6244502068, 0.5535951853, 0.3710155487, 0.7478141189, 0.8568129539, 0.5567179918, 0.083728157, 0.0019600135, 0.6064441204, 0.5771192312, 0.8251596093, 0.824780345, 0.2491392791, 0.7487629652, 0.8003931046, 0.7262272835, 0.0639881641, 0.4659017324, 0.3788300157, 0.2949594259, 0.3163681328, 0.7640358806, 0.1101438701, 0.1056645438, 0.3873530626, 0.4960630536, 0.6864768267, 0.9154553413, 0.8615294695, 0.2559624314, 0.7989096642, 0.662511766, 0.9001371264, 0.7480590343, 0.6873580813, 0.7042953968, 0.6001659036, 0.9630150199, 0.1048192158, 0.288710326, 0.3989432156, 0.0453191102, 0.4998694956, 0.8727855682, 0.6800495982, 0.9642062783, 0.8788028359, 0.893274188, 0.326251179, 0.9138993621, 0.2269975692, 0.8641566634, 0.1462096572, 0.0843187422, 0.2788262665, 0.6114114523, 0.3318571448, 0.9067651629, 0.461648047, 0.1266877949, 0.2502485216, 0.5860577822, 0.0958286002, 0.0922295079, 0.4288218617, 0.907441318, 0.4079282582, 0.6137171388, 0.0851320103, 0.5717654824, 0.3757576048, 0.7709387541, 0.563616097, 0.7495493889, 0.8735838532, 0.2498029768, 0.0087167388, 0.4318227172, 0.8701936007, 0.6245196462, 0.8999392986, 0.1284180433, 0.400906384, 0.9929772615, 0.8151273131, 0.1400654167, 0.839412868, 0.4778622091, 0.0906223208, 0.0628775582, 0.099385187, 0.5617870688, 0.4811372757, 0.6064599156, 0.7258613706, 0.4005918205, 0.5493366122, 0.5253468156, 0.197447747, 0.6060486436, 0.941464901, 0.1814007461, 0.822930634, 0.8198007941, 0.206200704, 0.9575828314, 0.1041302457, 0.1171427444, 0.0852282196, 0.5917007923, 0.7063627243, 0.0833598897, 0.5979328156, 0.3241254687, 0.5886921287, 0.8592047095, 0.512615025, 0.102445744, 0.9590021968, 0.5871566534, 0.9378551245, 0.2742413282, 0.3772708178, 0.8194110394, 0.3097124994, 0.5186815262, 0.5790687203, 0.3888548911, 0.3783981502, 0.5485949516, 0.2360849977, 0.1109971181, 0.1770060807, 0.0904324874, 0.8018411398, 0.2950742543, 0.0381450877, 0.5604131222, 0.3210267127, 0.3792554736, 0.2347474247, 0.7373712063, 0.3776365817, 0.9647908211, 0.5733613372, 0.8895215988, 0.912230134, 0.8845624328, 0.9890085459, 0.3346363306, 0.4683856964, 0.8458541036, 0.9644401073, 0.5725477934, 0.6002668142, 0.9618119001, 0.049046468, 0.8619559407, 0.8179126382, 0.1007454395, 0.2741018534, 0.252915442, 0.2252032608, 0.9641648531, 0.2719295323, 0.0849194601, 0.4006107152, 0.6589605212, 0.3210944235, 0.0674258247, 0.1288291514, 0.4096716344, 0.6497788429, 0.8458643556, 0.0803250298, 0.8487070203, 0.5242260098, 0.8959512115, 0.8697840571, 0.6578457952, 0.7050910592, 0.0260187238, 0.6544261575, 0.3784641922, 0.6697351336, 0.6984977722, 0.2300171852, 0.2275477648, 0.4618140161, 0.004380255, 0.1367783546, 0.5262473822, 0.5664927363, 0.8188179135, 0.2854401469, 0.5096173286, 0.846061945, 0.6538503766, 0.1976764202, 0.8113370538, 0.6878486276, 0.2772192657, 0.5029959083, 0.3217979074, 0.868201673, 0.9023321867, 0.2392933965, 0.3244680464, 0.2063642442, 0.3317535222, 0.4532529712, 0.6298089623, 0.9295437932, 0.9851393104, 0.9638314843, 0.9375714064, 0.943533361, 0.8102272749, 0.6071764827, 0.9091103077, 0.2624617815, 0.7722917199, 0.4389513731, 0.8667045832, 0.342523098, 0.0033291576, 0.923145473, 0.9432785511, 0.9592960477, 0.2287584394, 0.0247588865, 0.1442265064, 0.2602964342, 0.0918844566, 0.6565052271, 0.9979584217, 0.218133539, 0.4316166937, 0.0917130336, 0.6942002177, 0.9575509429, 0.1220782027, 0.6995287538, 0.8739034534, 0.348526299, 0.4598202407, 0.6827418208, 0.2721637189, 0.8722845316, 0.4672423899, 0.970356226, 0.4107722938, 0.8949344754, 0.1996881366, 0.6141865253, 0.9579420686, 0.4882082641, 0.4934619963, 0.9897007346, 0.7543770075, 0.325093478, 0.8106310368, 0.2069644034, 0.9926779866, 0.2243934423, 0.7587417364, 0.7491098642, 0.8762744069, 0.990685761, 0.429707557, 0.9256587029, 0.2549348772, 0.1323014796, 0.1039625034, 0.2169004679, 0.1334284395, 0.9942365885, 0.8120270371, 0.4623450041, 0.2175034285, 0.0858128145, 0.4969757497, 0.1789617538, 0.8189846277, 0.2477202863, 0.7505609989, 0.1874369234, 0.8741084933, 0.104247041, 0.6346544027, 0.4555490911, 0.7371039391, 0.4959346652, 0.1045920923, 0.1488533467, 0.2084970623, 0.2087403238, 0.8766234517, 0.4639246166, 0.2548867464, 0.7751787901, 0.7511588335, 0.0367171839, 0.8742753863, 0.7835904956, 0.1286349744, 0.2470860481, 0.1739185601, 0.3238283992, 0.7448464632, 0.3101584911, 0.3149905205, 0.1473620832, 0.1043146625, 0.8647398949, 0.2620262802, 0.6992393732, 0.8620148301, 0.2021593451, 0.3004637957, 0.5054730773, 0.6774873137, 0.0113230776, 0.3227222562, 0.2864091694, 0.422524482, 0.7935581207, 0.0975255296, 0.3237173557, 0.8806690574, 0.8842474818, 0.3075688779, 0.888156116, 0.2061693072, 0.2642721832, 0.7491376996, 0.6765557528, 0.82862252, 0.963966608, 0.4441624284, 0.9878573418, 0.9235497117, 0.6316314936, 0.202571556, 0.5196759105, 0.2212169319, 0.6624719501, 0.9407488108, 0.2060395926, 0.2672573626, 0.4387931228, 0.2834221721, 0.7842905521, 0.5729217529, 0.8006983399, 0.6752763391, 0.8671710491, 0.8866243362, 0.9910276532, 0.2595298886, 0.4719019532, 0.6245686412, 0.1164552271, 0.202843979, 0.2505145371, 0.7376209497, 0.3879756331, 0.6127753258, 0.2036545426, 0.7027260661, 0.4211112261, 0.1811889112, 0.8868420124, 0.2035310566, 0.8182333708, 0.6264363527, 0.3459434509, 0.9136525989, 0.991984725, 0.5912823081, 0.9506404996, 0.02927774, 0.403455019, 0.5760018229, 0.5426461697, 0.2608519495, 0.1179740056, 0.4091444314, 0.5757969618, 0.6824651361, 0.4251429737, 0.0928455889, 0.3766567707, 0.2033229172, 0.7959060073, 0.6874306202, 0.2414992452, 0.6848184466, 0.5737532973, 0.897330761, 0.2751243412, 0.3875006735, 0.8072223663, 0.5735291839, 0.9130150676, 0.2748070061, 0.2921602428, 0.988473177, 0.5731204748, 0.540784955, 0.3014898002, 0.435996592, 0.2804161608, 0.5733448863, 0.9205425978, 0.2539848983]);
C.List_s9c = Isolate.makeConstantList([0.000003917, 0.000004393581, 0.000004929604, 0.000005532136, 0.000006208245, 0.000006965, 0.000007813219, 0.000008767336, 0.000009839844, 0.00001104323, 0.00001239, 0.00001388641, 0.00001555728, 0.00001744296, 0.00001958375, 0.00002202, 0.00002483965, 0.00002804126, 0.00003153104, 0.00003521521, 0.000039, 0.0000428264, 0.0000469146, 0.0000515896, 0.0000571764, 0.000064, 0.00007234421, 0.00008221224, 0.00009350816, 0.0001061361, 0.00012, 0.000134984, 0.000151492, 0.000170208, 0.000191816, 0.000217, 0.0002469067, 0.00028124, 0.00031852, 0.0003572667, 0.000396, 0.0004337147, 0.000473024, 0.000517876, 0.0005722187, 0.00064, 0.00072456, 0.0008255, 0.00094116, 0.00106988, 0.00121, 0.001362091, 0.001530752, 0.001720368, 0.001935323, 0.00218, 0.0024548, 0.002764, 0.0031178, 0.0035264, 0.004, 0.00454624, 0.00515932, 0.00582928, 0.00654616, 0.0073, 0.008086507, 0.00890872, 0.00976768, 0.01066443, 0.0116, 0.01257317, 0.01358272, 0.01462968, 0.01571509, 0.01684, 0.01800736, 0.01921448, 0.02045392, 0.02171824, 0.023, 0.02429461, 0.02561024, 0.02695857, 0.02835125, 0.0298, 0.03131083, 0.03288368, 0.03452112, 0.03622571, 0.038, 0.03984667, 0.041768, 0.043766, 0.04584267, 0.048, 0.05024368, 0.05257304, 0.05498056, 0.05745872, 0.06, 0.06260197, 0.06527752, 0.06804208, 0.07091109, 0.0739, 0.077016, 0.0802664, 0.0836668, 0.0872328, 0.09098, 0.09491755, 0.09904584, 0.1033674, 0.1078846, 0.1126, 0.117532, 0.1226744, 0.1279928, 0.1334528, 0.13902, 0.1446764, 0.1504693, 0.1564619, 0.1627177, 0.1693, 0.1762431, 0.1835581, 0.1912735, 0.199418, 0.20802, 0.2171199, 0.2267345, 0.2368571, 0.2474812, 0.2586, 0.2701849, 0.2822939, 0.2950505, 0.308578, 0.323, 0.3384021, 0.3546858, 0.3716986, 0.3892875, 0.4073, 0.4256299, 0.4443096, 0.4633944, 0.4829395, 0.503, 0.5235693, 0.544512, 0.56569, 0.5869653, 0.6082, 0.6293456, 0.6503068, 0.6708752, 0.6908424, 0.71, 0.7281852, 0.7454636, 0.7619694, 0.7778368, 0.7932, 0.8081104, 0.8224962, 0.8363068, 0.8494916, 0.862, 0.8738108, 0.8849624, 0.8954936, 0.9054432, 0.9148501, 0.9237348, 0.9320924, 0.9399226, 0.9472252, 0.954, 0.9602561, 0.9660074, 0.9712606, 0.9760225, 0.9803, 0.9840924, 0.9874812, 0.9903128, 0.9928116, 0.9949501, 0.9967108, 0.9980983, 0.999112, 0.9997482, 1, 0.9998567, 0.9993046, 0.9983255, 0.9968987, 0.995, 0.9926005, 0.9897426, 0.9864444, 0.9827241, 0.9786, 0.9740837, 0.9691712, 0.9638568, 0.9581349, 0.952, 0.9454504, 0.9384992, 0.9311628, 0.9234576, 0.9154, 0.9070064, 0.8982772, 0.8892048, 0.8797816, 0.87, 0.8598613, 0.849392, 0.838622, 0.8275813, 0.8163, 0.8047947, 0.793082, 0.781192, 0.7691547, 0.757, 0.7447541, 0.7324224, 0.7200036, 0.7074965, 0.6949, 0.6822192, 0.6694716, 0.6566744, 0.6438448, 0.631, 0.6181555, 0.6053144, 0.5924756, 0.5796379, 0.5668, 0.5539611, 0.5411372, 0.5283528, 0.5156323, 0.503, 0.4904688, 0.4780304, 0.4656776, 0.4534032, 0.4412, 0.42908, 0.417036, 0.405032, 0.393032, 0.381, 0.3689184, 0.3568272, 0.3447768, 0.3328176, 0.321, 0.3093381, 0.2978504, 0.2865936, 0.2756245, 0.265, 0.2547632, 0.2448896, 0.2353344, 0.2260528, 0.217, 0.2081616, 0.1995488, 0.1911552, 0.1829744, 0.175, 0.1672235, 0.1596464, 0.1522776, 0.1451259, 0.1382, 0.1315003, 0.1250248, 0.1187792, 0.1127691, 0.107, 0.1014762, 0.09618864, 0.09112296, 0.08626485, 0.0816, 0.07712064, 0.07282552, 0.06871008, 0.06476976, 0.061, 0.05739621, 0.05395504, 0.05067376, 0.04754965, 0.04458, 0.04175872, 0.03908496, 0.03656384, 0.03420048, 0.032, 0.02996261, 0.02807664, 0.02632936, 0.02470805, 0.0232, 0.02180077, 0.02050112, 0.01928108, 0.01812069, 0.017, 0.01590379, 0.01483718, 0.01381068, 0.01283478, 0.01192, 0.01106831, 0.01027339, 0.009533311, 0.008846157, 0.00821, 0.007623781, 0.007085424, 0.006591476, 0.006138485, 0.005723, 0.005343059, 0.004995796, 0.004676404, 0.004380075, 0.004102, 0.003838453, 0.003589099, 0.003354219, 0.003134093, 0.002929, 0.002738139, 0.002559876, 0.002393244, 0.002237275, 0.002091, 0.001953587, 0.00182458, 0.00170358, 0.001590187, 0.001484, 0.001384496, 0.001291268, 0.001204092, 0.001122744, 0.001047, 0.0009765896, 0.0009111088, 0.0008501332, 0.0007932384, 0.00074, 0.0006900827, 0.00064331, 0.000599496, 0.0005584547, 0.00052, 0.0004839136, 0.0004500528, 0.0004183452, 0.0003887184, 0.0003611, 0.0003353835, 0.0003114404, 0.0002891656, 0.0002684539, 0.0002492, 0.0002313019, 0.0002146856, 0.0001992884, 0.0001850475, 0.0001719, 0.0001597781, 0.0001486044, 0.0001383016, 0.0001287925, 0.00012, 0.0001118595, 0.0001043224, 0.0000973356, 0.00009084587, 0.0000848, 0.00007914667, 0.000073858, 0.000068916, 0.00006430267, 0.00006, 0.00005598187, 0.0000522256, 0.0000487184, 0.00004544747, 0.0000424, 0.00003956104, 0.00003691512, 0.00003444868, 0.00003214816, 0.00003, 0.00002799125, 0.00002611356, 0.00002436024, 0.00002272461, 0.0000212, 0.00001977855, 0.00001845285, 0.00001721687, 0.00001606459, 0.00001499, 0.00001398728, 0.00001305155, 0.00001217818, 0.00001136254, 0.0000106, 0.000009885877, 0.000009217304, 0.000008592362, 0.000008009133, 0.0000074657, 0.000006959567, 0.000006487995, 0.000006048699, 0.000005639396, 0.0000052578, 0.000004901771, 0.00000456972, 0.000004260194, 0.000003971739, 0.0000037029, 0.000003452163, 0.000003218302, 0.0000030003, 0.000002797139, 0.0000026078, 0.00000243122, 0.000002266531, 0.000002113013, 0.000001969943, 0.0000018366, 0.00000171223, 0.000001596228, 0.00000148809, 0.000001387314, 0.0000012934, 0.00000120582, 0.000001124143, 0.000001048009, 9.770578e-7, 9.1093e-7, 8.492513e-7, 7.917212e-7, 7.380904e-7, 6.881098e-7, 6.4153e-7, 5.980895e-7, 5.575746e-7, 5.19808e-7, 4.846123e-7, 4.5181e-7]);
C.List_173_148_140 = Isolate.makeConstantList([173, 148, 140]);
C.List_176_155_140_135 = Isolate.makeConstantList([176, 155, 140, 135]);
C.List_yTu0 = Isolate.makeConstantList([180, 157, 141, 134, 130]);
C.List_2hT8 = Isolate.makeConstantList([254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129]);
C.List_sao = Isolate.makeConstantList([C.List_173_148_140, C.List_176_155_140_135, C.List_yTu0, C.List_2hT8]);
C.List_ssa = Isolate.makeConstantList([1.1565232050369776, 1.156722500011914, 1.1566203150243823, 1.1555782088080084, 1.15621755092157, 1.1567674012207332, 1.156802319480863, 1.156767744548552, 1.156356318295283, 1.1567054702510189, 1.1565134139372772, 1.1564336176499312, 1.1568023181530034, 1.1473147688514642, 1.1339317140561065, 1.1293876490671435, 1.1290515328639648, 1.0504864823782283, 1.0459696042230884, 0.9936668716859569, 0.9560166926539394, 0.924674820335118, 0.9149994470205176, 0.8993946765845346, 0.8954252075133111, 0.8887056669381475, 0.8822284381422811, 0.8799831137382668, 0.8763524461224458, 0.8800036833170911, 0.8806566542844112, 0.883047064602769]);
C.List_sty = Isolate.makeConstantList([U.VP8Filter_DC4$closure(), U.VP8Filter_TM4$closure(), U.VP8Filter_VE4$closure(), U.VP8Filter_HE4$closure(), U.VP8Filter_RD4$closure(), U.VP8Filter_VR4$closure(), U.VP8Filter_LD4$closure(), U.VP8Filter_VL4$closure(), U.VP8Filter_HD4$closure(), U.VP8Filter_HU4$closure()]);
C.List_uSC = Isolate.makeConstantList([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
C.List_uSC0 = Isolate.makeConstantList([17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
C.List_wQn = Isolate.makeConstantList([0.05471118715729184, 0.0556090664983034, 0.060755873790918236, 0.05623294861596237, 0.04616994053570868, 0.038012808167818095, 0.02442422575667034, 0.003898358058159218, -0.0005608225217273444, 0.0009649387125519465, 0.0003734119805151037, -0.000433673890931352, -0.00009353396225689203, -0.00012354967412842033, -0.0001452454808168746, -0.0002004769191554373, -0.0004993858769469367, 0.027255083540032476, 0.1606740590629706, 0.35069788873150953, 0.5735746553841896, 0.7639209189071895, 0.8914446674038152, 0.9639460990957489, 0.9887946427601628, 0.998974499662272, 0.9860514040356416, 0.995325028053452, 0.9743347837730537, 0.9913436461687141, 0.9886628777217475, 0.9971385608973553]);
C.List_wmc = Isolate.makeConstantList([127, 127, 191, 127, 159, 191, 223, 127, 143, 159, 175, 191, 207, 223, 239, 127, 135, 143, 151, 159, 167, 175, 183, 191, 199, 207, 215, 223, 231, 239, 247, 127, 131, 135, 139, 143, 147, 151, 155, 159, 163, 167, 171, 175, 179, 183, 187, 191, 195, 199, 203, 207, 211, 215, 219, 223, 227, 231, 235, 239, 243, 247, 251, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 127]);
C.List_wsa = Isolate.makeConstantList([0.0001299, 0.000145847, 0.0001638021, 0.0001840037, 0.0002066902, 0.0002321, 0.000260728, 0.000293075, 0.000329388, 0.000369914, 0.0004149, 0.0004641587, 0.000518986, 0.000581854, 0.0006552347, 0.0007416, 0.0008450296, 0.0009645268, 0.001094949, 0.001231154, 0.001368, 0.00150205, 0.001642328, 0.001802382, 0.001995757, 0.002236, 0.002535385, 0.002892603, 0.003300829, 0.003753236, 0.004243, 0.004762389, 0.005330048, 0.005978712, 0.006741117, 0.00765, 0.008751373, 0.01002888, 0.0114217, 0.01286901, 0.01431, 0.01570443, 0.01714744, 0.01878122, 0.02074801, 0.02319, 0.02620736, 0.02978248, 0.03388092, 0.03846824, 0.04351, 0.0489956, 0.0550226, 0.0617188, 0.069212, 0.07763, 0.08695811, 0.09717672, 0.1084063, 0.1207672, 0.13438, 0.1493582, 0.1653957, 0.1819831, 0.198611, 0.21477, 0.2301868, 0.2448797, 0.2587773, 0.2718079, 0.2839, 0.2949438, 0.3048965, 0.3137873, 0.3216454, 0.3285, 0.3343513, 0.3392101, 0.3431213, 0.3461296, 0.34828, 0.3495999, 0.3501474, 0.350013, 0.349287, 0.34806, 0.3463733, 0.3442624, 0.3418088, 0.3390941, 0.3362, 0.3331977, 0.3300411, 0.3266357, 0.3228868, 0.3187, 0.3140251, 0.308884, 0.3032904, 0.2972579, 0.2908, 0.2839701, 0.2767214, 0.2689178, 0.2604227, 0.2511, 0.2408475, 0.2298512, 0.2184072, 0.2068115, 0.19536, 0.1842136, 0.1733273, 0.1626881, 0.1522833, 0.1421, 0.1321786, 0.1225696, 0.1132752, 0.1042979, 0.09564, 0.08729955, 0.07930804, 0.07171776, 0.06458099, 0.05795001, 0.05186211, 0.04628152, 0.04115088, 0.03641283, 0.03201, 0.0279172, 0.0241444, 0.020687, 0.0175404, 0.0147, 0.01216179, 0.00991996, 0.00796724, 0.006296346, 0.0049, 0.003777173, 0.00294532, 0.00242488, 0.002236293, 0.0024, 0.00292552, 0.00383656, 0.00517484, 0.00698208, 0.0093, 0.01214949, 0.01553588, 0.01947752, 0.02399277, 0.0291, 0.03481485, 0.04112016, 0.04798504, 0.05537861, 0.06327, 0.07163501, 0.08046224, 0.08973996, 0.09945645, 0.1096, 0.1201674, 0.1311145, 0.1423679, 0.1538542, 0.1655, 0.1772571, 0.18914, 0.2011694, 0.2133658, 0.2257499, 0.2383209, 0.2510668, 0.2639922, 0.2771017, 0.2904, 0.3038912, 0.3175726, 0.3314384, 0.3454828, 0.3597, 0.3740839, 0.3886396, 0.4033784, 0.4183115, 0.4334499, 0.4487953, 0.464336, 0.480064, 0.4959713, 0.5120501, 0.5282959, 0.5446916, 0.5612094, 0.5778215, 0.5945, 0.6112209, 0.6279758, 0.6447602, 0.6615697, 0.6784, 0.6952392, 0.7120586, 0.7288284, 0.7455188, 0.7621, 0.7785432, 0.7948256, 0.8109264, 0.8268248, 0.8425, 0.8579325, 0.8730816, 0.8878944, 0.9023181, 0.9163, 0.9297995, 0.9427984, 0.9552776, 0.9672179, 0.9786, 0.9893856, 0.9995488, 1.0090892, 1.0180064, 1.0263, 1.0339827, 1.040986, 1.047188, 1.0524667, 1.0567, 1.0597944, 1.0617992, 1.0628068, 1.0629096, 1.0622, 1.0607352, 1.0584436, 1.0552244, 1.0509768, 1.0456, 1.0390369, 1.0313608, 1.0226662, 1.0130477, 1.0026, 0.9913675, 0.9793314, 0.9664916, 0.9528479, 0.9384, 0.923194, 0.907244, 0.890502, 0.87292, 0.8544499, 0.835084, 0.814946, 0.794186, 0.772954, 0.7514, 0.7295836, 0.7075888, 0.6856022, 0.6638104, 0.6424, 0.6215149, 0.6011138, 0.5811052, 0.5613977, 0.5419, 0.5225995, 0.5035464, 0.4847436, 0.4661939, 0.4479, 0.4298613, 0.412098, 0.394644, 0.3775333, 0.3608, 0.3444563, 0.3285168, 0.3130192, 0.2980011, 0.2835, 0.2695448, 0.2561184, 0.2431896, 0.2307272, 0.2187, 0.2070971, 0.1959232, 0.1851708, 0.1748323, 0.1649, 0.1553667, 0.14623, 0.13749, 0.1291467, 0.1212, 0.1136397, 0.106465, 0.09969044, 0.09333061, 0.0874, 0.08190096, 0.07680428, 0.07207712, 0.06768664, 0.0636, 0.05980685, 0.05628216, 0.05297104, 0.04981861, 0.04677, 0.04378405, 0.04087536, 0.03807264, 0.03540461, 0.0329, 0.03056419, 0.02838056, 0.02634484, 0.02445275, 0.0227, 0.02108429, 0.01959988, 0.01823732, 0.01698717, 0.01584, 0.01479064, 0.01383132, 0.01294868, 0.0121292, 0.01135916, 0.01062935, 0.009938846, 0.009288422, 0.008678854, 0.008110916, 0.007582388, 0.007088746, 0.006627313, 0.006195408, 0.005790346, 0.005409826, 0.005052583, 0.004717512, 0.004403507, 0.004109457, 0.003833913, 0.003575748, 0.003334342, 0.003109075, 0.002899327, 0.002704348, 0.00252302, 0.002354168, 0.002196616, 0.00204919, 0.00191096, 0.001781438, 0.00166011, 0.001546459, 0.001439971, 0.001340042, 0.001246275, 0.001158471, 0.00107643, 0.0009999493, 0.0009287358, 0.0008624332, 0.0008007503, 0.000743396, 0.0006900786, 0.0006405156, 0.0005945021, 0.0005518646, 0.000512429, 0.0004760213, 0.0004424536, 0.0004115117, 0.0003829814, 0.0003566491, 0.0003323011, 0.0003097586, 0.0002888871, 0.0002695394, 0.0002515682, 0.0002348261, 0.000219171, 0.0002045258, 0.0001908405, 0.0001780654, 0.0001661505, 0.0001550236, 0.0001446219, 0.0001349098, 0.000125852, 0.000117413, 0.0001095515, 0.0001022245, 0.00009539445, 0.0000890239, 0.00008307527, 0.00007751269, 0.00007231304, 0.00006745778, 0.00006292844, 0.00005870652, 0.00005477028, 0.00005109918, 0.00004767654, 0.00004448567, 0.00004150994, 0.00003873324, 0.00003614203, 0.00003372352, 0.00003146487, 0.00002935326, 0.00002737573, 0.00002552433, 0.00002379376, 0.0000221787, 0.00002067383, 0.00001927226, 0.0000179664, 0.00001674991, 0.00001561648, 0.00001455977, 0.00001357387, 0.00001265436, 0.00001179723, 0.00001099844, 0.00001025398, 0.000009559646, 0.000008912044, 0.000008308358, 0.000007745769, 0.000007221456, 0.000006732475, 0.000006276423, 0.000005851304, 0.000005455118, 0.000005085868, 0.000004741466, 0.000004420236, 0.000004120783, 0.000003841716, 0.000003581652, 0.000003339127, 0.000003112949, 0.000002902121, 0.000002705645, 0.000002522525, 0.000002351726, 0.000002192415, 0.000002043902, 0.000001905497, 0.000001776509, 0.000001656215, 0.000001544022, 0.00000143944, 0.000001341977, 0.000001251141]);
C.List_wwi = Isolate.makeConstantList([1.662125, 1.687, 1.703313, 1.72, 1.744563, 1.77, 1.791625, 1.81, 1.822125, 1.834, 1.85175, 1.872, 1.89425, 1.916, 1.931688, 1.95, 1.972438, 2.015, 2.121562, 2.21, 2.177188, 2.13, 2.160063, 2.21, 2.249938, 2.289, 2.326, 2.362, 2.397625, 2.433, 2.469187, 2.504, 2.535875, 2.564, 2.589625, 2.605, 2.595562, 2.583, 2.5765, 2.599, 2.678062, 2.809, 3.01075, 3.24, 3.458187, 3.67, 3.863125, 4.05, 4.239563, 4.43, 4.619563, 4.817, 5.034125, 5.26, 5.485625, 5.717]);
C.List_yTu = Isolate.makeConstantList([280, 256, 256, 256, 40]);
C.List_yYQ = Isolate.makeConstantList([0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 0]);
C.List_2jN0 = Isolate.makeConstantList(["Apple", "Chicken1", "Chicken2", "Cream", "Ketchup", "Marble", "Potato", "Skimmilk", "Skin1", "Skin2", "Spectralon", "Wholemilk", "Lowfat Milk", "Reduced Milk", "Regular Milk", "Espresso", "Mint Mocha Coffee", "Lowfat Soy Milk", "Regular Soy Milk", "Lowfat Chocolate Milk", "Regular Chocolate Milk", "Coke", "Pepsi", "Sprite", "Gatorade", "Chardonnay", "White Zinfandel", "Merlot", "Budweiser Beer", "Coors Light Beer", "Clorox", "Apple Juice", "Cranberry Juice", "Grape Juice", "Ruby Grapefruit Juice", "White Grapefruit Juice", "Shampoo", "Strawberry Shampoo", "Head & Shoulders Shampoo", "Lemon Tea", "Orange Juice Powder", "Pink Lemonade", "Cappuccino Powder", "Salt Powder", "Sugar Powder", "Suisse Mocha", "Pacific Ocean Surface Water"]);
C.List_mUN = Isolate.makeConstantList([2.29, 2.39, 1.97]);
C.List_ww8 = Isolate.makeConstantList([0.003, 0.0034, 0.046]);
C.List_ezA = Isolate.makeConstantList([C.List_mUN, C.List_ww8]);
C.List_EfQ = Isolate.makeConstantList([0.15, 0.21, 0.38]);
C.List_NSV = Isolate.makeConstantList([0.015, 0.077, 0.19]);
C.List_scn = Isolate.makeConstantList([C.List_EfQ, C.List_NSV]);
C.List_ouf = Isolate.makeConstantList([0.19, 0.25, 0.32]);
C.List_aZ8 = Isolate.makeConstantList([0.018, 0.088, 0.2]);
C.List_SxQ = Isolate.makeConstantList([C.List_ouf, C.List_aZ8]);
C.List_7Vh = Isolate.makeConstantList([7.38, 5.47, 3.15]);
C.List_5Qz = Isolate.makeConstantList([0.0002, 0.0028, 0.0163]);
C.List_yT3 = Isolate.makeConstantList([C.List_7Vh, C.List_5Qz]);
C.List_O6H = Isolate.makeConstantList([0.18, 0.07, 0.03]);
C.List_Yf3 = Isolate.makeConstantList([0.061, 0.97, 1.45]);
C.List_omC = Isolate.makeConstantList([C.List_O6H, C.List_Yf3]);
C.List_QCc = Isolate.makeConstantList([2.19, 2.62, 3]);
C.List_05 = Isolate.makeConstantList([0.0021, 0.0041, 0.0071]);
C.List_woc = Isolate.makeConstantList([C.List_QCc, C.List_05]);
C.List_AWk = Isolate.makeConstantList([0.68, 0.7, 0.55]);
C.List_86y = Isolate.makeConstantList([0.0024, 0.009, 0.12]);
C.List_2ix = Isolate.makeConstantList([C.List_AWk, C.List_86y]);
C.List_FZX = Isolate.makeConstantList([0.7, 1.22, 1.9]);
C.List_ZfX = Isolate.makeConstantList([0.0014, 0.0025, 0.0142]);
C.List_Gb7 = Isolate.makeConstantList([C.List_FZX, C.List_ZfX]);
C.List_bzZ = Isolate.makeConstantList([0.74, 0.88, 1.01]);
C.List_ivu = Isolate.makeConstantList([0.032, 0.17, 0.48]);
C.List_n7e = Isolate.makeConstantList([C.List_bzZ, C.List_ivu]);
C.List_TnQ = Isolate.makeConstantList([1.09, 1.59, 1.79]);
C.List_evT = Isolate.makeConstantList([0.013, 0.07, 0.145]);
C.List_oiE = Isolate.makeConstantList([C.List_TnQ, C.List_evT]);
C.List_06 = Isolate.makeConstantList([11.6, 20.4, 14.9]);
C.List_0_0_0 = Isolate.makeConstantList([0, 0, 0]);
C.List_asd = Isolate.makeConstantList([C.List_06, C.List_0_0_0]);
C.List_gQW = Isolate.makeConstantList([2.55, 3.21, 3.77]);
C.List_4mj = Isolate.makeConstantList([0.0011, 0.0024, 0.014]);
C.List_yDQ = Isolate.makeConstantList([C.List_gQW, C.List_4mj]);
C.List_kqE = Isolate.makeConstantList([0.9126, 1.0748, 1.25]);
C.List_gA4 = Isolate.makeConstantList([0.0002, 0.0004, 0.0008]);
C.List_bkm = Isolate.makeConstantList([C.List_kqE, C.List_gA4]);
C.List_kRZ = Isolate.makeConstantList([1.075, 1.2213, 1.3941]);
C.List_pPg = Isolate.makeConstantList([0.0002, 0.0004, 0.001]);
C.List_O5U = Isolate.makeConstantList([C.List_kRZ, C.List_pPg]);
C.List_3MM = Isolate.makeConstantList([1.1874, 1.3296, 1.4602]);
C.List_Xdg = Isolate.makeConstantList([0.0001, 0.0003, 0.0013]);
C.List_c9P = Isolate.makeConstantList([C.List_3MM, C.List_Xdg]);
C.List_sIV = Isolate.makeConstantList([0.4376, 0.5115, 0.6048]);
C.List_kqs = Isolate.makeConstantList([0.1669, 0.2287, 0.3078]);
C.List_74F = Isolate.makeConstantList([C.List_sIV, C.List_kqs]);
C.List_wpv = Isolate.makeConstantList([0.19, 0.26, 0.35]);
C.List_RsV = Isolate.makeConstantList([0.0984, 0.1519, 0.204]);
C.List_uwZ = Isolate.makeConstantList([C.List_wpv, C.List_RsV]);
C.List_mRX = Isolate.makeConstantList([0.1419, 0.1625, 0.274]);
C.List_U4G = Isolate.makeConstantList([0.0001, 0.0005, 0.0025]);
C.List_G7t = Isolate.makeConstantList([C.List_mRX, C.List_U4G]);
C.List_Vjv = Isolate.makeConstantList([0.2434, 0.2719, 0.4597]);
C.List_EKW = Isolate.makeConstantList([0.0001, 0.0005, 0.0034]);
C.List_ECn = Isolate.makeConstantList([C.List_Vjv, C.List_EKW]);
C.List_cSk = Isolate.makeConstantList([0.4282, 0.5014, 0.5791]);
C.List_EYy = Isolate.makeConstantList([0.0005, 0.0016, 0.0068]);
C.List_mye = Isolate.makeConstantList([C.List_cSk, C.List_EYy]);
C.List_gam = Isolate.makeConstantList([0.7359, 0.9172, 1.0688]);
C.List_wSH = Isolate.makeConstantList([0.0007, 0.003, 0.01]);
C.List_zsT = Isolate.makeConstantList([C.List_gam, C.List_wSH]);
C.List_sEV = Isolate.makeConstantList([0.7143, 1.1688, 1.7169]);
C.List_xd9 = Isolate.makeConstantList([0.6966, 1.148, 1.7169]);
C.List_4CA = Isolate.makeConstantList([C.List_sEV, C.List_xd9]);
C.List_6pZ = Isolate.makeConstantList([0.6433, 0.999, 1.442]);
C.List_EO3 = Isolate.makeConstantList([0.6375, 0.9849, 1.442]);
C.List_BGa = Isolate.makeConstantList([C.List_6pZ, C.List_EO3]);
C.List_4QF0 = Isolate.makeConstantList([0.1299, 0.1283, 0.1395]);
C.List_E0K = Isolate.makeConstantList([0.123, 0.1194, 0.1306]);
C.List_nAy = Isolate.makeConstantList([C.List_4QF0, C.List_E0K]);
C.List_fHw = Isolate.makeConstantList([0.4009, 0.4185, 0.4324]);
C.List_7N7 = Isolate.makeConstantList([0.1617, 0.1258, 0.0579]);
C.List_vnT = Isolate.makeConstantList([C.List_fHw, C.List_7N7]);
C.List_6NN = Isolate.makeConstantList([0.1577, 0.1748, 0.3512]);
C.List_ahs = Isolate.makeConstantList([0.1547, 0.1701, 0.3443]);
C.List_We0 = Isolate.makeConstantList([C.List_6NN, C.List_ahs]);
C.List_n3g = Isolate.makeConstantList([0.1763, 0.237, 0.2913]);
C.List_SHK = Isolate.makeConstantList([0.1732, 0.2322, 0.2847]);
C.List_KlU = Isolate.makeConstantList([C.List_n3g, C.List_SHK]);
C.List_9GF = Isolate.makeConstantList([0.7639, 1.6429, 1.9196]);
C.List_omC0 = Isolate.makeConstantList([0.7586, 1.6429, 1.9196]);
C.List_JNA = Isolate.makeConstantList([C.List_9GF, C.List_omC0]);
C.List_AmO = Isolate.makeConstantList([0.1486, 0.321, 0.736]);
C.List_ESh = Isolate.makeConstantList([0.1449, 0.3141, 0.7286]);
C.List_hVR = Isolate.makeConstantList([C.List_AmO, C.List_ESh]);
C.List_8Ac = Isolate.makeConstantList([0.0295, 0.0663, 0.1521]);
C.List_cMb = Isolate.makeConstantList([0.0268, 0.0608, 0.1521]);
C.List_zpz = Isolate.makeConstantList([C.List_8Ac, C.List_cMb]);
C.List_ifn = Isolate.makeConstantList([0.16, 0.25, 0.33]);
C.List_9Bk = Isolate.makeConstantList([0.0175, 0.0777, 0.1372]);
C.List_PHN = Isolate.makeConstantList([C.List_ifn, C.List_9Bk]);
C.List_wEs = Isolate.makeConstantList([0.1215, 0.2101, 0.4407]);
C.List_b3I = Isolate.makeConstantList([0.1014, 0.1858, 0.4084]);
C.List_axY = Isolate.makeConstantList([C.List_wEs, C.List_b3I]);
C.List_luc = Isolate.makeConstantList([0.27, 0.63, 0.83]);
C.List_esx = Isolate.makeConstantList([0.2572, 0.6145, 0.8104]);
C.List_aOd = Isolate.makeConstantList([C.List_luc, C.List_esx]);
C.List_Ieh = Isolate.makeConstantList([0.55, 1.25, 1.53]);
C.List_4a0 = Isolate.makeConstantList([0.5428, 1.25, 1.53]);
C.List_8aB0 = Isolate.makeConstantList([C.List_Ieh, C.List_4a0]);
C.List_esZ = Isolate.makeConstantList([0.2513, 0.3517, 0.4305]);
C.List_8IC = Isolate.makeConstantList([0.0896, 0.1911, 0.2636]);
C.List_spY = Isolate.makeConstantList([C.List_esZ, C.List_8IC]);
C.List_KTZ = Isolate.makeConstantList([0.3609, 0.38, 0.5632]);
C.List_Vsy = Isolate.makeConstantList([0.0096, 0.0131, 0.0395]);
C.List_G3K = Isolate.makeConstantList([C.List_KTZ, C.List_Vsy]);
C.List_54c = Isolate.makeConstantList([0.0288, 0.071, 0.0952]);
C.List_WZ4 = Isolate.makeConstantList([0.0184, 0.0596, 0.0805]);
C.List_Iwp = Isolate.makeConstantList([C.List_54c, C.List_WZ4]);
C.List_k4X = Isolate.makeConstantList([0.0217, 0.0788, 0.1022]);
C.List_j00 = Isolate.makeConstantList([0.0189, 0.0756, 0.0989]);
C.List_CzM = Isolate.makeConstantList([C.List_k4X, C.List_j00]);
C.List_Nci = Isolate.makeConstantList([0.3674, 0.4527, 0.5211]);
C.List_46c = Isolate.makeConstantList([0.0883, 0.1637, 0.2125]);
C.List_GZB = Isolate.makeConstantList([C.List_Nci, C.List_46c]);
C.List_8IM = Isolate.makeConstantList([0.34, 0.58, 0.88]);
C.List_rCi = Isolate.makeConstantList([0.2602, 0.4902, 0.7727]);
C.List_Q92 = Isolate.makeConstantList([C.List_8IM, C.List_rCi]);
C.List_oKv = Isolate.makeConstantList([0.3377, 0.5573, 1.0122]);
C.List_aOh = Isolate.makeConstantList([0.1449, 0.3441, 0.7863]);
C.List_FQd = Isolate.makeConstantList([C.List_oKv, C.List_aOh]);
C.List_X3Z = Isolate.makeConstantList([0.24, 0.37, 0.45]);
C.List_Y6u = Isolate.makeConstantList([0.1165, 0.2366, 0.3195]);
C.List_mbx = Isolate.makeConstantList([C.List_X3Z, C.List_Y6u]);
C.List_GbU = Isolate.makeConstantList([0.2574, 0.3536, 0.484]);
C.List_qAw = Isolate.makeConstantList([0.192, 0.2654, 0.3272]);
C.List_Scp = Isolate.makeConstantList([C.List_GbU, C.List_qAw]);
C.List_k3D = Isolate.makeConstantList([0.76, 0.8685, 0.9363]);
C.List_c0h = Isolate.makeConstantList([0.5115, 0.5863, 0.6147]);
C.List_aFE = Isolate.makeConstantList([C.List_k3D, C.List_c0h]);
C.List_ATp = Isolate.makeConstantList([0.0795, 0.1759, 0.278]);
C.List_uUY = Isolate.makeConstantList([0.065, 0.1597, 0.2578]);
C.List_eig = Isolate.makeConstantList([C.List_ATp, C.List_uUY]);
C.List_L12 = Isolate.makeConstantList([0.5098, 0.6476, 0.7944]);
C.List_wwi0 = Isolate.makeConstantList([0.1875, 0.2893, 0.3796]);
C.List_BCk = Isolate.makeConstantList([C.List_L12, C.List_wwi0]);
C.List_mCd = Isolate.makeConstantList([3.3645, 3.3158, 3.2428]);
C.List_HCu = Isolate.makeConstantList([3.1845, 3.1324, 3.0147]);
C.List_Ec2 = Isolate.makeConstantList([C.List_mCd, C.List_HCu]);
C.Map_2j0 = new H.ConstantStringMap(47, {Apple: C.List_ezA, Chicken1: C.List_scn, Chicken2: C.List_SxQ, Cream: C.List_yT3, Ketchup: C.List_omC, Marble: C.List_woc, Potato: C.List_2ix, Skimmilk: C.List_Gb7, Skin1: C.List_n7e, Skin2: C.List_oiE, Spectralon: C.List_asd, Wholemilk: C.List_yDQ, "Lowfat Milk": C.List_bkm, "Reduced Milk": C.List_O5U, "Regular Milk": C.List_c9P, Espresso: C.List_74F, "Mint Mocha Coffee": C.List_uwZ, "Lowfat Soy Milk": C.List_G7t, "Regular Soy Milk": C.List_ECn, "Lowfat Chocolate Milk": C.List_mye, "Regular Chocolate Milk": C.List_zsT, Coke: C.List_4CA, Pepsi: C.List_BGa, Sprite: C.List_nAy, Gatorade: C.List_vnT, Chardonnay: C.List_We0, "White Zinfandel": C.List_KlU, Merlot: C.List_JNA, "Budweiser Beer": C.List_hVR, "Coors Light Beer": C.List_zpz, Clorox: C.List_PHN, "Apple Juice": C.List_axY, "Cranberry Juice": C.List_aOd, "Grape Juice": C.List_8aB0, "Ruby Grapefruit Juice": C.List_spY, "White Grapefruit Juice": C.List_G3K, Shampoo: C.List_Iwp, "Strawberry Shampoo": C.List_CzM, "Head & Shoulders Shampoo": C.List_GZB, "Lemon Tea": C.List_Q92, "Orange Juice Powder": C.List_FQd, "Pink Lemonade": C.List_mbx, "Cappuccino Powder": C.List_Scp, "Salt Powder": C.List_aFE, "Sugar Powder": C.List_eig, "Suisse Mocha": C.List_BCk, "Pacific Ocean Surface Water": C.List_Ec2}, C.List_2jN0);
C.Map_Od2I8 = new H.GeneralConstantMap([315, "artist", 258, "bitsPerSample", 265, "cellLength", 264, "cellWidth", 320, "colorMap", 259, "compression", 306, "dateTime", 34665, "exifIFD", 338, "extraSamples", 266, "fillOrder", 289, "freeByteCounts", 288, "freeOffsets", 291, "grayResponseCurve", 290, "grayResponseUnit", 316, "hostComputer", 34675, "iccProfile", 270, "imageDescription", 257, "imageLength", 256, "imageWidth", 33723, "iptc", 271, "make", 281, "maxSampleValue", 280, "minSampleValue", 272, "model", 254, "newSubfileType", 274, "orientation", 262, "photometricInterpretation", 34377, "photoshop", 284, "planarConfiguration", 317, "predictor", 296, "resolutionUnit", 278, "rowsPerStrip", 277, "samplesPerPixel", 305, "software", 279, "stripByteCounts", 273, "stropOffsets", 255, "subfileType", 292, "t4Options", 293, "t6Options", 263, "thresholding", 322, "tileWidth", 323, "tileLength", 324, "tileOffsets", 325, "tileByteCounts", 700, "xmp", 282, "xResolution", 283, "yResolution", 529, "yCbCrCoefficients", 530, "yCbCrSubsampling", 531, "yCbCrPositioning"]);
C.Type_AHF = H.createRuntimeType('NativeTypedArray');
C.Type_EQs = H.createRuntimeType('GlobalEventHandlers');
C.Type_NlB = H.createRuntimeType('NativeTypedArrayOfDouble');
C.Type_QyU = H.createRuntimeType('WindowEventHandlers');
C.Type_wOW = H.createRuntimeType('NativeTypedArrayOfInt');
$.libraries_to_load = {};
$.RawReceivePortImpl__nextFreeId = 1;
$.Primitives_mirrorFunctionCacheName = "$cachedFunction";
$.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.RuntimeFunctionType_inAssert = false;
$.getTagFunction = null;
$.alternateTagFunction = null;
$.prototypeForTagFunction = null;
$.dispatchRecordsForInstanceTags = null;
$.interceptorsForUncacheableTags = null;
$.initNativeDispatchFlag = null;
$.Log = G.PrintLogger$closure();
$.MIPMap_weightLut = null;
$.Primitive__nextprimitiveId = 1;
$.ResourceManager_global = null;
$.Shape__nextShapeId = 1;
$.Spectrum_type = 0;
$.printToZone = null;
$._nextCallback = null;
$._lastCallback = null;
$.Zone__current = C.C__RootZone;
$.Expando__keyCount = 0;
$.Device__isOpera = null;
$.Device__isWebKit = null;
$.VP8Filter__tablesInitialized = false;
$.Half__toFloatUint32 = null;
$.Half__toFloatFloat32 = null;
$.Half__eLut = null;
Isolate.$lazy($, "globalThis", "globalThis", "get$globalThis", function() {
  return function() { return this; }();
});
Isolate.$lazy($, "globalWindow", "globalWindow", "get$globalWindow", function() {
  return $.get$globalThis().window;
});
Isolate.$lazy($, "globalWorker", "globalWorker", "get$globalWorker", function() {
  return $.get$globalThis().Worker;
});
Isolate.$lazy($, "globalPostMessageDefined", "globalPostMessageDefined", "get$globalPostMessageDefined", function() {
  return $.get$globalThis().postMessage !== void 0;
});
Isolate.$lazy($, "thisScript", "IsolateNatives_thisScript", "get$IsolateNatives_thisScript", function() {
  return H.IsolateNatives_computeThisScript();
});
Isolate.$lazy($, "workerIds", "IsolateNatives_workerIds", "get$IsolateNatives_workerIds", function() {
  return new P.Expando(null);
});
Isolate.$lazy($, "noSuchMethodPattern", "TypeErrorDecoder_noSuchMethodPattern", "get$TypeErrorDecoder_noSuchMethodPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({ toString: function() { return "$receiver$"; } }));
});
Isolate.$lazy($, "notClosurePattern", "TypeErrorDecoder_notClosurePattern", "get$TypeErrorDecoder_notClosurePattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({ $method$: null, toString: function() { return "$receiver$"; } }));
});
Isolate.$lazy($, "nullCallPattern", "TypeErrorDecoder_nullCallPattern", "get$TypeErrorDecoder_nullCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
});
Isolate.$lazy($, "nullLiteralCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "get$TypeErrorDecoder_nullLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
  var $argumentsExpr$ = '$arguments$'
  try {
    null.$method$($argumentsExpr$);
  } catch (e) {
    return e.message;
  }
}());
});
Isolate.$lazy($, "undefinedCallPattern", "TypeErrorDecoder_undefinedCallPattern", "get$TypeErrorDecoder_undefinedCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
  var $argumentsExpr$ = '$arguments$'
  try {
    (void 0).$method$($argumentsExpr$);
  } catch (e) {
    return e.message;
  }
}());
});
Isolate.$lazy($, "nullPropertyPattern", "TypeErrorDecoder_nullPropertyPattern", "get$TypeErrorDecoder_nullPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
});
Isolate.$lazy($, "nullLiteralPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
  try {
    null.$method$;
  } catch (e) {
    return e.message;
  }
}());
});
Isolate.$lazy($, "undefinedPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "get$TypeErrorDecoder_undefinedPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
  try {
    (void 0).$method$;
  } catch (e) {
    return e.message;
  }
}());
});
Isolate.$lazy($, "_invLog2", "_invLog2", "get$_invLog2", function() {
  return 1 / Math.log(2);
});
Isolate.$lazy($, "ONE", "FresnelConductor_ONE", "get$FresnelConductor_ONE", function() {
  return G.Spectrum_Spectrum(1);
});
Isolate.$lazy($, "G", "_Spectrum_G", "get$_Spectrum_G", function() {
  return G._Spectrum$();
});
Isolate.$lazy($, "_output", "SpectrumImage__output", "get$SpectrumImage__output", function() {
  var t1 = new G.RGBColor(new Float32Array(3));
  t1.Spectrum$samples$2(3, 0);
  return t1;
});
Isolate.$lazy($, "trackers", "Stats_trackers", "get$Stats_trackers", function() {
  return [];
});
Isolate.$lazy($, "cameraRays", "Stats_cameraRays", "get$Stats_cameraRays", function() {
  var t1 = new G.StatsCounter(0, "Rays", "Camera Rays Traced");
  $.get$Stats_trackers().push(t1);
  return t1;
});
Isolate.$lazy($, "specularReflectionRays", "Stats_specularReflectionRays", "get$Stats_specularReflectionRays", function() {
  var t1 = new G.StatsCounter(0, "Rays", "Specular Reflection Rays Traced");
  $.get$Stats_trackers().push(t1);
  return t1;
});
Isolate.$lazy($, "specularRefractionRays", "Stats_specularRefractionRays", "get$Stats_specularRefractionRays", function() {
  var t1 = new G.StatsCounter(0, "Rays", "Specular Refraction Rays Traced");
  $.get$Stats_trackers().push(t1);
  return t1;
});
Isolate.$lazy($, "shadowRays", "Stats_shadowRays", "get$Stats_shadowRays", function() {
  var t1 = new G.StatsCounter(0, "Rays", "Shadow Rays Traced");
  $.get$Stats_trackers().push(t1);
  return t1;
});
Isolate.$lazy($, "nonShadowRays", "Stats_nonShadowRays", "get$Stats_nonShadowRays", function() {
  var t1 = new G.StatsCounter(0, "Rays", "Total Non-Shadow Rays Traced");
  $.get$Stats_trackers().push(t1);
  return t1;
});
Isolate.$lazy($, "_toStringList", "IterableMixinWorkaround__toStringList", "get$IterableMixinWorkaround__toStringList", function() {
  return [];
});
Isolate.$lazy($, "_nullFuture", "Future__nullFuture", "get$Future__nullFuture", function() {
  return P._Future$immediate(null, null);
});
Isolate.$lazy($, "_toStringVisiting", "_toStringVisiting", "get$_toStringVisiting", function() {
  return P.HashSet_HashSet$identity(null);
});
Isolate.$lazy($, "_toStringList", "Maps__toStringList", "get$Maps__toStringList", function() {
  return [];
});
Isolate.$lazy($, "abs0", "VP8Filter_abs0", "get$VP8Filter_abs0", function() {
  return new Uint8Array(511);
});
Isolate.$lazy($, "abs1", "VP8Filter_abs1", "get$VP8Filter_abs1", function() {
  return new Uint8Array(511);
});
Isolate.$lazy($, "sclip1", "VP8Filter_sclip1", "get$VP8Filter_sclip1", function() {
  return new Int8Array(2041);
});
Isolate.$lazy($, "sclip2", "VP8Filter_sclip2", "get$VP8Filter_sclip2", function() {
  return new Int8Array(225);
});
Isolate.$lazy($, "clip1", "VP8Filter_clip1", "get$VP8Filter_clip1", function() {
  return new Uint8Array(766);
});
Isolate.$lazy($, "PREDICTORS", "VP8LTransform_PREDICTORS", "get$VP8LTransform_PREDICTORS", function() {
  return [U.VP8LTransform__predictor0$closure(), U.VP8LTransform__predictor1$closure(), U.VP8LTransform__predictor2$closure(), U.VP8LTransform__predictor3$closure(), U.VP8LTransform__predictor4$closure(), U.VP8LTransform__predictor5$closure(), U.VP8LTransform__predictor6$closure(), U.VP8LTransform__predictor7$closure(), U.VP8LTransform__predictor8$closure(), U.VP8LTransform__predictor9$closure(), U.VP8LTransform__predictor10$closure(), U.VP8LTransform__predictor11$closure(), U.VP8LTransform__predictor12$closure(), U.VP8LTransform__predictor13$closure(), U.VP8LTransform__predictor0$closure(), U.VP8LTransform__predictor0$closure()];
});
Isolate.$lazy($, "__uint8", "__uint8", "get$__uint8", function() {
  return new Uint8Array(1);
});
Isolate.$lazy($, "__uint8ToInt8", "__uint8ToInt8", "get$__uint8ToInt8", function() {
  var t1 = $.get$__uint8().buffer;
  H._checkViewArguments(t1, 0, null);
  return new Int8Array(t1, 0);
});
Isolate.$lazy($, "__uint16", "__uint16", "get$__uint16", function() {
  return new Uint16Array(1);
});
Isolate.$lazy($, "__uint16ToInt16", "__uint16ToInt16", "get$__uint16ToInt16", function() {
  var t1 = $.get$__uint16().buffer;
  H._checkViewArguments(t1, 0, null);
  return new Int16Array(t1, 0);
});
Isolate.$lazy($, "__uint32", "__uint32", "get$__uint32", function() {
  return new Uint32Array(1);
});
Isolate.$lazy($, "__uint32ToInt32", "__uint32ToInt32", "get$__uint32ToInt32", function() {
  var t1 = $.get$__uint32().buffer;
  H._checkViewArguments(t1, 0, null);
  return new Int32Array(t1, 0);
});
Isolate.$lazy($, "__uint32ToFloat32", "__uint32ToFloat32", "get$__uint32ToFloat32", function() {
  return H.NativeFloat32List_NativeFloat32List$view($.get$__uint32().buffer, 0, null);
});
Isolate.$lazy($, "__int32", "__int32", "get$__int32", function() {
  return new Int32Array(1);
});
Isolate.$lazy($, "__int32ToUint32", "__int32ToUint32", "get$__int32ToUint32", function() {
  return H.NativeUint32List_NativeUint32List$view($.get$__int32().buffer, 0, null);
});
Isolate.$lazy($, "loadedRegularHalfangle", "MeasuredMaterial_loadedRegularHalfangle", "get$MeasuredMaterial_loadedRegularHalfangle", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "loadedThetaPhi", "MeasuredMaterial_loadedThetaPhi", "get$MeasuredMaterial_loadedThetaPhi", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_copperN", "MetalMaterial__copperN", "get$MetalMaterial__copperN", function() {
  return G.Spectrum_Spectrum(0).setSampled$2(C.List_cwh, C.List_AIB);
});
Isolate.$lazy($, "_copperK", "MetalMaterial__copperK", "get$MetalMaterial__copperK", function() {
  return G.Spectrum_Spectrum(0).setSampled$2(C.List_cwh, C.List_wwi);
});
Isolate.$lazy($, "_accelerators", "Pbrt__accelerators", "get$Pbrt__accelerators", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_cameras", "Pbrt__cameras", "get$Pbrt__cameras", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_films", "Pbrt__films", "get$Pbrt__films", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_filters", "Pbrt__filters", "get$Pbrt__filters", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_surfaceIntegrators", "Pbrt__surfaceIntegrators", "get$Pbrt__surfaceIntegrators", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_volumeIntegrators", "Pbrt__volumeIntegrators", "get$Pbrt__volumeIntegrators", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_lights", "Pbrt__lights", "get$Pbrt__lights", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_areaLights", "Pbrt__areaLights", "get$Pbrt__areaLights", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_materials", "Pbrt__materials", "get$Pbrt__materials", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_samplers", "Pbrt__samplers", "get$Pbrt__samplers", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_shapes", "Pbrt__shapes", "get$Pbrt__shapes", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_floatTextures", "Pbrt__floatTextures", "get$Pbrt__floatTextures", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_spectrumTextures", "Pbrt__spectrumTextures", "get$Pbrt__spectrumTextures", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_volumeRegions", "Pbrt__volumeRegions", "get$Pbrt__volumeRegions", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
// Native classes

init.functionAliases = {};
;
init.metadata = [{func: "dynamic__String", args: [J.JSString]},
{func: "BruteForceAccel__List_ParamSet", ret: E.BruteForceAccel, args: [[J.JSArray, G.Primitive], G.ParamSet]},
{func: "BVHAccel__List_ParamSet", ret: E.BVHAccel, args: [[J.JSArray, G.Primitive], G.ParamSet]},
{func: "GridAccel__List_ParamSet", ret: E.GridAccel, args: [[J.JSArray, G.Primitive], G.ParamSet]},
{func: "KdTreeAccel__List_ParamSet", ret: E.KdTreeAccel, args: [[J.JSArray, G.Primitive], G.ParamSet]},
{func: "EnvironmentCamera__ParamSet_AnimatedTransform_Film", ret: K.EnvironmentCamera, args: [G.ParamSet, G.AnimatedTransform, G.Film]},
{func: "OrthographicCamera__ParamSet_AnimatedTransform_Film", ret: K.OrthographicCamera, args: [G.ParamSet, G.AnimatedTransform, G.Film]},
{func: "PerspectiveCamera__ParamSet_AnimatedTransform_Film", ret: K.PerspectiveCamera, args: [G.ParamSet, G.AnimatedTransform, G.Film]},
{func: "bool__dynamic_dynamic", ret: J.JSBool, args: [null, null]},
{func: "void__int_String", void: true, args: [J.JSInt, J.JSString]},
{func: "void_", void: true},
{func: "void__dynamic", void: true, args: [null]},
{func: "void__dynamic__StackTrace", void: true, args: [null], opt: [P.StackTrace]},
,
{func: "int__dynamic", ret: J.JSInt, args: [null]},
{func: "int__Comparable_Comparable", ret: J.JSInt, args: [P.Comparable, P.Comparable]},
{func: "bool__Object_Object", ret: J.JSBool, args: [P.Object, P.Object]},
{func: "int__Object", ret: J.JSInt, args: [P.Object]},
{func: "ImageFilm__ParamSet_Filter__Image_PreviewCallback", ret: R.ImageFilm, args: [G.ParamSet, G.Filter], opt: [U.Image, {func: "dynamic__Image", args: [U.Image]}]},
{func: "BoxFilter__ParamSet", ret: S.BoxFilter, args: [G.ParamSet]},
{func: "GaussianFilter__ParamSet", ret: S.GaussianFilter, args: [G.ParamSet]},
{func: "LanczosSincFilter__ParamSet", ret: S.LanczosSincFilter, args: [G.ParamSet]},
{func: "MitchellFilter__ParamSet", ret: S.MitchellFilter, args: [G.ParamSet]},
{func: "TriangleFilter__ParamSet", ret: S.TriangleFilter, args: [G.ParamSet]},
{func: "void__InputBuffer", void: true, args: [U.InputBuffer]},
{func: "int__Uint32List_int_int", ret: J.JSInt, args: [P.Uint32List, J.JSInt, J.JSInt]},
{func: "void__int_int_int_int_int_Uint8List", void: true, args: [J.JSInt, J.JSInt, J.JSInt, J.JSInt, J.JSInt, P.Uint8List]},
{func: "DiffuseAreaLight__Transform_ParamSet_Shape", ret: O.DiffuseAreaLight, args: [G.Transform, G.ParamSet, G.Shape]},
{func: "DistantLight__Transform_ParamSet", ret: O.DistantLight, args: [G.Transform, G.ParamSet]},
{func: "GoniometricLight__Transform_ParamSet", ret: O.GoniometricLight, args: [G.Transform, G.ParamSet]},
{func: "InfiniteAreaLight__Transform_ParamSet", ret: O.InfiniteAreaLight, args: [G.Transform, G.ParamSet]},
{func: "PointLight__Transform_ParamSet", ret: O.PointLight, args: [G.Transform, G.ParamSet]},
{func: "ProjectionLight__Transform_ParamSet", ret: O.ProjectionLight, args: [G.Transform, G.ParamSet]},
{func: "SpotLight__Transform_ParamSet", ret: O.SpotLight, args: [G.Transform, G.ParamSet]},
{func: "GlassMaterial__Transform_TextureParams", ret: D.GlassMaterial, args: [G.Transform, G.TextureParams]},
{func: "KdSubsurfaceMaterial__Transform_TextureParams", ret: D.KdSubsurfaceMaterial, args: [G.Transform, G.TextureParams]},
{func: "MatteMaterial__Transform_TextureParams", ret: D.MatteMaterial, args: [G.Transform, G.TextureParams]},
{func: "MeasuredMaterial__Transform_TextureParams", ret: D.MeasuredMaterial, args: [G.Transform, G.TextureParams]},
{func: "MetalMaterial__Transform_TextureParams", ret: D.MetalMaterial, args: [G.Transform, G.TextureParams]},
{func: "MirrorMaterial__Transform_TextureParams", ret: D.MirrorMaterial, args: [G.Transform, G.TextureParams]},
{func: "PlasticMaterial__Transform_TextureParams", ret: D.PlasticMaterial, args: [G.Transform, G.TextureParams]},
{func: "ShinyMetalMaterial__Transform_TextureParams", ret: D.ShinyMetalMaterial, args: [G.Transform, G.TextureParams]},
{func: "SubstrateMaterial__Transform_TextureParams", ret: D.SubstrateMaterial, args: [G.Transform, G.TextureParams]},
{func: "SubsurfaceMaterial__Transform_TextureParams", ret: D.SubsurfaceMaterial, args: [G.Transform, G.TextureParams]},
{func: "TranslucentMaterial__Transform_TextureParams", ret: D.TranslucentMaterial, args: [G.Transform, G.TextureParams]},
{func: "UberMaterial__Transform_TextureParams", ret: D.UberMaterial, args: [G.Transform, G.TextureParams]},
{func: "AdaptiveSampler__ParamSet_Film_Camera", ret: U.AdaptiveSampler, args: [G.ParamSet, G.Film, G.Camera]},
{func: "BestCandidateSampler__ParamSet_Film_Camera", ret: U.BestCandidateSampler, args: [G.ParamSet, G.Film, G.Camera]},
{func: "HaltonSampler__ParamSet_Film_Camera", ret: U.HaltonSampler, args: [G.ParamSet, G.Film, G.Camera]},
{func: "LowDiscrepancySampler__ParamSet_Film_Camera", ret: U.LowDiscrepancySampler, args: [G.ParamSet, G.Film, G.Camera]},
{func: "RandomSampler__ParamSet_Film_Camera", ret: U.RandomSampler, args: [G.ParamSet, G.Film, G.Camera]},
{func: "StratifiedSampler__ParamSet_Film_Camera", ret: U.StratifiedSampler, args: [G.ParamSet, G.Film, G.Camera]},
{func: "ConeShape__Transform_Transform_bool_ParamSet", ret: M.ConeShape, args: [G.Transform, G.Transform, J.JSBool, G.ParamSet]},
{func: "CylinderShape__Transform_Transform_bool_ParamSet", ret: M.CylinderShape, args: [G.Transform, G.Transform, J.JSBool, G.ParamSet]},
{func: "DiskShape__Transform_Transform_bool_ParamSet", ret: M.DiskShape, args: [G.Transform, G.Transform, J.JSBool, G.ParamSet]},
{func: "HyperboloidShape__Transform_Transform_bool_ParamSet", ret: M.HyperboloidShape, args: [G.Transform, G.Transform, J.JSBool, G.ParamSet]},
{func: "LoopSubdivisionShape__Transform_Transform_bool_ParamSet", ret: M.LoopSubdivisionShape, args: [G.Transform, G.Transform, J.JSBool, G.ParamSet]},
{func: "ParaboloidShape__Transform_Transform_bool_ParamSet", ret: M.ParaboloidShape, args: [G.Transform, G.Transform, J.JSBool, G.ParamSet]},
{func: "SphereShape__Transform_Transform_bool_ParamSet", ret: M.SphereShape, args: [G.Transform, G.Transform, J.JSBool, G.ParamSet]},
{func: "TriangleMeshShape__Transform_Transform_bool_ParamSet__Map", ret: M.TriangleMeshShape, args: [G.Transform, G.Transform, J.JSBool, G.ParamSet], opt: [[P.Map, J.JSString, G.Texture]]},
{func: "AmbientOcclusionIntegrator__ParamSet", ret: U.AmbientOcclusionIntegrator, args: [G.ParamSet]},
{func: "DiffusePRTIntegrator__ParamSet", ret: U.DiffusePRTIntegrator, args: [G.ParamSet]},
{func: "DirectLightingIntegrator__ParamSet", ret: U.DirectLightingIntegrator, args: [G.ParamSet]},
{func: "GlossyPRTIntegrator__ParamSet", ret: U.GlossyPRTIntegrator, args: [G.ParamSet]},
{func: "IGIIntegrator__ParamSet", ret: U.IGIIntegrator, args: [G.ParamSet]},
{func: "IrradianceCacheIntegrator__ParamSet", ret: U.IrradianceCacheIntegrator, args: [G.ParamSet]},
{func: "PathIntegrator__ParamSet", ret: U.PathIntegrator, args: [G.ParamSet]},
{func: "PhotonMapIntegrator__ParamSet", ret: U.PhotonMapIntegrator, args: [G.ParamSet]},
{func: "WhittedIntegrator__ParamSet", ret: U.WhittedIntegrator, args: [G.ParamSet]},
{func: "BilerpTexture__Transform_TextureParams", ret: G.BilerpTexture, args: [G.Transform, G.TextureParams]},
{func: "Texture__Transform_TextureParams", ret: G.Texture, args: [G.Transform, G.TextureParams]},
{func: "DotsTexture__Transform_TextureParams", ret: G.DotsTexture, args: [G.Transform, G.TextureParams]},
{func: "FBmTexture__Transform_TextureParams", ret: G.FBmTexture, args: [G.Transform, G.TextureParams]},
{func: "ImageTexture__Transform_TextureParams", ret: G.ImageTexture, args: [G.Transform, G.TextureParams]},
{func: "MarbleTexture__Transform_TextureParams", ret: G.MarbleTexture, args: [G.Transform, G.TextureParams]},
{func: "MixTexture__Transform_TextureParams", ret: G.MixTexture, args: [G.Transform, G.TextureParams]},
{func: "ScaleTexture__Transform_TextureParams", ret: G.ScaleTexture, args: [G.Transform, G.TextureParams]},
{func: "UVTexture__Transform_TextureParams", ret: G.UVTexture, args: [G.Transform, G.TextureParams]},
{func: "WindyTexture__Transform_TextureParams", ret: G.WindyTexture, args: [G.Transform, G.TextureParams]},
{func: "WrinkledTexture__Transform_TextureParams", ret: G.WrinkledTexture, args: [G.Transform, G.TextureParams]},
{func: "EmissionIntegrator__ParamSet", ret: S.EmissionIntegrator, args: [G.ParamSet]},
{func: "SingleScatteringIntegrator__ParamSet", ret: S.SingleScatteringIntegrator, args: [G.ParamSet]},
{func: "ExponentialDensityRegion__Transform_ParamSet", ret: B.ExponentialDensityRegion, args: [G.Transform, G.ParamSet]},
{func: "HomogeneousVolumeRegion__Transform_ParamSet", ret: B.HomogeneousVolumeRegion, args: [G.Transform, G.ParamSet]},
{func: "VolumeGridDensity__Transform_ParamSet", ret: B.VolumeGridDensity, args: [G.Transform, G.ParamSet]},
{func: "void__List_SendPort", void: true, args: [[J.JSArray, J.JSString], P.SendPort]},
{func: "args0"},
{func: "args2", args: [null, null]},
{func: "args1", args: [null]},
{func: "dynamic__dynamic_String", args: [null, J.JSString]},
{func: "bool___BVHPrimitiveInfo__BVHPrimitiveInfo", ret: J.JSBool, args: [E._BVHPrimitiveInfo, E._BVHPrimitiveInfo]},
{func: "bool___BVHPrimitiveInfo", ret: J.JSBool, args: [E._BVHPrimitiveInfo]},
{func: "int_", ret: J.JSInt},
{func: "double_", ret: J.JSDouble},
{func: "bool__String", ret: J.JSBool, args: [J.JSString]},
{func: "Spectrum__Vector_Vector", ret: G.Spectrum, args: [G.Vector, G.Vector]},
{func: "Spectrum__Vector_Vector__int", ret: G.Spectrum, args: [G.Vector, G.Vector], opt: [J.JSInt]},
31,
{func: "void__Point_IrregIsotropicBRDFSample_double_double", void: true, args: [G.Point, G.IrregIsotropicBRDFSample, J.JSDouble, J.JSDouble]},
{func: "int__dynamic_dynamic_dynamic", ret: J.JSInt, args: [null, null, null]},
{func: "args3", args: [null, null, null]},
{func: "dynamic__int_int", args: [J.JSInt, J.JSInt]},
{func: "double__Point_Vector_Vector_double", ret: J.JSDouble, args: [G.Point, G.Vector, G.Vector, J.JSDouble]},
{func: "dynamic__Object", args: [P.Object]},
{func: "void__Object__StackTrace", void: true, args: [P.Object], opt: [P.StackTrace]},
{func: "dynamic__dynamic__dynamic", args: [null], opt: [null]},
{func: "bool_", ret: J.JSBool},
{func: "dynamic__dynamic_StackTrace", args: [null, P.StackTrace]},
{func: "void__dynamic_StackTrace", void: true, args: [null, P.StackTrace]},
{func: "dynamic__Symbol_dynamic", args: [P.Symbol, null]},
{func: "String__int", ret: J.JSString, args: [J.JSInt]},
{func: "dynamic__int", args: [J.JSInt]},
{func: "dynamic__int_dynamic", args: [J.JSInt, null]},
{func: "int__int", ret: J.JSInt, args: [J.JSInt]},
{func: "void__JpegComponent_List", void: true, args: [U.JpegComponent, J.JSArray]},
{func: "void__JpegComponent_dynamic", void: true, args: [U.JpegComponent, null]},
{func: "int__int_int", ret: J.JSInt, args: [J.JSInt, J.JSInt]},
{func: "void__int", void: true, args: [J.JSInt]},
{func: "double__double_double", ret: J.JSDouble, args: [J.JSDouble, J.JSDouble]},
{func: "dynamic__SpectrumImage", args: [G.SpectrumImage]},
{func: "Spectrum__Point_Vector", ret: G.Spectrum, args: [G.Point, G.Vector]},
{func: "void__String_ParamSet", void: true, args: [J.JSString, G.ParamSet]},
{func: "dynamic__List", args: [[J.JSArray, J.JSInt]]},
{func: "dynamic__List0", args: [J.JSArray]},
{func: "void__SendPort", void: true, args: [P.SendPort]},
{func: "dynamic__Image", args: [U.Image]},
{func: "bool__IrradianceSample", ret: J.JSBool, args: [U.IrradianceSample]},
{func: "void__Point_Photon_double_List", void: true, args: [G.Point, U.Photon, J.JSDouble, [J.JSArray, J.JSDouble]]},
{func: "void__Point_RadiancePhoton_double_List", void: true, args: [G.Point, U.RadiancePhoton, J.JSDouble, [J.JSArray, J.JSDouble]]},
{func: "double__Point_Vector_Vector_dynamic", ret: J.JSDouble, args: [G.Point, G.Vector, G.Vector, null]},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {};
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
!function() {
  function intern(s) {
    var o = {};
    o[s] = 1;
    return Object.keys(convertToFastObject(o))[0];
  }
  init.getIsolateTag = function(name) {
    return intern("___dart_" + name + init.isolateTag);
  };
  var tableProperty = "___dart_isolate_tags_";
  var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
  var rootProperty = "_ZxYxX";
  for (var i = 0;; i++) {
    var property = intern(rootProperty + "_" + i + "_");
    if (!(property in usedProperties)) {
      usedProperties[property] = 1;
      init.isolateTag = property;
      break;
    }
  }
}();
init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
// BEGIN invoke [main].
;(function (callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }

  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].removeEventListener("load", onLoad, false);
    }
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i) {
    scripts[i].addEventListener("load", onLoad, false);
  }
})(function(currentScript) {
  init.currentScript = currentScript;

  if (typeof dartMainRunner === "function") {
    dartMainRunner((function(a){H.startRootIsolate(M.main$closure(),a)}), []);
  } else {
    (function(a){H.startRootIsolate(M.main$closure(),a)})([]);
  }
});
// END invoke [main].
function init() {
  Isolate.$isolateProperties = {};
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  Isolate.$isolateProperties.$generateAccessor = generateAccessor;
  function defineClass(name, cls, fields) {
    var accessors = [];
    var str = "function " + cls + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, cls);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += cls + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + cls + ";\n";
    str += "if($desc instanceof Array) $desc = $desc[1];\n";
    str += cls + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string") {
      str += cls + ".name=\"" + cls + "\";\n";
    }
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      for (var member in properties)
        if (hasOwnProperty.call(properties, member))
          object[member] = properties[member];
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  Isolate.$finishClasses = function(collectedClasses, isolateProperties, existingIsolateProperties) {
    var pendingClasses = {};
    if (!init.allClasses)
      init.allClasses = {};
    var allClasses = init.allClasses;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (typeof dart_precompiled == "function") {
      var constructors = dart_precompiled(collectedClasses);
    } else {
      var combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
      var constructorsList = [];
    }
    for (var cls in collectedClasses) {
      if (hasOwnProperty.call(collectedClasses, cls)) {
        var desc = collectedClasses[cls];
        if (desc instanceof Array)
          desc = desc[1];
        var classData = desc["^"], supr, name = cls, fields = classData;
        if (typeof classData == "string") {
          var split = classData.split("/");
          if (split.length == 2) {
            name = split[0];
            fields = split[1];
          }
        }
        var s = fields.split(";");
        fields = s[1] == "" ? [] : s[1].split(",");
        supr = s[0];
        split = supr.split(":");
        if (split.length == 2) {
          supr = split[0];
          var functionSignature = split[1];
          if (functionSignature)
            desc.$signature = function(s) {
              return function() {
                return init.metadata[s];
              };
            }(functionSignature);
        }
        if (supr && supr.indexOf("+") > 0) {
          s = supr.split("+");
          supr = s[0];
          var mixin = collectedClasses[s[1]];
          if (mixin instanceof Array)
            mixin = mixin[1];
          for (var d in mixin) {
            if (hasOwnProperty.call(mixin, d) && !hasOwnProperty.call(desc, d))
              desc[d] = mixin[d];
          }
        }
        if (typeof dart_precompiled != "function") {
          combinedConstructorFunction += defineClass(name, cls, fields);
          constructorsList.push(cls);
        }
        if (supr)
          pendingClasses[cls] = supr;
      }
    }
    if (typeof dart_precompiled != "function") {
      combinedConstructorFunction += "return [\n  " + constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", combinedConstructorFunction)(collectedClasses);
      combinedConstructorFunction = null;
    }
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = collectedClasses[cls];
      var globalObject = isolateProperties;
      if (desc instanceof Array) {
        globalObject = desc[0] || isolateProperties;
        desc = desc[1];
      }
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = {};
    init.interceptorsByTag = Object.create(null);
    init.leafTags = {};
    function finishClass(cls) {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      if (hasOwnProperty.call(finishedClasses, cls))
        return;
      finishedClasses[cls] = true;
      var superclass = pendingClasses[cls];
      if (!superclass || typeof superclass != "string")
        return;
      finishClass(superclass);
      var constructor = allClasses[cls];
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var prototype = inheritFrom(constructor, superConstructor);
      if (hasOwnProperty.call(prototype, "%")) {
        var nativeSpec = prototype["%"].split(";");
        if (nativeSpec[0]) {
          var tags = nativeSpec[0].split("|");
          for (var i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = true;
          }
        }
        if (nativeSpec[1]) {
          tags = nativeSpec[1].split("|");
          if (nativeSpec[2]) {
            var subclasses = nativeSpec[2].split("|");
            for (var i = 0; i < subclasses.length; i++) {
              var subclass = allClasses[subclasses[i]];
              subclass.$nativeSuperclassTag = tags[0];
            }
          }
          for (i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = false;
          }
        }
      }
    }
    for (var cls in pendingClasses)
      finishClass(cls);
  };
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined) {
              if ($[fieldName] === sentinelInProgress) {
                $[fieldName] = null;
              }
            }
          }
        } else {
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        }
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var staticName in isolateProperties)
        if (hasOwnProperty.call(isolateProperties, staticName))
          this[staticName] = isolateProperties[staticName];
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.$finishClasses = oldIsolate.$finishClasses;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
})()
{
  var message = 
      'Deprecation: Automatic generation of output for Content Security\n' +
      'Policy is deprecated and will be removed with the next development\n' +
      'release. Use the --csp option to generate CSP restricted output.';
  if (typeof dartPrint == "function") {
    dartPrint(message);
  } else if (typeof console == "object" && typeof console.log == "function") {
    console.log(message);
  } else if (typeof print == "function") {
    print(message);
  }
}
function dart_precompiled($collectedClasses) {
  var $desc;
  function HtmlElement() {
  }
  HtmlElement.builtin$cls = "HtmlElement";
  if (!"name" in HtmlElement)
    HtmlElement.name = "HtmlElement";
  $desc = $collectedClasses.HtmlElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HtmlElement.prototype = $desc;
  function AnchorElement() {
  }
  AnchorElement.builtin$cls = "AnchorElement";
  if (!"name" in AnchorElement)
    AnchorElement.name = "AnchorElement";
  $desc = $collectedClasses.AnchorElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnchorElement.prototype = $desc;
  AnchorElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  AnchorElement.prototype.get$origin = function(receiver) {
    return receiver.origin;
  };
  function AnimationEvent() {
  }
  AnimationEvent.builtin$cls = "AnimationEvent";
  if (!"name" in AnimationEvent)
    AnimationEvent.name = "AnimationEvent";
  $desc = $collectedClasses.AnimationEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimationEvent.prototype = $desc;
  function AreaElement() {
  }
  AreaElement.builtin$cls = "AreaElement";
  if (!"name" in AreaElement)
    AreaElement.name = "AreaElement";
  $desc = $collectedClasses.AreaElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AreaElement.prototype = $desc;
  AreaElement.prototype.get$origin = function(receiver) {
    return receiver.origin;
  };
  function AudioElement() {
  }
  AudioElement.builtin$cls = "AudioElement";
  if (!"name" in AudioElement)
    AudioElement.name = "AudioElement";
  $desc = $collectedClasses.AudioElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AudioElement.prototype = $desc;
  function AutocompleteErrorEvent() {
  }
  AutocompleteErrorEvent.builtin$cls = "AutocompleteErrorEvent";
  if (!"name" in AutocompleteErrorEvent)
    AutocompleteErrorEvent.name = "AutocompleteErrorEvent";
  $desc = $collectedClasses.AutocompleteErrorEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AutocompleteErrorEvent.prototype = $desc;
  function BRElement() {
  }
  BRElement.builtin$cls = "BRElement";
  if (!"name" in BRElement)
    BRElement.name = "BRElement";
  $desc = $collectedClasses.BRElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BRElement.prototype = $desc;
  function BaseElement() {
  }
  BaseElement.builtin$cls = "BaseElement";
  if (!"name" in BaseElement)
    BaseElement.name = "BaseElement";
  $desc = $collectedClasses.BaseElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BaseElement.prototype = $desc;
  function BeforeLoadEvent() {
  }
  BeforeLoadEvent.builtin$cls = "BeforeLoadEvent";
  if (!"name" in BeforeLoadEvent)
    BeforeLoadEvent.name = "BeforeLoadEvent";
  $desc = $collectedClasses.BeforeLoadEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BeforeLoadEvent.prototype = $desc;
  function BeforeUnloadEvent() {
  }
  BeforeUnloadEvent.builtin$cls = "BeforeUnloadEvent";
  if (!"name" in BeforeUnloadEvent)
    BeforeUnloadEvent.name = "BeforeUnloadEvent";
  $desc = $collectedClasses.BeforeUnloadEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BeforeUnloadEvent.prototype = $desc;
  function Blob() {
  }
  Blob.builtin$cls = "Blob";
  if (!"name" in Blob)
    Blob.name = "Blob";
  $desc = $collectedClasses.Blob;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Blob.prototype = $desc;
  Blob.prototype.get$size = function(receiver) {
    return receiver.size;
  };
  Blob.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function BodyElement() {
  }
  BodyElement.builtin$cls = "BodyElement";
  if (!"name" in BodyElement)
    BodyElement.name = "BodyElement";
  $desc = $collectedClasses.BodyElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BodyElement.prototype = $desc;
  function ButtonElement() {
  }
  ButtonElement.builtin$cls = "ButtonElement";
  if (!"name" in ButtonElement)
    ButtonElement.name = "ButtonElement";
  $desc = $collectedClasses.ButtonElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ButtonElement.prototype = $desc;
  ButtonElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  ButtonElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function CDataSection() {
  }
  CDataSection.builtin$cls = "CDataSection";
  if (!"name" in CDataSection)
    CDataSection.name = "CDataSection";
  $desc = $collectedClasses.CDataSection;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CDataSection.prototype = $desc;
  function CanvasElement() {
  }
  CanvasElement.builtin$cls = "CanvasElement";
  if (!"name" in CanvasElement)
    CanvasElement.name = "CanvasElement";
  $desc = $collectedClasses.CanvasElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CanvasElement.prototype = $desc;
  CanvasElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  CanvasElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  function CharacterData() {
  }
  CharacterData.builtin$cls = "CharacterData";
  if (!"name" in CharacterData)
    CharacterData.name = "CharacterData";
  $desc = $collectedClasses.CharacterData;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CharacterData.prototype = $desc;
  CharacterData.prototype.get$data = function(receiver) {
    return receiver.data;
  };
  CharacterData.prototype.get$length = function(receiver) {
    return receiver.length;
  };
  function CloseEvent() {
  }
  CloseEvent.builtin$cls = "CloseEvent";
  if (!"name" in CloseEvent)
    CloseEvent.name = "CloseEvent";
  $desc = $collectedClasses.CloseEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CloseEvent.prototype = $desc;
  function Comment() {
  }
  Comment.builtin$cls = "Comment";
  if (!"name" in Comment)
    Comment.name = "Comment";
  $desc = $collectedClasses.Comment;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Comment.prototype = $desc;
  function CompositionEvent() {
  }
  CompositionEvent.builtin$cls = "CompositionEvent";
  if (!"name" in CompositionEvent)
    CompositionEvent.name = "CompositionEvent";
  $desc = $collectedClasses.CompositionEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CompositionEvent.prototype = $desc;
  CompositionEvent.prototype.get$data = function(receiver) {
    return receiver.data;
  };
  function ContentElement() {
  }
  ContentElement.builtin$cls = "ContentElement";
  if (!"name" in ContentElement)
    ContentElement.name = "ContentElement";
  $desc = $collectedClasses.ContentElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ContentElement.prototype = $desc;
  function CssFontFaceLoadEvent() {
  }
  CssFontFaceLoadEvent.builtin$cls = "CssFontFaceLoadEvent";
  if (!"name" in CssFontFaceLoadEvent)
    CssFontFaceLoadEvent.name = "CssFontFaceLoadEvent";
  $desc = $collectedClasses.CssFontFaceLoadEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CssFontFaceLoadEvent.prototype = $desc;
  function CustomEvent() {
  }
  CustomEvent.builtin$cls = "CustomEvent";
  if (!"name" in CustomEvent)
    CustomEvent.name = "CustomEvent";
  $desc = $collectedClasses.CustomEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CustomEvent.prototype = $desc;
  function DListElement() {
  }
  DListElement.builtin$cls = "DListElement";
  if (!"name" in DListElement)
    DListElement.name = "DListElement";
  $desc = $collectedClasses.DListElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DListElement.prototype = $desc;
  function DataListElement() {
  }
  DataListElement.builtin$cls = "DataListElement";
  if (!"name" in DataListElement)
    DataListElement.name = "DataListElement";
  $desc = $collectedClasses.DataListElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DataListElement.prototype = $desc;
  function DetailsElement() {
  }
  DetailsElement.builtin$cls = "DetailsElement";
  if (!"name" in DetailsElement)
    DetailsElement.name = "DetailsElement";
  $desc = $collectedClasses.DetailsElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DetailsElement.prototype = $desc;
  function DeviceMotionEvent() {
  }
  DeviceMotionEvent.builtin$cls = "DeviceMotionEvent";
  if (!"name" in DeviceMotionEvent)
    DeviceMotionEvent.name = "DeviceMotionEvent";
  $desc = $collectedClasses.DeviceMotionEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DeviceMotionEvent.prototype = $desc;
  function DeviceOrientationEvent() {
  }
  DeviceOrientationEvent.builtin$cls = "DeviceOrientationEvent";
  if (!"name" in DeviceOrientationEvent)
    DeviceOrientationEvent.name = "DeviceOrientationEvent";
  $desc = $collectedClasses.DeviceOrientationEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DeviceOrientationEvent.prototype = $desc;
  DeviceOrientationEvent.prototype.get$alpha = function(receiver) {
    return receiver.alpha;
  };
  function DialogElement() {
  }
  DialogElement.builtin$cls = "DialogElement";
  if (!"name" in DialogElement)
    DialogElement.name = "DialogElement";
  $desc = $collectedClasses.DialogElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DialogElement.prototype = $desc;
  function DivElement() {
  }
  DivElement.builtin$cls = "DivElement";
  if (!"name" in DivElement)
    DivElement.name = "DivElement";
  $desc = $collectedClasses.DivElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DivElement.prototype = $desc;
  function Document() {
  }
  Document.builtin$cls = "Document";
  if (!"name" in Document)
    Document.name = "Document";
  $desc = $collectedClasses.Document;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Document.prototype = $desc;
  function DocumentFragment() {
  }
  DocumentFragment.builtin$cls = "DocumentFragment";
  if (!"name" in DocumentFragment)
    DocumentFragment.name = "DocumentFragment";
  $desc = $collectedClasses.DocumentFragment;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DocumentFragment.prototype = $desc;
  function DomError() {
  }
  DomError.builtin$cls = "DomError";
  if (!"name" in DomError)
    DomError.name = "DomError";
  $desc = $collectedClasses.DomError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DomError.prototype = $desc;
  DomError.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function DomException() {
  }
  DomException.builtin$cls = "DomException";
  if (!"name" in DomException)
    DomException.name = "DomException";
  $desc = $collectedClasses.DomException;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DomException.prototype = $desc;
  function Element() {
  }
  Element.builtin$cls = "Element";
  if (!"name" in Element)
    Element.name = "Element";
  $desc = $collectedClasses.Element;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Element.prototype = $desc;
  Element.prototype.get$id = function(receiver) {
    return receiver.id;
  };
  function EmbedElement() {
  }
  EmbedElement.builtin$cls = "EmbedElement";
  if (!"name" in EmbedElement)
    EmbedElement.name = "EmbedElement";
  $desc = $collectedClasses.EmbedElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  EmbedElement.prototype = $desc;
  EmbedElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  EmbedElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  EmbedElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  EmbedElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  function ErrorEvent() {
  }
  ErrorEvent.builtin$cls = "ErrorEvent";
  if (!"name" in ErrorEvent)
    ErrorEvent.name = "ErrorEvent";
  $desc = $collectedClasses.ErrorEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ErrorEvent.prototype = $desc;
  ErrorEvent.prototype.get$error = function(receiver) {
    return receiver.error;
  };
  function Event() {
  }
  Event.builtin$cls = "Event";
  if (!"name" in Event)
    Event.name = "Event";
  $desc = $collectedClasses.Event;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Event.prototype = $desc;
  Event.prototype.get$path = function(receiver) {
    return receiver.path;
  };
  Event.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function EventTarget() {
  }
  EventTarget.builtin$cls = "EventTarget";
  if (!"name" in EventTarget)
    EventTarget.name = "EventTarget";
  $desc = $collectedClasses.EventTarget;
  if ($desc instanceof Array)
    $desc = $desc[1];
  EventTarget.prototype = $desc;
  function FieldSetElement() {
  }
  FieldSetElement.builtin$cls = "FieldSetElement";
  if (!"name" in FieldSetElement)
    FieldSetElement.name = "FieldSetElement";
  $desc = $collectedClasses.FieldSetElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FieldSetElement.prototype = $desc;
  FieldSetElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  FieldSetElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function File() {
  }
  File.builtin$cls = "File";
  if (!"name" in File)
    File.name = "File";
  $desc = $collectedClasses.File;
  if ($desc instanceof Array)
    $desc = $desc[1];
  File.prototype = $desc;
  File.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function FileError() {
  }
  FileError.builtin$cls = "FileError";
  if (!"name" in FileError)
    FileError.name = "FileError";
  $desc = $collectedClasses.FileError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FileError.prototype = $desc;
  function FocusEvent() {
  }
  FocusEvent.builtin$cls = "FocusEvent";
  if (!"name" in FocusEvent)
    FocusEvent.name = "FocusEvent";
  $desc = $collectedClasses.FocusEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FocusEvent.prototype = $desc;
  function FormElement() {
  }
  FormElement.builtin$cls = "FormElement";
  if (!"name" in FormElement)
    FormElement.name = "FormElement";
  $desc = $collectedClasses.FormElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FormElement.prototype = $desc;
  FormElement.prototype.get$length = function(receiver) {
    return receiver.length;
  };
  FormElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function HRElement() {
  }
  HRElement.builtin$cls = "HRElement";
  if (!"name" in HRElement)
    HRElement.name = "HRElement";
  $desc = $collectedClasses.HRElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HRElement.prototype = $desc;
  function HashChangeEvent() {
  }
  HashChangeEvent.builtin$cls = "HashChangeEvent";
  if (!"name" in HashChangeEvent)
    HashChangeEvent.name = "HashChangeEvent";
  $desc = $collectedClasses.HashChangeEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HashChangeEvent.prototype = $desc;
  function HeadElement() {
  }
  HeadElement.builtin$cls = "HeadElement";
  if (!"name" in HeadElement)
    HeadElement.name = "HeadElement";
  $desc = $collectedClasses.HeadElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HeadElement.prototype = $desc;
  function HeadingElement() {
  }
  HeadingElement.builtin$cls = "HeadingElement";
  if (!"name" in HeadingElement)
    HeadingElement.name = "HeadingElement";
  $desc = $collectedClasses.HeadingElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HeadingElement.prototype = $desc;
  function HtmlCollection() {
  }
  HtmlCollection.builtin$cls = "HtmlCollection";
  if (!"name" in HtmlCollection)
    HtmlCollection.name = "HtmlCollection";
  $desc = $collectedClasses.HtmlCollection;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HtmlCollection.prototype = $desc;
  function HtmlDocument() {
  }
  HtmlDocument.builtin$cls = "HtmlDocument";
  if (!"name" in HtmlDocument)
    HtmlDocument.name = "HtmlDocument";
  $desc = $collectedClasses.HtmlDocument;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HtmlDocument.prototype = $desc;
  function HtmlFormControlsCollection() {
  }
  HtmlFormControlsCollection.builtin$cls = "HtmlFormControlsCollection";
  if (!"name" in HtmlFormControlsCollection)
    HtmlFormControlsCollection.name = "HtmlFormControlsCollection";
  $desc = $collectedClasses.HtmlFormControlsCollection;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HtmlFormControlsCollection.prototype = $desc;
  function HtmlHtmlElement() {
  }
  HtmlHtmlElement.builtin$cls = "HtmlHtmlElement";
  if (!"name" in HtmlHtmlElement)
    HtmlHtmlElement.name = "HtmlHtmlElement";
  $desc = $collectedClasses.HtmlHtmlElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HtmlHtmlElement.prototype = $desc;
  function HtmlOptionsCollection() {
  }
  HtmlOptionsCollection.builtin$cls = "HtmlOptionsCollection";
  if (!"name" in HtmlOptionsCollection)
    HtmlOptionsCollection.name = "HtmlOptionsCollection";
  $desc = $collectedClasses.HtmlOptionsCollection;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HtmlOptionsCollection.prototype = $desc;
  function HttpRequest() {
  }
  HttpRequest.builtin$cls = "HttpRequest";
  if (!"name" in HttpRequest)
    HttpRequest.name = "HttpRequest";
  $desc = $collectedClasses.HttpRequest;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HttpRequest.prototype = $desc;
  function HttpRequestEventTarget() {
  }
  HttpRequestEventTarget.builtin$cls = "HttpRequestEventTarget";
  if (!"name" in HttpRequestEventTarget)
    HttpRequestEventTarget.name = "HttpRequestEventTarget";
  $desc = $collectedClasses.HttpRequestEventTarget;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HttpRequestEventTarget.prototype = $desc;
  function IFrameElement() {
  }
  IFrameElement.builtin$cls = "IFrameElement";
  if (!"name" in IFrameElement)
    IFrameElement.name = "IFrameElement";
  $desc = $collectedClasses.IFrameElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IFrameElement.prototype = $desc;
  IFrameElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  IFrameElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  IFrameElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  function ImageElement() {
  }
  ImageElement.builtin$cls = "ImageElement";
  if (!"name" in ImageElement)
    ImageElement.name = "ImageElement";
  $desc = $collectedClasses.ImageElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ImageElement.prototype = $desc;
  ImageElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  ImageElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  function InputElement() {
  }
  InputElement.builtin$cls = "InputElement";
  if (!"name" in InputElement)
    InputElement.name = "InputElement";
  $desc = $collectedClasses.InputElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  InputElement.prototype = $desc;
  InputElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  InputElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  InputElement.prototype.get$size = function(receiver) {
    return receiver.size;
  };
  InputElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  InputElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  function InstallEvent() {
  }
  InstallEvent.builtin$cls = "InstallEvent";
  if (!"name" in InstallEvent)
    InstallEvent.name = "InstallEvent";
  $desc = $collectedClasses.InstallEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  InstallEvent.prototype = $desc;
  function InstallPhaseEvent() {
  }
  InstallPhaseEvent.builtin$cls = "InstallPhaseEvent";
  if (!"name" in InstallPhaseEvent)
    InstallPhaseEvent.name = "InstallPhaseEvent";
  $desc = $collectedClasses.InstallPhaseEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  InstallPhaseEvent.prototype = $desc;
  function KeyboardEvent() {
  }
  KeyboardEvent.builtin$cls = "KeyboardEvent";
  if (!"name" in KeyboardEvent)
    KeyboardEvent.name = "KeyboardEvent";
  $desc = $collectedClasses.KeyboardEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  KeyboardEvent.prototype = $desc;
  function KeygenElement() {
  }
  KeygenElement.builtin$cls = "KeygenElement";
  if (!"name" in KeygenElement)
    KeygenElement.name = "KeygenElement";
  $desc = $collectedClasses.KeygenElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  KeygenElement.prototype = $desc;
  KeygenElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  KeygenElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function LIElement() {
  }
  LIElement.builtin$cls = "LIElement";
  if (!"name" in LIElement)
    LIElement.name = "LIElement";
  $desc = $collectedClasses.LIElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LIElement.prototype = $desc;
  function LabelElement() {
  }
  LabelElement.builtin$cls = "LabelElement";
  if (!"name" in LabelElement)
    LabelElement.name = "LabelElement";
  $desc = $collectedClasses.LabelElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LabelElement.prototype = $desc;
  function LegendElement() {
  }
  LegendElement.builtin$cls = "LegendElement";
  if (!"name" in LegendElement)
    LegendElement.name = "LegendElement";
  $desc = $collectedClasses.LegendElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LegendElement.prototype = $desc;
  function LinkElement() {
  }
  LinkElement.builtin$cls = "LinkElement";
  if (!"name" in LinkElement)
    LinkElement.name = "LinkElement";
  $desc = $collectedClasses.LinkElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LinkElement.prototype = $desc;
  LinkElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function MapElement() {
  }
  MapElement.builtin$cls = "MapElement";
  if (!"name" in MapElement)
    MapElement.name = "MapElement";
  $desc = $collectedClasses.MapElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MapElement.prototype = $desc;
  MapElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function MediaElement() {
  }
  MediaElement.builtin$cls = "MediaElement";
  if (!"name" in MediaElement)
    MediaElement.name = "MediaElement";
  $desc = $collectedClasses.MediaElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MediaElement.prototype = $desc;
  MediaElement.prototype.get$error = function(receiver) {
    return receiver.error;
  };
  function MediaError() {
  }
  MediaError.builtin$cls = "MediaError";
  if (!"name" in MediaError)
    MediaError.name = "MediaError";
  $desc = $collectedClasses.MediaError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MediaError.prototype = $desc;
  function MediaKeyError() {
  }
  MediaKeyError.builtin$cls = "MediaKeyError";
  if (!"name" in MediaKeyError)
    MediaKeyError.name = "MediaKeyError";
  $desc = $collectedClasses.MediaKeyError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MediaKeyError.prototype = $desc;
  function MediaKeyEvent() {
  }
  MediaKeyEvent.builtin$cls = "MediaKeyEvent";
  if (!"name" in MediaKeyEvent)
    MediaKeyEvent.name = "MediaKeyEvent";
  $desc = $collectedClasses.MediaKeyEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MediaKeyEvent.prototype = $desc;
  function MediaKeyMessageEvent() {
  }
  MediaKeyMessageEvent.builtin$cls = "MediaKeyMessageEvent";
  if (!"name" in MediaKeyMessageEvent)
    MediaKeyMessageEvent.name = "MediaKeyMessageEvent";
  $desc = $collectedClasses.MediaKeyMessageEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MediaKeyMessageEvent.prototype = $desc;
  function MediaKeyNeededEvent() {
  }
  MediaKeyNeededEvent.builtin$cls = "MediaKeyNeededEvent";
  if (!"name" in MediaKeyNeededEvent)
    MediaKeyNeededEvent.name = "MediaKeyNeededEvent";
  $desc = $collectedClasses.MediaKeyNeededEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MediaKeyNeededEvent.prototype = $desc;
  function MediaStream() {
  }
  MediaStream.builtin$cls = "MediaStream";
  if (!"name" in MediaStream)
    MediaStream.name = "MediaStream";
  $desc = $collectedClasses.MediaStream;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MediaStream.prototype = $desc;
  MediaStream.prototype.get$id = function(receiver) {
    return receiver.id;
  };
  function MediaStreamEvent() {
  }
  MediaStreamEvent.builtin$cls = "MediaStreamEvent";
  if (!"name" in MediaStreamEvent)
    MediaStreamEvent.name = "MediaStreamEvent";
  $desc = $collectedClasses.MediaStreamEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MediaStreamEvent.prototype = $desc;
  function MediaStreamTrackEvent() {
  }
  MediaStreamTrackEvent.builtin$cls = "MediaStreamTrackEvent";
  if (!"name" in MediaStreamTrackEvent)
    MediaStreamTrackEvent.name = "MediaStreamTrackEvent";
  $desc = $collectedClasses.MediaStreamTrackEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MediaStreamTrackEvent.prototype = $desc;
  function MenuElement() {
  }
  MenuElement.builtin$cls = "MenuElement";
  if (!"name" in MenuElement)
    MenuElement.name = "MenuElement";
  $desc = $collectedClasses.MenuElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MenuElement.prototype = $desc;
  function MessageEvent() {
  }
  MessageEvent.builtin$cls = "MessageEvent";
  if (!"name" in MessageEvent)
    MessageEvent.name = "MessageEvent";
  $desc = $collectedClasses.MessageEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MessageEvent.prototype = $desc;
  MessageEvent.prototype.get$origin = function(receiver) {
    return receiver.origin;
  };
  function MetaElement() {
  }
  MetaElement.builtin$cls = "MetaElement";
  if (!"name" in MetaElement)
    MetaElement.name = "MetaElement";
  $desc = $collectedClasses.MetaElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MetaElement.prototype = $desc;
  MetaElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function MeterElement() {
  }
  MeterElement.builtin$cls = "MeterElement";
  if (!"name" in MeterElement)
    MeterElement.name = "MeterElement";
  $desc = $collectedClasses.MeterElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MeterElement.prototype = $desc;
  function MidiConnectionEvent() {
  }
  MidiConnectionEvent.builtin$cls = "MidiConnectionEvent";
  if (!"name" in MidiConnectionEvent)
    MidiConnectionEvent.name = "MidiConnectionEvent";
  $desc = $collectedClasses.MidiConnectionEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MidiConnectionEvent.prototype = $desc;
  function MidiInput() {
  }
  MidiInput.builtin$cls = "MidiInput";
  if (!"name" in MidiInput)
    MidiInput.name = "MidiInput";
  $desc = $collectedClasses.MidiInput;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MidiInput.prototype = $desc;
  function MidiMessageEvent() {
  }
  MidiMessageEvent.builtin$cls = "MidiMessageEvent";
  if (!"name" in MidiMessageEvent)
    MidiMessageEvent.name = "MidiMessageEvent";
  $desc = $collectedClasses.MidiMessageEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MidiMessageEvent.prototype = $desc;
  MidiMessageEvent.prototype.get$data = function(receiver) {
    return receiver.data;
  };
  function MidiOutput() {
  }
  MidiOutput.builtin$cls = "MidiOutput";
  if (!"name" in MidiOutput)
    MidiOutput.name = "MidiOutput";
  $desc = $collectedClasses.MidiOutput;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MidiOutput.prototype = $desc;
  function MidiPort() {
  }
  MidiPort.builtin$cls = "MidiPort";
  if (!"name" in MidiPort)
    MidiPort.name = "MidiPort";
  $desc = $collectedClasses.MidiPort;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MidiPort.prototype = $desc;
  MidiPort.prototype.get$id = function(receiver) {
    return receiver.id;
  };
  MidiPort.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  MidiPort.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function ModElement() {
  }
  ModElement.builtin$cls = "ModElement";
  if (!"name" in ModElement)
    ModElement.name = "ModElement";
  $desc = $collectedClasses.ModElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ModElement.prototype = $desc;
  function MouseEvent() {
  }
  MouseEvent.builtin$cls = "MouseEvent";
  if (!"name" in MouseEvent)
    MouseEvent.name = "MouseEvent";
  $desc = $collectedClasses.MouseEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MouseEvent.prototype = $desc;
  function Navigator() {
  }
  Navigator.builtin$cls = "Navigator";
  if (!"name" in Navigator)
    Navigator.name = "Navigator";
  $desc = $collectedClasses.Navigator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Navigator.prototype = $desc;
  function NavigatorUserMediaError() {
  }
  NavigatorUserMediaError.builtin$cls = "NavigatorUserMediaError";
  if (!"name" in NavigatorUserMediaError)
    NavigatorUserMediaError.name = "NavigatorUserMediaError";
  $desc = $collectedClasses.NavigatorUserMediaError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NavigatorUserMediaError.prototype = $desc;
  NavigatorUserMediaError.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function Node() {
  }
  Node.builtin$cls = "Node";
  if (!"name" in Node)
    Node.name = "Node";
  $desc = $collectedClasses.Node;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Node.prototype = $desc;
  function NodeList() {
  }
  NodeList.builtin$cls = "NodeList";
  if (!"name" in NodeList)
    NodeList.name = "NodeList";
  $desc = $collectedClasses.NodeList;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NodeList.prototype = $desc;
  function OListElement() {
  }
  OListElement.builtin$cls = "OListElement";
  if (!"name" in OListElement)
    OListElement.name = "OListElement";
  $desc = $collectedClasses.OListElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OListElement.prototype = $desc;
  OListElement.prototype.get$start = function(receiver) {
    return receiver.start;
  };
  OListElement.prototype.set$start = function(receiver, v) {
    return receiver.start = v;
  };
  OListElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function ObjectElement() {
  }
  ObjectElement.builtin$cls = "ObjectElement";
  if (!"name" in ObjectElement)
    ObjectElement.name = "ObjectElement";
  $desc = $collectedClasses.ObjectElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ObjectElement.prototype = $desc;
  ObjectElement.prototype.get$data = function(receiver) {
    return receiver.data;
  };
  ObjectElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  ObjectElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  ObjectElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  ObjectElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  function OptGroupElement() {
  }
  OptGroupElement.builtin$cls = "OptGroupElement";
  if (!"name" in OptGroupElement)
    OptGroupElement.name = "OptGroupElement";
  $desc = $collectedClasses.OptGroupElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OptGroupElement.prototype = $desc;
  function OptionElement() {
  }
  OptionElement.builtin$cls = "OptionElement";
  if (!"name" in OptionElement)
    OptionElement.name = "OptionElement";
  $desc = $collectedClasses.OptionElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OptionElement.prototype = $desc;
  function OutputElement() {
  }
  OutputElement.builtin$cls = "OutputElement";
  if (!"name" in OutputElement)
    OutputElement.name = "OutputElement";
  $desc = $collectedClasses.OutputElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OutputElement.prototype = $desc;
  OutputElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  OutputElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function OverflowEvent() {
  }
  OverflowEvent.builtin$cls = "OverflowEvent";
  if (!"name" in OverflowEvent)
    OverflowEvent.name = "OverflowEvent";
  $desc = $collectedClasses.OverflowEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OverflowEvent.prototype = $desc;
  function PageTransitionEvent() {
  }
  PageTransitionEvent.builtin$cls = "PageTransitionEvent";
  if (!"name" in PageTransitionEvent)
    PageTransitionEvent.name = "PageTransitionEvent";
  $desc = $collectedClasses.PageTransitionEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PageTransitionEvent.prototype = $desc;
  function ParagraphElement() {
  }
  ParagraphElement.builtin$cls = "ParagraphElement";
  if (!"name" in ParagraphElement)
    ParagraphElement.name = "ParagraphElement";
  $desc = $collectedClasses.ParagraphElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ParagraphElement.prototype = $desc;
  function ParamElement() {
  }
  ParamElement.builtin$cls = "ParamElement";
  if (!"name" in ParamElement)
    ParamElement.name = "ParamElement";
  $desc = $collectedClasses.ParamElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ParamElement.prototype = $desc;
  ParamElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function PopStateEvent() {
  }
  PopStateEvent.builtin$cls = "PopStateEvent";
  if (!"name" in PopStateEvent)
    PopStateEvent.name = "PopStateEvent";
  $desc = $collectedClasses.PopStateEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PopStateEvent.prototype = $desc;
  function PositionError() {
  }
  PositionError.builtin$cls = "PositionError";
  if (!"name" in PositionError)
    PositionError.name = "PositionError";
  $desc = $collectedClasses.PositionError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PositionError.prototype = $desc;
  function PreElement() {
  }
  PreElement.builtin$cls = "PreElement";
  if (!"name" in PreElement)
    PreElement.name = "PreElement";
  $desc = $collectedClasses.PreElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PreElement.prototype = $desc;
  function ProcessingInstruction() {
  }
  ProcessingInstruction.builtin$cls = "ProcessingInstruction";
  if (!"name" in ProcessingInstruction)
    ProcessingInstruction.name = "ProcessingInstruction";
  $desc = $collectedClasses.ProcessingInstruction;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ProcessingInstruction.prototype = $desc;
  function ProgressElement() {
  }
  ProgressElement.builtin$cls = "ProgressElement";
  if (!"name" in ProgressElement)
    ProgressElement.name = "ProgressElement";
  $desc = $collectedClasses.ProgressElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ProgressElement.prototype = $desc;
  function ProgressEvent() {
  }
  ProgressEvent.builtin$cls = "ProgressEvent";
  if (!"name" in ProgressEvent)
    ProgressEvent.name = "ProgressEvent";
  $desc = $collectedClasses.ProgressEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ProgressEvent.prototype = $desc;
  function QuoteElement() {
  }
  QuoteElement.builtin$cls = "QuoteElement";
  if (!"name" in QuoteElement)
    QuoteElement.name = "QuoteElement";
  $desc = $collectedClasses.QuoteElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  QuoteElement.prototype = $desc;
  function ResourceProgressEvent() {
  }
  ResourceProgressEvent.builtin$cls = "ResourceProgressEvent";
  if (!"name" in ResourceProgressEvent)
    ResourceProgressEvent.name = "ResourceProgressEvent";
  $desc = $collectedClasses.ResourceProgressEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ResourceProgressEvent.prototype = $desc;
  function RtcDataChannelEvent() {
  }
  RtcDataChannelEvent.builtin$cls = "RtcDataChannelEvent";
  if (!"name" in RtcDataChannelEvent)
    RtcDataChannelEvent.name = "RtcDataChannelEvent";
  $desc = $collectedClasses.RtcDataChannelEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RtcDataChannelEvent.prototype = $desc;
  function RtcDtmfToneChangeEvent() {
  }
  RtcDtmfToneChangeEvent.builtin$cls = "RtcDtmfToneChangeEvent";
  if (!"name" in RtcDtmfToneChangeEvent)
    RtcDtmfToneChangeEvent.name = "RtcDtmfToneChangeEvent";
  $desc = $collectedClasses.RtcDtmfToneChangeEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RtcDtmfToneChangeEvent.prototype = $desc;
  function RtcIceCandidateEvent() {
  }
  RtcIceCandidateEvent.builtin$cls = "RtcIceCandidateEvent";
  if (!"name" in RtcIceCandidateEvent)
    RtcIceCandidateEvent.name = "RtcIceCandidateEvent";
  $desc = $collectedClasses.RtcIceCandidateEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RtcIceCandidateEvent.prototype = $desc;
  function ScriptElement() {
  }
  ScriptElement.builtin$cls = "ScriptElement";
  if (!"name" in ScriptElement)
    ScriptElement.name = "ScriptElement";
  $desc = $collectedClasses.ScriptElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ScriptElement.prototype = $desc;
  ScriptElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function SecurityPolicyViolationEvent() {
  }
  SecurityPolicyViolationEvent.builtin$cls = "SecurityPolicyViolationEvent";
  if (!"name" in SecurityPolicyViolationEvent)
    SecurityPolicyViolationEvent.name = "SecurityPolicyViolationEvent";
  $desc = $collectedClasses.SecurityPolicyViolationEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SecurityPolicyViolationEvent.prototype = $desc;
  function SelectElement() {
  }
  SelectElement.builtin$cls = "SelectElement";
  if (!"name" in SelectElement)
    SelectElement.name = "SelectElement";
  $desc = $collectedClasses.SelectElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SelectElement.prototype = $desc;
  SelectElement.prototype.get$length = function(receiver) {
    return receiver.length;
  };
  SelectElement.prototype.set$length = function(receiver, v) {
    return receiver.length = v;
  };
  SelectElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  SelectElement.prototype.get$size = function(receiver) {
    return receiver.size;
  };
  SelectElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function ShadowElement() {
  }
  ShadowElement.builtin$cls = "ShadowElement";
  if (!"name" in ShadowElement)
    ShadowElement.name = "ShadowElement";
  $desc = $collectedClasses.ShadowElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ShadowElement.prototype = $desc;
  function ShadowRoot() {
  }
  ShadowRoot.builtin$cls = "ShadowRoot";
  if (!"name" in ShadowRoot)
    ShadowRoot.name = "ShadowRoot";
  $desc = $collectedClasses.ShadowRoot;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ShadowRoot.prototype = $desc;
  function SourceElement() {
  }
  SourceElement.builtin$cls = "SourceElement";
  if (!"name" in SourceElement)
    SourceElement.name = "SourceElement";
  $desc = $collectedClasses.SourceElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SourceElement.prototype = $desc;
  SourceElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function SpanElement() {
  }
  SpanElement.builtin$cls = "SpanElement";
  if (!"name" in SpanElement)
    SpanElement.name = "SpanElement";
  $desc = $collectedClasses.SpanElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SpanElement.prototype = $desc;
  function SpeechInputEvent() {
  }
  SpeechInputEvent.builtin$cls = "SpeechInputEvent";
  if (!"name" in SpeechInputEvent)
    SpeechInputEvent.name = "SpeechInputEvent";
  $desc = $collectedClasses.SpeechInputEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SpeechInputEvent.prototype = $desc;
  function SpeechRecognitionError() {
  }
  SpeechRecognitionError.builtin$cls = "SpeechRecognitionError";
  if (!"name" in SpeechRecognitionError)
    SpeechRecognitionError.name = "SpeechRecognitionError";
  $desc = $collectedClasses.SpeechRecognitionError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SpeechRecognitionError.prototype = $desc;
  SpeechRecognitionError.prototype.get$error = function(receiver) {
    return receiver.error;
  };
  function SpeechRecognitionEvent() {
  }
  SpeechRecognitionEvent.builtin$cls = "SpeechRecognitionEvent";
  if (!"name" in SpeechRecognitionEvent)
    SpeechRecognitionEvent.name = "SpeechRecognitionEvent";
  $desc = $collectedClasses.SpeechRecognitionEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SpeechRecognitionEvent.prototype = $desc;
  function SpeechSynthesisEvent() {
  }
  SpeechSynthesisEvent.builtin$cls = "SpeechSynthesisEvent";
  if (!"name" in SpeechSynthesisEvent)
    SpeechSynthesisEvent.name = "SpeechSynthesisEvent";
  $desc = $collectedClasses.SpeechSynthesisEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SpeechSynthesisEvent.prototype = $desc;
  SpeechSynthesisEvent.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function StorageEvent() {
  }
  StorageEvent.builtin$cls = "StorageEvent";
  if (!"name" in StorageEvent)
    StorageEvent.name = "StorageEvent";
  $desc = $collectedClasses.StorageEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StorageEvent.prototype = $desc;
  function StyleElement() {
  }
  StyleElement.builtin$cls = "StyleElement";
  if (!"name" in StyleElement)
    StyleElement.name = "StyleElement";
  $desc = $collectedClasses.StyleElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StyleElement.prototype = $desc;
  StyleElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function TableCaptionElement() {
  }
  TableCaptionElement.builtin$cls = "TableCaptionElement";
  if (!"name" in TableCaptionElement)
    TableCaptionElement.name = "TableCaptionElement";
  $desc = $collectedClasses.TableCaptionElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TableCaptionElement.prototype = $desc;
  function TableCellElement() {
  }
  TableCellElement.builtin$cls = "TableCellElement";
  if (!"name" in TableCellElement)
    TableCellElement.name = "TableCellElement";
  $desc = $collectedClasses.TableCellElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TableCellElement.prototype = $desc;
  function TableColElement() {
  }
  TableColElement.builtin$cls = "TableColElement";
  if (!"name" in TableColElement)
    TableColElement.name = "TableColElement";
  $desc = $collectedClasses.TableColElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TableColElement.prototype = $desc;
  function TableElement() {
  }
  TableElement.builtin$cls = "TableElement";
  if (!"name" in TableElement)
    TableElement.name = "TableElement";
  $desc = $collectedClasses.TableElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TableElement.prototype = $desc;
  function TableRowElement() {
  }
  TableRowElement.builtin$cls = "TableRowElement";
  if (!"name" in TableRowElement)
    TableRowElement.name = "TableRowElement";
  $desc = $collectedClasses.TableRowElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TableRowElement.prototype = $desc;
  function TableSectionElement() {
  }
  TableSectionElement.builtin$cls = "TableSectionElement";
  if (!"name" in TableSectionElement)
    TableSectionElement.name = "TableSectionElement";
  $desc = $collectedClasses.TableSectionElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TableSectionElement.prototype = $desc;
  function TemplateElement() {
  }
  TemplateElement.builtin$cls = "TemplateElement";
  if (!"name" in TemplateElement)
    TemplateElement.name = "TemplateElement";
  $desc = $collectedClasses.TemplateElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TemplateElement.prototype = $desc;
  function Text() {
  }
  Text.builtin$cls = "Text";
  if (!"name" in Text)
    Text.name = "Text";
  $desc = $collectedClasses.Text;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Text.prototype = $desc;
  function TextAreaElement() {
  }
  TextAreaElement.builtin$cls = "TextAreaElement";
  if (!"name" in TextAreaElement)
    TextAreaElement.name = "TextAreaElement";
  $desc = $collectedClasses.TextAreaElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TextAreaElement.prototype = $desc;
  TextAreaElement.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  TextAreaElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function TextEvent() {
  }
  TextEvent.builtin$cls = "TextEvent";
  if (!"name" in TextEvent)
    TextEvent.name = "TextEvent";
  $desc = $collectedClasses.TextEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TextEvent.prototype = $desc;
  TextEvent.prototype.get$data = function(receiver) {
    return receiver.data;
  };
  function TitleElement() {
  }
  TitleElement.builtin$cls = "TitleElement";
  if (!"name" in TitleElement)
    TitleElement.name = "TitleElement";
  $desc = $collectedClasses.TitleElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TitleElement.prototype = $desc;
  function TouchEvent() {
  }
  TouchEvent.builtin$cls = "TouchEvent";
  if (!"name" in TouchEvent)
    TouchEvent.name = "TouchEvent";
  $desc = $collectedClasses.TouchEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TouchEvent.prototype = $desc;
  function TrackElement() {
  }
  TrackElement.builtin$cls = "TrackElement";
  if (!"name" in TrackElement)
    TrackElement.name = "TrackElement";
  $desc = $collectedClasses.TrackElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TrackElement.prototype = $desc;
  function TrackEvent() {
  }
  TrackEvent.builtin$cls = "TrackEvent";
  if (!"name" in TrackEvent)
    TrackEvent.name = "TrackEvent";
  $desc = $collectedClasses.TrackEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TrackEvent.prototype = $desc;
  function TransitionEvent() {
  }
  TransitionEvent.builtin$cls = "TransitionEvent";
  if (!"name" in TransitionEvent)
    TransitionEvent.name = "TransitionEvent";
  $desc = $collectedClasses.TransitionEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TransitionEvent.prototype = $desc;
  function UIEvent() {
  }
  UIEvent.builtin$cls = "UIEvent";
  if (!"name" in UIEvent)
    UIEvent.name = "UIEvent";
  $desc = $collectedClasses.UIEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UIEvent.prototype = $desc;
  function UListElement() {
  }
  UListElement.builtin$cls = "UListElement";
  if (!"name" in UListElement)
    UListElement.name = "UListElement";
  $desc = $collectedClasses.UListElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UListElement.prototype = $desc;
  function UnknownElement() {
  }
  UnknownElement.builtin$cls = "UnknownElement";
  if (!"name" in UnknownElement)
    UnknownElement.name = "UnknownElement";
  $desc = $collectedClasses.UnknownElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UnknownElement.prototype = $desc;
  function VideoElement() {
  }
  VideoElement.builtin$cls = "VideoElement";
  if (!"name" in VideoElement)
    VideoElement.name = "VideoElement";
  $desc = $collectedClasses.VideoElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VideoElement.prototype = $desc;
  VideoElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  VideoElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  function WheelEvent() {
  }
  WheelEvent.builtin$cls = "WheelEvent";
  if (!"name" in WheelEvent)
    WheelEvent.name = "WheelEvent";
  $desc = $collectedClasses.WheelEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WheelEvent.prototype = $desc;
  function Window() {
  }
  Window.builtin$cls = "Window";
  if (!"name" in Window)
    Window.name = "Window";
  $desc = $collectedClasses.Window;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Window.prototype = $desc;
  Window.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function XmlDocument() {
  }
  XmlDocument.builtin$cls = "XmlDocument";
  if (!"name" in XmlDocument)
    XmlDocument.name = "XmlDocument";
  $desc = $collectedClasses.XmlDocument;
  if ($desc instanceof Array)
    $desc = $desc[1];
  XmlDocument.prototype = $desc;
  function _Attr() {
  }
  _Attr.builtin$cls = "_Attr";
  if (!"name" in _Attr)
    _Attr.name = "_Attr";
  $desc = $collectedClasses._Attr;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Attr.prototype = $desc;
  _Attr.prototype.get$name = function(receiver) {
    return receiver.name;
  };
  function _ClientRect() {
  }
  _ClientRect.builtin$cls = "_ClientRect";
  if (!"name" in _ClientRect)
    _ClientRect.name = "_ClientRect";
  $desc = $collectedClasses._ClientRect;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ClientRect.prototype = $desc;
  _ClientRect.prototype.get$bottom = function(receiver) {
    return receiver.bottom;
  };
  _ClientRect.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  _ClientRect.prototype.get$left = function(receiver) {
    return receiver.left;
  };
  _ClientRect.prototype.get$right = function(receiver) {
    return receiver.right;
  };
  _ClientRect.prototype.get$top = function(receiver) {
    return receiver.top;
  };
  _ClientRect.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  function _DocumentType() {
  }
  _DocumentType.builtin$cls = "_DocumentType";
  if (!"name" in _DocumentType)
    _DocumentType.name = "_DocumentType";
  $desc = $collectedClasses._DocumentType;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _DocumentType.prototype = $desc;
  function _HTMLAppletElement() {
  }
  _HTMLAppletElement.builtin$cls = "_HTMLAppletElement";
  if (!"name" in _HTMLAppletElement)
    _HTMLAppletElement.name = "_HTMLAppletElement";
  $desc = $collectedClasses._HTMLAppletElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HTMLAppletElement.prototype = $desc;
  function _HTMLDirectoryElement() {
  }
  _HTMLDirectoryElement.builtin$cls = "_HTMLDirectoryElement";
  if (!"name" in _HTMLDirectoryElement)
    _HTMLDirectoryElement.name = "_HTMLDirectoryElement";
  $desc = $collectedClasses._HTMLDirectoryElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HTMLDirectoryElement.prototype = $desc;
  function _HTMLFontElement() {
  }
  _HTMLFontElement.builtin$cls = "_HTMLFontElement";
  if (!"name" in _HTMLFontElement)
    _HTMLFontElement.name = "_HTMLFontElement";
  $desc = $collectedClasses._HTMLFontElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HTMLFontElement.prototype = $desc;
  function _HTMLFrameElement() {
  }
  _HTMLFrameElement.builtin$cls = "_HTMLFrameElement";
  if (!"name" in _HTMLFrameElement)
    _HTMLFrameElement.name = "_HTMLFrameElement";
  $desc = $collectedClasses._HTMLFrameElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HTMLFrameElement.prototype = $desc;
  function _HTMLFrameSetElement() {
  }
  _HTMLFrameSetElement.builtin$cls = "_HTMLFrameSetElement";
  if (!"name" in _HTMLFrameSetElement)
    _HTMLFrameSetElement.name = "_HTMLFrameSetElement";
  $desc = $collectedClasses._HTMLFrameSetElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HTMLFrameSetElement.prototype = $desc;
  function _HTMLMarqueeElement() {
  }
  _HTMLMarqueeElement.builtin$cls = "_HTMLMarqueeElement";
  if (!"name" in _HTMLMarqueeElement)
    _HTMLMarqueeElement.name = "_HTMLMarqueeElement";
  $desc = $collectedClasses._HTMLMarqueeElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HTMLMarqueeElement.prototype = $desc;
  function _MutationEvent() {
  }
  _MutationEvent.builtin$cls = "_MutationEvent";
  if (!"name" in _MutationEvent)
    _MutationEvent.name = "_MutationEvent";
  $desc = $collectedClasses._MutationEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _MutationEvent.prototype = $desc;
  function _NamedNodeMap() {
  }
  _NamedNodeMap.builtin$cls = "_NamedNodeMap";
  if (!"name" in _NamedNodeMap)
    _NamedNodeMap.name = "_NamedNodeMap";
  $desc = $collectedClasses._NamedNodeMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _NamedNodeMap.prototype = $desc;
  function _Notation() {
  }
  _Notation.builtin$cls = "_Notation";
  if (!"name" in _Notation)
    _Notation.name = "_Notation";
  $desc = $collectedClasses._Notation;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Notation.prototype = $desc;
  function _XMLHttpRequestProgressEvent() {
  }
  _XMLHttpRequestProgressEvent.builtin$cls = "_XMLHttpRequestProgressEvent";
  if (!"name" in _XMLHttpRequestProgressEvent)
    _XMLHttpRequestProgressEvent.name = "_XMLHttpRequestProgressEvent";
  $desc = $collectedClasses._XMLHttpRequestProgressEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _XMLHttpRequestProgressEvent.prototype = $desc;
  function VersionChangeEvent() {
  }
  VersionChangeEvent.builtin$cls = "VersionChangeEvent";
  if (!"name" in VersionChangeEvent)
    VersionChangeEvent.name = "VersionChangeEvent";
  $desc = $collectedClasses.VersionChangeEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VersionChangeEvent.prototype = $desc;
  function AElement() {
  }
  AElement.builtin$cls = "AElement";
  if (!"name" in AElement)
    AElement.name = "AElement";
  $desc = $collectedClasses.AElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AElement.prototype = $desc;
  function AltGlyphElement() {
  }
  AltGlyphElement.builtin$cls = "AltGlyphElement";
  if (!"name" in AltGlyphElement)
    AltGlyphElement.name = "AltGlyphElement";
  $desc = $collectedClasses.AltGlyphElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AltGlyphElement.prototype = $desc;
  function AnimateElement() {
  }
  AnimateElement.builtin$cls = "AnimateElement";
  if (!"name" in AnimateElement)
    AnimateElement.name = "AnimateElement";
  $desc = $collectedClasses.AnimateElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimateElement.prototype = $desc;
  function AnimateMotionElement() {
  }
  AnimateMotionElement.builtin$cls = "AnimateMotionElement";
  if (!"name" in AnimateMotionElement)
    AnimateMotionElement.name = "AnimateMotionElement";
  $desc = $collectedClasses.AnimateMotionElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimateMotionElement.prototype = $desc;
  function AnimateTransformElement() {
  }
  AnimateTransformElement.builtin$cls = "AnimateTransformElement";
  if (!"name" in AnimateTransformElement)
    AnimateTransformElement.name = "AnimateTransformElement";
  $desc = $collectedClasses.AnimateTransformElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimateTransformElement.prototype = $desc;
  function AnimatedEnumeration() {
  }
  AnimatedEnumeration.builtin$cls = "AnimatedEnumeration";
  if (!"name" in AnimatedEnumeration)
    AnimatedEnumeration.name = "AnimatedEnumeration";
  $desc = $collectedClasses.AnimatedEnumeration;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimatedEnumeration.prototype = $desc;
  function AnimatedLength() {
  }
  AnimatedLength.builtin$cls = "AnimatedLength";
  if (!"name" in AnimatedLength)
    AnimatedLength.name = "AnimatedLength";
  $desc = $collectedClasses.AnimatedLength;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimatedLength.prototype = $desc;
  function AnimatedLengthList() {
  }
  AnimatedLengthList.builtin$cls = "AnimatedLengthList";
  if (!"name" in AnimatedLengthList)
    AnimatedLengthList.name = "AnimatedLengthList";
  $desc = $collectedClasses.AnimatedLengthList;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimatedLengthList.prototype = $desc;
  function AnimatedNumber() {
  }
  AnimatedNumber.builtin$cls = "AnimatedNumber";
  if (!"name" in AnimatedNumber)
    AnimatedNumber.name = "AnimatedNumber";
  $desc = $collectedClasses.AnimatedNumber;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimatedNumber.prototype = $desc;
  function AnimatedNumberList() {
  }
  AnimatedNumberList.builtin$cls = "AnimatedNumberList";
  if (!"name" in AnimatedNumberList)
    AnimatedNumberList.name = "AnimatedNumberList";
  $desc = $collectedClasses.AnimatedNumberList;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimatedNumberList.prototype = $desc;
  function AnimatedString() {
  }
  AnimatedString.builtin$cls = "AnimatedString";
  if (!"name" in AnimatedString)
    AnimatedString.name = "AnimatedString";
  $desc = $collectedClasses.AnimatedString;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimatedString.prototype = $desc;
  function AnimatedTransformList() {
  }
  AnimatedTransformList.builtin$cls = "AnimatedTransformList";
  if (!"name" in AnimatedTransformList)
    AnimatedTransformList.name = "AnimatedTransformList";
  $desc = $collectedClasses.AnimatedTransformList;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimatedTransformList.prototype = $desc;
  function AnimationElement() {
  }
  AnimationElement.builtin$cls = "AnimationElement";
  if (!"name" in AnimationElement)
    AnimationElement.name = "AnimationElement";
  $desc = $collectedClasses.AnimationElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimationElement.prototype = $desc;
  function CircleElement() {
  }
  CircleElement.builtin$cls = "CircleElement";
  if (!"name" in CircleElement)
    CircleElement.name = "CircleElement";
  $desc = $collectedClasses.CircleElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CircleElement.prototype = $desc;
  function ClipPathElement() {
  }
  ClipPathElement.builtin$cls = "ClipPathElement";
  if (!"name" in ClipPathElement)
    ClipPathElement.name = "ClipPathElement";
  $desc = $collectedClasses.ClipPathElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ClipPathElement.prototype = $desc;
  function DefsElement() {
  }
  DefsElement.builtin$cls = "DefsElement";
  if (!"name" in DefsElement)
    DefsElement.name = "DefsElement";
  $desc = $collectedClasses.DefsElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DefsElement.prototype = $desc;
  function DescElement() {
  }
  DescElement.builtin$cls = "DescElement";
  if (!"name" in DescElement)
    DescElement.name = "DescElement";
  $desc = $collectedClasses.DescElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DescElement.prototype = $desc;
  function DiscardElement() {
  }
  DiscardElement.builtin$cls = "DiscardElement";
  if (!"name" in DiscardElement)
    DiscardElement.name = "DiscardElement";
  $desc = $collectedClasses.DiscardElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DiscardElement.prototype = $desc;
  function EllipseElement() {
  }
  EllipseElement.builtin$cls = "EllipseElement";
  if (!"name" in EllipseElement)
    EllipseElement.name = "EllipseElement";
  $desc = $collectedClasses.EllipseElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  EllipseElement.prototype = $desc;
  function FEBlendElement() {
  }
  FEBlendElement.builtin$cls = "FEBlendElement";
  if (!"name" in FEBlendElement)
    FEBlendElement.name = "FEBlendElement";
  $desc = $collectedClasses.FEBlendElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEBlendElement.prototype = $desc;
  FEBlendElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEBlendElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEBlendElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEBlendElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEColorMatrixElement() {
  }
  FEColorMatrixElement.builtin$cls = "FEColorMatrixElement";
  if (!"name" in FEColorMatrixElement)
    FEColorMatrixElement.name = "FEColorMatrixElement";
  $desc = $collectedClasses.FEColorMatrixElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEColorMatrixElement.prototype = $desc;
  FEColorMatrixElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  FEColorMatrixElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEColorMatrixElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEColorMatrixElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEColorMatrixElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEComponentTransferElement() {
  }
  FEComponentTransferElement.builtin$cls = "FEComponentTransferElement";
  if (!"name" in FEComponentTransferElement)
    FEComponentTransferElement.name = "FEComponentTransferElement";
  $desc = $collectedClasses.FEComponentTransferElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEComponentTransferElement.prototype = $desc;
  FEComponentTransferElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEComponentTransferElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEComponentTransferElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEComponentTransferElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FECompositeElement() {
  }
  FECompositeElement.builtin$cls = "FECompositeElement";
  if (!"name" in FECompositeElement)
    FECompositeElement.name = "FECompositeElement";
  $desc = $collectedClasses.FECompositeElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FECompositeElement.prototype = $desc;
  FECompositeElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FECompositeElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FECompositeElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FECompositeElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEConvolveMatrixElement() {
  }
  FEConvolveMatrixElement.builtin$cls = "FEConvolveMatrixElement";
  if (!"name" in FEConvolveMatrixElement)
    FEConvolveMatrixElement.name = "FEConvolveMatrixElement";
  $desc = $collectedClasses.FEConvolveMatrixElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEConvolveMatrixElement.prototype = $desc;
  FEConvolveMatrixElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEConvolveMatrixElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEConvolveMatrixElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEConvolveMatrixElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEDiffuseLightingElement() {
  }
  FEDiffuseLightingElement.builtin$cls = "FEDiffuseLightingElement";
  if (!"name" in FEDiffuseLightingElement)
    FEDiffuseLightingElement.name = "FEDiffuseLightingElement";
  $desc = $collectedClasses.FEDiffuseLightingElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEDiffuseLightingElement.prototype = $desc;
  FEDiffuseLightingElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEDiffuseLightingElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEDiffuseLightingElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEDiffuseLightingElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEDisplacementMapElement() {
  }
  FEDisplacementMapElement.builtin$cls = "FEDisplacementMapElement";
  if (!"name" in FEDisplacementMapElement)
    FEDisplacementMapElement.name = "FEDisplacementMapElement";
  $desc = $collectedClasses.FEDisplacementMapElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEDisplacementMapElement.prototype = $desc;
  FEDisplacementMapElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEDisplacementMapElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEDisplacementMapElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEDisplacementMapElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEDistantLightElement() {
  }
  FEDistantLightElement.builtin$cls = "FEDistantLightElement";
  if (!"name" in FEDistantLightElement)
    FEDistantLightElement.name = "FEDistantLightElement";
  $desc = $collectedClasses.FEDistantLightElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEDistantLightElement.prototype = $desc;
  function FEFloodElement() {
  }
  FEFloodElement.builtin$cls = "FEFloodElement";
  if (!"name" in FEFloodElement)
    FEFloodElement.name = "FEFloodElement";
  $desc = $collectedClasses.FEFloodElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEFloodElement.prototype = $desc;
  FEFloodElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEFloodElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEFloodElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEFloodElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEFuncAElement() {
  }
  FEFuncAElement.builtin$cls = "FEFuncAElement";
  if (!"name" in FEFuncAElement)
    FEFuncAElement.name = "FEFuncAElement";
  $desc = $collectedClasses.FEFuncAElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEFuncAElement.prototype = $desc;
  function FEFuncBElement() {
  }
  FEFuncBElement.builtin$cls = "FEFuncBElement";
  if (!"name" in FEFuncBElement)
    FEFuncBElement.name = "FEFuncBElement";
  $desc = $collectedClasses.FEFuncBElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEFuncBElement.prototype = $desc;
  function FEFuncGElement() {
  }
  FEFuncGElement.builtin$cls = "FEFuncGElement";
  if (!"name" in FEFuncGElement)
    FEFuncGElement.name = "FEFuncGElement";
  $desc = $collectedClasses.FEFuncGElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEFuncGElement.prototype = $desc;
  function FEFuncRElement() {
  }
  FEFuncRElement.builtin$cls = "FEFuncRElement";
  if (!"name" in FEFuncRElement)
    FEFuncRElement.name = "FEFuncRElement";
  $desc = $collectedClasses.FEFuncRElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEFuncRElement.prototype = $desc;
  function FEGaussianBlurElement() {
  }
  FEGaussianBlurElement.builtin$cls = "FEGaussianBlurElement";
  if (!"name" in FEGaussianBlurElement)
    FEGaussianBlurElement.name = "FEGaussianBlurElement";
  $desc = $collectedClasses.FEGaussianBlurElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEGaussianBlurElement.prototype = $desc;
  FEGaussianBlurElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEGaussianBlurElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEGaussianBlurElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEGaussianBlurElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEImageElement() {
  }
  FEImageElement.builtin$cls = "FEImageElement";
  if (!"name" in FEImageElement)
    FEImageElement.name = "FEImageElement";
  $desc = $collectedClasses.FEImageElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEImageElement.prototype = $desc;
  FEImageElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEImageElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEImageElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEImageElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEMergeElement() {
  }
  FEMergeElement.builtin$cls = "FEMergeElement";
  if (!"name" in FEMergeElement)
    FEMergeElement.name = "FEMergeElement";
  $desc = $collectedClasses.FEMergeElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEMergeElement.prototype = $desc;
  FEMergeElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEMergeElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEMergeElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEMergeElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEMergeNodeElement() {
  }
  FEMergeNodeElement.builtin$cls = "FEMergeNodeElement";
  if (!"name" in FEMergeNodeElement)
    FEMergeNodeElement.name = "FEMergeNodeElement";
  $desc = $collectedClasses.FEMergeNodeElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEMergeNodeElement.prototype = $desc;
  function FEMorphologyElement() {
  }
  FEMorphologyElement.builtin$cls = "FEMorphologyElement";
  if (!"name" in FEMorphologyElement)
    FEMorphologyElement.name = "FEMorphologyElement";
  $desc = $collectedClasses.FEMorphologyElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEMorphologyElement.prototype = $desc;
  FEMorphologyElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEMorphologyElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEMorphologyElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEMorphologyElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEOffsetElement() {
  }
  FEOffsetElement.builtin$cls = "FEOffsetElement";
  if (!"name" in FEOffsetElement)
    FEOffsetElement.name = "FEOffsetElement";
  $desc = $collectedClasses.FEOffsetElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEOffsetElement.prototype = $desc;
  FEOffsetElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FEOffsetElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FEOffsetElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEOffsetElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FEPointLightElement() {
  }
  FEPointLightElement.builtin$cls = "FEPointLightElement";
  if (!"name" in FEPointLightElement)
    FEPointLightElement.name = "FEPointLightElement";
  $desc = $collectedClasses.FEPointLightElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FEPointLightElement.prototype = $desc;
  FEPointLightElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FEPointLightElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  FEPointLightElement.prototype.get$z = function(receiver) {
    return receiver.z;
  };
  function FESpecularLightingElement() {
  }
  FESpecularLightingElement.builtin$cls = "FESpecularLightingElement";
  if (!"name" in FESpecularLightingElement)
    FESpecularLightingElement.name = "FESpecularLightingElement";
  $desc = $collectedClasses.FESpecularLightingElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FESpecularLightingElement.prototype = $desc;
  FESpecularLightingElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FESpecularLightingElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FESpecularLightingElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FESpecularLightingElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FESpotLightElement() {
  }
  FESpotLightElement.builtin$cls = "FESpotLightElement";
  if (!"name" in FESpotLightElement)
    FESpotLightElement.name = "FESpotLightElement";
  $desc = $collectedClasses.FESpotLightElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FESpotLightElement.prototype = $desc;
  FESpotLightElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FESpotLightElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  FESpotLightElement.prototype.get$z = function(receiver) {
    return receiver.z;
  };
  function FETileElement() {
  }
  FETileElement.builtin$cls = "FETileElement";
  if (!"name" in FETileElement)
    FETileElement.name = "FETileElement";
  $desc = $collectedClasses.FETileElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FETileElement.prototype = $desc;
  FETileElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FETileElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FETileElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FETileElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FETurbulenceElement() {
  }
  FETurbulenceElement.builtin$cls = "FETurbulenceElement";
  if (!"name" in FETurbulenceElement)
    FETurbulenceElement.name = "FETurbulenceElement";
  $desc = $collectedClasses.FETurbulenceElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FETurbulenceElement.prototype = $desc;
  FETurbulenceElement.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  FETurbulenceElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FETurbulenceElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FETurbulenceElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FETurbulenceElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function FilterElement() {
  }
  FilterElement.builtin$cls = "FilterElement";
  if (!"name" in FilterElement)
    FilterElement.name = "FilterElement";
  $desc = $collectedClasses.FilterElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FilterElement.prototype = $desc;
  FilterElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  FilterElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  FilterElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  FilterElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function ForeignObjectElement() {
  }
  ForeignObjectElement.builtin$cls = "ForeignObjectElement";
  if (!"name" in ForeignObjectElement)
    ForeignObjectElement.name = "ForeignObjectElement";
  $desc = $collectedClasses.ForeignObjectElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ForeignObjectElement.prototype = $desc;
  ForeignObjectElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  ForeignObjectElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  ForeignObjectElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  ForeignObjectElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function GElement() {
  }
  GElement.builtin$cls = "GElement";
  if (!"name" in GElement)
    GElement.name = "GElement";
  $desc = $collectedClasses.GElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GElement.prototype = $desc;
  function GeometryElement() {
  }
  GeometryElement.builtin$cls = "GeometryElement";
  if (!"name" in GeometryElement)
    GeometryElement.name = "GeometryElement";
  $desc = $collectedClasses.GeometryElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GeometryElement.prototype = $desc;
  function GraphicsElement() {
  }
  GraphicsElement.builtin$cls = "GraphicsElement";
  if (!"name" in GraphicsElement)
    GraphicsElement.name = "GraphicsElement";
  $desc = $collectedClasses.GraphicsElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GraphicsElement.prototype = $desc;
  function ImageElement0() {
  }
  ImageElement0.builtin$cls = "ImageElement0";
  if (!"name" in ImageElement0)
    ImageElement0.name = "ImageElement0";
  $desc = $collectedClasses.ImageElement0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ImageElement0.prototype = $desc;
  ImageElement0.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  ImageElement0.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  ImageElement0.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  ImageElement0.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function LineElement() {
  }
  LineElement.builtin$cls = "LineElement";
  if (!"name" in LineElement)
    LineElement.name = "LineElement";
  $desc = $collectedClasses.LineElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LineElement.prototype = $desc;
  function LinearGradientElement() {
  }
  LinearGradientElement.builtin$cls = "LinearGradientElement";
  if (!"name" in LinearGradientElement)
    LinearGradientElement.name = "LinearGradientElement";
  $desc = $collectedClasses.LinearGradientElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LinearGradientElement.prototype = $desc;
  function MarkerElement() {
  }
  MarkerElement.builtin$cls = "MarkerElement";
  if (!"name" in MarkerElement)
    MarkerElement.name = "MarkerElement";
  $desc = $collectedClasses.MarkerElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MarkerElement.prototype = $desc;
  function MaskElement() {
  }
  MaskElement.builtin$cls = "MaskElement";
  if (!"name" in MaskElement)
    MaskElement.name = "MaskElement";
  $desc = $collectedClasses.MaskElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MaskElement.prototype = $desc;
  MaskElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  MaskElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  MaskElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  MaskElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function MetadataElement() {
  }
  MetadataElement.builtin$cls = "MetadataElement";
  if (!"name" in MetadataElement)
    MetadataElement.name = "MetadataElement";
  $desc = $collectedClasses.MetadataElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MetadataElement.prototype = $desc;
  function PathElement() {
  }
  PathElement.builtin$cls = "PathElement";
  if (!"name" in PathElement)
    PathElement.name = "PathElement";
  $desc = $collectedClasses.PathElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PathElement.prototype = $desc;
  function PatternElement() {
  }
  PatternElement.builtin$cls = "PatternElement";
  if (!"name" in PatternElement)
    PatternElement.name = "PatternElement";
  $desc = $collectedClasses.PatternElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PatternElement.prototype = $desc;
  PatternElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  PatternElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  PatternElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  PatternElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function PointList() {
  }
  PointList.builtin$cls = "PointList";
  if (!"name" in PointList)
    PointList.name = "PointList";
  $desc = $collectedClasses.PointList;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PointList.prototype = $desc;
  function PolygonElement() {
  }
  PolygonElement.builtin$cls = "PolygonElement";
  if (!"name" in PolygonElement)
    PolygonElement.name = "PolygonElement";
  $desc = $collectedClasses.PolygonElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PolygonElement.prototype = $desc;
  function PolylineElement() {
  }
  PolylineElement.builtin$cls = "PolylineElement";
  if (!"name" in PolylineElement)
    PolylineElement.name = "PolylineElement";
  $desc = $collectedClasses.PolylineElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PolylineElement.prototype = $desc;
  function RadialGradientElement() {
  }
  RadialGradientElement.builtin$cls = "RadialGradientElement";
  if (!"name" in RadialGradientElement)
    RadialGradientElement.name = "RadialGradientElement";
  $desc = $collectedClasses.RadialGradientElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RadialGradientElement.prototype = $desc;
  function RectElement() {
  }
  RectElement.builtin$cls = "RectElement";
  if (!"name" in RectElement)
    RectElement.name = "RectElement";
  $desc = $collectedClasses.RectElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RectElement.prototype = $desc;
  RectElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  RectElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  RectElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  RectElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function ScriptElement0() {
  }
  ScriptElement0.builtin$cls = "ScriptElement0";
  if (!"name" in ScriptElement0)
    ScriptElement0.name = "ScriptElement0";
  $desc = $collectedClasses.ScriptElement0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ScriptElement0.prototype = $desc;
  ScriptElement0.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function SetElement() {
  }
  SetElement.builtin$cls = "SetElement";
  if (!"name" in SetElement)
    SetElement.name = "SetElement";
  $desc = $collectedClasses.SetElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SetElement.prototype = $desc;
  function StopElement() {
  }
  StopElement.builtin$cls = "StopElement";
  if (!"name" in StopElement)
    StopElement.name = "StopElement";
  $desc = $collectedClasses.StopElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StopElement.prototype = $desc;
  function StyleElement0() {
  }
  StyleElement0.builtin$cls = "StyleElement0";
  if (!"name" in StyleElement0)
    StyleElement0.name = "StyleElement0";
  $desc = $collectedClasses.StyleElement0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StyleElement0.prototype = $desc;
  StyleElement0.prototype.get$type = function(receiver) {
    return receiver.type;
  };
  function SvgElement() {
  }
  SvgElement.builtin$cls = "SvgElement";
  if (!"name" in SvgElement)
    SvgElement.name = "SvgElement";
  $desc = $collectedClasses.SvgElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SvgElement.prototype = $desc;
  function SvgSvgElement() {
  }
  SvgSvgElement.builtin$cls = "SvgSvgElement";
  if (!"name" in SvgSvgElement)
    SvgSvgElement.name = "SvgSvgElement";
  $desc = $collectedClasses.SvgSvgElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SvgSvgElement.prototype = $desc;
  SvgSvgElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  SvgSvgElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  SvgSvgElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  SvgSvgElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function SwitchElement() {
  }
  SwitchElement.builtin$cls = "SwitchElement";
  if (!"name" in SwitchElement)
    SwitchElement.name = "SwitchElement";
  $desc = $collectedClasses.SwitchElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SwitchElement.prototype = $desc;
  function SymbolElement() {
  }
  SymbolElement.builtin$cls = "SymbolElement";
  if (!"name" in SymbolElement)
    SymbolElement.name = "SymbolElement";
  $desc = $collectedClasses.SymbolElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SymbolElement.prototype = $desc;
  function TSpanElement() {
  }
  TSpanElement.builtin$cls = "TSpanElement";
  if (!"name" in TSpanElement)
    TSpanElement.name = "TSpanElement";
  $desc = $collectedClasses.TSpanElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TSpanElement.prototype = $desc;
  function TextContentElement() {
  }
  TextContentElement.builtin$cls = "TextContentElement";
  if (!"name" in TextContentElement)
    TextContentElement.name = "TextContentElement";
  $desc = $collectedClasses.TextContentElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TextContentElement.prototype = $desc;
  function TextElement() {
  }
  TextElement.builtin$cls = "TextElement";
  if (!"name" in TextElement)
    TextElement.name = "TextElement";
  $desc = $collectedClasses.TextElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TextElement.prototype = $desc;
  function TextPathElement() {
  }
  TextPathElement.builtin$cls = "TextPathElement";
  if (!"name" in TextPathElement)
    TextPathElement.name = "TextPathElement";
  $desc = $collectedClasses.TextPathElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TextPathElement.prototype = $desc;
  function TextPositioningElement() {
  }
  TextPositioningElement.builtin$cls = "TextPositioningElement";
  if (!"name" in TextPositioningElement)
    TextPositioningElement.name = "TextPositioningElement";
  $desc = $collectedClasses.TextPositioningElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TextPositioningElement.prototype = $desc;
  TextPositioningElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  TextPositioningElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function TitleElement0() {
  }
  TitleElement0.builtin$cls = "TitleElement0";
  if (!"name" in TitleElement0)
    TitleElement0.name = "TitleElement0";
  $desc = $collectedClasses.TitleElement0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TitleElement0.prototype = $desc;
  function UseElement() {
  }
  UseElement.builtin$cls = "UseElement";
  if (!"name" in UseElement)
    UseElement.name = "UseElement";
  $desc = $collectedClasses.UseElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UseElement.prototype = $desc;
  UseElement.prototype.get$height = function(receiver) {
    return receiver.height;
  };
  UseElement.prototype.get$width = function(receiver) {
    return receiver.width;
  };
  UseElement.prototype.get$x = function(receiver) {
    return receiver.x;
  };
  UseElement.prototype.get$y = function(receiver) {
    return receiver.y;
  };
  function ViewElement() {
  }
  ViewElement.builtin$cls = "ViewElement";
  if (!"name" in ViewElement)
    ViewElement.name = "ViewElement";
  $desc = $collectedClasses.ViewElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ViewElement.prototype = $desc;
  function ZoomEvent() {
  }
  ZoomEvent.builtin$cls = "ZoomEvent";
  if (!"name" in ZoomEvent)
    ZoomEvent.name = "ZoomEvent";
  $desc = $collectedClasses.ZoomEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ZoomEvent.prototype = $desc;
  function _GradientElement() {
  }
  _GradientElement.builtin$cls = "_GradientElement";
  if (!"name" in _GradientElement)
    _GradientElement.name = "_GradientElement";
  $desc = $collectedClasses._GradientElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _GradientElement.prototype = $desc;
  function _SVGAltGlyphDefElement() {
  }
  _SVGAltGlyphDefElement.builtin$cls = "_SVGAltGlyphDefElement";
  if (!"name" in _SVGAltGlyphDefElement)
    _SVGAltGlyphDefElement.name = "_SVGAltGlyphDefElement";
  $desc = $collectedClasses._SVGAltGlyphDefElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGAltGlyphDefElement.prototype = $desc;
  function _SVGAltGlyphItemElement() {
  }
  _SVGAltGlyphItemElement.builtin$cls = "_SVGAltGlyphItemElement";
  if (!"name" in _SVGAltGlyphItemElement)
    _SVGAltGlyphItemElement.name = "_SVGAltGlyphItemElement";
  $desc = $collectedClasses._SVGAltGlyphItemElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGAltGlyphItemElement.prototype = $desc;
  function _SVGComponentTransferFunctionElement() {
  }
  _SVGComponentTransferFunctionElement.builtin$cls = "_SVGComponentTransferFunctionElement";
  if (!"name" in _SVGComponentTransferFunctionElement)
    _SVGComponentTransferFunctionElement.name = "_SVGComponentTransferFunctionElement";
  $desc = $collectedClasses._SVGComponentTransferFunctionElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGComponentTransferFunctionElement.prototype = $desc;
  function _SVGCursorElement() {
  }
  _SVGCursorElement.builtin$cls = "_SVGCursorElement";
  if (!"name" in _SVGCursorElement)
    _SVGCursorElement.name = "_SVGCursorElement";
  $desc = $collectedClasses._SVGCursorElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGCursorElement.prototype = $desc;
  function _SVGFEDropShadowElement() {
  }
  _SVGFEDropShadowElement.builtin$cls = "_SVGFEDropShadowElement";
  if (!"name" in _SVGFEDropShadowElement)
    _SVGFEDropShadowElement.name = "_SVGFEDropShadowElement";
  $desc = $collectedClasses._SVGFEDropShadowElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGFEDropShadowElement.prototype = $desc;
  function _SVGFontElement() {
  }
  _SVGFontElement.builtin$cls = "_SVGFontElement";
  if (!"name" in _SVGFontElement)
    _SVGFontElement.name = "_SVGFontElement";
  $desc = $collectedClasses._SVGFontElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGFontElement.prototype = $desc;
  function _SVGFontFaceElement() {
  }
  _SVGFontFaceElement.builtin$cls = "_SVGFontFaceElement";
  if (!"name" in _SVGFontFaceElement)
    _SVGFontFaceElement.name = "_SVGFontFaceElement";
  $desc = $collectedClasses._SVGFontFaceElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGFontFaceElement.prototype = $desc;
  function _SVGFontFaceFormatElement() {
  }
  _SVGFontFaceFormatElement.builtin$cls = "_SVGFontFaceFormatElement";
  if (!"name" in _SVGFontFaceFormatElement)
    _SVGFontFaceFormatElement.name = "_SVGFontFaceFormatElement";
  $desc = $collectedClasses._SVGFontFaceFormatElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGFontFaceFormatElement.prototype = $desc;
  function _SVGFontFaceNameElement() {
  }
  _SVGFontFaceNameElement.builtin$cls = "_SVGFontFaceNameElement";
  if (!"name" in _SVGFontFaceNameElement)
    _SVGFontFaceNameElement.name = "_SVGFontFaceNameElement";
  $desc = $collectedClasses._SVGFontFaceNameElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGFontFaceNameElement.prototype = $desc;
  function _SVGFontFaceSrcElement() {
  }
  _SVGFontFaceSrcElement.builtin$cls = "_SVGFontFaceSrcElement";
  if (!"name" in _SVGFontFaceSrcElement)
    _SVGFontFaceSrcElement.name = "_SVGFontFaceSrcElement";
  $desc = $collectedClasses._SVGFontFaceSrcElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGFontFaceSrcElement.prototype = $desc;
  function _SVGFontFaceUriElement() {
  }
  _SVGFontFaceUriElement.builtin$cls = "_SVGFontFaceUriElement";
  if (!"name" in _SVGFontFaceUriElement)
    _SVGFontFaceUriElement.name = "_SVGFontFaceUriElement";
  $desc = $collectedClasses._SVGFontFaceUriElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGFontFaceUriElement.prototype = $desc;
  function _SVGGlyphElement() {
  }
  _SVGGlyphElement.builtin$cls = "_SVGGlyphElement";
  if (!"name" in _SVGGlyphElement)
    _SVGGlyphElement.name = "_SVGGlyphElement";
  $desc = $collectedClasses._SVGGlyphElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGGlyphElement.prototype = $desc;
  function _SVGGlyphRefElement() {
  }
  _SVGGlyphRefElement.builtin$cls = "_SVGGlyphRefElement";
  if (!"name" in _SVGGlyphRefElement)
    _SVGGlyphRefElement.name = "_SVGGlyphRefElement";
  $desc = $collectedClasses._SVGGlyphRefElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGGlyphRefElement.prototype = $desc;
  function _SVGHKernElement() {
  }
  _SVGHKernElement.builtin$cls = "_SVGHKernElement";
  if (!"name" in _SVGHKernElement)
    _SVGHKernElement.name = "_SVGHKernElement";
  $desc = $collectedClasses._SVGHKernElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGHKernElement.prototype = $desc;
  function _SVGMPathElement() {
  }
  _SVGMPathElement.builtin$cls = "_SVGMPathElement";
  if (!"name" in _SVGMPathElement)
    _SVGMPathElement.name = "_SVGMPathElement";
  $desc = $collectedClasses._SVGMPathElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGMPathElement.prototype = $desc;
  function _SVGMissingGlyphElement() {
  }
  _SVGMissingGlyphElement.builtin$cls = "_SVGMissingGlyphElement";
  if (!"name" in _SVGMissingGlyphElement)
    _SVGMissingGlyphElement.name = "_SVGMissingGlyphElement";
  $desc = $collectedClasses._SVGMissingGlyphElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGMissingGlyphElement.prototype = $desc;
  function _SVGVKernElement() {
  }
  _SVGVKernElement.builtin$cls = "_SVGVKernElement";
  if (!"name" in _SVGVKernElement)
    _SVGVKernElement.name = "_SVGVKernElement";
  $desc = $collectedClasses._SVGVKernElement;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SVGVKernElement.prototype = $desc;
  function AudioProcessingEvent() {
  }
  AudioProcessingEvent.builtin$cls = "AudioProcessingEvent";
  if (!"name" in AudioProcessingEvent)
    AudioProcessingEvent.name = "AudioProcessingEvent";
  $desc = $collectedClasses.AudioProcessingEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AudioProcessingEvent.prototype = $desc;
  function OfflineAudioCompletionEvent() {
  }
  OfflineAudioCompletionEvent.builtin$cls = "OfflineAudioCompletionEvent";
  if (!"name" in OfflineAudioCompletionEvent)
    OfflineAudioCompletionEvent.name = "OfflineAudioCompletionEvent";
  $desc = $collectedClasses.OfflineAudioCompletionEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OfflineAudioCompletionEvent.prototype = $desc;
  function ContextEvent() {
  }
  ContextEvent.builtin$cls = "ContextEvent";
  if (!"name" in ContextEvent)
    ContextEvent.name = "ContextEvent";
  $desc = $collectedClasses.ContextEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ContextEvent.prototype = $desc;
  function SqlError() {
  }
  SqlError.builtin$cls = "SqlError";
  if (!"name" in SqlError)
    SqlError.name = "SqlError";
  $desc = $collectedClasses.SqlError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SqlError.prototype = $desc;
  function NativeByteBuffer() {
  }
  NativeByteBuffer.builtin$cls = "NativeByteBuffer";
  if (!"name" in NativeByteBuffer)
    NativeByteBuffer.name = "NativeByteBuffer";
  $desc = $collectedClasses.NativeByteBuffer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeByteBuffer.prototype = $desc;
  function NativeTypedData() {
  }
  NativeTypedData.builtin$cls = "NativeTypedData";
  if (!"name" in NativeTypedData)
    NativeTypedData.name = "NativeTypedData";
  $desc = $collectedClasses.NativeTypedData;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeTypedData.prototype = $desc;
  NativeTypedData.prototype.get$buffer = function(receiver) {
    return receiver.buffer;
  };
  NativeTypedData.prototype.get$offsetInBytes = function(receiver) {
    return receiver.byteOffset;
  };
  function NativeByteData() {
  }
  NativeByteData.builtin$cls = "NativeByteData";
  if (!"name" in NativeByteData)
    NativeByteData.name = "NativeByteData";
  $desc = $collectedClasses.NativeByteData;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeByteData.prototype = $desc;
  function NativeFloat32List() {
  }
  NativeFloat32List.builtin$cls = "NativeFloat32List";
  if (!"name" in NativeFloat32List)
    NativeFloat32List.name = "NativeFloat32List";
  $desc = $collectedClasses.NativeFloat32List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeFloat32List.prototype = $desc;
  function NativeFloat64List() {
  }
  NativeFloat64List.builtin$cls = "NativeFloat64List";
  if (!"name" in NativeFloat64List)
    NativeFloat64List.name = "NativeFloat64List";
  $desc = $collectedClasses.NativeFloat64List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeFloat64List.prototype = $desc;
  function NativeInt16List() {
  }
  NativeInt16List.builtin$cls = "NativeInt16List";
  if (!"name" in NativeInt16List)
    NativeInt16List.name = "NativeInt16List";
  $desc = $collectedClasses.NativeInt16List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeInt16List.prototype = $desc;
  function NativeInt32List() {
  }
  NativeInt32List.builtin$cls = "NativeInt32List";
  if (!"name" in NativeInt32List)
    NativeInt32List.name = "NativeInt32List";
  $desc = $collectedClasses.NativeInt32List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeInt32List.prototype = $desc;
  function NativeInt8List() {
  }
  NativeInt8List.builtin$cls = "NativeInt8List";
  if (!"name" in NativeInt8List)
    NativeInt8List.name = "NativeInt8List";
  $desc = $collectedClasses.NativeInt8List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeInt8List.prototype = $desc;
  function NativeUint16List() {
  }
  NativeUint16List.builtin$cls = "NativeUint16List";
  if (!"name" in NativeUint16List)
    NativeUint16List.name = "NativeUint16List";
  $desc = $collectedClasses.NativeUint16List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeUint16List.prototype = $desc;
  function NativeUint32List() {
  }
  NativeUint32List.builtin$cls = "NativeUint32List";
  if (!"name" in NativeUint32List)
    NativeUint32List.name = "NativeUint32List";
  $desc = $collectedClasses.NativeUint32List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeUint32List.prototype = $desc;
  function NativeUint8ClampedList() {
  }
  NativeUint8ClampedList.builtin$cls = "NativeUint8ClampedList";
  if (!"name" in NativeUint8ClampedList)
    NativeUint8ClampedList.name = "NativeUint8ClampedList";
  $desc = $collectedClasses.NativeUint8ClampedList;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeUint8ClampedList.prototype = $desc;
  function NativeUint8List() {
  }
  NativeUint8List.builtin$cls = "NativeUint8List";
  if (!"name" in NativeUint8List)
    NativeUint8List.name = "NativeUint8List";
  $desc = $collectedClasses.NativeUint8List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeUint8List.prototype = $desc;
  function JS_CONST(code) {
    this.code = code;
  }
  JS_CONST.builtin$cls = "JS_CONST";
  if (!"name" in JS_CONST)
    JS_CONST.name = "JS_CONST";
  $desc = $collectedClasses.JS_CONST;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JS_CONST.prototype = $desc;
  function Interceptor() {
  }
  Interceptor.builtin$cls = "Interceptor";
  if (!"name" in Interceptor)
    Interceptor.name = "Interceptor";
  $desc = $collectedClasses.Interceptor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Interceptor.prototype = $desc;
  function JSBool() {
  }
  JSBool.builtin$cls = "bool";
  if (!"name" in JSBool)
    JSBool.name = "JSBool";
  $desc = $collectedClasses.JSBool;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JSBool.prototype = $desc;
  function JSNull() {
  }
  JSNull.builtin$cls = "Null";
  if (!"name" in JSNull)
    JSNull.name = "JSNull";
  $desc = $collectedClasses.JSNull;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JSNull.prototype = $desc;
  function JavaScriptObject() {
  }
  JavaScriptObject.builtin$cls = "JavaScriptObject";
  if (!"name" in JavaScriptObject)
    JavaScriptObject.name = "JavaScriptObject";
  $desc = $collectedClasses.JavaScriptObject;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JavaScriptObject.prototype = $desc;
  function PlainJavaScriptObject() {
  }
  PlainJavaScriptObject.builtin$cls = "PlainJavaScriptObject";
  if (!"name" in PlainJavaScriptObject)
    PlainJavaScriptObject.name = "PlainJavaScriptObject";
  $desc = $collectedClasses.PlainJavaScriptObject;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PlainJavaScriptObject.prototype = $desc;
  function UnknownJavaScriptObject() {
  }
  UnknownJavaScriptObject.builtin$cls = "UnknownJavaScriptObject";
  if (!"name" in UnknownJavaScriptObject)
    UnknownJavaScriptObject.name = "UnknownJavaScriptObject";
  $desc = $collectedClasses.UnknownJavaScriptObject;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UnknownJavaScriptObject.prototype = $desc;
  function JSArray() {
  }
  JSArray.builtin$cls = "List";
  if (!"name" in JSArray)
    JSArray.name = "JSArray";
  $desc = $collectedClasses.JSArray;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JSArray.prototype = $desc;
  function JSNumber() {
  }
  JSNumber.builtin$cls = "num";
  if (!"name" in JSNumber)
    JSNumber.name = "JSNumber";
  $desc = $collectedClasses.JSNumber;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JSNumber.prototype = $desc;
  function JSInt() {
  }
  JSInt.builtin$cls = "int";
  if (!"name" in JSInt)
    JSInt.name = "JSInt";
  $desc = $collectedClasses.JSInt;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JSInt.prototype = $desc;
  function JSDouble() {
  }
  JSDouble.builtin$cls = "double";
  if (!"name" in JSDouble)
    JSDouble.name = "JSDouble";
  $desc = $collectedClasses.JSDouble;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JSDouble.prototype = $desc;
  function JSString() {
  }
  JSString.builtin$cls = "String";
  if (!"name" in JSString)
    JSString.name = "JSString";
  $desc = $collectedClasses.JSString;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JSString.prototype = $desc;
  function _CodeUnits(_string) {
    this._string = _string;
  }
  _CodeUnits.builtin$cls = "_CodeUnits";
  if (!"name" in _CodeUnits)
    _CodeUnits.name = "_CodeUnits";
  $desc = $collectedClasses._CodeUnits;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _CodeUnits.prototype = $desc;
  function startRootIsolate_closure(box_0, entry_1) {
    this.box_0 = box_0;
    this.entry_1 = entry_1;
  }
  startRootIsolate_closure.builtin$cls = "startRootIsolate_closure";
  if (!"name" in startRootIsolate_closure)
    startRootIsolate_closure.name = "startRootIsolate_closure";
  $desc = $collectedClasses.startRootIsolate_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  startRootIsolate_closure.prototype = $desc;
  function startRootIsolate_closure0(box_0, entry_2) {
    this.box_0 = box_0;
    this.entry_2 = entry_2;
  }
  startRootIsolate_closure0.builtin$cls = "startRootIsolate_closure0";
  if (!"name" in startRootIsolate_closure0)
    startRootIsolate_closure0.name = "startRootIsolate_closure0";
  $desc = $collectedClasses.startRootIsolate_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  startRootIsolate_closure0.prototype = $desc;
  function _Manager(nextIsolateId, currentManagerId, nextManagerId, currentContext, rootContext, topEventLoop, fromCommandLine, isWorker, supportsWorkers, isolates, mainManager, managers, entry) {
    this.nextIsolateId = nextIsolateId;
    this.currentManagerId = currentManagerId;
    this.nextManagerId = nextManagerId;
    this.currentContext = currentContext;
    this.rootContext = rootContext;
    this.topEventLoop = topEventLoop;
    this.fromCommandLine = fromCommandLine;
    this.isWorker = isWorker;
    this.supportsWorkers = supportsWorkers;
    this.isolates = isolates;
    this.mainManager = mainManager;
    this.managers = managers;
    this.entry = entry;
  }
  _Manager.builtin$cls = "_Manager";
  if (!"name" in _Manager)
    _Manager.name = "_Manager";
  $desc = $collectedClasses._Manager;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Manager.prototype = $desc;
  function _IsolateContext(id, ports, weakPorts, isolateStatics, controlPort, pauseCapability, terminateCapability, isPaused, delayedEvents, pauseTokens, doneHandlers, errorsAreFatal) {
    this.id = id;
    this.ports = ports;
    this.weakPorts = weakPorts;
    this.isolateStatics = isolateStatics;
    this.controlPort = controlPort;
    this.pauseCapability = pauseCapability;
    this.terminateCapability = terminateCapability;
    this.isPaused = isPaused;
    this.delayedEvents = delayedEvents;
    this.pauseTokens = pauseTokens;
    this.doneHandlers = doneHandlers;
    this.errorsAreFatal = errorsAreFatal;
  }
  _IsolateContext.builtin$cls = "_IsolateContext";
  if (!"name" in _IsolateContext)
    _IsolateContext.name = "_IsolateContext";
  $desc = $collectedClasses._IsolateContext;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _IsolateContext.prototype = $desc;
  _IsolateContext.prototype.get$id = function(receiver) {
    return this.id;
  };
  _IsolateContext.prototype.get$isolateStatics = function() {
    return this.isolateStatics;
  };
  _IsolateContext.prototype.get$controlPort = function() {
    return this.controlPort;
  };
  _IsolateContext.prototype.get$isPaused = function() {
    return this.isPaused;
  };
  function _IsolateContext_handlePing_closure(responsePort_0) {
    this.responsePort_0 = responsePort_0;
  }
  _IsolateContext_handlePing_closure.builtin$cls = "_IsolateContext_handlePing_closure";
  if (!"name" in _IsolateContext_handlePing_closure)
    _IsolateContext_handlePing_closure.name = "_IsolateContext_handlePing_closure";
  $desc = $collectedClasses._IsolateContext_handlePing_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _IsolateContext_handlePing_closure.prototype = $desc;
  function _EventLoop(events, _activeJsAsyncCount) {
    this.events = events;
    this._activeJsAsyncCount = _activeJsAsyncCount;
  }
  _EventLoop.builtin$cls = "_EventLoop";
  if (!"name" in _EventLoop)
    _EventLoop.name = "_EventLoop";
  $desc = $collectedClasses._EventLoop;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _EventLoop.prototype = $desc;
  function _EventLoop__runHelper_next(this_0) {
    this.this_0 = this_0;
  }
  _EventLoop__runHelper_next.builtin$cls = "_EventLoop__runHelper_next";
  if (!"name" in _EventLoop__runHelper_next)
    _EventLoop__runHelper_next.name = "_EventLoop__runHelper_next";
  $desc = $collectedClasses._EventLoop__runHelper_next;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _EventLoop__runHelper_next.prototype = $desc;
  function _IsolateEvent(isolate, fn, message) {
    this.isolate = isolate;
    this.fn = fn;
    this.message = message;
  }
  _IsolateEvent.builtin$cls = "_IsolateEvent";
  if (!"name" in _IsolateEvent)
    _IsolateEvent.name = "_IsolateEvent";
  $desc = $collectedClasses._IsolateEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _IsolateEvent.prototype = $desc;
  function _MainManagerStub() {
  }
  _MainManagerStub.builtin$cls = "_MainManagerStub";
  if (!"name" in _MainManagerStub)
    _MainManagerStub.name = "_MainManagerStub";
  $desc = $collectedClasses._MainManagerStub;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _MainManagerStub.prototype = $desc;
  function IsolateNatives__processWorkerMessage_closure(entryPoint_0, args_1, message_2, isSpawnUri_3, startPaused_4, replyTo_5) {
    this.entryPoint_0 = entryPoint_0;
    this.args_1 = args_1;
    this.message_2 = message_2;
    this.isSpawnUri_3 = isSpawnUri_3;
    this.startPaused_4 = startPaused_4;
    this.replyTo_5 = replyTo_5;
  }
  IsolateNatives__processWorkerMessage_closure.builtin$cls = "IsolateNatives__processWorkerMessage_closure";
  if (!"name" in IsolateNatives__processWorkerMessage_closure)
    IsolateNatives__processWorkerMessage_closure.name = "IsolateNatives__processWorkerMessage_closure";
  $desc = $collectedClasses.IsolateNatives__processWorkerMessage_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IsolateNatives__processWorkerMessage_closure.prototype = $desc;
  function IsolateNatives__startIsolate_runStartFunction(topLevel_0, args_1, message_2, isSpawnUri_3) {
    this.topLevel_0 = topLevel_0;
    this.args_1 = args_1;
    this.message_2 = message_2;
    this.isSpawnUri_3 = isSpawnUri_3;
  }
  IsolateNatives__startIsolate_runStartFunction.builtin$cls = "IsolateNatives__startIsolate_runStartFunction";
  if (!"name" in IsolateNatives__startIsolate_runStartFunction)
    IsolateNatives__startIsolate_runStartFunction.name = "IsolateNatives__startIsolate_runStartFunction";
  $desc = $collectedClasses.IsolateNatives__startIsolate_runStartFunction;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IsolateNatives__startIsolate_runStartFunction.prototype = $desc;
  function _BaseSendPort() {
  }
  _BaseSendPort.builtin$cls = "_BaseSendPort";
  if (!"name" in _BaseSendPort)
    _BaseSendPort.name = "_BaseSendPort";
  $desc = $collectedClasses._BaseSendPort;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BaseSendPort.prototype = $desc;
  function _NativeJsSendPort(_receivePort, _isolateId) {
    this._receivePort = _receivePort;
    this._isolateId = _isolateId;
  }
  _NativeJsSendPort.builtin$cls = "_NativeJsSendPort";
  if (!"name" in _NativeJsSendPort)
    _NativeJsSendPort.name = "_NativeJsSendPort";
  $desc = $collectedClasses._NativeJsSendPort;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _NativeJsSendPort.prototype = $desc;
  function _NativeJsSendPort_send_closure(box_0, this_1, shouldSerialize_2) {
    this.box_0 = box_0;
    this.this_1 = this_1;
    this.shouldSerialize_2 = shouldSerialize_2;
  }
  _NativeJsSendPort_send_closure.builtin$cls = "_NativeJsSendPort_send_closure";
  if (!"name" in _NativeJsSendPort_send_closure)
    _NativeJsSendPort_send_closure.name = "_NativeJsSendPort_send_closure";
  $desc = $collectedClasses._NativeJsSendPort_send_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _NativeJsSendPort_send_closure.prototype = $desc;
  function _WorkerSendPort(_workerId, _receivePortId, _isolateId) {
    this._workerId = _workerId;
    this._receivePortId = _receivePortId;
    this._isolateId = _isolateId;
  }
  _WorkerSendPort.builtin$cls = "_WorkerSendPort";
  if (!"name" in _WorkerSendPort)
    _WorkerSendPort.name = "_WorkerSendPort";
  $desc = $collectedClasses._WorkerSendPort;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _WorkerSendPort.prototype = $desc;
  function RawReceivePortImpl(_id, _handler, _isClosed) {
    this._id = _id;
    this._handler = _handler;
    this._isClosed = _isClosed;
  }
  RawReceivePortImpl.builtin$cls = "RawReceivePortImpl";
  if (!"name" in RawReceivePortImpl)
    RawReceivePortImpl.name = "RawReceivePortImpl";
  $desc = $collectedClasses.RawReceivePortImpl;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RawReceivePortImpl.prototype = $desc;
  RawReceivePortImpl.prototype.get$_id = function() {
    return this._id;
  };
  RawReceivePortImpl.prototype.get$_isClosed = function() {
    return this._isClosed;
  };
  function ReceivePortImpl(_rawPort, _controller) {
    this._rawPort = _rawPort;
    this._controller = _controller;
  }
  ReceivePortImpl.builtin$cls = "ReceivePortImpl";
  if (!"name" in ReceivePortImpl)
    ReceivePortImpl.name = "ReceivePortImpl";
  $desc = $collectedClasses.ReceivePortImpl;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ReceivePortImpl.prototype = $desc;
  function _JsSerializer(_nextFreeRefId, _visited) {
    this._nextFreeRefId = _nextFreeRefId;
    this._visited = _visited;
  }
  _JsSerializer.builtin$cls = "_JsSerializer";
  if (!"name" in _JsSerializer)
    _JsSerializer.name = "_JsSerializer";
  $desc = $collectedClasses._JsSerializer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _JsSerializer.prototype = $desc;
  function _JsCopier(_visited) {
    this._visited = _visited;
  }
  _JsCopier.builtin$cls = "_JsCopier";
  if (!"name" in _JsCopier)
    _JsCopier.name = "_JsCopier";
  $desc = $collectedClasses._JsCopier;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _JsCopier.prototype = $desc;
  function _JsDeserializer(_deserialized) {
    this._deserialized = _deserialized;
  }
  _JsDeserializer.builtin$cls = "_JsDeserializer";
  if (!"name" in _JsDeserializer)
    _JsDeserializer.name = "_JsDeserializer";
  $desc = $collectedClasses._JsDeserializer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _JsDeserializer.prototype = $desc;
  function _JsVisitedMap(tagged) {
    this.tagged = tagged;
  }
  _JsVisitedMap.builtin$cls = "_JsVisitedMap";
  if (!"name" in _JsVisitedMap)
    _JsVisitedMap.name = "_JsVisitedMap";
  $desc = $collectedClasses._JsVisitedMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _JsVisitedMap.prototype = $desc;
  function _MessageTraverserVisitedMap() {
  }
  _MessageTraverserVisitedMap.builtin$cls = "_MessageTraverserVisitedMap";
  if (!"name" in _MessageTraverserVisitedMap)
    _MessageTraverserVisitedMap.name = "_MessageTraverserVisitedMap";
  $desc = $collectedClasses._MessageTraverserVisitedMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _MessageTraverserVisitedMap.prototype = $desc;
  function _MessageTraverser() {
  }
  _MessageTraverser.builtin$cls = "_MessageTraverser";
  if (!"name" in _MessageTraverser)
    _MessageTraverser.name = "_MessageTraverser";
  $desc = $collectedClasses._MessageTraverser;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _MessageTraverser.prototype = $desc;
  function _Copier() {
  }
  _Copier.builtin$cls = "_Copier";
  if (!"name" in _Copier)
    _Copier.name = "_Copier";
  $desc = $collectedClasses._Copier;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Copier.prototype = $desc;
  function _Copier_visitMap_closure(box_0, this_1) {
    this.box_0 = box_0;
    this.this_1 = this_1;
  }
  _Copier_visitMap_closure.builtin$cls = "_Copier_visitMap_closure";
  if (!"name" in _Copier_visitMap_closure)
    _Copier_visitMap_closure.name = "_Copier_visitMap_closure";
  $desc = $collectedClasses._Copier_visitMap_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Copier_visitMap_closure.prototype = $desc;
  function _Serializer() {
  }
  _Serializer.builtin$cls = "_Serializer";
  if (!"name" in _Serializer)
    _Serializer.name = "_Serializer";
  $desc = $collectedClasses._Serializer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Serializer.prototype = $desc;
  function _Deserializer() {
  }
  _Deserializer.builtin$cls = "_Deserializer";
  if (!"name" in _Deserializer)
    _Deserializer.name = "_Deserializer";
  $desc = $collectedClasses._Deserializer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Deserializer.prototype = $desc;
  function TimerImpl(_once, _inEventLoop, _handle) {
    this._once = _once;
    this._inEventLoop = _inEventLoop;
    this._handle = _handle;
  }
  TimerImpl.builtin$cls = "TimerImpl";
  if (!"name" in TimerImpl)
    TimerImpl.name = "TimerImpl";
  $desc = $collectedClasses.TimerImpl;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TimerImpl.prototype = $desc;
  function TimerImpl_internalCallback(this_0, callback_1) {
    this.this_0 = this_0;
    this.callback_1 = callback_1;
  }
  TimerImpl_internalCallback.builtin$cls = "TimerImpl_internalCallback";
  if (!"name" in TimerImpl_internalCallback)
    TimerImpl_internalCallback.name = "TimerImpl_internalCallback";
  $desc = $collectedClasses.TimerImpl_internalCallback;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TimerImpl_internalCallback.prototype = $desc;
  function TimerImpl_internalCallback0(this_2, callback_3) {
    this.this_2 = this_2;
    this.callback_3 = callback_3;
  }
  TimerImpl_internalCallback0.builtin$cls = "TimerImpl_internalCallback0";
  if (!"name" in TimerImpl_internalCallback0)
    TimerImpl_internalCallback0.name = "TimerImpl_internalCallback0";
  $desc = $collectedClasses.TimerImpl_internalCallback0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TimerImpl_internalCallback0.prototype = $desc;
  function CapabilityImpl(_id) {
    this._id = _id;
  }
  CapabilityImpl.builtin$cls = "CapabilityImpl";
  if (!"name" in CapabilityImpl)
    CapabilityImpl.name = "CapabilityImpl";
  $desc = $collectedClasses.CapabilityImpl;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CapabilityImpl.prototype = $desc;
  CapabilityImpl.prototype.get$_id = function() {
    return this._id;
  };
  function ConstantMap() {
  }
  ConstantMap.builtin$cls = "ConstantMap";
  if (!"name" in ConstantMap)
    ConstantMap.name = "ConstantMap";
  $desc = $collectedClasses.ConstantMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ConstantMap.prototype = $desc;
  function ConstantStringMap(length, _jsObject, __js_helper$_keys) {
    this.length = length;
    this._jsObject = _jsObject;
    this.__js_helper$_keys = __js_helper$_keys;
  }
  ConstantStringMap.builtin$cls = "ConstantStringMap";
  if (!"name" in ConstantStringMap)
    ConstantStringMap.name = "ConstantStringMap";
  $desc = $collectedClasses.ConstantStringMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ConstantStringMap.prototype = $desc;
  ConstantStringMap.prototype.get$length = function(receiver) {
    return this.length;
  };
  function ConstantStringMap_values_closure(this_0) {
    this.this_0 = this_0;
  }
  ConstantStringMap_values_closure.builtin$cls = "ConstantStringMap_values_closure";
  if (!"name" in ConstantStringMap_values_closure)
    ConstantStringMap_values_closure.name = "ConstantStringMap_values_closure";
  $desc = $collectedClasses.ConstantStringMap_values_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ConstantStringMap_values_closure.prototype = $desc;
  function _ConstantMapKeyIterable(__js_helper$_map) {
    this.__js_helper$_map = __js_helper$_map;
  }
  _ConstantMapKeyIterable.builtin$cls = "_ConstantMapKeyIterable";
  if (!"name" in _ConstantMapKeyIterable)
    _ConstantMapKeyIterable.name = "_ConstantMapKeyIterable";
  $desc = $collectedClasses._ConstantMapKeyIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ConstantMapKeyIterable.prototype = $desc;
  function GeneralConstantMap(_jsData) {
    this._jsData = _jsData;
  }
  GeneralConstantMap.builtin$cls = "GeneralConstantMap";
  if (!"name" in GeneralConstantMap)
    GeneralConstantMap.name = "GeneralConstantMap";
  $desc = $collectedClasses.GeneralConstantMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GeneralConstantMap.prototype = $desc;
  function ReflectionInfo(jsFunction, data, isAccessor, requiredParameterCount, optionalParameterCount, areOptionalParametersNamed, functionType, cachedSortedIndices) {
    this.jsFunction = jsFunction;
    this.data = data;
    this.isAccessor = isAccessor;
    this.requiredParameterCount = requiredParameterCount;
    this.optionalParameterCount = optionalParameterCount;
    this.areOptionalParametersNamed = areOptionalParametersNamed;
    this.functionType = functionType;
    this.cachedSortedIndices = cachedSortedIndices;
  }
  ReflectionInfo.builtin$cls = "ReflectionInfo";
  if (!"name" in ReflectionInfo)
    ReflectionInfo.name = "ReflectionInfo";
  $desc = $collectedClasses.ReflectionInfo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ReflectionInfo.prototype = $desc;
  ReflectionInfo.prototype.get$data = function(receiver) {
    return this.data;
  };
  function TypeErrorDecoder(_pattern, _arguments, _argumentsExpr, _expr, _method, _receiver) {
    this._pattern = _pattern;
    this._arguments = _arguments;
    this._argumentsExpr = _argumentsExpr;
    this._expr = _expr;
    this._method = _method;
    this._receiver = _receiver;
  }
  TypeErrorDecoder.builtin$cls = "TypeErrorDecoder";
  if (!"name" in TypeErrorDecoder)
    TypeErrorDecoder.name = "TypeErrorDecoder";
  $desc = $collectedClasses.TypeErrorDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TypeErrorDecoder.prototype = $desc;
  function NullError(_message, _method) {
    this._message = _message;
    this._method = _method;
  }
  NullError.builtin$cls = "NullError";
  if (!"name" in NullError)
    NullError.name = "NullError";
  $desc = $collectedClasses.NullError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NullError.prototype = $desc;
  function JsNoSuchMethodError(_message, _method, _receiver) {
    this._message = _message;
    this._method = _method;
    this._receiver = _receiver;
  }
  JsNoSuchMethodError.builtin$cls = "JsNoSuchMethodError";
  if (!"name" in JsNoSuchMethodError)
    JsNoSuchMethodError.name = "JsNoSuchMethodError";
  $desc = $collectedClasses.JsNoSuchMethodError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JsNoSuchMethodError.prototype = $desc;
  function UnknownJsTypeError(_message) {
    this._message = _message;
  }
  UnknownJsTypeError.builtin$cls = "UnknownJsTypeError";
  if (!"name" in UnknownJsTypeError)
    UnknownJsTypeError.name = "UnknownJsTypeError";
  $desc = $collectedClasses.UnknownJsTypeError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UnknownJsTypeError.prototype = $desc;
  function unwrapException_saveStackTrace(ex_0) {
    this.ex_0 = ex_0;
  }
  unwrapException_saveStackTrace.builtin$cls = "unwrapException_saveStackTrace";
  if (!"name" in unwrapException_saveStackTrace)
    unwrapException_saveStackTrace.name = "unwrapException_saveStackTrace";
  $desc = $collectedClasses.unwrapException_saveStackTrace;
  if ($desc instanceof Array)
    $desc = $desc[1];
  unwrapException_saveStackTrace.prototype = $desc;
  function _StackTrace(_exception, _trace) {
    this._exception = _exception;
    this._trace = _trace;
  }
  _StackTrace.builtin$cls = "_StackTrace";
  if (!"name" in _StackTrace)
    _StackTrace.name = "_StackTrace";
  $desc = $collectedClasses._StackTrace;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _StackTrace.prototype = $desc;
  function invokeClosure_closure(closure_0) {
    this.closure_0 = closure_0;
  }
  invokeClosure_closure.builtin$cls = "invokeClosure_closure";
  if (!"name" in invokeClosure_closure)
    invokeClosure_closure.name = "invokeClosure_closure";
  $desc = $collectedClasses.invokeClosure_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  invokeClosure_closure.prototype = $desc;
  function invokeClosure_closure0(closure_1, arg1_2) {
    this.closure_1 = closure_1;
    this.arg1_2 = arg1_2;
  }
  invokeClosure_closure0.builtin$cls = "invokeClosure_closure0";
  if (!"name" in invokeClosure_closure0)
    invokeClosure_closure0.name = "invokeClosure_closure0";
  $desc = $collectedClasses.invokeClosure_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  invokeClosure_closure0.prototype = $desc;
  function invokeClosure_closure1(closure_3, arg1_4, arg2_5) {
    this.closure_3 = closure_3;
    this.arg1_4 = arg1_4;
    this.arg2_5 = arg2_5;
  }
  invokeClosure_closure1.builtin$cls = "invokeClosure_closure1";
  if (!"name" in invokeClosure_closure1)
    invokeClosure_closure1.name = "invokeClosure_closure1";
  $desc = $collectedClasses.invokeClosure_closure1;
  if ($desc instanceof Array)
    $desc = $desc[1];
  invokeClosure_closure1.prototype = $desc;
  function invokeClosure_closure2(closure_6, arg1_7, arg2_8, arg3_9) {
    this.closure_6 = closure_6;
    this.arg1_7 = arg1_7;
    this.arg2_8 = arg2_8;
    this.arg3_9 = arg3_9;
  }
  invokeClosure_closure2.builtin$cls = "invokeClosure_closure2";
  if (!"name" in invokeClosure_closure2)
    invokeClosure_closure2.name = "invokeClosure_closure2";
  $desc = $collectedClasses.invokeClosure_closure2;
  if ($desc instanceof Array)
    $desc = $desc[1];
  invokeClosure_closure2.prototype = $desc;
  function invokeClosure_closure3(closure_10, arg1_11, arg2_12, arg3_13, arg4_14) {
    this.closure_10 = closure_10;
    this.arg1_11 = arg1_11;
    this.arg2_12 = arg2_12;
    this.arg3_13 = arg3_13;
    this.arg4_14 = arg4_14;
  }
  invokeClosure_closure3.builtin$cls = "invokeClosure_closure3";
  if (!"name" in invokeClosure_closure3)
    invokeClosure_closure3.name = "invokeClosure_closure3";
  $desc = $collectedClasses.invokeClosure_closure3;
  if ($desc instanceof Array)
    $desc = $desc[1];
  invokeClosure_closure3.prototype = $desc;
  function Closure() {
  }
  Closure.builtin$cls = "Closure";
  if (!"name" in Closure)
    Closure.name = "Closure";
  $desc = $collectedClasses.Closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Closure.prototype = $desc;
  function TearOffClosure() {
  }
  TearOffClosure.builtin$cls = "TearOffClosure";
  if (!"name" in TearOffClosure)
    TearOffClosure.name = "TearOffClosure";
  $desc = $collectedClasses.TearOffClosure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TearOffClosure.prototype = $desc;
  function BoundClosure(_self, _target, _receiver, __js_helper$_name) {
    this._self = _self;
    this._target = _target;
    this._receiver = _receiver;
    this.__js_helper$_name = __js_helper$_name;
  }
  BoundClosure.builtin$cls = "BoundClosure";
  if (!"name" in BoundClosure)
    BoundClosure.name = "BoundClosure";
  $desc = $collectedClasses.BoundClosure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BoundClosure.prototype = $desc;
  function RuntimeError(message) {
    this.message = message;
  }
  RuntimeError.builtin$cls = "RuntimeError";
  if (!"name" in RuntimeError)
    RuntimeError.name = "RuntimeError";
  $desc = $collectedClasses.RuntimeError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RuntimeError.prototype = $desc;
  function RuntimeType() {
  }
  RuntimeType.builtin$cls = "RuntimeType";
  if (!"name" in RuntimeType)
    RuntimeType.name = "RuntimeType";
  $desc = $collectedClasses.RuntimeType;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RuntimeType.prototype = $desc;
  function RuntimeFunctionType(returnType, parameterTypes, optionalParameterTypes, namedParameters) {
    this.returnType = returnType;
    this.parameterTypes = parameterTypes;
    this.optionalParameterTypes = optionalParameterTypes;
    this.namedParameters = namedParameters;
  }
  RuntimeFunctionType.builtin$cls = "RuntimeFunctionType";
  if (!"name" in RuntimeFunctionType)
    RuntimeFunctionType.name = "RuntimeFunctionType";
  $desc = $collectedClasses.RuntimeFunctionType;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RuntimeFunctionType.prototype = $desc;
  function DynamicRuntimeType() {
  }
  DynamicRuntimeType.builtin$cls = "DynamicRuntimeType";
  if (!"name" in DynamicRuntimeType)
    DynamicRuntimeType.name = "DynamicRuntimeType";
  $desc = $collectedClasses.DynamicRuntimeType;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DynamicRuntimeType.prototype = $desc;
  function TypeImpl(_typeName, _unmangledName) {
    this._typeName = _typeName;
    this._unmangledName = _unmangledName;
  }
  TypeImpl.builtin$cls = "TypeImpl";
  if (!"name" in TypeImpl)
    TypeImpl.name = "TypeImpl";
  $desc = $collectedClasses.TypeImpl;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TypeImpl.prototype = $desc;
  function initHooks_closure(getTag_0) {
    this.getTag_0 = getTag_0;
  }
  initHooks_closure.builtin$cls = "initHooks_closure";
  if (!"name" in initHooks_closure)
    initHooks_closure.name = "initHooks_closure";
  $desc = $collectedClasses.initHooks_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  initHooks_closure.prototype = $desc;
  function initHooks_closure0(getUnknownTag_1) {
    this.getUnknownTag_1 = getUnknownTag_1;
  }
  initHooks_closure0.builtin$cls = "initHooks_closure0";
  if (!"name" in initHooks_closure0)
    initHooks_closure0.name = "initHooks_closure0";
  $desc = $collectedClasses.initHooks_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  initHooks_closure0.prototype = $desc;
  function initHooks_closure1(prototypeForTag_2) {
    this.prototypeForTag_2 = prototypeForTag_2;
  }
  initHooks_closure1.builtin$cls = "initHooks_closure1";
  if (!"name" in initHooks_closure1)
    initHooks_closure1.name = "initHooks_closure1";
  $desc = $collectedClasses.initHooks_closure1;
  if ($desc instanceof Array)
    $desc = $desc[1];
  initHooks_closure1.prototype = $desc;
  function BruteForceAccel(primitives, bounds, primitiveId) {
    this.primitives = primitives;
    this.bounds = bounds;
    this.primitiveId = primitiveId;
  }
  BruteForceAccel.builtin$cls = "BruteForceAccel";
  if (!"name" in BruteForceAccel)
    BruteForceAccel.name = "BruteForceAccel";
  $desc = $collectedClasses.BruteForceAccel;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BruteForceAccel.prototype = $desc;
  BruteForceAccel.prototype.get$bounds = function() {
    return this.bounds;
  };
  BruteForceAccel.prototype.set$bounds = function(v) {
    return this.bounds = v;
  };
  function BVHAccel(maxPrimsInNode, splitMethod, primitives, nodes, primitiveId) {
    this.maxPrimsInNode = maxPrimsInNode;
    this.splitMethod = splitMethod;
    this.primitives = primitives;
    this.nodes = nodes;
    this.primitiveId = primitiveId;
  }
  BVHAccel.builtin$cls = "BVHAccel";
  if (!"name" in BVHAccel)
    BVHAccel.name = "BVHAccel";
  $desc = $collectedClasses.BVHAccel;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BVHAccel.prototype = $desc;
  function BVHAccel__recursiveBuild_ComparePoints(dim_1) {
    this.dim_1 = dim_1;
  }
  BVHAccel__recursiveBuild_ComparePoints.builtin$cls = "BVHAccel__recursiveBuild_ComparePoints";
  if (!"name" in BVHAccel__recursiveBuild_ComparePoints)
    BVHAccel__recursiveBuild_ComparePoints.name = "BVHAccel__recursiveBuild_ComparePoints";
  $desc = $collectedClasses.BVHAccel__recursiveBuild_ComparePoints;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BVHAccel__recursiveBuild_ComparePoints.prototype = $desc;
  function BVHAccel__recursiveBuild_CompareToMid(dim_2, pmid_3) {
    this.dim_2 = dim_2;
    this.pmid_3 = pmid_3;
  }
  BVHAccel__recursiveBuild_CompareToMid.builtin$cls = "BVHAccel__recursiveBuild_CompareToMid";
  if (!"name" in BVHAccel__recursiveBuild_CompareToMid)
    BVHAccel__recursiveBuild_CompareToMid.name = "BVHAccel__recursiveBuild_CompareToMid";
  $desc = $collectedClasses.BVHAccel__recursiveBuild_CompareToMid;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BVHAccel__recursiveBuild_CompareToMid.prototype = $desc;
  function BVHAccel__recursiveBuild_CompareToBucket(box_0, dim_4, nBuckets_5) {
    this.box_0 = box_0;
    this.dim_4 = dim_4;
    this.nBuckets_5 = nBuckets_5;
  }
  BVHAccel__recursiveBuild_CompareToBucket.builtin$cls = "BVHAccel__recursiveBuild_CompareToBucket";
  if (!"name" in BVHAccel__recursiveBuild_CompareToBucket)
    BVHAccel__recursiveBuild_CompareToBucket.name = "BVHAccel__recursiveBuild_CompareToBucket";
  $desc = $collectedClasses.BVHAccel__recursiveBuild_CompareToBucket;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BVHAccel__recursiveBuild_CompareToBucket.prototype = $desc;
  function _BVHPrimitiveInfo(primitiveNumber, centroid, bounds) {
    this.primitiveNumber = primitiveNumber;
    this.centroid = centroid;
    this.bounds = bounds;
  }
  _BVHPrimitiveInfo.builtin$cls = "_BVHPrimitiveInfo";
  if (!"name" in _BVHPrimitiveInfo)
    _BVHPrimitiveInfo.name = "_BVHPrimitiveInfo";
  $desc = $collectedClasses._BVHPrimitiveInfo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BVHPrimitiveInfo.prototype = $desc;
  _BVHPrimitiveInfo.prototype.get$primitiveNumber = function() {
    return this.primitiveNumber;
  };
  _BVHPrimitiveInfo.prototype.get$centroid = function() {
    return this.centroid;
  };
  _BVHPrimitiveInfo.prototype.get$bounds = function() {
    return this.bounds;
  };
  _BVHPrimitiveInfo.prototype.set$bounds = function(v) {
    return this.bounds = v;
  };
  function _BVHBucketInfo(count, bounds) {
    this.count = count;
    this.bounds = bounds;
  }
  _BVHBucketInfo.builtin$cls = "_BVHBucketInfo";
  if (!"name" in _BVHBucketInfo)
    _BVHBucketInfo.name = "_BVHBucketInfo";
  $desc = $collectedClasses._BVHBucketInfo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BVHBucketInfo.prototype = $desc;
  _BVHBucketInfo.prototype.get$count = function() {
    return this.count;
  };
  _BVHBucketInfo.prototype.set$count = function(v) {
    return this.count = v;
  };
  _BVHBucketInfo.prototype.get$bounds = function() {
    return this.bounds;
  };
  _BVHBucketInfo.prototype.set$bounds = function(v) {
    return this.bounds = v;
  };
  function _BVHBuildNode(bounds, children, splitAxis, firstPrimOffset, nPrimitives) {
    this.bounds = bounds;
    this.children = children;
    this.splitAxis = splitAxis;
    this.firstPrimOffset = firstPrimOffset;
    this.nPrimitives = nPrimitives;
  }
  _BVHBuildNode.builtin$cls = "_BVHBuildNode";
  if (!"name" in _BVHBuildNode)
    _BVHBuildNode.name = "_BVHBuildNode";
  $desc = $collectedClasses._BVHBuildNode;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BVHBuildNode.prototype = $desc;
  _BVHBuildNode.prototype.get$bounds = function() {
    return this.bounds;
  };
  _BVHBuildNode.prototype.set$bounds = function(v) {
    return this.bounds = v;
  };
  _BVHBuildNode.prototype.get$children = function(receiver) {
    return this.children;
  };
  _BVHBuildNode.prototype.get$splitAxis = function() {
    return this.splitAxis;
  };
  _BVHBuildNode.prototype.get$firstPrimOffset = function() {
    return this.firstPrimOffset;
  };
  _BVHBuildNode.prototype.get$nPrimitives = function() {
    return this.nPrimitives;
  };
  function _LinearBVHNode(bounds, offset, nPrimitives, axis) {
    this.bounds = bounds;
    this.offset = offset;
    this.nPrimitives = nPrimitives;
    this.axis = axis;
  }
  _LinearBVHNode.builtin$cls = "_LinearBVHNode";
  if (!"name" in _LinearBVHNode)
    _LinearBVHNode.name = "_LinearBVHNode";
  $desc = $collectedClasses._LinearBVHNode;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _LinearBVHNode.prototype = $desc;
  _LinearBVHNode.prototype.get$bounds = function() {
    return this.bounds;
  };
  _LinearBVHNode.prototype.set$bounds = function(v) {
    return this.bounds = v;
  };
  _LinearBVHNode.prototype.get$offset = function(receiver) {
    return this.offset;
  };
  _LinearBVHNode.prototype.set$offset = function(receiver, v) {
    return this.offset = v;
  };
  _LinearBVHNode.prototype.get$nPrimitives = function() {
    return this.nPrimitives;
  };
  _LinearBVHNode.prototype.set$nPrimitives = function(v) {
    return this.nPrimitives = v;
  };
  _LinearBVHNode.prototype.get$axis = function() {
    return this.axis;
  };
  _LinearBVHNode.prototype.set$axis = function(v) {
    return this.axis = v;
  };
  function GridAccel(primitives, nVoxels, bounds, width, invWidth, voxels, primitiveId) {
    this.primitives = primitives;
    this.nVoxels = nVoxels;
    this.bounds = bounds;
    this.width = width;
    this.invWidth = invWidth;
    this.voxels = voxels;
    this.primitiveId = primitiveId;
  }
  GridAccel.builtin$cls = "GridAccel";
  if (!"name" in GridAccel)
    GridAccel.name = "GridAccel";
  $desc = $collectedClasses.GridAccel;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GridAccel.prototype = $desc;
  GridAccel.prototype.get$bounds = function() {
    return this.bounds;
  };
  GridAccel.prototype.set$bounds = function(v) {
    return this.bounds = v;
  };
  GridAccel.prototype.get$width = function(receiver) {
    return this.width;
  };
  function _Voxel(primitives, allCanIntersect) {
    this.primitives = primitives;
    this.allCanIntersect = allCanIntersect;
  }
  _Voxel.builtin$cls = "_Voxel";
  if (!"name" in _Voxel)
    _Voxel.name = "_Voxel";
  $desc = $collectedClasses._Voxel;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Voxel.prototype = $desc;
  function KdTreeAccel(isectCost, traversalCost, maxPrims, maxDepth, emptyBonus, primitives, nodes, nAllocedNodes, nextFreeNode, bounds, primitiveId) {
    this.isectCost = isectCost;
    this.traversalCost = traversalCost;
    this.maxPrims = maxPrims;
    this.maxDepth = maxDepth;
    this.emptyBonus = emptyBonus;
    this.primitives = primitives;
    this.nodes = nodes;
    this.nAllocedNodes = nAllocedNodes;
    this.nextFreeNode = nextFreeNode;
    this.bounds = bounds;
    this.primitiveId = primitiveId;
  }
  KdTreeAccel.builtin$cls = "KdTreeAccel";
  if (!"name" in KdTreeAccel)
    KdTreeAccel.name = "KdTreeAccel";
  $desc = $collectedClasses.KdTreeAccel;
  if ($desc instanceof Array)
    $desc = $desc[1];
  KdTreeAccel.prototype = $desc;
  KdTreeAccel.prototype.get$bounds = function() {
    return this.bounds;
  };
  KdTreeAccel.prototype.set$bounds = function(v) {
    return this.bounds = v;
  };
  function KdTreeAccel__buildTree_closure() {
  }
  KdTreeAccel__buildTree_closure.builtin$cls = "KdTreeAccel__buildTree_closure";
  if (!"name" in KdTreeAccel__buildTree_closure)
    KdTreeAccel__buildTree_closure.name = "KdTreeAccel__buildTree_closure";
  $desc = $collectedClasses.KdTreeAccel__buildTree_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  KdTreeAccel__buildTree_closure.prototype = $desc;
  function _KdToDo(node, nodeIndex, tmin, tmax) {
    this.node = node;
    this.nodeIndex = nodeIndex;
    this.tmin = tmin;
    this.tmax = tmax;
  }
  _KdToDo.builtin$cls = "_KdToDo";
  if (!"name" in _KdToDo)
    _KdToDo.name = "_KdToDo";
  $desc = $collectedClasses._KdToDo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _KdToDo.prototype = $desc;
  _KdToDo.prototype.get$node = function() {
    return this.node;
  };
  _KdToDo.prototype.set$node = function(v) {
    return this.node = v;
  };
  function _KdAccelNode(split, onePrimitive, primitives, flags) {
    this.split = split;
    this.onePrimitive = onePrimitive;
    this.primitives = primitives;
    this.flags = flags;
  }
  _KdAccelNode.builtin$cls = "_KdAccelNode";
  if (!"name" in _KdAccelNode)
    _KdAccelNode.name = "_KdAccelNode";
  $desc = $collectedClasses._KdAccelNode;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _KdAccelNode.prototype = $desc;
  function _BoundEdge(t, primNum, type) {
    this.t = t;
    this.primNum = primNum;
    this.type = type;
  }
  _BoundEdge.builtin$cls = "_BoundEdge";
  if (!"name" in _BoundEdge)
    _BoundEdge.name = "_BoundEdge";
  $desc = $collectedClasses._BoundEdge;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BoundEdge.prototype = $desc;
  _BoundEdge.prototype.get$t = function() {
    return this.t;
  };
  _BoundEdge.prototype.get$primNum = function() {
    return this.primNum;
  };
  _BoundEdge.prototype.get$type = function(receiver) {
    return this.type;
  };
  function ArchiveException(message) {
    this.message = message;
  }
  ArchiveException.builtin$cls = "ArchiveException";
  if (!"name" in ArchiveException)
    ArchiveException.name = "ArchiveException";
  $desc = $collectedClasses.ArchiveException;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ArchiveException.prototype = $desc;
  function InputStream(buffer, offset, start, byteOrder, _archive$_length) {
    this.buffer = buffer;
    this.offset = offset;
    this.start = start;
    this.byteOrder = byteOrder;
    this._archive$_length = _archive$_length;
  }
  InputStream.builtin$cls = "InputStream";
  if (!"name" in InputStream)
    InputStream.name = "InputStream";
  $desc = $collectedClasses.InputStream;
  if ($desc instanceof Array)
    $desc = $desc[1];
  InputStream.prototype = $desc;
  InputStream.prototype.get$buffer = function(receiver) {
    return this.buffer;
  };
  InputStream.prototype.get$offset = function(receiver) {
    return this.offset;
  };
  InputStream.prototype.set$offset = function(receiver, v) {
    return this.offset = v;
  };
  InputStream.prototype.get$start = function(receiver) {
    return this.start;
  };
  function OutputStream(length, byteOrder, _archive$_buffer) {
    this.length = length;
    this.byteOrder = byteOrder;
    this._archive$_buffer = _archive$_buffer;
  }
  OutputStream.builtin$cls = "OutputStream";
  if (!"name" in OutputStream)
    OutputStream.name = "OutputStream";
  $desc = $collectedClasses.OutputStream;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OutputStream.prototype = $desc;
  OutputStream.prototype.get$length = function(receiver) {
    return this.length;
  };
  OutputStream.prototype.set$length = function(receiver, v) {
    return this.length = v;
  };
  function HuffmanTable(table, maxCodeLength, minCodeLength) {
    this.table = table;
    this.maxCodeLength = maxCodeLength;
    this.minCodeLength = minCodeLength;
  }
  HuffmanTable.builtin$cls = "HuffmanTable";
  if (!"name" in HuffmanTable)
    HuffmanTable.name = "HuffmanTable";
  $desc = $collectedClasses.HuffmanTable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HuffmanTable.prototype = $desc;
  function Inflate(input, output, _bitBuffer, _bitBufferLen, _blockPos, _fixedLiteralLengthTable, _fixedDistanceTable) {
    this.input = input;
    this.output = output;
    this._bitBuffer = _bitBuffer;
    this._bitBufferLen = _bitBufferLen;
    this._blockPos = _blockPos;
    this._fixedLiteralLengthTable = _fixedLiteralLengthTable;
    this._fixedDistanceTable = _fixedDistanceTable;
  }
  Inflate.builtin$cls = "Inflate";
  if (!"name" in Inflate)
    Inflate.name = "Inflate";
  $desc = $collectedClasses.Inflate;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Inflate.prototype = $desc;
  function ZLibDecoder() {
  }
  ZLibDecoder.builtin$cls = "ZLibDecoder";
  if (!"name" in ZLibDecoder)
    ZLibDecoder.name = "ZLibDecoder";
  $desc = $collectedClasses.ZLibDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ZLibDecoder.prototype = $desc;
  function EnvironmentCamera(cameraToWorld, shutterOpen, shutterClose, film) {
    this.cameraToWorld = cameraToWorld;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
    this.film = film;
  }
  EnvironmentCamera.builtin$cls = "EnvironmentCamera";
  if (!"name" in EnvironmentCamera)
    EnvironmentCamera.name = "EnvironmentCamera";
  $desc = $collectedClasses.EnvironmentCamera;
  if ($desc instanceof Array)
    $desc = $desc[1];
  EnvironmentCamera.prototype = $desc;
  function OrthographicCamera(dxCamera, dyCamera, cameraToScreen, rasterToCamera, screenToRaster, rasterToScreen, lensRadius, focalDistance, cameraToWorld, shutterOpen, shutterClose, film) {
    this.dxCamera = dxCamera;
    this.dyCamera = dyCamera;
    this.cameraToScreen = cameraToScreen;
    this.rasterToCamera = rasterToCamera;
    this.screenToRaster = screenToRaster;
    this.rasterToScreen = rasterToScreen;
    this.lensRadius = lensRadius;
    this.focalDistance = focalDistance;
    this.cameraToWorld = cameraToWorld;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
    this.film = film;
  }
  OrthographicCamera.builtin$cls = "OrthographicCamera";
  if (!"name" in OrthographicCamera)
    OrthographicCamera.name = "OrthographicCamera";
  $desc = $collectedClasses.OrthographicCamera;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OrthographicCamera.prototype = $desc;
  function PerspectiveCamera(dxCamera, dyCamera, cameraToScreen, rasterToCamera, screenToRaster, rasterToScreen, lensRadius, focalDistance, cameraToWorld, shutterOpen, shutterClose, film) {
    this.dxCamera = dxCamera;
    this.dyCamera = dyCamera;
    this.cameraToScreen = cameraToScreen;
    this.rasterToCamera = rasterToCamera;
    this.screenToRaster = screenToRaster;
    this.rasterToScreen = rasterToScreen;
    this.lensRadius = lensRadius;
    this.focalDistance = focalDistance;
    this.cameraToWorld = cameraToWorld;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
    this.film = film;
  }
  PerspectiveCamera.builtin$cls = "PerspectiveCamera";
  if (!"name" in PerspectiveCamera)
    PerspectiveCamera.name = "PerspectiveCamera";
  $desc = $collectedClasses.PerspectiveCamera;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PerspectiveCamera.prototype = $desc;
  function AnimatedTransform(startTime, endTime, startTransform, endTransform, actuallyAnimated, T, R, S) {
    this.startTime = startTime;
    this.endTime = endTime;
    this.startTransform = startTransform;
    this.endTransform = endTransform;
    this.actuallyAnimated = actuallyAnimated;
    this.T = T;
    this.R = R;
    this.S = S;
  }
  AnimatedTransform.builtin$cls = "AnimatedTransform";
  if (!"name" in AnimatedTransform)
    AnimatedTransform.name = "AnimatedTransform";
  $desc = $collectedClasses.AnimatedTransform;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AnimatedTransform.prototype = $desc;
  function BBox(pMin, pMax) {
    this.pMin = pMin;
    this.pMax = pMax;
  }
  BBox.builtin$cls = "BBox";
  if (!"name" in BBox)
    BBox.name = "BBox";
  $desc = $collectedClasses.BBox;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BBox.prototype = $desc;
  BBox.prototype.get$pMin = function() {
    return this.pMin;
  };
  function Camera(shutterOpen, shutterClose, film) {
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
    this.film = film;
  }
  Camera.builtin$cls = "Camera";
  if (!"name" in Camera)
    Camera.name = "Camera";
  $desc = $collectedClasses.Camera;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Camera.prototype = $desc;
  Camera.prototype.get$shutterOpen = function() {
    return this.shutterOpen;
  };
  Camera.prototype.get$shutterClose = function() {
    return this.shutterClose;
  };
  Camera.prototype.get$film = function() {
    return this.film;
  };
  function CameraSample(imageX, imageY, lensU, lensV, time) {
    this.imageX = imageX;
    this.imageY = imageY;
    this.lensU = lensU;
    this.lensV = lensV;
    this.time = time;
  }
  CameraSample.builtin$cls = "CameraSample";
  if (!"name" in CameraSample)
    CameraSample.name = "CameraSample";
  $desc = $collectedClasses.CameraSample;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CameraSample.prototype = $desc;
  CameraSample.prototype.get$imageX = function() {
    return this.imageX;
  };
  CameraSample.prototype.set$imageX = function(v) {
    return this.imageX = v;
  };
  CameraSample.prototype.get$imageY = function() {
    return this.imageY;
  };
  CameraSample.prototype.set$imageY = function(v) {
    return this.imageY = v;
  };
  CameraSample.prototype.set$lensU = function(v) {
    return this.lensU = v;
  };
  CameraSample.prototype.set$lensV = function(v) {
    return this.lensV = v;
  };
  CameraSample.prototype.get$time = function() {
    return this.time;
  };
  CameraSample.prototype.set$time = function(v) {
    return this.time = v;
  };
  function nth_element_closure(pred_0) {
    this.pred_0 = pred_0;
  }
  nth_element_closure.builtin$cls = "nth_element_closure";
  if (!"name" in nth_element_closure)
    nth_element_closure.name = "nth_element_closure";
  $desc = $collectedClasses.nth_element_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  nth_element_closure.prototype = $desc;
  function DifferentialGeometry(p, nn, u, v, shape, dpdu, dpdv, dndu, dndv, dpdx, dpdy, dudx, dvdx, dudy, dvdy) {
    this.p = p;
    this.nn = nn;
    this.u = u;
    this.v = v;
    this.shape = shape;
    this.dpdu = dpdu;
    this.dpdv = dpdv;
    this.dndu = dndu;
    this.dndv = dndv;
    this.dpdx = dpdx;
    this.dpdy = dpdy;
    this.dudx = dudx;
    this.dvdx = dvdx;
    this.dudy = dudy;
    this.dvdy = dvdy;
  }
  DifferentialGeometry.builtin$cls = "DifferentialGeometry";
  if (!"name" in DifferentialGeometry)
    DifferentialGeometry.name = "DifferentialGeometry";
  $desc = $collectedClasses.DifferentialGeometry;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DifferentialGeometry.prototype = $desc;
  DifferentialGeometry.prototype.get$p = function(receiver) {
    return this.p;
  };
  DifferentialGeometry.prototype.get$nn = function() {
    return this.nn;
  };
  DifferentialGeometry.prototype.get$u = function() {
    return this.u;
  };
  DifferentialGeometry.prototype.get$v = function() {
    return this.v;
  };
  function Film(xResolution) {
    this.xResolution = xResolution;
  }
  Film.builtin$cls = "Film";
  if (!"name" in Film)
    Film.name = "Film";
  $desc = $collectedClasses.Film;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Film.prototype = $desc;
  Film.prototype.get$xResolution = function() {
    return this.xResolution;
  };
  function Filter(xWidth, yWidth, invXWidth, invYWidth) {
    this.xWidth = xWidth;
    this.yWidth = yWidth;
    this.invXWidth = invXWidth;
    this.invYWidth = invYWidth;
  }
  Filter.builtin$cls = "Filter";
  if (!"name" in Filter)
    Filter.name = "Filter";
  $desc = $collectedClasses.Filter;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Filter.prototype = $desc;
  Filter.prototype.get$xWidth = function() {
    return this.xWidth;
  };
  Filter.prototype.get$yWidth = function() {
    return this.yWidth;
  };
  Filter.prototype.get$invXWidth = function() {
    return this.invXWidth;
  };
  Filter.prototype.get$invYWidth = function() {
    return this.invYWidth;
  };
  function ImageSampler() {
  }
  ImageSampler.builtin$cls = "ImageSampler";
  if (!"name" in ImageSampler)
    ImageSampler.name = "ImageSampler";
  $desc = $collectedClasses.ImageSampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ImageSampler.prototype = $desc;
  function Integrator() {
  }
  Integrator.builtin$cls = "Integrator";
  if (!"name" in Integrator)
    Integrator.name = "Integrator";
  $desc = $collectedClasses.Integrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Integrator.prototype = $desc;
  function Intersection(dg, primitive, worldToObject, objectToWorld, shapeId, primitiveId, rayEpsilon) {
    this.dg = dg;
    this.primitive = primitive;
    this.worldToObject = worldToObject;
    this.objectToWorld = objectToWorld;
    this.shapeId = shapeId;
    this.primitiveId = primitiveId;
    this.rayEpsilon = rayEpsilon;
  }
  Intersection.builtin$cls = "Intersection";
  if (!"name" in Intersection)
    Intersection.name = "Intersection";
  $desc = $collectedClasses.Intersection;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Intersection.prototype = $desc;
  Intersection.prototype.get$dg = function() {
    return this.dg;
  };
  Intersection.prototype.get$worldToObject = function() {
    return this.worldToObject;
  };
  Intersection.prototype.get$objectToWorld = function() {
    return this.objectToWorld;
  };
  Intersection.prototype.get$shapeId = function() {
    return this.shapeId;
  };
  Intersection.prototype.get$primitiveId = function() {
    return this.primitiveId;
  };
  Intersection.prototype.set$primitiveId = function(v) {
    return this.primitiveId = v;
  };
  function KdTree(nodes, nodeData, nNodes, nextFreeNode) {
    this.nodes = nodes;
    this.nodeData = nodeData;
    this.nNodes = nNodes;
    this.nextFreeNode = nextFreeNode;
  }
  KdTree.builtin$cls = "KdTree";
  if (!"name" in KdTree)
    KdTree.name = "KdTree";
  $desc = $collectedClasses.KdTree;
  if ($desc instanceof Array)
    $desc = $desc[1];
  KdTree.prototype = $desc;
  function _CompareNode(data, axis) {
    this.data = data;
    this.axis = axis;
  }
  _CompareNode.builtin$cls = "_CompareNode";
  if (!"name" in _CompareNode)
    _CompareNode.name = "_CompareNode";
  $desc = $collectedClasses._CompareNode;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _CompareNode.prototype = $desc;
  _CompareNode.prototype.get$data = function(receiver) {
    return this.data;
  };
  _CompareNode.prototype.set$axis = function(v) {
    return this.axis = v;
  };
  function _KdNode(splitPos, splitAxis, hasLeftChild, rightChild) {
    this.splitPos = splitPos;
    this.splitAxis = splitAxis;
    this.hasLeftChild = hasLeftChild;
    this.rightChild = rightChild;
  }
  _KdNode.builtin$cls = "_KdNode";
  if (!"name" in _KdNode)
    _KdNode.name = "_KdNode";
  $desc = $collectedClasses._KdNode;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _KdNode.prototype = $desc;
  _KdNode.prototype.get$splitPos = function() {
    return this.splitPos;
  };
  _KdNode.prototype.get$splitAxis = function() {
    return this.splitAxis;
  };
  _KdNode.prototype.get$hasLeftChild = function() {
    return this.hasLeftChild;
  };
  _KdNode.prototype.set$hasLeftChild = function(v) {
    return this.hasLeftChild = v;
  };
  _KdNode.prototype.get$rightChild = function() {
    return this.rightChild;
  };
  _KdNode.prototype.set$rightChild = function(v) {
    return this.rightChild = v;
  };
  function AreaLight() {
  }
  AreaLight.builtin$cls = "AreaLight";
  if (!"name" in AreaLight)
    AreaLight.name = "AreaLight";
  $desc = $collectedClasses.AreaLight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AreaLight.prototype = $desc;
  function Light(nSamples) {
    this.nSamples = nSamples;
  }
  Light.builtin$cls = "Light";
  if (!"name" in Light)
    Light.name = "Light";
  $desc = $collectedClasses.Light;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Light.prototype = $desc;
  Light.prototype.get$nSamples = function() {
    return this.nSamples;
  };
  function LightSample(uPos, uComponent) {
    this.uPos = uPos;
    this.uComponent = uComponent;
  }
  LightSample.builtin$cls = "LightSample";
  if (!"name" in LightSample)
    LightSample.name = "LightSample";
  $desc = $collectedClasses.LightSample;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LightSample.prototype = $desc;
  LightSample.prototype.get$uPos = function() {
    return this.uPos;
  };
  LightSample.prototype.get$uComponent = function() {
    return this.uComponent;
  };
  function LightSampleOffsets(nSamples, componentOffset, posOffset) {
    this.nSamples = nSamples;
    this.componentOffset = componentOffset;
    this.posOffset = posOffset;
  }
  LightSampleOffsets.builtin$cls = "LightSampleOffsets";
  if (!"name" in LightSampleOffsets)
    LightSampleOffsets.name = "LightSampleOffsets";
  $desc = $collectedClasses.LightSampleOffsets;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LightSampleOffsets.prototype = $desc;
  LightSampleOffsets.prototype.get$nSamples = function() {
    return this.nSamples;
  };
  LightSampleOffsets.prototype.get$posOffset = function() {
    return this.posOffset;
  };
  function ShapeSet(shapes, area, areas, areaDistribution) {
    this.shapes = shapes;
    this.area = area;
    this.areas = areas;
    this.areaDistribution = areaDistribution;
  }
  ShapeSet.builtin$cls = "ShapeSet";
  if (!"name" in ShapeSet)
    ShapeSet.name = "ShapeSet";
  $desc = $collectedClasses.ShapeSet;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ShapeSet.prototype = $desc;
  function VisibilityTester(r) {
    this.r = r;
  }
  VisibilityTester.builtin$cls = "VisibilityTester";
  if (!"name" in VisibilityTester)
    VisibilityTester.name = "VisibilityTester";
  $desc = $collectedClasses.VisibilityTester;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VisibilityTester.prototype = $desc;
  function Material() {
  }
  Material.builtin$cls = "Material";
  if (!"name" in Material)
    Material.name = "Material";
  $desc = $collectedClasses.Material;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Material.prototype = $desc;
  function Matrix4x4(m) {
    this.m = m;
  }
  Matrix4x4.builtin$cls = "Matrix4x4";
  if (!"name" in Matrix4x4)
    Matrix4x4.name = "Matrix4x4";
  $desc = $collectedClasses.Matrix4x4;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Matrix4x4.prototype = $desc;
  Matrix4x4.prototype.get$m = function() {
    return this.m;
  };
  function MIPMap(doTrilinear, maxAnisotropy, wrapMode, pyramid, width, height, levels) {
    this.doTrilinear = doTrilinear;
    this.maxAnisotropy = maxAnisotropy;
    this.wrapMode = wrapMode;
    this.pyramid = pyramid;
    this.width = width;
    this.height = height;
    this.levels = levels;
  }
  MIPMap.builtin$cls = "MIPMap";
  if (!"name" in MIPMap)
    MIPMap.name = "MIPMap";
  $desc = $collectedClasses.MIPMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MIPMap.prototype = $desc;
  MIPMap.prototype.get$width = function(receiver) {
    return this.width;
  };
  MIPMap.prototype.get$height = function(receiver) {
    return this.height;
  };
  function _ResampleWeight(firstTexel, weight) {
    this.firstTexel = firstTexel;
    this.weight = weight;
  }
  _ResampleWeight.builtin$cls = "_ResampleWeight";
  if (!"name" in _ResampleWeight)
    _ResampleWeight.name = "_ResampleWeight";
  $desc = $collectedClasses._ResampleWeight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ResampleWeight.prototype = $desc;
  _ResampleWeight.prototype.get$firstTexel = function() {
    return this.firstTexel;
  };
  _ResampleWeight.prototype.get$weight = function() {
    return this.weight;
  };
  function Distribution1D(func, cdf, funcInt, count) {
    this.func = func;
    this.cdf = cdf;
    this.funcInt = funcInt;
    this.count = count;
  }
  Distribution1D.builtin$cls = "Distribution1D";
  if (!"name" in Distribution1D)
    Distribution1D.name = "Distribution1D";
  $desc = $collectedClasses.Distribution1D;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Distribution1D.prototype = $desc;
  Distribution1D.prototype.get$funcInt = function() {
    return this.funcInt;
  };
  Distribution1D.prototype.get$count = function() {
    return this.count;
  };
  Distribution1D.prototype.set$count = function(v) {
    return this.count = v;
  };
  function Distribution2D(pConditionalV, pMarginal) {
    this.pConditionalV = pConditionalV;
    this.pMarginal = pMarginal;
  }
  Distribution2D.builtin$cls = "Distribution2D";
  if (!"name" in Distribution2D)
    Distribution2D.name = "Distribution2D";
  $desc = $collectedClasses.Distribution2D;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Distribution2D.prototype = $desc;
  function PermutedHalton(dims, b, permute) {
    this.dims = dims;
    this.b = b;
    this.permute = permute;
  }
  PermutedHalton.builtin$cls = "PermutedHalton";
  if (!"name" in PermutedHalton)
    PermutedHalton.name = "PermutedHalton";
  $desc = $collectedClasses.PermutedHalton;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PermutedHalton.prototype = $desc;
  function Normal(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  Normal.builtin$cls = "Normal";
  if (!"name" in Normal)
    Normal.name = "Normal";
  $desc = $collectedClasses.Normal;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Normal.prototype = $desc;
  function Octree(maxDepth, bound, root) {
    this.maxDepth = maxDepth;
    this.bound = bound;
    this.root = root;
  }
  Octree.builtin$cls = "Octree";
  if (!"name" in Octree)
    Octree.name = "Octree";
  $desc = $collectedClasses.Octree;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Octree.prototype = $desc;
  function _OctreeNode(children, data) {
    this.children = children;
    this.data = data;
  }
  _OctreeNode.builtin$cls = "_OctreeNode";
  if (!"name" in _OctreeNode)
    _OctreeNode.name = "_OctreeNode";
  $desc = $collectedClasses._OctreeNode;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _OctreeNode.prototype = $desc;
  _OctreeNode.prototype.get$children = function(receiver) {
    return this.children;
  };
  _OctreeNode.prototype.get$data = function(receiver) {
    return this.data;
  };
  function OutputImage(width, height, xOffset, yOffset, rgb) {
    this.width = width;
    this.height = height;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
    this.rgb = rgb;
  }
  OutputImage.builtin$cls = "OutputImage";
  if (!"name" in OutputImage)
    OutputImage.name = "OutputImage";
  $desc = $collectedClasses.OutputImage;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OutputImage.prototype = $desc;
  OutputImage.prototype.get$width = function(receiver) {
    return this.width;
  };
  OutputImage.prototype.get$height = function(receiver) {
    return this.height;
  };
  OutputImage.prototype.get$rgb = function() {
    return this.rgb;
  };
  function ParamSet(bools, ints, floats, points, vectors, normals, spectra, strings, textures) {
    this.bools = bools;
    this.ints = ints;
    this.floats = floats;
    this.points = points;
    this.vectors = vectors;
    this.normals = normals;
    this.spectra = spectra;
    this.strings = strings;
    this.textures = textures;
  }
  ParamSet.builtin$cls = "ParamSet";
  if (!"name" in ParamSet)
    ParamSet.name = "ParamSet";
  $desc = $collectedClasses.ParamSet;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ParamSet.prototype = $desc;
  ParamSet.prototype.get$bools = function() {
    return this.bools;
  };
  function ParamSet_addSpectrumFiles_closure(box_0, this_1, s_2, path_3, sc_4) {
    this.box_0 = box_0;
    this.this_1 = this_1;
    this.s_2 = s_2;
    this.path_3 = path_3;
    this.sc_4 = sc_4;
  }
  ParamSet_addSpectrumFiles_closure.builtin$cls = "ParamSet_addSpectrumFiles_closure";
  if (!"name" in ParamSet_addSpectrumFiles_closure)
    ParamSet_addSpectrumFiles_closure.name = "ParamSet_addSpectrumFiles_closure";
  $desc = $collectedClasses.ParamSet_addSpectrumFiles_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ParamSet_addSpectrumFiles_closure.prototype = $desc;
  function ParamSet_addSpectrumFiles_closure0(this_5, name_6, s_7, c_8) {
    this.this_5 = this_5;
    this.name_6 = name_6;
    this.s_7 = s_7;
    this.c_8 = c_8;
  }
  ParamSet_addSpectrumFiles_closure0.builtin$cls = "ParamSet_addSpectrumFiles_closure0";
  if (!"name" in ParamSet_addSpectrumFiles_closure0)
    ParamSet_addSpectrumFiles_closure0.name = "ParamSet_addSpectrumFiles_closure0";
  $desc = $collectedClasses.ParamSet_addSpectrumFiles_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ParamSet_addSpectrumFiles_closure0.prototype = $desc;
  function ParamSet__readFloatFile__isdigit(ZERO_0, NINE_1) {
    this.ZERO_0 = ZERO_0;
    this.NINE_1 = NINE_1;
  }
  ParamSet__readFloatFile__isdigit.builtin$cls = "ParamSet__readFloatFile__isdigit";
  if (!"name" in ParamSet__readFloatFile__isdigit)
    ParamSet__readFloatFile__isdigit.name = "ParamSet__readFloatFile__isdigit";
  $desc = $collectedClasses.ParamSet__readFloatFile__isdigit;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ParamSet__readFloatFile__isdigit.prototype = $desc;
  function ParamSet__readFloatFile__isspace() {
  }
  ParamSet__readFloatFile__isspace.builtin$cls = "ParamSet__readFloatFile__isspace";
  if (!"name" in ParamSet__readFloatFile__isspace)
    ParamSet__readFloatFile__isspace.name = "ParamSet__readFloatFile__isspace";
  $desc = $collectedClasses.ParamSet__readFloatFile__isspace;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ParamSet__readFloatFile__isspace.prototype = $desc;
  function ParamSetItem(name, data, lookedUp) {
    this.name = name;
    this.data = data;
    this.lookedUp = lookedUp;
  }
  ParamSetItem.builtin$cls = "ParamSetItem";
  if (!"name" in ParamSetItem)
    ParamSetItem.name = "ParamSetItem";
  $desc = $collectedClasses.ParamSetItem;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ParamSetItem.prototype = $desc;
  ParamSetItem.prototype.get$name = function(receiver) {
    return this.name;
  };
  ParamSetItem.prototype.get$data = function(receiver) {
    return this.data;
  };
  ParamSetItem.prototype.get$lookedUp = function() {
    return this.lookedUp;
  };
  ParamSetItem.prototype.set$lookedUp = function(v) {
    return this.lookedUp = v;
  };
  function Point(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  Point.builtin$cls = "Point";
  if (!"name" in Point)
    Point.name = "Point";
  $desc = $collectedClasses.Point;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Point.prototype = $desc;
  function Aggregate() {
  }
  Aggregate.builtin$cls = "Aggregate";
  if (!"name" in Aggregate)
    Aggregate.name = "Aggregate";
  $desc = $collectedClasses.Aggregate;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Aggregate.prototype = $desc;
  function GeometricPrimitive(shape, material, areaLight, primitiveId) {
    this.shape = shape;
    this.material = material;
    this.areaLight = areaLight;
    this.primitiveId = primitiveId;
  }
  GeometricPrimitive.builtin$cls = "GeometricPrimitive";
  if (!"name" in GeometricPrimitive)
    GeometricPrimitive.name = "GeometricPrimitive";
  $desc = $collectedClasses.GeometricPrimitive;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GeometricPrimitive.prototype = $desc;
  GeometricPrimitive.prototype.get$material = function() {
    return this.material;
  };
  GeometricPrimitive.prototype.set$material = function(v) {
    return this.material = v;
  };
  GeometricPrimitive.prototype.get$areaLight = function() {
    return this.areaLight;
  };
  GeometricPrimitive.prototype.set$areaLight = function(v) {
    return this.areaLight = v;
  };
  function Primitive() {
  }
  Primitive.builtin$cls = "Primitive";
  if (!"name" in Primitive)
    Primitive.name = "Primitive";
  $desc = $collectedClasses.Primitive;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Primitive.prototype = $desc;
  function TransformedPrimitive(primitive, worldToPrimitive, primitiveId) {
    this.primitive = primitive;
    this.worldToPrimitive = worldToPrimitive;
    this.primitiveId = primitiveId;
  }
  TransformedPrimitive.builtin$cls = "TransformedPrimitive";
  if (!"name" in TransformedPrimitive)
    TransformedPrimitive.name = "TransformedPrimitive";
  $desc = $collectedClasses.TransformedPrimitive;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TransformedPrimitive.prototype = $desc;
  function ProjectiveCamera() {
  }
  ProjectiveCamera.builtin$cls = "ProjectiveCamera";
  if (!"name" in ProjectiveCamera)
    ProjectiveCamera.name = "ProjectiveCamera";
  $desc = $collectedClasses.ProjectiveCamera;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ProjectiveCamera.prototype = $desc;
  function Quaternion(v, w) {
    this.v = v;
    this.w = w;
  }
  Quaternion.builtin$cls = "Quaternion";
  if (!"name" in Quaternion)
    Quaternion.name = "Quaternion";
  $desc = $collectedClasses.Quaternion;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Quaternion.prototype = $desc;
  Quaternion.prototype.get$v = function() {
    return this.v;
  };
  Quaternion.prototype.get$w = function() {
    return this.w;
  };
  function Ray(origin, direction, minDistance, maxDistance, time, depth) {
    this.origin = origin;
    this.direction = direction;
    this.minDistance = minDistance;
    this.maxDistance = maxDistance;
    this.time = time;
    this.depth = depth;
  }
  Ray.builtin$cls = "Ray";
  if (!"name" in Ray)
    Ray.name = "Ray";
  $desc = $collectedClasses.Ray;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Ray.prototype = $desc;
  Ray.prototype.get$origin = function(receiver) {
    return this.origin;
  };
  Ray.prototype.set$origin = function(receiver, v) {
    return this.origin = v;
  };
  Ray.prototype.get$direction = function() {
    return this.direction;
  };
  Ray.prototype.get$minDistance = function() {
    return this.minDistance;
  };
  Ray.prototype.set$maxDistance = function(v) {
    return this.maxDistance = v;
  };
  Ray.prototype.get$time = function() {
    return this.time;
  };
  Ray.prototype.set$time = function(v) {
    return this.time = v;
  };
  function RayDifferential(hasDifferentials, rxOrigin, ryOrigin, rxDirection, ryDirection, origin, direction, minDistance, maxDistance, time, depth) {
    this.hasDifferentials = hasDifferentials;
    this.rxOrigin = rxOrigin;
    this.ryOrigin = ryOrigin;
    this.rxDirection = rxDirection;
    this.ryDirection = ryDirection;
    this.origin = origin;
    this.direction = direction;
    this.minDistance = minDistance;
    this.maxDistance = maxDistance;
    this.time = time;
    this.depth = depth;
  }
  RayDifferential.builtin$cls = "RayDifferential";
  if (!"name" in RayDifferential)
    RayDifferential.name = "RayDifferential";
  $desc = $collectedClasses.RayDifferential;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RayDifferential.prototype = $desc;
  RayDifferential.prototype.get$hasDifferentials = function() {
    return this.hasDifferentials;
  };
  RayDifferential.prototype.set$rxOrigin = function(v) {
    return this.rxOrigin = v;
  };
  function Anisotropic(ex, ey) {
    this.ex = ex;
    this.ey = ey;
  }
  Anisotropic.builtin$cls = "Anisotropic";
  if (!"name" in Anisotropic)
    Anisotropic.name = "Anisotropic";
  $desc = $collectedClasses.Anisotropic;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Anisotropic.prototype = $desc;
  function Blinn(exponent) {
    this.exponent = exponent;
  }
  Blinn.builtin$cls = "Blinn";
  if (!"name" in Blinn)
    Blinn.name = "Blinn";
  $desc = $collectedClasses.Blinn;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Blinn.prototype = $desc;
  function BRDFToBTDF(brdf, type) {
    this.brdf = brdf;
    this.type = type;
  }
  BRDFToBTDF.builtin$cls = "BRDFToBTDF";
  if (!"name" in BRDFToBTDF)
    BRDFToBTDF.name = "BRDFToBTDF";
  $desc = $collectedClasses.BRDFToBTDF;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BRDFToBTDF.prototype = $desc;
  function BSDF(dgShading, eta, nn, ng, sn, tn, nBxDFs, bxdfs) {
    this.dgShading = dgShading;
    this.eta = eta;
    this.nn = nn;
    this.ng = ng;
    this.sn = sn;
    this.tn = tn;
    this.nBxDFs = nBxDFs;
    this.bxdfs = bxdfs;
  }
  BSDF.builtin$cls = "BSDF";
  if (!"name" in BSDF)
    BSDF.name = "BSDF";
  $desc = $collectedClasses.BSDF;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BSDF.prototype = $desc;
  BSDF.prototype.get$nn = function() {
    return this.nn;
  };
  function BSDFSample(uDir, uComponent) {
    this.uDir = uDir;
    this.uComponent = uComponent;
  }
  BSDFSample.builtin$cls = "BSDFSample";
  if (!"name" in BSDFSample)
    BSDFSample.name = "BSDFSample";
  $desc = $collectedClasses.BSDFSample;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BSDFSample.prototype = $desc;
  BSDFSample.prototype.get$uDir = function() {
    return this.uDir;
  };
  BSDFSample.prototype.get$uComponent = function() {
    return this.uComponent;
  };
  function BSDFSampleOffsets(nSamples, componentOffset, dirOffset) {
    this.nSamples = nSamples;
    this.componentOffset = componentOffset;
    this.dirOffset = dirOffset;
  }
  BSDFSampleOffsets.builtin$cls = "BSDFSampleOffsets";
  if (!"name" in BSDFSampleOffsets)
    BSDFSampleOffsets.name = "BSDFSampleOffsets";
  $desc = $collectedClasses.BSDFSampleOffsets;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BSDFSampleOffsets.prototype = $desc;
  BSDFSampleOffsets.prototype.get$nSamples = function() {
    return this.nSamples;
  };
  BSDFSampleOffsets.prototype.get$dirOffset = function() {
    return this.dirOffset;
  };
  function BxDF(type) {
    this.type = type;
  }
  BxDF.builtin$cls = "BxDF";
  if (!"name" in BxDF)
    BxDF.name = "BxDF";
  $desc = $collectedClasses.BxDF;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BxDF.prototype = $desc;
  BxDF.prototype.get$type = function(receiver) {
    return this.type;
  };
  function Fresnel() {
  }
  Fresnel.builtin$cls = "Fresnel";
  if (!"name" in Fresnel)
    Fresnel.name = "Fresnel";
  $desc = $collectedClasses.Fresnel;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Fresnel.prototype = $desc;
  function FresnelBlend(Rd, Rs, distribution, type) {
    this.Rd = Rd;
    this.Rs = Rs;
    this.distribution = distribution;
    this.type = type;
  }
  FresnelBlend.builtin$cls = "FresnelBlend";
  if (!"name" in FresnelBlend)
    FresnelBlend.name = "FresnelBlend";
  $desc = $collectedClasses.FresnelBlend;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FresnelBlend.prototype = $desc;
  function FresnelConductor(eta, k) {
    this.eta = eta;
    this.k = k;
  }
  FresnelConductor.builtin$cls = "FresnelConductor";
  if (!"name" in FresnelConductor)
    FresnelConductor.name = "FresnelConductor";
  $desc = $collectedClasses.FresnelConductor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FresnelConductor.prototype = $desc;
  function FresnelDielectric(eta_i, eta_t) {
    this.eta_i = eta_i;
    this.eta_t = eta_t;
  }
  FresnelDielectric.builtin$cls = "FresnelDielectric";
  if (!"name" in FresnelDielectric)
    FresnelDielectric.name = "FresnelDielectric";
  $desc = $collectedClasses.FresnelDielectric;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FresnelDielectric.prototype = $desc;
  function FresnelNoOp() {
  }
  FresnelNoOp.builtin$cls = "FresnelNoOp";
  if (!"name" in FresnelNoOp)
    FresnelNoOp.name = "FresnelNoOp";
  $desc = $collectedClasses.FresnelNoOp;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FresnelNoOp.prototype = $desc;
  function IrregIsotropicBRDFSample(p, v) {
    this.p = p;
    this.v = v;
  }
  IrregIsotropicBRDFSample.builtin$cls = "IrregIsotropicBRDFSample";
  if (!"name" in IrregIsotropicBRDFSample)
    IrregIsotropicBRDFSample.name = "IrregIsotropicBRDFSample";
  $desc = $collectedClasses.IrregIsotropicBRDFSample;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IrregIsotropicBRDFSample.prototype = $desc;
  IrregIsotropicBRDFSample.prototype.get$p = function(receiver) {
    return this.p;
  };
  IrregIsotropicBRDFSample.prototype.get$v = function() {
    return this.v;
  };
  function IrregularIsotropicBRDF(isoBRDFData, type) {
    this.isoBRDFData = isoBRDFData;
    this.type = type;
  }
  IrregularIsotropicBRDF.builtin$cls = "IrregularIsotropicBRDF";
  if (!"name" in IrregularIsotropicBRDF)
    IrregularIsotropicBRDF.name = "IrregularIsotropicBRDF";
  $desc = $collectedClasses.IrregularIsotropicBRDF;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IrregularIsotropicBRDF.prototype = $desc;
  function IrregularIsotropicBRDF_f_proc(box_0) {
    this.box_0 = box_0;
  }
  IrregularIsotropicBRDF_f_proc.builtin$cls = "IrregularIsotropicBRDF_f_proc";
  if (!"name" in IrregularIsotropicBRDF_f_proc)
    IrregularIsotropicBRDF_f_proc.name = "IrregularIsotropicBRDF_f_proc";
  $desc = $collectedClasses.IrregularIsotropicBRDF_f_proc;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IrregularIsotropicBRDF_f_proc.prototype = $desc;
  function Lambertian(R, type) {
    this.R = R;
    this.type = type;
  }
  Lambertian.builtin$cls = "Lambertian";
  if (!"name" in Lambertian)
    Lambertian.name = "Lambertian";
  $desc = $collectedClasses.Lambertian;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Lambertian.prototype = $desc;
  function Microfacet(R, distribution, fresnel, type) {
    this.R = R;
    this.distribution = distribution;
    this.fresnel = fresnel;
    this.type = type;
  }
  Microfacet.builtin$cls = "Microfacet";
  if (!"name" in Microfacet)
    Microfacet.name = "Microfacet";
  $desc = $collectedClasses.Microfacet;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Microfacet.prototype = $desc;
  function MicrofacetDistribution() {
  }
  MicrofacetDistribution.builtin$cls = "MicrofacetDistribution";
  if (!"name" in MicrofacetDistribution)
    MicrofacetDistribution.name = "MicrofacetDistribution";
  $desc = $collectedClasses.MicrofacetDistribution;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MicrofacetDistribution.prototype = $desc;
  function OrenNayar(R, A, B, type) {
    this.R = R;
    this.A = A;
    this.B = B;
    this.type = type;
  }
  OrenNayar.builtin$cls = "OrenNayar";
  if (!"name" in OrenNayar)
    OrenNayar.name = "OrenNayar";
  $desc = $collectedClasses.OrenNayar;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OrenNayar.prototype = $desc;
  function RegularHalfangleBRDF(brdf, nThetaH, nThetaD, nPhiD, type) {
    this.brdf = brdf;
    this.nThetaH = nThetaH;
    this.nThetaD = nThetaD;
    this.nPhiD = nPhiD;
    this.type = type;
  }
  RegularHalfangleBRDF.builtin$cls = "RegularHalfangleBRDF";
  if (!"name" in RegularHalfangleBRDF)
    RegularHalfangleBRDF.name = "RegularHalfangleBRDF";
  $desc = $collectedClasses.RegularHalfangleBRDF;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RegularHalfangleBRDF.prototype = $desc;
  function RegularHalfangleBRDF_f_REMAP() {
  }
  RegularHalfangleBRDF_f_REMAP.builtin$cls = "RegularHalfangleBRDF_f_REMAP";
  if (!"name" in RegularHalfangleBRDF_f_REMAP)
    RegularHalfangleBRDF_f_REMAP.name = "RegularHalfangleBRDF_f_REMAP";
  $desc = $collectedClasses.RegularHalfangleBRDF_f_REMAP;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RegularHalfangleBRDF_f_REMAP.prototype = $desc;
  function ScaledBxDF(bxdf, s, type) {
    this.bxdf = bxdf;
    this.s = s;
    this.type = type;
  }
  ScaledBxDF.builtin$cls = "ScaledBxDF";
  if (!"name" in ScaledBxDF)
    ScaledBxDF.name = "ScaledBxDF";
  $desc = $collectedClasses.ScaledBxDF;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ScaledBxDF.prototype = $desc;
  function SpecularReflection(R, fresnel, type) {
    this.R = R;
    this.fresnel = fresnel;
    this.type = type;
  }
  SpecularReflection.builtin$cls = "SpecularReflection";
  if (!"name" in SpecularReflection)
    SpecularReflection.name = "SpecularReflection";
  $desc = $collectedClasses.SpecularReflection;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SpecularReflection.prototype = $desc;
  function SpecularTransmission(T, etai, etat, fresnel, type) {
    this.T = T;
    this.etai = etai;
    this.etat = etat;
    this.fresnel = fresnel;
    this.type = type;
  }
  SpecularTransmission.builtin$cls = "SpecularTransmission";
  if (!"name" in SpecularTransmission)
    SpecularTransmission.name = "SpecularTransmission";
  $desc = $collectedClasses.SpecularTransmission;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SpecularTransmission.prototype = $desc;
  function Renderer() {
  }
  Renderer.builtin$cls = "Renderer";
  if (!"name" in Renderer)
    Renderer.name = "Renderer";
  $desc = $collectedClasses.Renderer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Renderer.prototype = $desc;
  function ResourceManager() {
  }
  ResourceManager.builtin$cls = "ResourceManager";
  if (!"name" in ResourceManager)
    ResourceManager.name = "ResourceManager";
  $desc = $collectedClasses.ResourceManager;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ResourceManager.prototype = $desc;
  function ResourceManager_requestFile_closure(this_0, path_1, c_2) {
    this.this_0 = this_0;
    this.path_1 = path_1;
    this.c_2 = c_2;
  }
  ResourceManager_requestFile_closure.builtin$cls = "ResourceManager_requestFile_closure";
  if (!"name" in ResourceManager_requestFile_closure)
    ResourceManager_requestFile_closure.name = "ResourceManager_requestFile_closure";
  $desc = $collectedClasses.ResourceManager_requestFile_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ResourceManager_requestFile_closure.prototype = $desc;
  function ResourceManager_requestImage_closure(this_0, path_1, c_2) {
    this.this_0 = this_0;
    this.path_1 = path_1;
    this.c_2 = c_2;
  }
  ResourceManager_requestImage_closure.builtin$cls = "ResourceManager_requestImage_closure";
  if (!"name" in ResourceManager_requestImage_closure)
    ResourceManager_requestImage_closure.name = "ResourceManager_requestImage_closure";
  $desc = $collectedClasses.ResourceManager_requestImage_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ResourceManager_requestImage_closure.prototype = $desc;
  function ResourceManager_waitUntilReady_closure(this_0, c_1) {
    this.this_0 = this_0;
    this.c_1 = c_1;
  }
  ResourceManager_waitUntilReady_closure.builtin$cls = "ResourceManager_waitUntilReady_closure";
  if (!"name" in ResourceManager_waitUntilReady_closure)
    ResourceManager_waitUntilReady_closure.name = "ResourceManager_waitUntilReady_closure";
  $desc = $collectedClasses.ResourceManager_waitUntilReady_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ResourceManager_waitUntilReady_closure.prototype = $desc;
  function RGBColor(c) {
    this.c = c;
  }
  RGBColor.builtin$cls = "RGBColor";
  if (!"name" in RGBColor)
    RGBColor.name = "RGBColor";
  $desc = $collectedClasses.RGBColor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RGBColor.prototype = $desc;
  function RNG(random, mt, mti) {
    this.random = random;
    this.mt = mt;
    this.mti = mti;
  }
  RNG.builtin$cls = "RNG";
  if (!"name" in RNG)
    RNG.name = "RNG";
  $desc = $collectedClasses.RNG;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RNG.prototype = $desc;
  function Sample(n1D, n2D, oneD, twoD, imageX, imageY, lensU, lensV, time) {
    this.n1D = n1D;
    this.n2D = n2D;
    this.oneD = oneD;
    this.twoD = twoD;
    this.imageX = imageX;
    this.imageY = imageY;
    this.lensU = lensU;
    this.lensV = lensV;
    this.time = time;
  }
  Sample.builtin$cls = "Sample";
  if (!"name" in Sample)
    Sample.name = "Sample";
  $desc = $collectedClasses.Sample;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Sample.prototype = $desc;
  Sample.prototype.get$n1D = function() {
    return this.n1D;
  };
  Sample.prototype.get$n2D = function() {
    return this.n2D;
  };
  Sample.prototype.get$oneD = function() {
    return this.oneD;
  };
  Sample.prototype.get$twoD = function() {
    return this.twoD;
  };
  function SampledSpectrum(c) {
    this.c = c;
  }
  SampledSpectrum.builtin$cls = "SampledSpectrum";
  if (!"name" in SampledSpectrum)
    SampledSpectrum.name = "SampledSpectrum";
  $desc = $collectedClasses.SampledSpectrum;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SampledSpectrum.prototype = $desc;
  function _Spectrum(X, Y, Z, rgbRefl2SpectWhite, rgbRefl2SpectCyan, rgbRefl2SpectMagenta, rgbRefl2SpectYellow, rgbRefl2SpectRed, rgbRefl2SpectGreen, rgbRefl2SpectBlue, rgbIllum2SpectWhite, rgbIllum2SpectCyan, rgbIllum2SpectMagenta, rgbIllum2SpectYellow, rgbIllum2SpectRed, rgbIllum2SpectGreen, rgbIllum2SpectBlue) {
    this.X = X;
    this.Y = Y;
    this.Z = Z;
    this.rgbRefl2SpectWhite = rgbRefl2SpectWhite;
    this.rgbRefl2SpectCyan = rgbRefl2SpectCyan;
    this.rgbRefl2SpectMagenta = rgbRefl2SpectMagenta;
    this.rgbRefl2SpectYellow = rgbRefl2SpectYellow;
    this.rgbRefl2SpectRed = rgbRefl2SpectRed;
    this.rgbRefl2SpectGreen = rgbRefl2SpectGreen;
    this.rgbRefl2SpectBlue = rgbRefl2SpectBlue;
    this.rgbIllum2SpectWhite = rgbIllum2SpectWhite;
    this.rgbIllum2SpectCyan = rgbIllum2SpectCyan;
    this.rgbIllum2SpectMagenta = rgbIllum2SpectMagenta;
    this.rgbIllum2SpectYellow = rgbIllum2SpectYellow;
    this.rgbIllum2SpectRed = rgbIllum2SpectRed;
    this.rgbIllum2SpectGreen = rgbIllum2SpectGreen;
    this.rgbIllum2SpectBlue = rgbIllum2SpectBlue;
  }
  _Spectrum.builtin$cls = "_Spectrum";
  if (!"name" in _Spectrum)
    _Spectrum.name = "_Spectrum";
  $desc = $collectedClasses._Spectrum;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Spectrum.prototype = $desc;
  function Sampler(samplesPerPixel, shutterOpen, shutterClose) {
    this.samplesPerPixel = samplesPerPixel;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
  }
  Sampler.builtin$cls = "Sampler";
  if (!"name" in Sampler)
    Sampler.name = "Sampler";
  $desc = $collectedClasses.Sampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Sampler.prototype = $desc;
  Sampler.prototype.get$samplesPerPixel = function() {
    return this.samplesPerPixel;
  };
  Sampler.prototype.get$shutterOpen = function() {
    return this.shutterOpen;
  };
  Sampler.prototype.get$shutterClose = function() {
    return this.shutterClose;
  };
  function Scene(aggregate, lights, volumeRegion, worldBound) {
    this.aggregate = aggregate;
    this.lights = lights;
    this.volumeRegion = volumeRegion;
    this.worldBound = worldBound;
  }
  Scene.builtin$cls = "Scene";
  if (!"name" in Scene)
    Scene.name = "Scene";
  $desc = $collectedClasses.Scene;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Scene.prototype = $desc;
  function Shape(objectToWorld, worldToObject, reverseOrientation, shapeId) {
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.shapeId = shapeId;
  }
  Shape.builtin$cls = "Shape";
  if (!"name" in Shape)
    Shape.name = "Shape";
  $desc = $collectedClasses.Shape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Shape.prototype = $desc;
  Shape.prototype.get$objectToWorld = function() {
    return this.objectToWorld;
  };
  Shape.prototype.get$worldToObject = function() {
    return this.worldToObject;
  };
  Shape.prototype.get$reverseOrientation = function() {
    return this.reverseOrientation;
  };
  Shape.prototype.set$reverseOrientation = function(v) {
    return this.reverseOrientation = v;
  };
  Shape.prototype.get$shapeId = function() {
    return this.shapeId;
  };
  function Spectrum(c) {
    this.c = c;
  }
  Spectrum.builtin$cls = "Spectrum";
  if (!"name" in Spectrum)
    Spectrum.name = "Spectrum";
  $desc = $collectedClasses.Spectrum;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Spectrum.prototype = $desc;
  Spectrum.prototype.get$c = function() {
    return this.c;
  };
  function Spectrum_SortSpectrumSamples_closure() {
  }
  Spectrum_SortSpectrumSamples_closure.builtin$cls = "Spectrum_SortSpectrumSamples_closure";
  if (!"name" in Spectrum_SortSpectrumSamples_closure)
    Spectrum_SortSpectrumSamples_closure.name = "Spectrum_SortSpectrumSamples_closure";
  $desc = $collectedClasses.Spectrum_SortSpectrumSamples_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Spectrum_SortSpectrumSamples_closure.prototype = $desc;
  function Spectrum_AverageSpectrumSamples_INTERP(lambda_0, vals_1, offset_2) {
    this.lambda_0 = lambda_0;
    this.vals_1 = vals_1;
    this.offset_2 = offset_2;
  }
  Spectrum_AverageSpectrumSamples_INTERP.builtin$cls = "Spectrum_AverageSpectrumSamples_INTERP";
  if (!"name" in Spectrum_AverageSpectrumSamples_INTERP)
    Spectrum_AverageSpectrumSamples_INTERP.name = "Spectrum_AverageSpectrumSamples_INTERP";
  $desc = $collectedClasses.Spectrum_AverageSpectrumSamples_INTERP;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Spectrum_AverageSpectrumSamples_INTERP.prototype = $desc;
  function Spectrum_AverageSpectrumSamples_SEG_AVG(INTERP_3) {
    this.INTERP_3 = INTERP_3;
  }
  Spectrum_AverageSpectrumSamples_SEG_AVG.builtin$cls = "Spectrum_AverageSpectrumSamples_SEG_AVG";
  if (!"name" in Spectrum_AverageSpectrumSamples_SEG_AVG)
    Spectrum_AverageSpectrumSamples_SEG_AVG.name = "Spectrum_AverageSpectrumSamples_SEG_AVG";
  $desc = $collectedClasses.Spectrum_AverageSpectrumSamples_SEG_AVG;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Spectrum_AverageSpectrumSamples_SEG_AVG.prototype = $desc;
  function SpectrumImage(width, height, samplesPerPixel, data) {
    this.width = width;
    this.height = height;
    this.samplesPerPixel = samplesPerPixel;
    this.data = data;
  }
  SpectrumImage.builtin$cls = "SpectrumImage";
  if (!"name" in SpectrumImage)
    SpectrumImage.name = "SpectrumImage";
  $desc = $collectedClasses.SpectrumImage;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SpectrumImage.prototype = $desc;
  SpectrumImage.prototype.get$width = function(receiver) {
    return this.width;
  };
  SpectrumImage.prototype.get$height = function(receiver) {
    return this.height;
  };
  SpectrumImage.prototype.get$samplesPerPixel = function() {
    return this.samplesPerPixel;
  };
  SpectrumImage.prototype.get$data = function(receiver) {
    return this.data;
  };
  function SphericalHarmonics_RotateXPlus_O(c_in_0) {
    this.c_in_0 = c_in_0;
  }
  SphericalHarmonics_RotateXPlus_O.builtin$cls = "SphericalHarmonics_RotateXPlus_O";
  if (!"name" in SphericalHarmonics_RotateXPlus_O)
    SphericalHarmonics_RotateXPlus_O.name = "SphericalHarmonics_RotateXPlus_O";
  $desc = $collectedClasses.SphericalHarmonics_RotateXPlus_O;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SphericalHarmonics_RotateXPlus_O.prototype = $desc;
  function SphericalHarmonics__legendrep_P(out_0, outIndex_1) {
    this.out_0 = out_0;
    this.outIndex_1 = outIndex_1;
  }
  SphericalHarmonics__legendrep_P.builtin$cls = "SphericalHarmonics__legendrep_P";
  if (!"name" in SphericalHarmonics__legendrep_P)
    SphericalHarmonics__legendrep_P.name = "SphericalHarmonics__legendrep_P";
  $desc = $collectedClasses.SphericalHarmonics__legendrep_P;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SphericalHarmonics__legendrep_P.prototype = $desc;
  function StatTracker(name) {
    this.name = name;
  }
  StatTracker.builtin$cls = "StatTracker";
  if (!"name" in StatTracker)
    StatTracker.name = "StatTracker";
  $desc = $collectedClasses.StatTracker;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StatTracker.prototype = $desc;
  StatTracker.prototype.get$name = function(receiver) {
    return this.name;
  };
  function StatsCounter(count, category, name) {
    this.count = count;
    this.category = category;
    this.name = name;
  }
  StatsCounter.builtin$cls = "StatsCounter";
  if (!"name" in StatsCounter)
    StatsCounter.name = "StatsCounter";
  $desc = $collectedClasses.StatsCounter;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StatsCounter.prototype = $desc;
  StatsCounter.prototype.get$count = function() {
    return this.count;
  };
  StatsCounter.prototype.set$count = function(v) {
    return this.count = v;
  };
  function SurfaceIntegrator() {
  }
  SurfaceIntegrator.builtin$cls = "SurfaceIntegrator";
  if (!"name" in SurfaceIntegrator)
    SurfaceIntegrator.name = "SurfaceIntegrator";
  $desc = $collectedClasses.SurfaceIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SurfaceIntegrator.prototype = $desc;
  function ConstantTexture(value) {
    this.value = value;
  }
  ConstantTexture.builtin$cls = "ConstantTexture";
  if (!"name" in ConstantTexture)
    ConstantTexture.name = "ConstantTexture";
  $desc = $collectedClasses.ConstantTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ConstantTexture.prototype = $desc;
  function CylindricalMapping2D(worldToTexture) {
    this.worldToTexture = worldToTexture;
  }
  CylindricalMapping2D.builtin$cls = "CylindricalMapping2D";
  if (!"name" in CylindricalMapping2D)
    CylindricalMapping2D.name = "CylindricalMapping2D";
  $desc = $collectedClasses.CylindricalMapping2D;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CylindricalMapping2D.prototype = $desc;
  function IdentityMapping3D(worldToTexture) {
    this.worldToTexture = worldToTexture;
  }
  IdentityMapping3D.builtin$cls = "IdentityMapping3D";
  if (!"name" in IdentityMapping3D)
    IdentityMapping3D.name = "IdentityMapping3D";
  $desc = $collectedClasses.IdentityMapping3D;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IdentityMapping3D.prototype = $desc;
  function PlanarMapping2D(vs, vt, ds, dt) {
    this.vs = vs;
    this.vt = vt;
    this.ds = ds;
    this.dt = dt;
  }
  PlanarMapping2D.builtin$cls = "PlanarMapping2D";
  if (!"name" in PlanarMapping2D)
    PlanarMapping2D.name = "PlanarMapping2D";
  $desc = $collectedClasses.PlanarMapping2D;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PlanarMapping2D.prototype = $desc;
  function SphericalMapping2D(worldToTexture) {
    this.worldToTexture = worldToTexture;
  }
  SphericalMapping2D.builtin$cls = "SphericalMapping2D";
  if (!"name" in SphericalMapping2D)
    SphericalMapping2D.name = "SphericalMapping2D";
  $desc = $collectedClasses.SphericalMapping2D;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SphericalMapping2D.prototype = $desc;
  function Texture() {
  }
  Texture.builtin$cls = "Texture";
  if (!"name" in Texture)
    Texture.name = "Texture";
  $desc = $collectedClasses.Texture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Texture.prototype = $desc;
  function TextureMapping2D() {
  }
  TextureMapping2D.builtin$cls = "TextureMapping2D";
  if (!"name" in TextureMapping2D)
    TextureMapping2D.name = "TextureMapping2D";
  $desc = $collectedClasses.TextureMapping2D;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TextureMapping2D.prototype = $desc;
  function TextureMapping3D() {
  }
  TextureMapping3D.builtin$cls = "TextureMapping3D";
  if (!"name" in TextureMapping3D)
    TextureMapping3D.name = "TextureMapping3D";
  $desc = $collectedClasses.TextureMapping3D;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TextureMapping3D.prototype = $desc;
  function UVMapping2D(su, sv, du, dv) {
    this.su = su;
    this.sv = sv;
    this.du = du;
    this.dv = dv;
  }
  UVMapping2D.builtin$cls = "UVMapping2D";
  if (!"name" in UVMapping2D)
    UVMapping2D.name = "UVMapping2D";
  $desc = $collectedClasses.UVMapping2D;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UVMapping2D.prototype = $desc;
  function TextureParams(floatTextures, spectrumTextures, geomParams, materialParams) {
    this.floatTextures = floatTextures;
    this.spectrumTextures = spectrumTextures;
    this.geomParams = geomParams;
    this.materialParams = materialParams;
  }
  TextureParams.builtin$cls = "TextureParams";
  if (!"name" in TextureParams)
    TextureParams.name = "TextureParams";
  $desc = $collectedClasses.TextureParams;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TextureParams.prototype = $desc;
  TextureParams.prototype.get$spectrumTextures = function() {
    return this.spectrumTextures;
  };
  TextureParams.prototype.get$materialParams = function() {
    return this.materialParams;
  };
  TextureParams.prototype.set$materialParams = function(v) {
    return this.materialParams = v;
  };
  function Transform(m, mInv) {
    this.m = m;
    this.mInv = mInv;
  }
  Transform.builtin$cls = "Transform";
  if (!"name" in Transform)
    Transform.name = "Transform";
  $desc = $collectedClasses.Transform;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Transform.prototype = $desc;
  Transform.prototype.get$m = function() {
    return this.m;
  };
  Transform.prototype.get$mInv = function() {
    return this.mInv;
  };
  function Vector(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  Vector.builtin$cls = "Vector";
  if (!"name" in Vector)
    Vector.name = "Vector";
  $desc = $collectedClasses.Vector;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Vector.prototype = $desc;
  Vector.prototype.get$x = function(receiver) {
    return this.x;
  };
  Vector.prototype.set$x = function(receiver, v) {
    return this.x = v;
  };
  Vector.prototype.get$y = function(receiver) {
    return this.y;
  };
  Vector.prototype.set$y = function(receiver, v) {
    return this.y = v;
  };
  Vector.prototype.get$z = function(receiver) {
    return this.z;
  };
  Vector.prototype.set$z = function(receiver, v) {
    return this.z = v;
  };
  function AggregateVolume(regions, _bound) {
    this.regions = regions;
    this._bound = _bound;
  }
  AggregateVolume.builtin$cls = "AggregateVolume";
  if (!"name" in AggregateVolume)
    AggregateVolume.name = "AggregateVolume";
  $desc = $collectedClasses.AggregateVolume;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AggregateVolume.prototype = $desc;
  function DensityRegion() {
  }
  DensityRegion.builtin$cls = "DensityRegion";
  if (!"name" in DensityRegion)
    DensityRegion.name = "DensityRegion";
  $desc = $collectedClasses.DensityRegion;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DensityRegion.prototype = $desc;
  function VolumeRegion() {
  }
  VolumeRegion.builtin$cls = "VolumeRegion";
  if (!"name" in VolumeRegion)
    VolumeRegion.name = "VolumeRegion";
  $desc = $collectedClasses.VolumeRegion;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VolumeRegion.prototype = $desc;
  function VolumeIntegrator() {
  }
  VolumeIntegrator.builtin$cls = "VolumeIntegrator";
  if (!"name" in VolumeIntegrator)
    VolumeIntegrator.name = "VolumeIntegrator";
  $desc = $collectedClasses.VolumeIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VolumeIntegrator.prototype = $desc;
  function XYZColor(c) {
    this.c = c;
  }
  XYZColor.builtin$cls = "XYZColor";
  if (!"name" in XYZColor)
    XYZColor.name = "XYZColor";
  $desc = $collectedClasses.XYZColor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  XYZColor.prototype = $desc;
  function ListIterable() {
  }
  ListIterable.builtin$cls = "ListIterable";
  if (!"name" in ListIterable)
    ListIterable.name = "ListIterable";
  $desc = $collectedClasses.ListIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ListIterable.prototype = $desc;
  function SubListIterable(_iterable, __internal$_start, _endOrLength) {
    this._iterable = _iterable;
    this.__internal$_start = __internal$_start;
    this._endOrLength = _endOrLength;
  }
  SubListIterable.builtin$cls = "SubListIterable";
  if (!"name" in SubListIterable)
    SubListIterable.name = "SubListIterable";
  $desc = $collectedClasses.SubListIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SubListIterable.prototype = $desc;
  function ListIterator(_iterable, _length, _index, _current) {
    this._iterable = _iterable;
    this._length = _length;
    this._index = _index;
    this._current = _current;
  }
  ListIterator.builtin$cls = "ListIterator";
  if (!"name" in ListIterator)
    ListIterator.name = "ListIterator";
  $desc = $collectedClasses.ListIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ListIterator.prototype = $desc;
  function MappedIterable(_iterable, _f) {
    this._iterable = _iterable;
    this._f = _f;
  }
  MappedIterable.builtin$cls = "MappedIterable";
  if (!"name" in MappedIterable)
    MappedIterable.name = "MappedIterable";
  $desc = $collectedClasses.MappedIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MappedIterable.prototype = $desc;
  function EfficientLengthMappedIterable(_iterable, _f) {
    this._iterable = _iterable;
    this._f = _f;
  }
  EfficientLengthMappedIterable.builtin$cls = "EfficientLengthMappedIterable";
  if (!"name" in EfficientLengthMappedIterable)
    EfficientLengthMappedIterable.name = "EfficientLengthMappedIterable";
  $desc = $collectedClasses.EfficientLengthMappedIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  EfficientLengthMappedIterable.prototype = $desc;
  function MappedIterator(_current, _iterator, _f) {
    this._current = _current;
    this._iterator = _iterator;
    this._f = _f;
  }
  MappedIterator.builtin$cls = "MappedIterator";
  if (!"name" in MappedIterator)
    MappedIterator.name = "MappedIterator";
  $desc = $collectedClasses.MappedIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MappedIterator.prototype = $desc;
  function WhereIterable(_iterable, _f) {
    this._iterable = _iterable;
    this._f = _f;
  }
  WhereIterable.builtin$cls = "WhereIterable";
  if (!"name" in WhereIterable)
    WhereIterable.name = "WhereIterable";
  $desc = $collectedClasses.WhereIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WhereIterable.prototype = $desc;
  function WhereIterator(_iterator, _f) {
    this._iterator = _iterator;
    this._f = _f;
  }
  WhereIterator.builtin$cls = "WhereIterator";
  if (!"name" in WhereIterator)
    WhereIterator.name = "WhereIterator";
  $desc = $collectedClasses.WhereIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WhereIterator.prototype = $desc;
  function SkipIterable(_iterable, _skipCount) {
    this._iterable = _iterable;
    this._skipCount = _skipCount;
  }
  SkipIterable.builtin$cls = "SkipIterable";
  if (!"name" in SkipIterable)
    SkipIterable.name = "SkipIterable";
  $desc = $collectedClasses.SkipIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SkipIterable.prototype = $desc;
  function EfficientLengthSkipIterable(_iterable, _skipCount) {
    this._iterable = _iterable;
    this._skipCount = _skipCount;
  }
  EfficientLengthSkipIterable.builtin$cls = "EfficientLengthSkipIterable";
  if (!"name" in EfficientLengthSkipIterable)
    EfficientLengthSkipIterable.name = "EfficientLengthSkipIterable";
  $desc = $collectedClasses.EfficientLengthSkipIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  EfficientLengthSkipIterable.prototype = $desc;
  function SkipIterator(_iterator, _skipCount) {
    this._iterator = _iterator;
    this._skipCount = _skipCount;
  }
  SkipIterator.builtin$cls = "SkipIterator";
  if (!"name" in SkipIterator)
    SkipIterator.name = "SkipIterator";
  $desc = $collectedClasses.SkipIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SkipIterator.prototype = $desc;
  function FixedLengthListMixin() {
  }
  FixedLengthListMixin.builtin$cls = "FixedLengthListMixin";
  if (!"name" in FixedLengthListMixin)
    FixedLengthListMixin.name = "FixedLengthListMixin";
  $desc = $collectedClasses.FixedLengthListMixin;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FixedLengthListMixin.prototype = $desc;
  function UnmodifiableListMixin() {
  }
  UnmodifiableListMixin.builtin$cls = "UnmodifiableListMixin";
  if (!"name" in UnmodifiableListMixin)
    UnmodifiableListMixin.name = "UnmodifiableListMixin";
  $desc = $collectedClasses.UnmodifiableListMixin;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UnmodifiableListMixin.prototype = $desc;
  function UnmodifiableListBase() {
  }
  UnmodifiableListBase.builtin$cls = "UnmodifiableListBase";
  if (!"name" in UnmodifiableListBase)
    UnmodifiableListBase.name = "UnmodifiableListBase";
  $desc = $collectedClasses.UnmodifiableListBase;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UnmodifiableListBase.prototype = $desc;
  function _AsyncError(error, stackTrace) {
    this.error = error;
    this.stackTrace = stackTrace;
  }
  _AsyncError.builtin$cls = "_AsyncError";
  if (!"name" in _AsyncError)
    _AsyncError.name = "_AsyncError";
  $desc = $collectedClasses._AsyncError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _AsyncError.prototype = $desc;
  _AsyncError.prototype.get$error = function(receiver) {
    return this.error;
  };
  _AsyncError.prototype.get$stackTrace = function() {
    return this.stackTrace;
  };
  function Future() {
  }
  Future.builtin$cls = "Future";
  if (!"name" in Future)
    Future.name = "Future";
  $desc = $collectedClasses.Future;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Future.prototype = $desc;
  function Future_wait_handleError(box_0, eagerError_1) {
    this.box_0 = box_0;
    this.eagerError_1 = eagerError_1;
  }
  Future_wait_handleError.builtin$cls = "Future_wait_handleError";
  if (!"name" in Future_wait_handleError)
    Future_wait_handleError.name = "Future_wait_handleError";
  $desc = $collectedClasses.Future_wait_handleError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Future_wait_handleError.prototype = $desc;
  function Future_wait_closure(box_0, eagerError_2, pos_3) {
    this.box_0 = box_0;
    this.eagerError_2 = eagerError_2;
    this.pos_3 = pos_3;
  }
  Future_wait_closure.builtin$cls = "Future_wait_closure";
  if (!"name" in Future_wait_closure)
    Future_wait_closure.name = "Future_wait_closure";
  $desc = $collectedClasses.Future_wait_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Future_wait_closure.prototype = $desc;
  function _Completer() {
  }
  _Completer.builtin$cls = "_Completer";
  if (!"name" in _Completer)
    _Completer.name = "_Completer";
  $desc = $collectedClasses._Completer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Completer.prototype = $desc;
  function _AsyncCompleter(future) {
    this.future = future;
  }
  _AsyncCompleter.builtin$cls = "_AsyncCompleter";
  if (!"name" in _AsyncCompleter)
    _AsyncCompleter.name = "_AsyncCompleter";
  $desc = $collectedClasses._AsyncCompleter;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _AsyncCompleter.prototype = $desc;
  function _Future(_state, _zone, _resultOrListeners, _nextListener, _onValueCallback, _errorTestCallback, _onErrorCallback, _whenCompleteActionCallback) {
    this._state = _state;
    this._zone = _zone;
    this._resultOrListeners = _resultOrListeners;
    this._nextListener = _nextListener;
    this._onValueCallback = _onValueCallback;
    this._errorTestCallback = _errorTestCallback;
    this._onErrorCallback = _onErrorCallback;
    this._whenCompleteActionCallback = _whenCompleteActionCallback;
  }
  _Future.builtin$cls = "_Future";
  if (!"name" in _Future)
    _Future.name = "_Future";
  $desc = $collectedClasses._Future;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future.prototype = $desc;
  _Future.prototype.get$_zone = function() {
    return this._zone;
  };
  _Future.prototype.get$_nextListener = function() {
    return this._nextListener;
  };
  function _Future__addListener_closure(this_0, listener_1) {
    this.this_0 = this_0;
    this.listener_1 = listener_1;
  }
  _Future__addListener_closure.builtin$cls = "_Future__addListener_closure";
  if (!"name" in _Future__addListener_closure)
    _Future__addListener_closure.name = "_Future__addListener_closure";
  $desc = $collectedClasses._Future__addListener_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__addListener_closure.prototype = $desc;
  function _Future__chainForeignFuture_closure(target_0) {
    this.target_0 = target_0;
  }
  _Future__chainForeignFuture_closure.builtin$cls = "_Future__chainForeignFuture_closure";
  if (!"name" in _Future__chainForeignFuture_closure)
    _Future__chainForeignFuture_closure.name = "_Future__chainForeignFuture_closure";
  $desc = $collectedClasses._Future__chainForeignFuture_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__chainForeignFuture_closure.prototype = $desc;
  function _Future__chainForeignFuture_closure0(target_1) {
    this.target_1 = target_1;
  }
  _Future__chainForeignFuture_closure0.builtin$cls = "_Future__chainForeignFuture_closure0";
  if (!"name" in _Future__chainForeignFuture_closure0)
    _Future__chainForeignFuture_closure0.name = "_Future__chainForeignFuture_closure0";
  $desc = $collectedClasses._Future__chainForeignFuture_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__chainForeignFuture_closure0.prototype = $desc;
  function _Future__asyncComplete_closure(this_0, coreFuture_1) {
    this.this_0 = this_0;
    this.coreFuture_1 = coreFuture_1;
  }
  _Future__asyncComplete_closure.builtin$cls = "_Future__asyncComplete_closure";
  if (!"name" in _Future__asyncComplete_closure)
    _Future__asyncComplete_closure.name = "_Future__asyncComplete_closure";
  $desc = $collectedClasses._Future__asyncComplete_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__asyncComplete_closure.prototype = $desc;
  function _Future__asyncComplete_closure0(this_2, value_3) {
    this.this_2 = this_2;
    this.value_3 = value_3;
  }
  _Future__asyncComplete_closure0.builtin$cls = "_Future__asyncComplete_closure0";
  if (!"name" in _Future__asyncComplete_closure0)
    _Future__asyncComplete_closure0.name = "_Future__asyncComplete_closure0";
  $desc = $collectedClasses._Future__asyncComplete_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__asyncComplete_closure0.prototype = $desc;
  function _Future__asyncCompleteError_closure(this_0, error_1, stackTrace_2) {
    this.this_0 = this_0;
    this.error_1 = error_1;
    this.stackTrace_2 = stackTrace_2;
  }
  _Future__asyncCompleteError_closure.builtin$cls = "_Future__asyncCompleteError_closure";
  if (!"name" in _Future__asyncCompleteError_closure)
    _Future__asyncCompleteError_closure.name = "_Future__asyncCompleteError_closure";
  $desc = $collectedClasses._Future__asyncCompleteError_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__asyncCompleteError_closure.prototype = $desc;
  function _Future__propagateToListeners_handleValueCallback(box_1, listener_3, sourceValue_4, zone_5) {
    this.box_1 = box_1;
    this.listener_3 = listener_3;
    this.sourceValue_4 = sourceValue_4;
    this.zone_5 = zone_5;
  }
  _Future__propagateToListeners_handleValueCallback.builtin$cls = "_Future__propagateToListeners_handleValueCallback";
  if (!"name" in _Future__propagateToListeners_handleValueCallback)
    _Future__propagateToListeners_handleValueCallback.name = "_Future__propagateToListeners_handleValueCallback";
  $desc = $collectedClasses._Future__propagateToListeners_handleValueCallback;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__propagateToListeners_handleValueCallback.prototype = $desc;
  function _Future__propagateToListeners_handleError(box_2, box_1, listener_6, zone_7) {
    this.box_2 = box_2;
    this.box_1 = box_1;
    this.listener_6 = listener_6;
    this.zone_7 = zone_7;
  }
  _Future__propagateToListeners_handleError.builtin$cls = "_Future__propagateToListeners_handleError";
  if (!"name" in _Future__propagateToListeners_handleError)
    _Future__propagateToListeners_handleError.name = "_Future__propagateToListeners_handleError";
  $desc = $collectedClasses._Future__propagateToListeners_handleError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__propagateToListeners_handleError.prototype = $desc;
  function _Future__propagateToListeners_handleWhenCompleteCallback(box_2, box_1, hasError_8, listener_9, zone_10) {
    this.box_2 = box_2;
    this.box_1 = box_1;
    this.hasError_8 = hasError_8;
    this.listener_9 = listener_9;
    this.zone_10 = zone_10;
  }
  _Future__propagateToListeners_handleWhenCompleteCallback.builtin$cls = "_Future__propagateToListeners_handleWhenCompleteCallback";
  if (!"name" in _Future__propagateToListeners_handleWhenCompleteCallback)
    _Future__propagateToListeners_handleWhenCompleteCallback.name = "_Future__propagateToListeners_handleWhenCompleteCallback";
  $desc = $collectedClasses._Future__propagateToListeners_handleWhenCompleteCallback;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__propagateToListeners_handleWhenCompleteCallback.prototype = $desc;
  function _Future__propagateToListeners_handleWhenCompleteCallback_closure(box_2, listener_11) {
    this.box_2 = box_2;
    this.listener_11 = listener_11;
  }
  _Future__propagateToListeners_handleWhenCompleteCallback_closure.builtin$cls = "_Future__propagateToListeners_handleWhenCompleteCallback_closure";
  if (!"name" in _Future__propagateToListeners_handleWhenCompleteCallback_closure)
    _Future__propagateToListeners_handleWhenCompleteCallback_closure.name = "_Future__propagateToListeners_handleWhenCompleteCallback_closure";
  $desc = $collectedClasses._Future__propagateToListeners_handleWhenCompleteCallback_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__propagateToListeners_handleWhenCompleteCallback_closure.prototype = $desc;
  function _Future__propagateToListeners_handleWhenCompleteCallback_closure0(box_0, listener_12) {
    this.box_0 = box_0;
    this.listener_12 = listener_12;
  }
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0.builtin$cls = "_Future__propagateToListeners_handleWhenCompleteCallback_closure0";
  if (!"name" in _Future__propagateToListeners_handleWhenCompleteCallback_closure0)
    _Future__propagateToListeners_handleWhenCompleteCallback_closure0.name = "_Future__propagateToListeners_handleWhenCompleteCallback_closure0";
  $desc = $collectedClasses._Future__propagateToListeners_handleWhenCompleteCallback_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0.prototype = $desc;
  function _AsyncCallbackEntry(callback, next) {
    this.callback = callback;
    this.next = next;
  }
  _AsyncCallbackEntry.builtin$cls = "_AsyncCallbackEntry";
  if (!"name" in _AsyncCallbackEntry)
    _AsyncCallbackEntry.name = "_AsyncCallbackEntry";
  $desc = $collectedClasses._AsyncCallbackEntry;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _AsyncCallbackEntry.prototype = $desc;
  _AsyncCallbackEntry.prototype.get$next = function() {
    return this.next;
  };
  _AsyncCallbackEntry.prototype.set$next = function(v) {
    return this.next = v;
  };
  function Stream() {
  }
  Stream.builtin$cls = "Stream";
  if (!"name" in Stream)
    Stream.name = "Stream";
  $desc = $collectedClasses.Stream;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream.prototype = $desc;
  function Stream_forEach_closure(box_0, this_1, action_2, future_3) {
    this.box_0 = box_0;
    this.this_1 = this_1;
    this.action_2 = action_2;
    this.future_3 = future_3;
  }
  Stream_forEach_closure.builtin$cls = "Stream_forEach_closure";
  if (!"name" in Stream_forEach_closure)
    Stream_forEach_closure.name = "Stream_forEach_closure";
  $desc = $collectedClasses.Stream_forEach_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_forEach_closure.prototype = $desc;
  function Stream_forEach__closure(action_4, element_5) {
    this.action_4 = action_4;
    this.element_5 = element_5;
  }
  Stream_forEach__closure.builtin$cls = "Stream_forEach__closure";
  if (!"name" in Stream_forEach__closure)
    Stream_forEach__closure.name = "Stream_forEach__closure";
  $desc = $collectedClasses.Stream_forEach__closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_forEach__closure.prototype = $desc;
  function Stream_forEach__closure0() {
  }
  Stream_forEach__closure0.builtin$cls = "Stream_forEach__closure0";
  if (!"name" in Stream_forEach__closure0)
    Stream_forEach__closure0.name = "Stream_forEach__closure0";
  $desc = $collectedClasses.Stream_forEach__closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_forEach__closure0.prototype = $desc;
  function Stream_forEach_closure0(future_6) {
    this.future_6 = future_6;
  }
  Stream_forEach_closure0.builtin$cls = "Stream_forEach_closure0";
  if (!"name" in Stream_forEach_closure0)
    Stream_forEach_closure0.name = "Stream_forEach_closure0";
  $desc = $collectedClasses.Stream_forEach_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_forEach_closure0.prototype = $desc;
  function Stream_length_closure(box_0) {
    this.box_0 = box_0;
  }
  Stream_length_closure.builtin$cls = "Stream_length_closure";
  if (!"name" in Stream_length_closure)
    Stream_length_closure.name = "Stream_length_closure";
  $desc = $collectedClasses.Stream_length_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_length_closure.prototype = $desc;
  function Stream_length_closure0(box_0, future_1) {
    this.box_0 = box_0;
    this.future_1 = future_1;
  }
  Stream_length_closure0.builtin$cls = "Stream_length_closure0";
  if (!"name" in Stream_length_closure0)
    Stream_length_closure0.name = "Stream_length_closure0";
  $desc = $collectedClasses.Stream_length_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_length_closure0.prototype = $desc;
  function Stream_isEmpty_closure(box_0, future_1) {
    this.box_0 = box_0;
    this.future_1 = future_1;
  }
  Stream_isEmpty_closure.builtin$cls = "Stream_isEmpty_closure";
  if (!"name" in Stream_isEmpty_closure)
    Stream_isEmpty_closure.name = "Stream_isEmpty_closure";
  $desc = $collectedClasses.Stream_isEmpty_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_isEmpty_closure.prototype = $desc;
  function Stream_isEmpty_closure0(future_2) {
    this.future_2 = future_2;
  }
  Stream_isEmpty_closure0.builtin$cls = "Stream_isEmpty_closure0";
  if (!"name" in Stream_isEmpty_closure0)
    Stream_isEmpty_closure0.name = "Stream_isEmpty_closure0";
  $desc = $collectedClasses.Stream_isEmpty_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_isEmpty_closure0.prototype = $desc;
  function Stream_first_closure(box_0, this_1, future_2) {
    this.box_0 = box_0;
    this.this_1 = this_1;
    this.future_2 = future_2;
  }
  Stream_first_closure.builtin$cls = "Stream_first_closure";
  if (!"name" in Stream_first_closure)
    Stream_first_closure.name = "Stream_first_closure";
  $desc = $collectedClasses.Stream_first_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_first_closure.prototype = $desc;
  function Stream_first_closure0(future_3) {
    this.future_3 = future_3;
  }
  Stream_first_closure0.builtin$cls = "Stream_first_closure0";
  if (!"name" in Stream_first_closure0)
    Stream_first_closure0.name = "Stream_first_closure0";
  $desc = $collectedClasses.Stream_first_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stream_first_closure0.prototype = $desc;
  function StreamSubscription() {
  }
  StreamSubscription.builtin$cls = "StreamSubscription";
  if (!"name" in StreamSubscription)
    StreamSubscription.name = "StreamSubscription";
  $desc = $collectedClasses.StreamSubscription;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StreamSubscription.prototype = $desc;
  function _StreamController() {
  }
  _StreamController.builtin$cls = "_StreamController";
  if (!"name" in _StreamController)
    _StreamController.name = "_StreamController";
  $desc = $collectedClasses._StreamController;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _StreamController.prototype = $desc;
  function _StreamController__subscribe_closure(this_0) {
    this.this_0 = this_0;
  }
  _StreamController__subscribe_closure.builtin$cls = "_StreamController__subscribe_closure";
  if (!"name" in _StreamController__subscribe_closure)
    _StreamController__subscribe_closure.name = "_StreamController__subscribe_closure";
  $desc = $collectedClasses._StreamController__subscribe_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _StreamController__subscribe_closure.prototype = $desc;
  function _StreamController__recordCancel_complete(this_0) {
    this.this_0 = this_0;
  }
  _StreamController__recordCancel_complete.builtin$cls = "_StreamController__recordCancel_complete";
  if (!"name" in _StreamController__recordCancel_complete)
    _StreamController__recordCancel_complete.name = "_StreamController__recordCancel_complete";
  $desc = $collectedClasses._StreamController__recordCancel_complete;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _StreamController__recordCancel_complete.prototype = $desc;
  function _SyncStreamControllerDispatch() {
  }
  _SyncStreamControllerDispatch.builtin$cls = "_SyncStreamControllerDispatch";
  if (!"name" in _SyncStreamControllerDispatch)
    _SyncStreamControllerDispatch.name = "_SyncStreamControllerDispatch";
  $desc = $collectedClasses._SyncStreamControllerDispatch;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SyncStreamControllerDispatch.prototype = $desc;
  function _AsyncStreamControllerDispatch() {
  }
  _AsyncStreamControllerDispatch.builtin$cls = "_AsyncStreamControllerDispatch";
  if (!"name" in _AsyncStreamControllerDispatch)
    _AsyncStreamControllerDispatch.name = "_AsyncStreamControllerDispatch";
  $desc = $collectedClasses._AsyncStreamControllerDispatch;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _AsyncStreamControllerDispatch.prototype = $desc;
  function _AsyncStreamController(_onListen, _onPause, _onResume, _onCancel, _varData, _state, _doneFuture) {
    this._onListen = _onListen;
    this._onPause = _onPause;
    this._onResume = _onResume;
    this._onCancel = _onCancel;
    this._varData = _varData;
    this._state = _state;
    this._doneFuture = _doneFuture;
  }
  _AsyncStreamController.builtin$cls = "_AsyncStreamController";
  if (!"name" in _AsyncStreamController)
    _AsyncStreamController.name = "_AsyncStreamController";
  $desc = $collectedClasses._AsyncStreamController;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _AsyncStreamController.prototype = $desc;
  _AsyncStreamController.prototype.get$_onListen = function() {
    return this._onListen;
  };
  _AsyncStreamController.prototype.get$_onPause = function() {
    return this._onPause;
  };
  _AsyncStreamController.prototype.get$_onResume = function() {
    return this._onResume;
  };
  _AsyncStreamController.prototype.get$_onCancel = function() {
    return this._onCancel;
  };
  function _StreamController__AsyncStreamControllerDispatch() {
  }
  _StreamController__AsyncStreamControllerDispatch.builtin$cls = "_StreamController__AsyncStreamControllerDispatch";
  if (!"name" in _StreamController__AsyncStreamControllerDispatch)
    _StreamController__AsyncStreamControllerDispatch.name = "_StreamController__AsyncStreamControllerDispatch";
  $desc = $collectedClasses._StreamController__AsyncStreamControllerDispatch;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _StreamController__AsyncStreamControllerDispatch.prototype = $desc;
  function _SyncStreamController(_onListen, _onPause, _onResume, _onCancel, _varData, _state, _doneFuture) {
    this._onListen = _onListen;
    this._onPause = _onPause;
    this._onResume = _onResume;
    this._onCancel = _onCancel;
    this._varData = _varData;
    this._state = _state;
    this._doneFuture = _doneFuture;
  }
  _SyncStreamController.builtin$cls = "_SyncStreamController";
  if (!"name" in _SyncStreamController)
    _SyncStreamController.name = "_SyncStreamController";
  $desc = $collectedClasses._SyncStreamController;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SyncStreamController.prototype = $desc;
  _SyncStreamController.prototype.get$_onListen = function() {
    return this._onListen;
  };
  _SyncStreamController.prototype.get$_onPause = function() {
    return this._onPause;
  };
  _SyncStreamController.prototype.get$_onResume = function() {
    return this._onResume;
  };
  _SyncStreamController.prototype.get$_onCancel = function() {
    return this._onCancel;
  };
  function _StreamController__SyncStreamControllerDispatch() {
  }
  _StreamController__SyncStreamControllerDispatch.builtin$cls = "_StreamController__SyncStreamControllerDispatch";
  if (!"name" in _StreamController__SyncStreamControllerDispatch)
    _StreamController__SyncStreamControllerDispatch.name = "_StreamController__SyncStreamControllerDispatch";
  $desc = $collectedClasses._StreamController__SyncStreamControllerDispatch;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _StreamController__SyncStreamControllerDispatch.prototype = $desc;
  function _ControllerStream(_async$_controller) {
    this._async$_controller = _async$_controller;
  }
  _ControllerStream.builtin$cls = "_ControllerStream";
  if (!"name" in _ControllerStream)
    _ControllerStream.name = "_ControllerStream";
  $desc = $collectedClasses._ControllerStream;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ControllerStream.prototype = $desc;
  function _ControllerSubscription(_async$_controller, _onData, _onError, _onDone, _zone, _state, _cancelFuture, _pending) {
    this._async$_controller = _async$_controller;
    this._onData = _onData;
    this._onError = _onError;
    this._onDone = _onDone;
    this._zone = _zone;
    this._state = _state;
    this._cancelFuture = _cancelFuture;
    this._pending = _pending;
  }
  _ControllerSubscription.builtin$cls = "_ControllerSubscription";
  if (!"name" in _ControllerSubscription)
    _ControllerSubscription.name = "_ControllerSubscription";
  $desc = $collectedClasses._ControllerSubscription;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ControllerSubscription.prototype = $desc;
  function _EventSink() {
  }
  _EventSink.builtin$cls = "_EventSink";
  if (!"name" in _EventSink)
    _EventSink.name = "_EventSink";
  $desc = $collectedClasses._EventSink;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _EventSink.prototype = $desc;
  function _BufferingStreamSubscription(_onData, _onError, _onDone, _zone, _state, _cancelFuture, _pending) {
    this._onData = _onData;
    this._onError = _onError;
    this._onDone = _onDone;
    this._zone = _zone;
    this._state = _state;
    this._cancelFuture = _cancelFuture;
    this._pending = _pending;
  }
  _BufferingStreamSubscription.builtin$cls = "_BufferingStreamSubscription";
  if (!"name" in _BufferingStreamSubscription)
    _BufferingStreamSubscription.name = "_BufferingStreamSubscription";
  $desc = $collectedClasses._BufferingStreamSubscription;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BufferingStreamSubscription.prototype = $desc;
  _BufferingStreamSubscription.prototype.get$_zone = function() {
    return this._zone;
  };
  function _BufferingStreamSubscription__sendError_sendError(this_0, error_1, stackTrace_2) {
    this.this_0 = this_0;
    this.error_1 = error_1;
    this.stackTrace_2 = stackTrace_2;
  }
  _BufferingStreamSubscription__sendError_sendError.builtin$cls = "_BufferingStreamSubscription__sendError_sendError";
  if (!"name" in _BufferingStreamSubscription__sendError_sendError)
    _BufferingStreamSubscription__sendError_sendError.name = "_BufferingStreamSubscription__sendError_sendError";
  $desc = $collectedClasses._BufferingStreamSubscription__sendError_sendError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BufferingStreamSubscription__sendError_sendError.prototype = $desc;
  function _BufferingStreamSubscription__sendDone_sendDone(this_0) {
    this.this_0 = this_0;
  }
  _BufferingStreamSubscription__sendDone_sendDone.builtin$cls = "_BufferingStreamSubscription__sendDone_sendDone";
  if (!"name" in _BufferingStreamSubscription__sendDone_sendDone)
    _BufferingStreamSubscription__sendDone_sendDone.name = "_BufferingStreamSubscription__sendDone_sendDone";
  $desc = $collectedClasses._BufferingStreamSubscription__sendDone_sendDone;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BufferingStreamSubscription__sendDone_sendDone.prototype = $desc;
  function _StreamImpl() {
  }
  _StreamImpl.builtin$cls = "_StreamImpl";
  if (!"name" in _StreamImpl)
    _StreamImpl.name = "_StreamImpl";
  $desc = $collectedClasses._StreamImpl;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _StreamImpl.prototype = $desc;
  function _DelayedEvent(next) {
    this.next = next;
  }
  _DelayedEvent.builtin$cls = "_DelayedEvent";
  if (!"name" in _DelayedEvent)
    _DelayedEvent.name = "_DelayedEvent";
  $desc = $collectedClasses._DelayedEvent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _DelayedEvent.prototype = $desc;
  _DelayedEvent.prototype.get$next = function() {
    return this.next;
  };
  _DelayedEvent.prototype.set$next = function(v) {
    return this.next = v;
  };
  function _DelayedData(value, next) {
    this.value = value;
    this.next = next;
  }
  _DelayedData.builtin$cls = "_DelayedData";
  if (!"name" in _DelayedData)
    _DelayedData.name = "_DelayedData";
  $desc = $collectedClasses._DelayedData;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _DelayedData.prototype = $desc;
  function _DelayedError(error, stackTrace, next) {
    this.error = error;
    this.stackTrace = stackTrace;
    this.next = next;
  }
  _DelayedError.builtin$cls = "_DelayedError";
  if (!"name" in _DelayedError)
    _DelayedError.name = "_DelayedError";
  $desc = $collectedClasses._DelayedError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _DelayedError.prototype = $desc;
  _DelayedError.prototype.get$error = function(receiver) {
    return this.error;
  };
  _DelayedError.prototype.get$stackTrace = function() {
    return this.stackTrace;
  };
  function _DelayedDone() {
  }
  _DelayedDone.builtin$cls = "_DelayedDone";
  if (!"name" in _DelayedDone)
    _DelayedDone.name = "_DelayedDone";
  $desc = $collectedClasses._DelayedDone;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _DelayedDone.prototype = $desc;
  function _PendingEvents() {
  }
  _PendingEvents.builtin$cls = "_PendingEvents";
  if (!"name" in _PendingEvents)
    _PendingEvents.name = "_PendingEvents";
  $desc = $collectedClasses._PendingEvents;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _PendingEvents.prototype = $desc;
  function _PendingEvents_schedule_closure(this_0, dispatch_1) {
    this.this_0 = this_0;
    this.dispatch_1 = dispatch_1;
  }
  _PendingEvents_schedule_closure.builtin$cls = "_PendingEvents_schedule_closure";
  if (!"name" in _PendingEvents_schedule_closure)
    _PendingEvents_schedule_closure.name = "_PendingEvents_schedule_closure";
  $desc = $collectedClasses._PendingEvents_schedule_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _PendingEvents_schedule_closure.prototype = $desc;
  function _StreamImplEvents(firstPendingEvent, lastPendingEvent, _state) {
    this.firstPendingEvent = firstPendingEvent;
    this.lastPendingEvent = lastPendingEvent;
    this._state = _state;
  }
  _StreamImplEvents.builtin$cls = "_StreamImplEvents";
  if (!"name" in _StreamImplEvents)
    _StreamImplEvents.name = "_StreamImplEvents";
  $desc = $collectedClasses._StreamImplEvents;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _StreamImplEvents.prototype = $desc;
  function _cancelAndError_closure(future_0, error_1, stackTrace_2) {
    this.future_0 = future_0;
    this.error_1 = error_1;
    this.stackTrace_2 = stackTrace_2;
  }
  _cancelAndError_closure.builtin$cls = "_cancelAndError_closure";
  if (!"name" in _cancelAndError_closure)
    _cancelAndError_closure.name = "_cancelAndError_closure";
  $desc = $collectedClasses._cancelAndError_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _cancelAndError_closure.prototype = $desc;
  function _cancelAndErrorClosure_closure(subscription_0, future_1) {
    this.subscription_0 = subscription_0;
    this.future_1 = future_1;
  }
  _cancelAndErrorClosure_closure.builtin$cls = "_cancelAndErrorClosure_closure";
  if (!"name" in _cancelAndErrorClosure_closure)
    _cancelAndErrorClosure_closure.name = "_cancelAndErrorClosure_closure";
  $desc = $collectedClasses._cancelAndErrorClosure_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _cancelAndErrorClosure_closure.prototype = $desc;
  function _cancelAndValue_closure(future_0, value_1) {
    this.future_0 = future_0;
    this.value_1 = value_1;
  }
  _cancelAndValue_closure.builtin$cls = "_cancelAndValue_closure";
  if (!"name" in _cancelAndValue_closure)
    _cancelAndValue_closure.name = "_cancelAndValue_closure";
  $desc = $collectedClasses._cancelAndValue_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _cancelAndValue_closure.prototype = $desc;
  function _ForwardingStream() {
  }
  _ForwardingStream.builtin$cls = "_ForwardingStream";
  if (!"name" in _ForwardingStream)
    _ForwardingStream.name = "_ForwardingStream";
  $desc = $collectedClasses._ForwardingStream;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ForwardingStream.prototype = $desc;
  function _ForwardingStreamSubscription(_stream, _subscription, _onData, _onError, _onDone, _zone, _state, _cancelFuture, _pending) {
    this._stream = _stream;
    this._subscription = _subscription;
    this._onData = _onData;
    this._onError = _onError;
    this._onDone = _onDone;
    this._zone = _zone;
    this._state = _state;
    this._cancelFuture = _cancelFuture;
    this._pending = _pending;
  }
  _ForwardingStreamSubscription.builtin$cls = "_ForwardingStreamSubscription";
  if (!"name" in _ForwardingStreamSubscription)
    _ForwardingStreamSubscription.name = "_ForwardingStreamSubscription";
  $desc = $collectedClasses._ForwardingStreamSubscription;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ForwardingStreamSubscription.prototype = $desc;
  function _SkipStream(_remaining, _source) {
    this._remaining = _remaining;
    this._source = _source;
  }
  _SkipStream.builtin$cls = "_SkipStream";
  if (!"name" in _SkipStream)
    _SkipStream.name = "_SkipStream";
  $desc = $collectedClasses._SkipStream;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SkipStream.prototype = $desc;
  function _BaseZone() {
  }
  _BaseZone.builtin$cls = "_BaseZone";
  if (!"name" in _BaseZone)
    _BaseZone.name = "_BaseZone";
  $desc = $collectedClasses._BaseZone;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BaseZone.prototype = $desc;
  function _BaseZone_bindCallback_closure(this_0, registered_1) {
    this.this_0 = this_0;
    this.registered_1 = registered_1;
  }
  _BaseZone_bindCallback_closure.builtin$cls = "_BaseZone_bindCallback_closure";
  if (!"name" in _BaseZone_bindCallback_closure)
    _BaseZone_bindCallback_closure.name = "_BaseZone_bindCallback_closure";
  $desc = $collectedClasses._BaseZone_bindCallback_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BaseZone_bindCallback_closure.prototype = $desc;
  function _BaseZone_bindCallback_closure0(this_2, registered_3) {
    this.this_2 = this_2;
    this.registered_3 = registered_3;
  }
  _BaseZone_bindCallback_closure0.builtin$cls = "_BaseZone_bindCallback_closure0";
  if (!"name" in _BaseZone_bindCallback_closure0)
    _BaseZone_bindCallback_closure0.name = "_BaseZone_bindCallback_closure0";
  $desc = $collectedClasses._BaseZone_bindCallback_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BaseZone_bindCallback_closure0.prototype = $desc;
  function _BaseZone_bindUnaryCallback_closure(this_0, registered_1) {
    this.this_0 = this_0;
    this.registered_1 = registered_1;
  }
  _BaseZone_bindUnaryCallback_closure.builtin$cls = "_BaseZone_bindUnaryCallback_closure";
  if (!"name" in _BaseZone_bindUnaryCallback_closure)
    _BaseZone_bindUnaryCallback_closure.name = "_BaseZone_bindUnaryCallback_closure";
  $desc = $collectedClasses._BaseZone_bindUnaryCallback_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BaseZone_bindUnaryCallback_closure.prototype = $desc;
  function _BaseZone_bindUnaryCallback_closure0(this_2, registered_3) {
    this.this_2 = this_2;
    this.registered_3 = registered_3;
  }
  _BaseZone_bindUnaryCallback_closure0.builtin$cls = "_BaseZone_bindUnaryCallback_closure0";
  if (!"name" in _BaseZone_bindUnaryCallback_closure0)
    _BaseZone_bindUnaryCallback_closure0.name = "_BaseZone_bindUnaryCallback_closure0";
  $desc = $collectedClasses._BaseZone_bindUnaryCallback_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _BaseZone_bindUnaryCallback_closure0.prototype = $desc;
  function _rootHandleUncaughtError_closure(error_0, stackTrace_1) {
    this.error_0 = error_0;
    this.stackTrace_1 = stackTrace_1;
  }
  _rootHandleUncaughtError_closure.builtin$cls = "_rootHandleUncaughtError_closure";
  if (!"name" in _rootHandleUncaughtError_closure)
    _rootHandleUncaughtError_closure.name = "_rootHandleUncaughtError_closure";
  $desc = $collectedClasses._rootHandleUncaughtError_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _rootHandleUncaughtError_closure.prototype = $desc;
  function _rootHandleUncaughtError__closure(error_2, stackTrace_3) {
    this.error_2 = error_2;
    this.stackTrace_3 = stackTrace_3;
  }
  _rootHandleUncaughtError__closure.builtin$cls = "_rootHandleUncaughtError__closure";
  if (!"name" in _rootHandleUncaughtError__closure)
    _rootHandleUncaughtError__closure.name = "_rootHandleUncaughtError__closure";
  $desc = $collectedClasses._rootHandleUncaughtError__closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _rootHandleUncaughtError__closure.prototype = $desc;
  function _RootZone() {
  }
  _RootZone.builtin$cls = "_RootZone";
  if (!"name" in _RootZone)
    _RootZone.name = "_RootZone";
  $desc = $collectedClasses._RootZone;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _RootZone.prototype = $desc;
  function _HashMap(_collection$_length, _strings, _nums, _rest, _keys) {
    this._collection$_length = _collection$_length;
    this._strings = _strings;
    this._nums = _nums;
    this._rest = _rest;
    this._keys = _keys;
  }
  _HashMap.builtin$cls = "_HashMap";
  if (!"name" in _HashMap)
    _HashMap.name = "_HashMap";
  $desc = $collectedClasses._HashMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HashMap.prototype = $desc;
  function _HashMap_values_closure(this_0) {
    this.this_0 = this_0;
  }
  _HashMap_values_closure.builtin$cls = "_HashMap_values_closure";
  if (!"name" in _HashMap_values_closure)
    _HashMap_values_closure.name = "_HashMap_values_closure";
  $desc = $collectedClasses._HashMap_values_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HashMap_values_closure.prototype = $desc;
  function HashMapKeyIterable(_map) {
    this._map = _map;
  }
  HashMapKeyIterable.builtin$cls = "HashMapKeyIterable";
  if (!"name" in HashMapKeyIterable)
    HashMapKeyIterable.name = "HashMapKeyIterable";
  $desc = $collectedClasses.HashMapKeyIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HashMapKeyIterable.prototype = $desc;
  function HashMapKeyIterator(_map, _keys, _offset, _collection$_current) {
    this._map = _map;
    this._keys = _keys;
    this._offset = _offset;
    this._collection$_current = _collection$_current;
  }
  HashMapKeyIterator.builtin$cls = "HashMapKeyIterator";
  if (!"name" in HashMapKeyIterator)
    HashMapKeyIterator.name = "HashMapKeyIterator";
  $desc = $collectedClasses.HashMapKeyIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HashMapKeyIterator.prototype = $desc;
  function _LinkedHashMap(_collection$_length, _strings, _nums, _rest, _first, _last, _modifications) {
    this._collection$_length = _collection$_length;
    this._strings = _strings;
    this._nums = _nums;
    this._rest = _rest;
    this._first = _first;
    this._last = _last;
    this._modifications = _modifications;
  }
  _LinkedHashMap.builtin$cls = "_LinkedHashMap";
  if (!"name" in _LinkedHashMap)
    _LinkedHashMap.name = "_LinkedHashMap";
  $desc = $collectedClasses._LinkedHashMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _LinkedHashMap.prototype = $desc;
  function _LinkedHashMap_values_closure(this_0) {
    this.this_0 = this_0;
  }
  _LinkedHashMap_values_closure.builtin$cls = "_LinkedHashMap_values_closure";
  if (!"name" in _LinkedHashMap_values_closure)
    _LinkedHashMap_values_closure.name = "_LinkedHashMap_values_closure";
  $desc = $collectedClasses._LinkedHashMap_values_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _LinkedHashMap_values_closure.prototype = $desc;
  function _LinkedHashMap_addAll_closure(this_0) {
    this.this_0 = this_0;
  }
  _LinkedHashMap_addAll_closure.builtin$cls = "_LinkedHashMap_addAll_closure";
  if (!"name" in _LinkedHashMap_addAll_closure)
    _LinkedHashMap_addAll_closure.name = "_LinkedHashMap_addAll_closure";
  $desc = $collectedClasses._LinkedHashMap_addAll_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _LinkedHashMap_addAll_closure.prototype = $desc;
  function LinkedHashMapCell(_key, _collection$_value, _next, _previous) {
    this._key = _key;
    this._collection$_value = _collection$_value;
    this._next = _next;
    this._previous = _previous;
  }
  LinkedHashMapCell.builtin$cls = "LinkedHashMapCell";
  if (!"name" in LinkedHashMapCell)
    LinkedHashMapCell.name = "LinkedHashMapCell";
  $desc = $collectedClasses.LinkedHashMapCell;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LinkedHashMapCell.prototype = $desc;
  LinkedHashMapCell.prototype.get$_key = function() {
    return this._key;
  };
  LinkedHashMapCell.prototype.get$_collection$_value = function() {
    return this._collection$_value;
  };
  LinkedHashMapCell.prototype.set$_collection$_value = function(v) {
    return this._collection$_value = v;
  };
  LinkedHashMapCell.prototype.get$_next = function() {
    return this._next;
  };
  LinkedHashMapCell.prototype.set$_next = function(v) {
    return this._next = v;
  };
  LinkedHashMapCell.prototype.get$_previous = function() {
    return this._previous;
  };
  LinkedHashMapCell.prototype.set$_previous = function(v) {
    return this._previous = v;
  };
  function LinkedHashMapKeyIterable(_map) {
    this._map = _map;
  }
  LinkedHashMapKeyIterable.builtin$cls = "LinkedHashMapKeyIterable";
  if (!"name" in LinkedHashMapKeyIterable)
    LinkedHashMapKeyIterable.name = "LinkedHashMapKeyIterable";
  $desc = $collectedClasses.LinkedHashMapKeyIterable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LinkedHashMapKeyIterable.prototype = $desc;
  function LinkedHashMapKeyIterator(_map, _modifications, _cell, _collection$_current) {
    this._map = _map;
    this._modifications = _modifications;
    this._cell = _cell;
    this._collection$_current = _collection$_current;
  }
  LinkedHashMapKeyIterator.builtin$cls = "LinkedHashMapKeyIterator";
  if (!"name" in LinkedHashMapKeyIterator)
    LinkedHashMapKeyIterator.name = "LinkedHashMapKeyIterator";
  $desc = $collectedClasses.LinkedHashMapKeyIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LinkedHashMapKeyIterator.prototype = $desc;
  function _HashSet() {
  }
  _HashSet.builtin$cls = "_HashSet";
  if (!"name" in _HashSet)
    _HashSet.name = "_HashSet";
  $desc = $collectedClasses._HashSet;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HashSet.prototype = $desc;
  function _IdentityHashSet(_collection$_length, _strings, _nums, _rest, _elements) {
    this._collection$_length = _collection$_length;
    this._strings = _strings;
    this._nums = _nums;
    this._rest = _rest;
    this._elements = _elements;
  }
  _IdentityHashSet.builtin$cls = "_IdentityHashSet";
  if (!"name" in _IdentityHashSet)
    _IdentityHashSet.name = "_IdentityHashSet";
  $desc = $collectedClasses._IdentityHashSet;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _IdentityHashSet.prototype = $desc;
  function HashSetIterator(_set, _elements, _offset, _collection$_current) {
    this._set = _set;
    this._elements = _elements;
    this._offset = _offset;
    this._collection$_current = _collection$_current;
  }
  HashSetIterator.builtin$cls = "HashSetIterator";
  if (!"name" in HashSetIterator)
    HashSetIterator.name = "HashSetIterator";
  $desc = $collectedClasses.HashSetIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HashSetIterator.prototype = $desc;
  function _LinkedHashSet(_collection$_length, _strings, _nums, _rest, _first, _last, _modifications) {
    this._collection$_length = _collection$_length;
    this._strings = _strings;
    this._nums = _nums;
    this._rest = _rest;
    this._first = _first;
    this._last = _last;
    this._modifications = _modifications;
  }
  _LinkedHashSet.builtin$cls = "_LinkedHashSet";
  if (!"name" in _LinkedHashSet)
    _LinkedHashSet.name = "_LinkedHashSet";
  $desc = $collectedClasses._LinkedHashSet;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _LinkedHashSet.prototype = $desc;
  function LinkedHashSetCell(_collection$_element, _next, _previous) {
    this._collection$_element = _collection$_element;
    this._next = _next;
    this._previous = _previous;
  }
  LinkedHashSetCell.builtin$cls = "LinkedHashSetCell";
  if (!"name" in LinkedHashSetCell)
    LinkedHashSetCell.name = "LinkedHashSetCell";
  $desc = $collectedClasses.LinkedHashSetCell;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LinkedHashSetCell.prototype = $desc;
  LinkedHashSetCell.prototype.get$_collection$_element = function() {
    return this._collection$_element;
  };
  LinkedHashSetCell.prototype.get$_next = function() {
    return this._next;
  };
  LinkedHashSetCell.prototype.set$_next = function(v) {
    return this._next = v;
  };
  LinkedHashSetCell.prototype.get$_previous = function() {
    return this._previous;
  };
  LinkedHashSetCell.prototype.set$_previous = function(v) {
    return this._previous = v;
  };
  function LinkedHashSetIterator(_set, _modifications, _cell, _collection$_current) {
    this._set = _set;
    this._modifications = _modifications;
    this._cell = _cell;
    this._collection$_current = _collection$_current;
  }
  LinkedHashSetIterator.builtin$cls = "LinkedHashSetIterator";
  if (!"name" in LinkedHashSetIterator)
    LinkedHashSetIterator.name = "LinkedHashSetIterator";
  $desc = $collectedClasses.LinkedHashSetIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LinkedHashSetIterator.prototype = $desc;
  function _HashSetBase() {
  }
  _HashSetBase.builtin$cls = "_HashSetBase";
  if (!"name" in _HashSetBase)
    _HashSetBase.name = "_HashSetBase";
  $desc = $collectedClasses._HashSetBase;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HashSetBase.prototype = $desc;
  function IterableBase() {
  }
  IterableBase.builtin$cls = "IterableBase";
  if (!"name" in IterableBase)
    IterableBase.name = "IterableBase";
  $desc = $collectedClasses.IterableBase;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IterableBase.prototype = $desc;
  function ListBase() {
  }
  ListBase.builtin$cls = "ListBase";
  if (!"name" in ListBase)
    ListBase.name = "ListBase";
  $desc = $collectedClasses.ListBase;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ListBase.prototype = $desc;
  function ListMixin() {
  }
  ListMixin.builtin$cls = "ListMixin";
  if (!"name" in ListMixin)
    ListMixin.name = "ListMixin";
  $desc = $collectedClasses.ListMixin;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ListMixin.prototype = $desc;
  function Maps_mapToString_closure(box_0, result_1) {
    this.box_0 = box_0;
    this.result_1 = result_1;
  }
  Maps_mapToString_closure.builtin$cls = "Maps_mapToString_closure";
  if (!"name" in Maps_mapToString_closure)
    Maps_mapToString_closure.name = "Maps_mapToString_closure";
  $desc = $collectedClasses.Maps_mapToString_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Maps_mapToString_closure.prototype = $desc;
  function ListQueue(_collection$_table, _head, _tail, _modificationCount) {
    this._collection$_table = _collection$_table;
    this._head = _head;
    this._tail = _tail;
    this._modificationCount = _modificationCount;
  }
  ListQueue.builtin$cls = "ListQueue";
  if (!"name" in ListQueue)
    ListQueue.name = "ListQueue";
  $desc = $collectedClasses.ListQueue;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ListQueue.prototype = $desc;
  function _ListQueueIterator(_queue, _end, _modificationCount, _collection$_position, _collection$_current) {
    this._queue = _queue;
    this._end = _end;
    this._modificationCount = _modificationCount;
    this._collection$_position = _collection$_position;
    this._collection$_current = _collection$_current;
  }
  _ListQueueIterator.builtin$cls = "_ListQueueIterator";
  if (!"name" in _ListQueueIterator)
    _ListQueueIterator.name = "_ListQueueIterator";
  $desc = $collectedClasses._ListQueueIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ListQueueIterator.prototype = $desc;
  function NoSuchMethodError_toString_closure(box_0) {
    this.box_0 = box_0;
  }
  NoSuchMethodError_toString_closure.builtin$cls = "NoSuchMethodError_toString_closure";
  if (!"name" in NoSuchMethodError_toString_closure)
    NoSuchMethodError_toString_closure.name = "NoSuchMethodError_toString_closure";
  $desc = $collectedClasses.NoSuchMethodError_toString_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NoSuchMethodError_toString_closure.prototype = $desc;
  function Comparable() {
  }
  Comparable.builtin$cls = "Comparable";
  if (!"name" in Comparable)
    Comparable.name = "Comparable";
  $desc = $collectedClasses.Comparable;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Comparable.prototype = $desc;
  function DateTime(millisecondsSinceEpoch, isUtc) {
    this.millisecondsSinceEpoch = millisecondsSinceEpoch;
    this.isUtc = isUtc;
  }
  DateTime.builtin$cls = "DateTime";
  if (!"name" in DateTime)
    DateTime.name = "DateTime";
  $desc = $collectedClasses.DateTime;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DateTime.prototype = $desc;
  DateTime.prototype.get$millisecondsSinceEpoch = function() {
    return this.millisecondsSinceEpoch;
  };
  function Duration(_duration) {
    this._duration = _duration;
  }
  Duration.builtin$cls = "Duration";
  if (!"name" in Duration)
    Duration.name = "Duration";
  $desc = $collectedClasses.Duration;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Duration.prototype = $desc;
  Duration.prototype.get$_duration = function() {
    return this._duration;
  };
  function Duration_toString_sixDigits() {
  }
  Duration_toString_sixDigits.builtin$cls = "Duration_toString_sixDigits";
  if (!"name" in Duration_toString_sixDigits)
    Duration_toString_sixDigits.name = "Duration_toString_sixDigits";
  $desc = $collectedClasses.Duration_toString_sixDigits;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Duration_toString_sixDigits.prototype = $desc;
  function Duration_toString_twoDigits() {
  }
  Duration_toString_twoDigits.builtin$cls = "Duration_toString_twoDigits";
  if (!"name" in Duration_toString_twoDigits)
    Duration_toString_twoDigits.name = "Duration_toString_twoDigits";
  $desc = $collectedClasses.Duration_toString_twoDigits;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Duration_toString_twoDigits.prototype = $desc;
  function Error() {
  }
  Error.builtin$cls = "Error";
  if (!"name" in Error)
    Error.name = "Error";
  $desc = $collectedClasses.Error;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Error.prototype = $desc;
  function NullThrownError() {
  }
  NullThrownError.builtin$cls = "NullThrownError";
  if (!"name" in NullThrownError)
    NullThrownError.name = "NullThrownError";
  $desc = $collectedClasses.NullThrownError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NullThrownError.prototype = $desc;
  function ArgumentError(message) {
    this.message = message;
  }
  ArgumentError.builtin$cls = "ArgumentError";
  if (!"name" in ArgumentError)
    ArgumentError.name = "ArgumentError";
  $desc = $collectedClasses.ArgumentError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ArgumentError.prototype = $desc;
  function RangeError(message) {
    this.message = message;
  }
  RangeError.builtin$cls = "RangeError";
  if (!"name" in RangeError)
    RangeError.name = "RangeError";
  $desc = $collectedClasses.RangeError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RangeError.prototype = $desc;
  function UnsupportedError(message) {
    this.message = message;
  }
  UnsupportedError.builtin$cls = "UnsupportedError";
  if (!"name" in UnsupportedError)
    UnsupportedError.name = "UnsupportedError";
  $desc = $collectedClasses.UnsupportedError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UnsupportedError.prototype = $desc;
  function UnimplementedError(message) {
    this.message = message;
  }
  UnimplementedError.builtin$cls = "UnimplementedError";
  if (!"name" in UnimplementedError)
    UnimplementedError.name = "UnimplementedError";
  $desc = $collectedClasses.UnimplementedError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UnimplementedError.prototype = $desc;
  function StateError(message) {
    this.message = message;
  }
  StateError.builtin$cls = "StateError";
  if (!"name" in StateError)
    StateError.name = "StateError";
  $desc = $collectedClasses.StateError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StateError.prototype = $desc;
  function ConcurrentModificationError(modifiedObject) {
    this.modifiedObject = modifiedObject;
  }
  ConcurrentModificationError.builtin$cls = "ConcurrentModificationError";
  if (!"name" in ConcurrentModificationError)
    ConcurrentModificationError.name = "ConcurrentModificationError";
  $desc = $collectedClasses.ConcurrentModificationError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ConcurrentModificationError.prototype = $desc;
  function OutOfMemoryError() {
  }
  OutOfMemoryError.builtin$cls = "OutOfMemoryError";
  if (!"name" in OutOfMemoryError)
    OutOfMemoryError.name = "OutOfMemoryError";
  $desc = $collectedClasses.OutOfMemoryError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OutOfMemoryError.prototype = $desc;
  function StackOverflowError() {
  }
  StackOverflowError.builtin$cls = "StackOverflowError";
  if (!"name" in StackOverflowError)
    StackOverflowError.name = "StackOverflowError";
  $desc = $collectedClasses.StackOverflowError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StackOverflowError.prototype = $desc;
  function CyclicInitializationError(variableName) {
    this.variableName = variableName;
  }
  CyclicInitializationError.builtin$cls = "CyclicInitializationError";
  if (!"name" in CyclicInitializationError)
    CyclicInitializationError.name = "CyclicInitializationError";
  $desc = $collectedClasses.CyclicInitializationError;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CyclicInitializationError.prototype = $desc;
  function _ExceptionImplementation(message) {
    this.message = message;
  }
  _ExceptionImplementation.builtin$cls = "_ExceptionImplementation";
  if (!"name" in _ExceptionImplementation)
    _ExceptionImplementation.name = "_ExceptionImplementation";
  $desc = $collectedClasses._ExceptionImplementation;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ExceptionImplementation.prototype = $desc;
  function FormatException(message) {
    this.message = message;
  }
  FormatException.builtin$cls = "FormatException";
  if (!"name" in FormatException)
    FormatException.name = "FormatException";
  $desc = $collectedClasses.FormatException;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FormatException.prototype = $desc;
  function IntegerDivisionByZeroException() {
  }
  IntegerDivisionByZeroException.builtin$cls = "IntegerDivisionByZeroException";
  if (!"name" in IntegerDivisionByZeroException)
    IntegerDivisionByZeroException.name = "IntegerDivisionByZeroException";
  $desc = $collectedClasses.IntegerDivisionByZeroException;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IntegerDivisionByZeroException.prototype = $desc;
  function Expando(name) {
    this.name = name;
  }
  Expando.builtin$cls = "Expando";
  if (!"name" in Expando)
    Expando.name = "Expando";
  $desc = $collectedClasses.Expando;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Expando.prototype = $desc;
  Expando.prototype.get$name = function(receiver) {
    return this.name;
  };
  function Function() {
  }
  Function.builtin$cls = "Function";
  if (!"name" in Function)
    Function.name = "Function";
  $desc = $collectedClasses.Function;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Function.prototype = $desc;
  function Iterator() {
  }
  Iterator.builtin$cls = "Iterator";
  if (!"name" in Iterator)
    Iterator.name = "Iterator";
  $desc = $collectedClasses.Iterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Iterator.prototype = $desc;
  function Map() {
  }
  Map.builtin$cls = "Map";
  if (!"name" in Map)
    Map.name = "Map";
  $desc = $collectedClasses.Map;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Map.prototype = $desc;
  function Null() {
  }
  Null.builtin$cls = "Null";
  if (!"name" in Null)
    Null.name = "Null";
  $desc = $collectedClasses.Null;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Null.prototype = $desc;
  function Object() {
  }
  Object.builtin$cls = "Object";
  if (!"name" in Object)
    Object.name = "Object";
  $desc = $collectedClasses.Object;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Object.prototype = $desc;
  function Pattern() {
  }
  Pattern.builtin$cls = "Pattern";
  if (!"name" in Pattern)
    Pattern.name = "Pattern";
  $desc = $collectedClasses.Pattern;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Pattern.prototype = $desc;
  function StackTrace() {
  }
  StackTrace.builtin$cls = "StackTrace";
  if (!"name" in StackTrace)
    StackTrace.name = "StackTrace";
  $desc = $collectedClasses.StackTrace;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StackTrace.prototype = $desc;
  function Stopwatch(frequency, _start, _stop) {
    this.frequency = frequency;
    this._start = _start;
    this._stop = _stop;
  }
  Stopwatch.builtin$cls = "Stopwatch";
  if (!"name" in Stopwatch)
    Stopwatch.name = "Stopwatch";
  $desc = $collectedClasses.Stopwatch;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Stopwatch.prototype = $desc;
  function StringBuffer(_contents) {
    this._contents = _contents;
  }
  StringBuffer.builtin$cls = "StringBuffer";
  if (!"name" in StringBuffer)
    StringBuffer.name = "StringBuffer";
  $desc = $collectedClasses.StringBuffer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StringBuffer.prototype = $desc;
  StringBuffer.prototype.get$_contents = function() {
    return this._contents;
  };
  function Symbol() {
  }
  Symbol.builtin$cls = "Symbol";
  if (!"name" in Symbol)
    Symbol.name = "Symbol";
  $desc = $collectedClasses.Symbol;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Symbol.prototype = $desc;
  function _ChildrenElementList(_element, _childElements) {
    this._element = _element;
    this._childElements = _childElements;
  }
  _ChildrenElementList.builtin$cls = "_ChildrenElementList";
  if (!"name" in _ChildrenElementList)
    _ChildrenElementList.name = "_ChildrenElementList";
  $desc = $collectedClasses._ChildrenElementList;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ChildrenElementList.prototype = $desc;
  function Interceptor_ListMixin() {
  }
  Interceptor_ListMixin.builtin$cls = "Interceptor_ListMixin";
  if (!"name" in Interceptor_ListMixin)
    Interceptor_ListMixin.name = "Interceptor_ListMixin";
  $desc = $collectedClasses.Interceptor_ListMixin;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Interceptor_ListMixin.prototype = $desc;
  function Interceptor_ListMixin_ImmutableListMixin() {
  }
  Interceptor_ListMixin_ImmutableListMixin.builtin$cls = "Interceptor_ListMixin_ImmutableListMixin";
  if (!"name" in Interceptor_ListMixin_ImmutableListMixin)
    Interceptor_ListMixin_ImmutableListMixin.name = "Interceptor_ListMixin_ImmutableListMixin";
  $desc = $collectedClasses.Interceptor_ListMixin_ImmutableListMixin;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Interceptor_ListMixin_ImmutableListMixin.prototype = $desc;
  function HttpRequest_request_closure0(xhr_0) {
    this.xhr_0 = xhr_0;
  }
  HttpRequest_request_closure0.builtin$cls = "HttpRequest_request_closure0";
  if (!"name" in HttpRequest_request_closure0)
    HttpRequest_request_closure0.name = "HttpRequest_request_closure0";
  $desc = $collectedClasses.HttpRequest_request_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HttpRequest_request_closure0.prototype = $desc;
  function HttpRequest_request_closure(completer_1, xhr_2) {
    this.completer_1 = completer_1;
    this.xhr_2 = xhr_2;
  }
  HttpRequest_request_closure.builtin$cls = "HttpRequest_request_closure";
  if (!"name" in HttpRequest_request_closure)
    HttpRequest_request_closure.name = "HttpRequest_request_closure";
  $desc = $collectedClasses.HttpRequest_request_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HttpRequest_request_closure.prototype = $desc;
  function _ChildNodeListLazy(_this) {
    this._this = _this;
  }
  _ChildNodeListLazy.builtin$cls = "_ChildNodeListLazy";
  if (!"name" in _ChildNodeListLazy)
    _ChildNodeListLazy.name = "_ChildNodeListLazy";
  $desc = $collectedClasses._ChildNodeListLazy;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _ChildNodeListLazy.prototype = $desc;
  function Interceptor_ListMixin0() {
  }
  Interceptor_ListMixin0.builtin$cls = "Interceptor_ListMixin0";
  if (!"name" in Interceptor_ListMixin0)
    Interceptor_ListMixin0.name = "Interceptor_ListMixin0";
  $desc = $collectedClasses.Interceptor_ListMixin0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Interceptor_ListMixin0.prototype = $desc;
  function Interceptor_ListMixin_ImmutableListMixin0() {
  }
  Interceptor_ListMixin_ImmutableListMixin0.builtin$cls = "Interceptor_ListMixin_ImmutableListMixin0";
  if (!"name" in Interceptor_ListMixin_ImmutableListMixin0)
    Interceptor_ListMixin_ImmutableListMixin0.name = "Interceptor_ListMixin_ImmutableListMixin0";
  $desc = $collectedClasses.Interceptor_ListMixin_ImmutableListMixin0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Interceptor_ListMixin_ImmutableListMixin0.prototype = $desc;
  function Interceptor_ListMixin1() {
  }
  Interceptor_ListMixin1.builtin$cls = "Interceptor_ListMixin1";
  if (!"name" in Interceptor_ListMixin1)
    Interceptor_ListMixin1.name = "Interceptor_ListMixin1";
  $desc = $collectedClasses.Interceptor_ListMixin1;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Interceptor_ListMixin1.prototype = $desc;
  function Interceptor_ListMixin_ImmutableListMixin1() {
  }
  Interceptor_ListMixin_ImmutableListMixin1.builtin$cls = "Interceptor_ListMixin_ImmutableListMixin1";
  if (!"name" in Interceptor_ListMixin_ImmutableListMixin1)
    Interceptor_ListMixin_ImmutableListMixin1.name = "Interceptor_ListMixin_ImmutableListMixin1";
  $desc = $collectedClasses.Interceptor_ListMixin_ImmutableListMixin1;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Interceptor_ListMixin_ImmutableListMixin1.prototype = $desc;
  function EventStreamProvider(_eventType) {
    this._eventType = _eventType;
  }
  EventStreamProvider.builtin$cls = "EventStreamProvider";
  if (!"name" in EventStreamProvider)
    EventStreamProvider.name = "EventStreamProvider";
  $desc = $collectedClasses.EventStreamProvider;
  if ($desc instanceof Array)
    $desc = $desc[1];
  EventStreamProvider.prototype = $desc;
  function _EventStream(_html$_target, _eventType, _useCapture) {
    this._html$_target = _html$_target;
    this._eventType = _eventType;
    this._useCapture = _useCapture;
  }
  _EventStream.builtin$cls = "_EventStream";
  if (!"name" in _EventStream)
    _EventStream.name = "_EventStream";
  $desc = $collectedClasses._EventStream;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _EventStream.prototype = $desc;
  function _EventStreamSubscription(_pauseCount, _html$_target, _eventType, _html$_onData, _useCapture) {
    this._pauseCount = _pauseCount;
    this._html$_target = _html$_target;
    this._eventType = _eventType;
    this._html$_onData = _html$_onData;
    this._useCapture = _useCapture;
  }
  _EventStreamSubscription.builtin$cls = "_EventStreamSubscription";
  if (!"name" in _EventStreamSubscription)
    _EventStreamSubscription.name = "_EventStreamSubscription";
  $desc = $collectedClasses._EventStreamSubscription;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _EventStreamSubscription.prototype = $desc;
  function ImmutableListMixin() {
  }
  ImmutableListMixin.builtin$cls = "ImmutableListMixin";
  if (!"name" in ImmutableListMixin)
    ImmutableListMixin.name = "ImmutableListMixin";
  $desc = $collectedClasses.ImmutableListMixin;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ImmutableListMixin.prototype = $desc;
  function FixedSizeListIterator(_array, _html$_length, _position, _html$_current) {
    this._array = _array;
    this._html$_length = _html$_length;
    this._position = _position;
    this._html$_current = _html$_current;
  }
  FixedSizeListIterator.builtin$cls = "FixedSizeListIterator";
  if (!"name" in FixedSizeListIterator)
    FixedSizeListIterator.name = "FixedSizeListIterator";
  $desc = $collectedClasses.FixedSizeListIterator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FixedSizeListIterator.prototype = $desc;
  function Capability() {
  }
  Capability.builtin$cls = "Capability";
  if (!"name" in Capability)
    Capability.name = "Capability";
  $desc = $collectedClasses.Capability;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Capability.prototype = $desc;
  function SendPort() {
  }
  SendPort.builtin$cls = "SendPort";
  if (!"name" in SendPort)
    SendPort.name = "SendPort";
  $desc = $collectedClasses.SendPort;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SendPort.prototype = $desc;
  function _JSRandom() {
  }
  _JSRandom.builtin$cls = "_JSRandom";
  if (!"name" in _JSRandom)
    _JSRandom.name = "_JSRandom";
  $desc = $collectedClasses._JSRandom;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _JSRandom.prototype = $desc;
  function Float32List() {
  }
  Float32List.builtin$cls = "Float32List";
  if (!"name" in Float32List)
    Float32List.name = "Float32List";
  $desc = $collectedClasses.Float32List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Float32List.prototype = $desc;
  function Uint32List() {
  }
  Uint32List.builtin$cls = "Uint32List";
  if (!"name" in Uint32List)
    Uint32List.name = "Uint32List";
  $desc = $collectedClasses.Uint32List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Uint32List.prototype = $desc;
  function Uint8List() {
  }
  Uint8List.builtin$cls = "Uint8List";
  if (!"name" in Uint8List)
    Uint8List.name = "Uint8List";
  $desc = $collectedClasses.Uint8List;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Uint8List.prototype = $desc;
  function NativeTypedArray() {
  }
  NativeTypedArray.builtin$cls = "NativeTypedArray";
  if (!"name" in NativeTypedArray)
    NativeTypedArray.name = "NativeTypedArray";
  $desc = $collectedClasses.NativeTypedArray;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeTypedArray.prototype = $desc;
  function NativeTypedArrayOfDouble() {
  }
  NativeTypedArrayOfDouble.builtin$cls = "NativeTypedArrayOfDouble";
  if (!"name" in NativeTypedArrayOfDouble)
    NativeTypedArrayOfDouble.name = "NativeTypedArrayOfDouble";
  $desc = $collectedClasses.NativeTypedArrayOfDouble;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeTypedArrayOfDouble.prototype = $desc;
  function NativeTypedArray_ListMixin() {
  }
  NativeTypedArray_ListMixin.builtin$cls = "NativeTypedArray_ListMixin";
  if (!"name" in NativeTypedArray_ListMixin)
    NativeTypedArray_ListMixin.name = "NativeTypedArray_ListMixin";
  $desc = $collectedClasses.NativeTypedArray_ListMixin;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeTypedArray_ListMixin.prototype = $desc;
  function NativeTypedArray_ListMixin_FixedLengthListMixin() {
  }
  NativeTypedArray_ListMixin_FixedLengthListMixin.builtin$cls = "NativeTypedArray_ListMixin_FixedLengthListMixin";
  if (!"name" in NativeTypedArray_ListMixin_FixedLengthListMixin)
    NativeTypedArray_ListMixin_FixedLengthListMixin.name = "NativeTypedArray_ListMixin_FixedLengthListMixin";
  $desc = $collectedClasses.NativeTypedArray_ListMixin_FixedLengthListMixin;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = $desc;
  function NativeTypedArrayOfInt() {
  }
  NativeTypedArrayOfInt.builtin$cls = "NativeTypedArrayOfInt";
  if (!"name" in NativeTypedArrayOfInt)
    NativeTypedArrayOfInt.name = "NativeTypedArrayOfInt";
  $desc = $collectedClasses.NativeTypedArrayOfInt;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeTypedArrayOfInt.prototype = $desc;
  function NativeTypedArray_ListMixin0() {
  }
  NativeTypedArray_ListMixin0.builtin$cls = "NativeTypedArray_ListMixin0";
  if (!"name" in NativeTypedArray_ListMixin0)
    NativeTypedArray_ListMixin0.name = "NativeTypedArray_ListMixin0";
  $desc = $collectedClasses.NativeTypedArray_ListMixin0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeTypedArray_ListMixin0.prototype = $desc;
  function NativeTypedArray_ListMixin_FixedLengthListMixin0() {
  }
  NativeTypedArray_ListMixin_FixedLengthListMixin0.builtin$cls = "NativeTypedArray_ListMixin_FixedLengthListMixin0";
  if (!"name" in NativeTypedArray_ListMixin_FixedLengthListMixin0)
    NativeTypedArray_ListMixin_FixedLengthListMixin0.name = "NativeTypedArray_ListMixin_FixedLengthListMixin0";
  $desc = $collectedClasses.NativeTypedArray_ListMixin_FixedLengthListMixin0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  NativeTypedArray_ListMixin_FixedLengthListMixin0.prototype = $desc;
  function RenderManager(pbrt, isolate, scenePath, includePaths, futures, resources) {
    this.pbrt = pbrt;
    this.isolate = isolate;
    this.scenePath = scenePath;
    this.includePaths = includePaths;
    this.futures = futures;
    this.resources = resources;
  }
  RenderManager.builtin$cls = "RenderManager";
  if (!"name" in RenderManager)
    RenderManager.name = "RenderManager";
  $desc = $collectedClasses.RenderManager;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderManager.prototype = $desc;
  function RenderManager_loadFile_closure(c_0) {
    this.c_0 = c_0;
  }
  RenderManager_loadFile_closure.builtin$cls = "RenderManager_loadFile_closure";
  if (!"name" in RenderManager_loadFile_closure)
    RenderManager_loadFile_closure.name = "RenderManager_loadFile_closure";
  $desc = $collectedClasses.RenderManager_loadFile_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderManager_loadFile_closure.prototype = $desc;
  function RenderManager_loadFile_closure0(c_1) {
    this.c_1 = c_1;
  }
  RenderManager_loadFile_closure0.builtin$cls = "RenderManager_loadFile_closure0";
  if (!"name" in RenderManager_loadFile_closure0)
    RenderManager_loadFile_closure0.name = "RenderManager_loadFile_closure0";
  $desc = $collectedClasses.RenderManager_loadFile_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderManager_loadFile_closure0.prototype = $desc;
  function RenderManager__loadFile_closure(c_1) {
    this.c_1 = c_1;
  }
  RenderManager__loadFile_closure.builtin$cls = "RenderManager__loadFile_closure";
  if (!"name" in RenderManager__loadFile_closure)
    RenderManager__loadFile_closure.name = "RenderManager__loadFile_closure";
  $desc = $collectedClasses.RenderManager__loadFile_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderManager__loadFile_closure.prototype = $desc;
  function RenderManager__loadFile_closure0(c_2) {
    this.c_2 = c_2;
  }
  RenderManager__loadFile_closure0.builtin$cls = "RenderManager__loadFile_closure0";
  if (!"name" in RenderManager__loadFile_closure0)
    RenderManager__loadFile_closure0.name = "RenderManager__loadFile_closure0";
  $desc = $collectedClasses.RenderManager__loadFile_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderManager__loadFile_closure0.prototype = $desc;
  function RenderManager__loadFile_closure1(box_0) {
    this.box_0 = box_0;
  }
  RenderManager__loadFile_closure1.builtin$cls = "RenderManager__loadFile_closure1";
  if (!"name" in RenderManager__loadFile_closure1)
    RenderManager__loadFile_closure1.name = "RenderManager__loadFile_closure1";
  $desc = $collectedClasses.RenderManager__loadFile_closure1;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderManager__loadFile_closure1.prototype = $desc;
  function ImageFilm(cropWindow, image, filename, previewCallback, output, samplesProcessed, previewCount, filter, xPixelStart, yPixelStart, xPixelCount, yPixelCount, _Lxyz, _splatXYZ, _weightSum, _filterTable, _gamma, xResolution, yResolution) {
    this.cropWindow = cropWindow;
    this.image = image;
    this.filename = filename;
    this.previewCallback = previewCallback;
    this.output = output;
    this.samplesProcessed = samplesProcessed;
    this.previewCount = previewCount;
    this.filter = filter;
    this.xPixelStart = xPixelStart;
    this.yPixelStart = yPixelStart;
    this.xPixelCount = xPixelCount;
    this.yPixelCount = yPixelCount;
    this._Lxyz = _Lxyz;
    this._splatXYZ = _splatXYZ;
    this._weightSum = _weightSum;
    this._filterTable = _filterTable;
    this._gamma = _gamma;
    this.xResolution = xResolution;
    this.yResolution = yResolution;
  }
  ImageFilm.builtin$cls = "ImageFilm";
  if (!"name" in ImageFilm)
    ImageFilm.name = "ImageFilm";
  $desc = $collectedClasses.ImageFilm;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ImageFilm.prototype = $desc;
  function BoxFilter(xWidth, yWidth, invXWidth, invYWidth) {
    this.xWidth = xWidth;
    this.yWidth = yWidth;
    this.invXWidth = invXWidth;
    this.invYWidth = invYWidth;
  }
  BoxFilter.builtin$cls = "BoxFilter";
  if (!"name" in BoxFilter)
    BoxFilter.name = "BoxFilter";
  $desc = $collectedClasses.BoxFilter;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BoxFilter.prototype = $desc;
  function GaussianFilter(alpha, expX, expY, xWidth, yWidth, invXWidth, invYWidth) {
    this.alpha = alpha;
    this.expX = expX;
    this.expY = expY;
    this.xWidth = xWidth;
    this.yWidth = yWidth;
    this.invXWidth = invXWidth;
    this.invYWidth = invYWidth;
  }
  GaussianFilter.builtin$cls = "GaussianFilter";
  if (!"name" in GaussianFilter)
    GaussianFilter.name = "GaussianFilter";
  $desc = $collectedClasses.GaussianFilter;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GaussianFilter.prototype = $desc;
  GaussianFilter.prototype.get$alpha = function(receiver) {
    return this.alpha;
  };
  function LanczosSincFilter(tau, xWidth, yWidth, invXWidth, invYWidth) {
    this.tau = tau;
    this.xWidth = xWidth;
    this.yWidth = yWidth;
    this.invXWidth = invXWidth;
    this.invYWidth = invYWidth;
  }
  LanczosSincFilter.builtin$cls = "LanczosSincFilter";
  if (!"name" in LanczosSincFilter)
    LanczosSincFilter.name = "LanczosSincFilter";
  $desc = $collectedClasses.LanczosSincFilter;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LanczosSincFilter.prototype = $desc;
  function MitchellFilter(b, c, xWidth, yWidth, invXWidth, invYWidth) {
    this.b = b;
    this.c = c;
    this.xWidth = xWidth;
    this.yWidth = yWidth;
    this.invXWidth = invXWidth;
    this.invYWidth = invYWidth;
  }
  MitchellFilter.builtin$cls = "MitchellFilter";
  if (!"name" in MitchellFilter)
    MitchellFilter.name = "MitchellFilter";
  $desc = $collectedClasses.MitchellFilter;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MitchellFilter.prototype = $desc;
  MitchellFilter.prototype.get$c = function() {
    return this.c;
  };
  function TriangleFilter(xWidth, yWidth, invXWidth, invYWidth) {
    this.xWidth = xWidth;
    this.yWidth = yWidth;
    this.invXWidth = invXWidth;
    this.invYWidth = invYWidth;
  }
  TriangleFilter.builtin$cls = "TriangleFilter";
  if (!"name" in TriangleFilter)
    TriangleFilter.name = "TriangleFilter";
  $desc = $collectedClasses.TriangleFilter;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TriangleFilter.prototype = $desc;
  function convertNativeToDart_AcceptStructuredClone_findSlot(values_0, copies_1) {
    this.values_0 = values_0;
    this.copies_1 = copies_1;
  }
  convertNativeToDart_AcceptStructuredClone_findSlot.builtin$cls = "convertNativeToDart_AcceptStructuredClone_findSlot";
  if (!"name" in convertNativeToDart_AcceptStructuredClone_findSlot)
    convertNativeToDart_AcceptStructuredClone_findSlot.name = "convertNativeToDart_AcceptStructuredClone_findSlot";
  $desc = $collectedClasses.convertNativeToDart_AcceptStructuredClone_findSlot;
  if ($desc instanceof Array)
    $desc = $desc[1];
  convertNativeToDart_AcceptStructuredClone_findSlot.prototype = $desc;
  function convertNativeToDart_AcceptStructuredClone_readSlot(copies_2) {
    this.copies_2 = copies_2;
  }
  convertNativeToDart_AcceptStructuredClone_readSlot.builtin$cls = "convertNativeToDart_AcceptStructuredClone_readSlot";
  if (!"name" in convertNativeToDart_AcceptStructuredClone_readSlot)
    convertNativeToDart_AcceptStructuredClone_readSlot.name = "convertNativeToDart_AcceptStructuredClone_readSlot";
  $desc = $collectedClasses.convertNativeToDart_AcceptStructuredClone_readSlot;
  if ($desc instanceof Array)
    $desc = $desc[1];
  convertNativeToDart_AcceptStructuredClone_readSlot.prototype = $desc;
  function convertNativeToDart_AcceptStructuredClone_writeSlot(copies_3) {
    this.copies_3 = copies_3;
  }
  convertNativeToDart_AcceptStructuredClone_writeSlot.builtin$cls = "convertNativeToDart_AcceptStructuredClone_writeSlot";
  if (!"name" in convertNativeToDart_AcceptStructuredClone_writeSlot)
    convertNativeToDart_AcceptStructuredClone_writeSlot.name = "convertNativeToDart_AcceptStructuredClone_writeSlot";
  $desc = $collectedClasses.convertNativeToDart_AcceptStructuredClone_writeSlot;
  if ($desc instanceof Array)
    $desc = $desc[1];
  convertNativeToDart_AcceptStructuredClone_writeSlot.prototype = $desc;
  function convertNativeToDart_AcceptStructuredClone_walk(mustCopy_4, findSlot_5, readSlot_6, writeSlot_7) {
    this.mustCopy_4 = mustCopy_4;
    this.findSlot_5 = findSlot_5;
    this.readSlot_6 = readSlot_6;
    this.writeSlot_7 = writeSlot_7;
  }
  convertNativeToDart_AcceptStructuredClone_walk.builtin$cls = "convertNativeToDart_AcceptStructuredClone_walk";
  if (!"name" in convertNativeToDart_AcceptStructuredClone_walk)
    convertNativeToDart_AcceptStructuredClone_walk.name = "convertNativeToDart_AcceptStructuredClone_walk";
  $desc = $collectedClasses.convertNativeToDart_AcceptStructuredClone_walk;
  if ($desc instanceof Array)
    $desc = $desc[1];
  convertNativeToDart_AcceptStructuredClone_walk.prototype = $desc;
  function FilteredElementList(_node, _childNodes) {
    this._node = _node;
    this._childNodes = _childNodes;
  }
  FilteredElementList.builtin$cls = "FilteredElementList";
  if (!"name" in FilteredElementList)
    FilteredElementList.name = "FilteredElementList";
  $desc = $collectedClasses.FilteredElementList;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FilteredElementList.prototype = $desc;
  function FilteredElementList__filtered_closure() {
  }
  FilteredElementList__filtered_closure.builtin$cls = "FilteredElementList__filtered_closure";
  if (!"name" in FilteredElementList__filtered_closure)
    FilteredElementList__filtered_closure.name = "FilteredElementList__filtered_closure";
  $desc = $collectedClasses.FilteredElementList__filtered_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FilteredElementList__filtered_closure.prototype = $desc;
  function FilteredElementList_removeRange_closure() {
  }
  FilteredElementList_removeRange_closure.builtin$cls = "FilteredElementList_removeRange_closure";
  if (!"name" in FilteredElementList_removeRange_closure)
    FilteredElementList_removeRange_closure.name = "FilteredElementList_removeRange_closure";
  $desc = $collectedClasses.FilteredElementList_removeRange_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FilteredElementList_removeRange_closure.prototype = $desc;
  function DecodeInfo(width, height) {
    this.width = width;
    this.height = height;
  }
  DecodeInfo.builtin$cls = "DecodeInfo";
  if (!"name" in DecodeInfo)
    DecodeInfo.name = "DecodeInfo";
  $desc = $collectedClasses.DecodeInfo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DecodeInfo.prototype = $desc;
  DecodeInfo.prototype.get$width = function(receiver) {
    return this.width;
  };
  DecodeInfo.prototype.get$height = function(receiver) {
    return this.height;
  };
  function Decoder() {
  }
  Decoder.builtin$cls = "Decoder";
  if (!"name" in Decoder)
    Decoder.name = "Decoder";
  $desc = $collectedClasses.Decoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Decoder.prototype = $desc;
  function ExrAttribute(name, type, size, data) {
    this.name = name;
    this.type = type;
    this.size = size;
    this.data = data;
  }
  ExrAttribute.builtin$cls = "ExrAttribute";
  if (!"name" in ExrAttribute)
    ExrAttribute.name = "ExrAttribute";
  $desc = $collectedClasses.ExrAttribute;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrAttribute.prototype = $desc;
  ExrAttribute.prototype.get$name = function(receiver) {
    return this.name;
  };
  ExrAttribute.prototype.get$type = function(receiver) {
    return this.type;
  };
  ExrAttribute.prototype.get$size = function(receiver) {
    return this.size;
  };
  ExrAttribute.prototype.get$data = function(receiver) {
    return this.data;
  };
  function ExrB44Compressor(_maxScanLineSize, _numScanLines, _optFlatFields, decodedWidth, decodedHeight, _header) {
    this._maxScanLineSize = _maxScanLineSize;
    this._numScanLines = _numScanLines;
    this._optFlatFields = _optFlatFields;
    this.decodedWidth = decodedWidth;
    this.decodedHeight = decodedHeight;
    this._header = _header;
  }
  ExrB44Compressor.builtin$cls = "ExrB44Compressor";
  if (!"name" in ExrB44Compressor)
    ExrB44Compressor.name = "ExrB44Compressor";
  $desc = $collectedClasses.ExrB44Compressor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrB44Compressor.prototype = $desc;
  function ExrChannel(name, type, size, pLinear, xSampling, ySampling) {
    this.name = name;
    this.type = type;
    this.size = size;
    this.pLinear = pLinear;
    this.xSampling = xSampling;
    this.ySampling = ySampling;
  }
  ExrChannel.builtin$cls = "ExrChannel";
  if (!"name" in ExrChannel)
    ExrChannel.name = "ExrChannel";
  $desc = $collectedClasses.ExrChannel;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrChannel.prototype = $desc;
  ExrChannel.prototype.get$name = function(receiver) {
    return this.name;
  };
  ExrChannel.prototype.get$type = function(receiver) {
    return this.type;
  };
  ExrChannel.prototype.get$size = function(receiver) {
    return this.size;
  };
  ExrChannel.prototype.get$xSampling = function() {
    return this.xSampling;
  };
  ExrChannel.prototype.get$ySampling = function() {
    return this.ySampling;
  };
  function ExrCompressor() {
  }
  ExrCompressor.builtin$cls = "ExrCompressor";
  if (!"name" in ExrCompressor)
    ExrCompressor.name = "ExrCompressor";
  $desc = $collectedClasses.ExrCompressor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrCompressor.prototype = $desc;
  function ExrHufDec(len, lit, p) {
    this.len = len;
    this.lit = lit;
    this.p = p;
  }
  ExrHufDec.builtin$cls = "ExrHufDec";
  if (!"name" in ExrHufDec)
    ExrHufDec.name = "ExrHufDec";
  $desc = $collectedClasses.ExrHufDec;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrHufDec.prototype = $desc;
  ExrHufDec.prototype.get$len = function() {
    return this.len;
  };
  ExrHufDec.prototype.get$p = function(receiver) {
    return this.p;
  };
  function ExrImage(parts, version, flags, width, height, backgroundColor) {
    this.parts = parts;
    this.version = version;
    this.flags = flags;
    this.width = width;
    this.height = height;
    this.backgroundColor = backgroundColor;
  }
  ExrImage.builtin$cls = "ExrImage";
  if (!"name" in ExrImage)
    ExrImage.name = "ExrImage";
  $desc = $collectedClasses.ExrImage;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrImage.prototype = $desc;
  function ExrPart(framebuffer, channels, attributes, displayWindow, dataWindow, width, height, pixelAspectRatio, screenWindowCenterX, screenWindowCenterY, screenWindowWidth, chromaticities, _type, _lineOrder, _compressionType, _offsets, _bytesPerLine, _compressor, _linesInBuffer, _lineBufferSize, _offsetInLineBuffer, _tiled, _tileWidth, _tileHeight, _tileLevelMode, _tileRoundingMode, _numXTiles, _numYTiles, _numXLevels, _numYLevels, _bytesPerPixel, _maxBytesPerTileLine, _tileBufferSize) {
    this.framebuffer = framebuffer;
    this.channels = channels;
    this.attributes = attributes;
    this.displayWindow = displayWindow;
    this.dataWindow = dataWindow;
    this.width = width;
    this.height = height;
    this.pixelAspectRatio = pixelAspectRatio;
    this.screenWindowCenterX = screenWindowCenterX;
    this.screenWindowCenterY = screenWindowCenterY;
    this.screenWindowWidth = screenWindowWidth;
    this.chromaticities = chromaticities;
    this._type = _type;
    this._lineOrder = _lineOrder;
    this._compressionType = _compressionType;
    this._offsets = _offsets;
    this._bytesPerLine = _bytesPerLine;
    this._compressor = _compressor;
    this._linesInBuffer = _linesInBuffer;
    this._lineBufferSize = _lineBufferSize;
    this._offsetInLineBuffer = _offsetInLineBuffer;
    this._tiled = _tiled;
    this._tileWidth = _tileWidth;
    this._tileHeight = _tileHeight;
    this._tileLevelMode = _tileLevelMode;
    this._tileRoundingMode = _tileRoundingMode;
    this._numXTiles = _numXTiles;
    this._numYTiles = _numYTiles;
    this._numXLevels = _numXLevels;
    this._numYLevels = _numYLevels;
    this._bytesPerPixel = _bytesPerPixel;
    this._maxBytesPerTileLine = _maxBytesPerTileLine;
    this._tileBufferSize = _tileBufferSize;
  }
  ExrPart.builtin$cls = "ExrPart";
  if (!"name" in ExrPart)
    ExrPart.name = "ExrPart";
  $desc = $collectedClasses.ExrPart;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrPart.prototype = $desc;
  ExrPart.prototype.get$framebuffer = function() {
    return this.framebuffer;
  };
  ExrPart.prototype.get$width = function(receiver) {
    return this.width;
  };
  ExrPart.prototype.get$height = function(receiver) {
    return this.height;
  };
  function ExrPizCompressor(_output, _maxScanLineSize, _numScanLines, _channelData, _tmpBuffer, decodedWidth, decodedHeight, _header) {
    this._output = _output;
    this._maxScanLineSize = _maxScanLineSize;
    this._numScanLines = _numScanLines;
    this._channelData = _channelData;
    this._tmpBuffer = _tmpBuffer;
    this.decodedWidth = decodedWidth;
    this.decodedHeight = decodedHeight;
    this._header = _header;
  }
  ExrPizCompressor.builtin$cls = "ExrPizCompressor";
  if (!"name" in ExrPizCompressor)
    ExrPizCompressor.name = "ExrPizCompressor";
  $desc = $collectedClasses.ExrPizCompressor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrPizCompressor.prototype = $desc;
  function _PizChannelData(start, end, nx, ny, ys, size) {
    this.start = start;
    this.end = end;
    this.nx = nx;
    this.ny = ny;
    this.ys = ys;
    this.size = size;
  }
  _PizChannelData.builtin$cls = "_PizChannelData";
  if (!"name" in _PizChannelData)
    _PizChannelData.name = "_PizChannelData";
  $desc = $collectedClasses._PizChannelData;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _PizChannelData.prototype = $desc;
  _PizChannelData.prototype.get$start = function(receiver) {
    return this.start;
  };
  _PizChannelData.prototype.set$start = function(receiver, v) {
    return this.start = v;
  };
  _PizChannelData.prototype.set$end = function(v) {
    return this.end = v;
  };
  _PizChannelData.prototype.get$nx = function() {
    return this.nx;
  };
  _PizChannelData.prototype.get$ys = function() {
    return this.ys;
  };
  _PizChannelData.prototype.get$size = function(receiver) {
    return this.size;
  };
  function ExrPxr24Compressor(_zlib, _maxScanLineSize, _numScanLines, _output, decodedWidth, decodedHeight, _header) {
    this._zlib = _zlib;
    this._maxScanLineSize = _maxScanLineSize;
    this._numScanLines = _numScanLines;
    this._output = _output;
    this.decodedWidth = decodedWidth;
    this.decodedHeight = decodedHeight;
    this._header = _header;
  }
  ExrPxr24Compressor.builtin$cls = "ExrPxr24Compressor";
  if (!"name" in ExrPxr24Compressor)
    ExrPxr24Compressor.name = "ExrPxr24Compressor";
  $desc = $collectedClasses.ExrPxr24Compressor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrPxr24Compressor.prototype = $desc;
  function ExrRleCompressor(_outCache, _maxScanLineSize, decodedWidth, decodedHeight, _header) {
    this._outCache = _outCache;
    this._maxScanLineSize = _maxScanLineSize;
    this.decodedWidth = decodedWidth;
    this.decodedHeight = decodedHeight;
    this._header = _header;
  }
  ExrRleCompressor.builtin$cls = "ExrRleCompressor";
  if (!"name" in ExrRleCompressor)
    ExrRleCompressor.name = "ExrRleCompressor";
  $desc = $collectedClasses.ExrRleCompressor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrRleCompressor.prototype = $desc;
  function ExrZipCompressor(zlib, _maxScanLineSize, _numScanLines, _outCache, decodedWidth, decodedHeight, _header) {
    this.zlib = zlib;
    this._maxScanLineSize = _maxScanLineSize;
    this._numScanLines = _numScanLines;
    this._outCache = _outCache;
    this.decodedWidth = decodedWidth;
    this.decodedHeight = decodedHeight;
    this._header = _header;
  }
  ExrZipCompressor.builtin$cls = "ExrZipCompressor";
  if (!"name" in ExrZipCompressor)
    ExrZipCompressor.name = "ExrZipCompressor";
  $desc = $collectedClasses.ExrZipCompressor;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrZipCompressor.prototype = $desc;
  function ExrDecoder(exrImage, exposure, gamma, reinhard, bloomAmount, bloomRadius, progressCallback) {
    this.exrImage = exrImage;
    this.exposure = exposure;
    this.gamma = gamma;
    this.reinhard = reinhard;
    this.bloomAmount = bloomAmount;
    this.bloomRadius = bloomRadius;
    this.progressCallback = progressCallback;
  }
  ExrDecoder.builtin$cls = "ExrDecoder";
  if (!"name" in ExrDecoder)
    ExrDecoder.name = "ExrDecoder";
  $desc = $collectedClasses.ExrDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExrDecoder.prototype = $desc;
  function GifColorMap(bitsPerPixel, numColors, transparent, colors) {
    this.bitsPerPixel = bitsPerPixel;
    this.numColors = numColors;
    this.transparent = transparent;
    this.colors = colors;
  }
  GifColorMap.builtin$cls = "GifColorMap";
  if (!"name" in GifColorMap)
    GifColorMap.name = "GifColorMap";
  $desc = $collectedClasses.GifColorMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GifColorMap.prototype = $desc;
  function GifImageDesc(x, y, width, height, interlaced, colorMap, duration, clearFrame, _inputPosition) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.interlaced = interlaced;
    this.colorMap = colorMap;
    this.duration = duration;
    this.clearFrame = clearFrame;
    this._inputPosition = _inputPosition;
  }
  GifImageDesc.builtin$cls = "GifImageDesc";
  if (!"name" in GifImageDesc)
    GifImageDesc.name = "GifImageDesc";
  $desc = $collectedClasses.GifImageDesc;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GifImageDesc.prototype = $desc;
  GifImageDesc.prototype.get$x = function(receiver) {
    return this.x;
  };
  GifImageDesc.prototype.set$x = function(receiver, v) {
    return this.x = v;
  };
  GifImageDesc.prototype.get$y = function(receiver) {
    return this.y;
  };
  GifImageDesc.prototype.set$y = function(receiver, v) {
    return this.y = v;
  };
  GifImageDesc.prototype.get$width = function(receiver) {
    return this.width;
  };
  GifImageDesc.prototype.get$height = function(receiver) {
    return this.height;
  };
  GifImageDesc.prototype.get$interlaced = function() {
    return this.interlaced;
  };
  GifImageDesc.prototype.get$colorMap = function() {
    return this.colorMap;
  };
  GifImageDesc.prototype.set$duration = function(receiver, v) {
    return this.duration = v;
  };
  GifImageDesc.prototype.set$clearFrame = function(v) {
    return this.clearFrame = v;
  };
  GifImageDesc.prototype.get$_inputPosition = function() {
    return this._inputPosition;
  };
  function GifInfo(colorResolution, globalColorMap, isGif89, frames, width, height, backgroundColor) {
    this.colorResolution = colorResolution;
    this.globalColorMap = globalColorMap;
    this.isGif89 = isGif89;
    this.frames = frames;
    this.width = width;
    this.height = height;
    this.backgroundColor = backgroundColor;
  }
  GifInfo.builtin$cls = "GifInfo";
  if (!"name" in GifInfo)
    GifInfo.name = "GifInfo";
  $desc = $collectedClasses.GifInfo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GifInfo.prototype = $desc;
  function GifDecoder(info, _input, _frame, _numFrames, _buffer, _stack, _suffix, _prefix, _bitsPerPixel, _pixelCount, _currentShiftDWord, _currentShiftState, _stackPtr, _currentCode, _lastCode, _maxCode1, _runningBits, _runningCode, _eofCode, _clearCode, progressCallback) {
    this.info = info;
    this._input = _input;
    this._frame = _frame;
    this._numFrames = _numFrames;
    this._buffer = _buffer;
    this._stack = _stack;
    this._suffix = _suffix;
    this._prefix = _prefix;
    this._bitsPerPixel = _bitsPerPixel;
    this._pixelCount = _pixelCount;
    this._currentShiftDWord = _currentShiftDWord;
    this._currentShiftState = _currentShiftState;
    this._stackPtr = _stackPtr;
    this._currentCode = _currentCode;
    this._lastCode = _lastCode;
    this._maxCode1 = _maxCode1;
    this._runningBits = _runningBits;
    this._runningCode = _runningCode;
    this._eofCode = _eofCode;
    this._clearCode = _clearCode;
    this.progressCallback = progressCallback;
  }
  GifDecoder.builtin$cls = "GifDecoder";
  if (!"name" in GifDecoder)
    GifDecoder.name = "GifDecoder";
  $desc = $collectedClasses.GifDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GifDecoder.prototype = $desc;
  function JpegAdobe(version, flags0, flags1, transformCode) {
    this.version = version;
    this.flags0 = flags0;
    this.flags1 = flags1;
    this.transformCode = transformCode;
  }
  JpegAdobe.builtin$cls = "JpegAdobe";
  if (!"name" in JpegAdobe)
    JpegAdobe.name = "JpegAdobe";
  $desc = $collectedClasses.JpegAdobe;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JpegAdobe.prototype = $desc;
  function JpegComponent(h, v, quantizationTableList, quantizationIndex, blocksPerLine, blocksPerColumn, blocks, huffmanTableDC, huffmanTableAC, pred) {
    this.h = h;
    this.v = v;
    this.quantizationTableList = quantizationTableList;
    this.quantizationIndex = quantizationIndex;
    this.blocksPerLine = blocksPerLine;
    this.blocksPerColumn = blocksPerColumn;
    this.blocks = blocks;
    this.huffmanTableDC = huffmanTableDC;
    this.huffmanTableAC = huffmanTableAC;
    this.pred = pred;
  }
  JpegComponent.builtin$cls = "JpegComponent";
  if (!"name" in JpegComponent)
    JpegComponent.name = "JpegComponent";
  $desc = $collectedClasses.JpegComponent;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JpegComponent.prototype = $desc;
  JpegComponent.prototype.get$h = function() {
    return this.h;
  };
  JpegComponent.prototype.get$v = function() {
    return this.v;
  };
  JpegComponent.prototype.get$blocksPerLine = function() {
    return this.blocksPerLine;
  };
  JpegComponent.prototype.get$huffmanTableDC = function() {
    return this.huffmanTableDC;
  };
  JpegComponent.prototype.get$huffmanTableAC = function() {
    return this.huffmanTableAC;
  };
  JpegComponent.prototype.set$pred = function(v) {
    return this.pred = v;
  };
  function JpegData(progressCallback, input, jfif, adobe, frame, resetInterval, quantizationTables, frames, huffmanTablesAC, huffmanTablesDC, components, _progressTotal, _progress) {
    this.progressCallback = progressCallback;
    this.input = input;
    this.jfif = jfif;
    this.adobe = adobe;
    this.frame = frame;
    this.resetInterval = resetInterval;
    this.quantizationTables = quantizationTables;
    this.frames = frames;
    this.huffmanTablesAC = huffmanTablesAC;
    this.huffmanTablesDC = huffmanTablesDC;
    this.components = components;
    this._progressTotal = _progressTotal;
    this._progress = _progress;
  }
  JpegData.builtin$cls = "JpegData";
  if (!"name" in JpegData)
    JpegData.name = "JpegData";
  $desc = $collectedClasses.JpegData;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JpegData.prototype = $desc;
  function JpegFrame(extended, progressive, precision, scanLines, samplesPerLine, maxH, maxV, mcusPerLine, mcusPerColumn, components, componentsOrder) {
    this.extended = extended;
    this.progressive = progressive;
    this.precision = precision;
    this.scanLines = scanLines;
    this.samplesPerLine = samplesPerLine;
    this.maxH = maxH;
    this.maxV = maxV;
    this.mcusPerLine = mcusPerLine;
    this.mcusPerColumn = mcusPerColumn;
    this.components = components;
    this.componentsOrder = componentsOrder;
  }
  JpegFrame.builtin$cls = "JpegFrame";
  if (!"name" in JpegFrame)
    JpegFrame.name = "JpegFrame";
  $desc = $collectedClasses.JpegFrame;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JpegFrame.prototype = $desc;
  function JpegJfif(majorVersion, minorVersion, densityUnits, xDensity, yDensity, thumbWidth, thumbHeight, thumbData) {
    this.majorVersion = majorVersion;
    this.minorVersion = minorVersion;
    this.densityUnits = densityUnits;
    this.xDensity = xDensity;
    this.yDensity = yDensity;
    this.thumbWidth = thumbWidth;
    this.thumbHeight = thumbHeight;
    this.thumbData = thumbData;
  }
  JpegJfif.builtin$cls = "JpegJfif";
  if (!"name" in JpegJfif)
    JpegJfif.name = "JpegJfif";
  $desc = $collectedClasses.JpegJfif;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JpegJfif.prototype = $desc;
  function JpegScan(input, frame, precision, samplesPerLine, scanLines, mcusPerLine, progressive, maxH, maxV, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, bitsData, bitsCount, eobrun, successiveACState, successiveACNextValue) {
    this.input = input;
    this.frame = frame;
    this.precision = precision;
    this.samplesPerLine = samplesPerLine;
    this.scanLines = scanLines;
    this.mcusPerLine = mcusPerLine;
    this.progressive = progressive;
    this.maxH = maxH;
    this.maxV = maxV;
    this.components = components;
    this.resetInterval = resetInterval;
    this.spectralStart = spectralStart;
    this.spectralEnd = spectralEnd;
    this.successivePrev = successivePrev;
    this.successive = successive;
    this.bitsData = bitsData;
    this.bitsCount = bitsCount;
    this.eobrun = eobrun;
    this.successiveACState = successiveACState;
    this.successiveACNextValue = successiveACNextValue;
  }
  JpegScan.builtin$cls = "JpegScan";
  if (!"name" in JpegScan)
    JpegScan.name = "JpegScan";
  $desc = $collectedClasses.JpegScan;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JpegScan.prototype = $desc;
  function JpegDecoder(info, input, progressCallback) {
    this.info = info;
    this.input = input;
    this.progressCallback = progressCallback;
  }
  JpegDecoder.builtin$cls = "JpegDecoder";
  if (!"name" in JpegDecoder)
    JpegDecoder.name = "JpegDecoder";
  $desc = $collectedClasses.JpegDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  JpegDecoder.prototype = $desc;
  function PngFrame(sequenceNumber, width, height, xOffset, yOffset, delayNum, delayDen, dispose, blend, _fdat) {
    this.sequenceNumber = sequenceNumber;
    this.width = width;
    this.height = height;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
    this.delayNum = delayNum;
    this.delayDen = delayDen;
    this.dispose = dispose;
    this.blend = blend;
    this._fdat = _fdat;
  }
  PngFrame.builtin$cls = "PngFrame";
  if (!"name" in PngFrame)
    PngFrame.name = "PngFrame";
  $desc = $collectedClasses.PngFrame;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PngFrame.prototype = $desc;
  PngFrame.prototype.get$width = function(receiver) {
    return this.width;
  };
  PngFrame.prototype.get$height = function(receiver) {
    return this.height;
  };
  PngFrame.prototype.get$_fdat = function() {
    return this._fdat;
  };
  function PngInfo(bits, colorType, compressionMethod, filterMethod, interlaceMethod, palette, transparency, colorLut, gamma, image$PngInfo$backgroundColor, numFrames, repeat, frames, _idat, width, height, backgroundColor) {
    this.bits = bits;
    this.colorType = colorType;
    this.compressionMethod = compressionMethod;
    this.filterMethod = filterMethod;
    this.interlaceMethod = interlaceMethod;
    this.palette = palette;
    this.transparency = transparency;
    this.colorLut = colorLut;
    this.gamma = gamma;
    this.image$PngInfo$backgroundColor = image$PngInfo$backgroundColor;
    this.numFrames = numFrames;
    this.repeat = repeat;
    this.frames = frames;
    this._idat = _idat;
    this.width = width;
    this.height = height;
    this.backgroundColor = backgroundColor;
  }
  PngInfo.builtin$cls = "PngInfo";
  if (!"name" in PngInfo)
    PngInfo.name = "PngInfo";
  $desc = $collectedClasses.PngInfo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PngInfo.prototype = $desc;
  function PngDecoder(info, _image$_bitBuffer, _image$_bitBufferLen, _input, _progressY, _frame, _numFrames, progressCallback) {
    this.info = info;
    this._image$_bitBuffer = _image$_bitBuffer;
    this._image$_bitBufferLen = _image$_bitBufferLen;
    this._input = _input;
    this._progressY = _progressY;
    this._frame = _frame;
    this._numFrames = _numFrames;
    this.progressCallback = progressCallback;
  }
  PngDecoder.builtin$cls = "PngDecoder";
  if (!"name" in PngDecoder)
    PngDecoder.name = "PngDecoder";
  $desc = $collectedClasses.PngDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PngDecoder.prototype = $desc;
  function PsdLayerAdditionalData(data, tag) {
    this.data = data;
    this.tag = tag;
  }
  PsdLayerAdditionalData.builtin$cls = "PsdLayerAdditionalData";
  if (!"name" in PsdLayerAdditionalData)
    PsdLayerAdditionalData.name = "PsdLayerAdditionalData";
  $desc = $collectedClasses.PsdLayerAdditionalData;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdLayerAdditionalData.prototype = $desc;
  PsdLayerAdditionalData.prototype.get$data = function(receiver) {
    return this.data;
  };
  function PsdLayerSectionDivider(type, key, subType, tag) {
    this.type = type;
    this.key = key;
    this.subType = subType;
    this.tag = tag;
  }
  PsdLayerSectionDivider.builtin$cls = "PsdLayerSectionDivider";
  if (!"name" in PsdLayerSectionDivider)
    PsdLayerSectionDivider.name = "PsdLayerSectionDivider";
  $desc = $collectedClasses.PsdLayerSectionDivider;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdLayerSectionDivider.prototype = $desc;
  PsdLayerSectionDivider.prototype.get$type = function(receiver) {
    return this.type;
  };
  function PsdBlendingRanges(grayBlackSrc, grayWhiteSrc, grayBlackDst, grayWhiteDst, blackSrc, whiteSrc, blackDst, whiteDst) {
    this.grayBlackSrc = grayBlackSrc;
    this.grayWhiteSrc = grayWhiteSrc;
    this.grayBlackDst = grayBlackDst;
    this.grayWhiteDst = grayWhiteDst;
    this.blackSrc = blackSrc;
    this.whiteSrc = whiteSrc;
    this.blackDst = blackDst;
    this.whiteDst = whiteDst;
  }
  PsdBlendingRanges.builtin$cls = "PsdBlendingRanges";
  if (!"name" in PsdBlendingRanges)
    PsdBlendingRanges.name = "PsdBlendingRanges";
  $desc = $collectedClasses.PsdBlendingRanges;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdBlendingRanges.prototype = $desc;
  function PsdChannel(id, dataLength, data) {
    this.id = id;
    this.dataLength = dataLength;
    this.data = data;
  }
  PsdChannel.builtin$cls = "PsdChannel";
  if (!"name" in PsdChannel)
    PsdChannel.name = "PsdChannel";
  $desc = $collectedClasses.PsdChannel;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdChannel.prototype = $desc;
  PsdChannel.prototype.get$id = function(receiver) {
    return this.id;
  };
  PsdChannel.prototype.get$data = function(receiver) {
    return this.data;
  };
  function PsdImage(signature, version, channels, depth, colorMode, layers, mergeImageChannels, mergedImage, imageResources, hasAlpha, _input, _colorData, _imageResourceData, _layerAndMaskData, _imageData, width, height, backgroundColor) {
    this.signature = signature;
    this.version = version;
    this.channels = channels;
    this.depth = depth;
    this.colorMode = colorMode;
    this.layers = layers;
    this.mergeImageChannels = mergeImageChannels;
    this.mergedImage = mergedImage;
    this.imageResources = imageResources;
    this.hasAlpha = hasAlpha;
    this._input = _input;
    this._colorData = _colorData;
    this._imageResourceData = _imageResourceData;
    this._layerAndMaskData = _layerAndMaskData;
    this._imageData = _imageData;
    this.width = width;
    this.height = height;
    this.backgroundColor = backgroundColor;
  }
  PsdImage.builtin$cls = "PsdImage";
  if (!"name" in PsdImage)
    PsdImage.name = "PsdImage";
  $desc = $collectedClasses.PsdImage;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdImage.prototype = $desc;
  function PsdImageResource(id, name, data) {
    this.id = id;
    this.name = name;
    this.data = data;
  }
  PsdImageResource.builtin$cls = "PsdImageResource";
  if (!"name" in PsdImageResource)
    PsdImageResource.name = "PsdImageResource";
  $desc = $collectedClasses.PsdImageResource;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdImageResource.prototype = $desc;
  PsdImageResource.prototype.get$id = function(receiver) {
    return this.id;
  };
  PsdImageResource.prototype.get$name = function(receiver) {
    return this.name;
  };
  PsdImageResource.prototype.get$data = function(receiver) {
    return this.data;
  };
  function PsdLayer(top, left, bottom, right, width, height, blendMode, opacity, clipping, flags, compression, name, channels, mask, blendingRanges, additionalData, children, parent, layerImage) {
    this.top = top;
    this.left = left;
    this.bottom = bottom;
    this.right = right;
    this.width = width;
    this.height = height;
    this.blendMode = blendMode;
    this.opacity = opacity;
    this.clipping = clipping;
    this.flags = flags;
    this.compression = compression;
    this.name = name;
    this.channels = channels;
    this.mask = mask;
    this.blendingRanges = blendingRanges;
    this.additionalData = additionalData;
    this.children = children;
    this.parent = parent;
    this.layerImage = layerImage;
  }
  PsdLayer.builtin$cls = "PsdLayer";
  if (!"name" in PsdLayer)
    PsdLayer.name = "PsdLayer";
  $desc = $collectedClasses.PsdLayer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdLayer.prototype = $desc;
  PsdLayer.prototype.get$width = function(receiver) {
    return this.width;
  };
  PsdLayer.prototype.get$height = function(receiver) {
    return this.height;
  };
  PsdLayer.prototype.get$name = function(receiver) {
    return this.name;
  };
  PsdLayer.prototype.get$children = function(receiver) {
    return this.children;
  };
  function PsdLayerData(tag) {
    this.tag = tag;
  }
  PsdLayerData.builtin$cls = "PsdLayerData";
  if (!"name" in PsdLayerData)
    PsdLayerData.name = "PsdLayerData";
  $desc = $collectedClasses.PsdLayerData;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdLayerData.prototype = $desc;
  function PsdMask(top, left, right, bottom, defaultColor, flags, params) {
    this.top = top;
    this.left = left;
    this.right = right;
    this.bottom = bottom;
    this.defaultColor = defaultColor;
    this.flags = flags;
    this.params = params;
  }
  PsdMask.builtin$cls = "PsdMask";
  if (!"name" in PsdMask)
    PsdMask.name = "PsdMask";
  $desc = $collectedClasses.PsdMask;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdMask.prototype = $desc;
  function PsdDecoder(info, progressCallback) {
    this.info = info;
    this.progressCallback = progressCallback;
  }
  PsdDecoder.builtin$cls = "PsdDecoder";
  if (!"name" in PsdDecoder)
    PsdDecoder.name = "PsdDecoder";
  $desc = $collectedClasses.PsdDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PsdDecoder.prototype = $desc;
  function TiffBitReader(input, _image$_bitBuffer, _bitPos) {
    this.input = input;
    this._image$_bitBuffer = _image$_bitBuffer;
    this._bitPos = _bitPos;
  }
  TiffBitReader.builtin$cls = "TiffBitReader";
  if (!"name" in TiffBitReader)
    TiffBitReader.name = "TiffBitReader";
  $desc = $collectedClasses.TiffBitReader;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TiffBitReader.prototype = $desc;
  function TiffEntry(tag, type, numValues, valueOffset) {
    this.tag = tag;
    this.type = type;
    this.numValues = numValues;
    this.valueOffset = valueOffset;
  }
  TiffEntry.builtin$cls = "TiffEntry";
  if (!"name" in TiffEntry)
    TiffEntry.name = "TiffEntry";
  $desc = $collectedClasses.TiffEntry;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TiffEntry.prototype = $desc;
  TiffEntry.prototype.get$type = function(receiver) {
    return this.type;
  };
  function TiffFaxDecoder(width, height, fillOrder, changingElemSize, prevChangingElems, currChangingElems, data, bitPointer, bytePointer, lastChangingElement, compression, uncompressedMode, fillBits, oneD) {
    this.width = width;
    this.height = height;
    this.fillOrder = fillOrder;
    this.changingElemSize = changingElemSize;
    this.prevChangingElems = prevChangingElems;
    this.currChangingElems = currChangingElems;
    this.data = data;
    this.bitPointer = bitPointer;
    this.bytePointer = bytePointer;
    this.lastChangingElement = lastChangingElement;
    this.compression = compression;
    this.uncompressedMode = uncompressedMode;
    this.fillBits = fillBits;
    this.oneD = oneD;
  }
  TiffFaxDecoder.builtin$cls = "TiffFaxDecoder";
  if (!"name" in TiffFaxDecoder)
    TiffFaxDecoder.name = "TiffFaxDecoder";
  $desc = $collectedClasses.TiffFaxDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TiffFaxDecoder.prototype = $desc;
  TiffFaxDecoder.prototype.get$width = function(receiver) {
    return this.width;
  };
  TiffFaxDecoder.prototype.get$height = function(receiver) {
    return this.height;
  };
  TiffFaxDecoder.prototype.get$data = function(receiver) {
    return this.data;
  };
  TiffFaxDecoder.prototype.get$oneD = function() {
    return this.oneD;
  };
  function TiffImage(tags, width, height, photometricType, compression, bitsPerSample, samplesPerPixel, imageType, isWhiteZero, predictor, chromaSubH, chromaSubV, tiled, tileWidth, tileHeight, tileOffsets, tileByteCounts, tilesX, tilesY, tileSize, fillOrder, t4Options, t6Options, extraSamples, colorMap, colorMapRed, colorMapGreen, colorMapBlue, image) {
    this.tags = tags;
    this.width = width;
    this.height = height;
    this.photometricType = photometricType;
    this.compression = compression;
    this.bitsPerSample = bitsPerSample;
    this.samplesPerPixel = samplesPerPixel;
    this.imageType = imageType;
    this.isWhiteZero = isWhiteZero;
    this.predictor = predictor;
    this.chromaSubH = chromaSubH;
    this.chromaSubV = chromaSubV;
    this.tiled = tiled;
    this.tileWidth = tileWidth;
    this.tileHeight = tileHeight;
    this.tileOffsets = tileOffsets;
    this.tileByteCounts = tileByteCounts;
    this.tilesX = tilesX;
    this.tilesY = tilesY;
    this.tileSize = tileSize;
    this.fillOrder = fillOrder;
    this.t4Options = t4Options;
    this.t6Options = t6Options;
    this.extraSamples = extraSamples;
    this.colorMap = colorMap;
    this.colorMapRed = colorMapRed;
    this.colorMapGreen = colorMapGreen;
    this.colorMapBlue = colorMapBlue;
    this.image = image;
  }
  TiffImage.builtin$cls = "TiffImage";
  if (!"name" in TiffImage)
    TiffImage.name = "TiffImage";
  $desc = $collectedClasses.TiffImage;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TiffImage.prototype = $desc;
  TiffImage.prototype.get$width = function(receiver) {
    return this.width;
  };
  TiffImage.prototype.get$height = function(receiver) {
    return this.height;
  };
  TiffImage.prototype.get$bitsPerSample = function() {
    return this.bitsPerSample;
  };
  TiffImage.prototype.get$samplesPerPixel = function() {
    return this.samplesPerPixel;
  };
  TiffImage.prototype.get$colorMap = function() {
    return this.colorMap;
  };
  function TiffInfo(bigEndian, signature, ifdOffset, images, width, height, backgroundColor) {
    this.bigEndian = bigEndian;
    this.signature = signature;
    this.ifdOffset = ifdOffset;
    this.images = images;
    this.width = width;
    this.height = height;
    this.backgroundColor = backgroundColor;
  }
  TiffInfo.builtin$cls = "TiffInfo";
  if (!"name" in TiffInfo)
    TiffInfo.name = "TiffInfo";
  $desc = $collectedClasses.TiffInfo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TiffInfo.prototype = $desc;
  function LzwDecoder(_bitsToGet, _bytePointer, _bitPointer, _nextData, _nextBits, _data, _dataLength, _out, _outPointer, _buffer, _table, _prefix, _tableIndex, _bufferLength) {
    this._bitsToGet = _bitsToGet;
    this._bytePointer = _bytePointer;
    this._bitPointer = _bitPointer;
    this._nextData = _nextData;
    this._nextBits = _nextBits;
    this._data = _data;
    this._dataLength = _dataLength;
    this._out = _out;
    this._outPointer = _outPointer;
    this._buffer = _buffer;
    this._table = _table;
    this._prefix = _prefix;
    this._tableIndex = _tableIndex;
    this._bufferLength = _bufferLength;
  }
  LzwDecoder.builtin$cls = "LzwDecoder";
  if (!"name" in LzwDecoder)
    LzwDecoder.name = "LzwDecoder";
  $desc = $collectedClasses.LzwDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LzwDecoder.prototype = $desc;
  function TiffDecoder(info, _input, progressCallback) {
    this.info = info;
    this._input = _input;
    this.progressCallback = progressCallback;
  }
  TiffDecoder.builtin$cls = "TiffDecoder";
  if (!"name" in TiffDecoder)
    TiffDecoder.name = "TiffDecoder";
  $desc = $collectedClasses.TiffDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TiffDecoder.prototype = $desc;
  function VP8(input, webp, br, output, _dsp, _frameHeader, _picHeader, _filterHeader, _segmentHeader, _cropLeft, _cropRight, _cropTop, _cropBottom, _mbWidth, _mbHeight, _tlMbX, _tlMbY, _brMbX, _brMbY, _numPartitions, _partitions, _dither, _ditheringRand, _dqm, _proba, _useSkipProba, _skipP, _intraT, _intraL, _segment, _yuvT, _mbInfo, _fInfo, _yuvBlock, _cacheY, _cacheU, _cacheV, _cacheYStride, _cacheUVStride, _tmpY, _tmpU, _tmpV, _y, _u, _v, _a, _mem, _mbX, _mbY, _mbData, _filterType, _fStrengths, _alpha, _alphaData, _isAlphaDecoded, _alphaPlane, _layerColorspace, _layerData) {
    this.input = input;
    this.webp = webp;
    this.br = br;
    this.output = output;
    this._dsp = _dsp;
    this._frameHeader = _frameHeader;
    this._picHeader = _picHeader;
    this._filterHeader = _filterHeader;
    this._segmentHeader = _segmentHeader;
    this._cropLeft = _cropLeft;
    this._cropRight = _cropRight;
    this._cropTop = _cropTop;
    this._cropBottom = _cropBottom;
    this._mbWidth = _mbWidth;
    this._mbHeight = _mbHeight;
    this._tlMbX = _tlMbX;
    this._tlMbY = _tlMbY;
    this._brMbX = _brMbX;
    this._brMbY = _brMbY;
    this._numPartitions = _numPartitions;
    this._partitions = _partitions;
    this._dither = _dither;
    this._ditheringRand = _ditheringRand;
    this._dqm = _dqm;
    this._proba = _proba;
    this._useSkipProba = _useSkipProba;
    this._skipP = _skipP;
    this._intraT = _intraT;
    this._intraL = _intraL;
    this._segment = _segment;
    this._yuvT = _yuvT;
    this._mbInfo = _mbInfo;
    this._fInfo = _fInfo;
    this._yuvBlock = _yuvBlock;
    this._cacheY = _cacheY;
    this._cacheU = _cacheU;
    this._cacheV = _cacheV;
    this._cacheYStride = _cacheYStride;
    this._cacheUVStride = _cacheUVStride;
    this._tmpY = _tmpY;
    this._tmpU = _tmpU;
    this._tmpV = _tmpV;
    this._y = _y;
    this._u = _u;
    this._v = _v;
    this._a = _a;
    this._mem = _mem;
    this._mbX = _mbX;
    this._mbY = _mbY;
    this._mbData = _mbData;
    this._filterType = _filterType;
    this._fStrengths = _fStrengths;
    this._alpha = _alpha;
    this._alphaData = _alphaData;
    this._isAlphaDecoded = _isAlphaDecoded;
    this._alphaPlane = _alphaPlane;
    this._layerColorspace = _layerColorspace;
    this._layerData = _layerData;
  }
  VP8.builtin$cls = "VP8";
  if (!"name" in VP8)
    VP8.name = "VP8";
  $desc = $collectedClasses.VP8;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8.prototype = $desc;
  function VP8__upsample_LOAD_UV() {
  }
  VP8__upsample_LOAD_UV.builtin$cls = "VP8__upsample_LOAD_UV";
  if (!"name" in VP8__upsample_LOAD_UV)
    VP8__upsample_LOAD_UV.name = "VP8__upsample_LOAD_UV";
  $desc = $collectedClasses.VP8__upsample_LOAD_UV;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8__upsample_LOAD_UV.prototype = $desc;
  function VP8BitReader(input, _range, _image$_value, _bits, _eof) {
    this.input = input;
    this._range = _range;
    this._image$_value = _image$_value;
    this._bits = _bits;
    this._eof = _eof;
  }
  VP8BitReader.builtin$cls = "VP8BitReader";
  if (!"name" in VP8BitReader)
    VP8BitReader.name = "VP8BitReader";
  $desc = $collectedClasses.VP8BitReader;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8BitReader.prototype = $desc;
  function VP8Filter() {
  }
  VP8Filter.builtin$cls = "VP8Filter";
  if (!"name" in VP8Filter)
    VP8Filter.name = "VP8Filter";
  $desc = $collectedClasses.VP8Filter;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8Filter.prototype = $desc;
  function VP8FrameHeader(keyFrame, profile, show, partitionLength) {
    this.keyFrame = keyFrame;
    this.profile = profile;
    this.show = show;
    this.partitionLength = partitionLength;
  }
  VP8FrameHeader.builtin$cls = "VP8FrameHeader";
  if (!"name" in VP8FrameHeader)
    VP8FrameHeader.name = "VP8FrameHeader";
  $desc = $collectedClasses.VP8FrameHeader;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8FrameHeader.prototype = $desc;
  function VP8PictureHeader(width, height, xscale, yscale, colorspace, clampType) {
    this.width = width;
    this.height = height;
    this.xscale = xscale;
    this.yscale = yscale;
    this.colorspace = colorspace;
    this.clampType = clampType;
  }
  VP8PictureHeader.builtin$cls = "VP8PictureHeader";
  if (!"name" in VP8PictureHeader)
    VP8PictureHeader.name = "VP8PictureHeader";
  $desc = $collectedClasses.VP8PictureHeader;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8PictureHeader.prototype = $desc;
  VP8PictureHeader.prototype.get$width = function(receiver) {
    return this.width;
  };
  VP8PictureHeader.prototype.get$height = function(receiver) {
    return this.height;
  };
  function VP8SegmentHeader(useSegment, updateMap, absoluteDelta, quantizer, filterStrength) {
    this.useSegment = useSegment;
    this.updateMap = updateMap;
    this.absoluteDelta = absoluteDelta;
    this.quantizer = quantizer;
    this.filterStrength = filterStrength;
  }
  VP8SegmentHeader.builtin$cls = "VP8SegmentHeader";
  if (!"name" in VP8SegmentHeader)
    VP8SegmentHeader.name = "VP8SegmentHeader";
  $desc = $collectedClasses.VP8SegmentHeader;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8SegmentHeader.prototype = $desc;
  function VP8BandProbas(probas) {
    this.probas = probas;
  }
  VP8BandProbas.builtin$cls = "VP8BandProbas";
  if (!"name" in VP8BandProbas)
    VP8BandProbas.name = "VP8BandProbas";
  $desc = $collectedClasses.VP8BandProbas;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8BandProbas.prototype = $desc;
  VP8BandProbas.prototype.get$probas = function() {
    return this.probas;
  };
  function VP8Proba(segments, bands) {
    this.segments = segments;
    this.bands = bands;
  }
  VP8Proba.builtin$cls = "VP8Proba";
  if (!"name" in VP8Proba)
    VP8Proba.name = "VP8Proba";
  $desc = $collectedClasses.VP8Proba;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8Proba.prototype = $desc;
  function VP8FilterHeader(simple, level, sharpness, useLfDelta, refLfDelta, modeLfDelta) {
    this.simple = simple;
    this.level = level;
    this.sharpness = sharpness;
    this.useLfDelta = useLfDelta;
    this.refLfDelta = refLfDelta;
    this.modeLfDelta = modeLfDelta;
  }
  VP8FilterHeader.builtin$cls = "VP8FilterHeader";
  if (!"name" in VP8FilterHeader)
    VP8FilterHeader.name = "VP8FilterHeader";
  $desc = $collectedClasses.VP8FilterHeader;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8FilterHeader.prototype = $desc;
  function VP8FInfo(fLimit, fInnerLevel, fInner, hevThresh) {
    this.fLimit = fLimit;
    this.fInnerLevel = fInnerLevel;
    this.fInner = fInner;
    this.hevThresh = hevThresh;
  }
  VP8FInfo.builtin$cls = "VP8FInfo";
  if (!"name" in VP8FInfo)
    VP8FInfo.name = "VP8FInfo";
  $desc = $collectedClasses.VP8FInfo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8FInfo.prototype = $desc;
  VP8FInfo.prototype.set$fLimit = function(v) {
    return this.fLimit = v;
  };
  VP8FInfo.prototype.get$fInnerLevel = function() {
    return this.fInnerLevel;
  };
  VP8FInfo.prototype.set$fInnerLevel = function(v) {
    return this.fInnerLevel = v;
  };
  VP8FInfo.prototype.get$fInner = function() {
    return this.fInner;
  };
  VP8FInfo.prototype.set$fInner = function(v) {
    return this.fInner = v;
  };
  function VP8MB(nz, nzDc) {
    this.nz = nz;
    this.nzDc = nzDc;
  }
  VP8MB.builtin$cls = "VP8MB";
  if (!"name" in VP8MB)
    VP8MB.name = "VP8MB";
  $desc = $collectedClasses.VP8MB;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8MB.prototype = $desc;
  VP8MB.prototype.get$nz = function() {
    return this.nz;
  };
  VP8MB.prototype.set$nz = function(v) {
    return this.nz = v;
  };
  VP8MB.prototype.get$nzDc = function() {
    return this.nzDc;
  };
  VP8MB.prototype.set$nzDc = function(v) {
    return this.nzDc = v;
  };
  function VP8QuantMatrix(y1Mat, y2Mat, uvMat, uvQuant, dither) {
    this.y1Mat = y1Mat;
    this.y2Mat = y2Mat;
    this.uvMat = uvMat;
    this.uvQuant = uvQuant;
    this.dither = dither;
  }
  VP8QuantMatrix.builtin$cls = "VP8QuantMatrix";
  if (!"name" in VP8QuantMatrix)
    VP8QuantMatrix.name = "VP8QuantMatrix";
  $desc = $collectedClasses.VP8QuantMatrix;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8QuantMatrix.prototype = $desc;
  VP8QuantMatrix.prototype.get$y1Mat = function() {
    return this.y1Mat;
  };
  VP8QuantMatrix.prototype.get$y2Mat = function() {
    return this.y2Mat;
  };
  VP8QuantMatrix.prototype.get$uvMat = function() {
    return this.uvMat;
  };
  VP8QuantMatrix.prototype.get$dither = function() {
    return this.dither;
  };
  function VP8MBData(coeffs, isIntra4x4, imodes, uvmode, nonZeroY, nonZeroUV, dither) {
    this.coeffs = coeffs;
    this.isIntra4x4 = isIntra4x4;
    this.imodes = imodes;
    this.uvmode = uvmode;
    this.nonZeroY = nonZeroY;
    this.nonZeroUV = nonZeroUV;
    this.dither = dither;
  }
  VP8MBData.builtin$cls = "VP8MBData";
  if (!"name" in VP8MBData)
    VP8MBData.name = "VP8MBData";
  $desc = $collectedClasses.VP8MBData;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8MBData.prototype = $desc;
  VP8MBData.prototype.get$coeffs = function() {
    return this.coeffs;
  };
  VP8MBData.prototype.get$isIntra4x4 = function() {
    return this.isIntra4x4;
  };
  VP8MBData.prototype.set$isIntra4x4 = function(v) {
    return this.isIntra4x4 = v;
  };
  VP8MBData.prototype.get$dither = function() {
    return this.dither;
  };
  function VP8TopSamples(y, u, v) {
    this.y = y;
    this.u = u;
    this.v = v;
  }
  VP8TopSamples.builtin$cls = "VP8TopSamples";
  if (!"name" in VP8TopSamples)
    VP8TopSamples.name = "VP8TopSamples";
  $desc = $collectedClasses.VP8TopSamples;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8TopSamples.prototype = $desc;
  VP8TopSamples.prototype.get$y = function(receiver) {
    return this.y;
  };
  VP8TopSamples.prototype.get$u = function() {
    return this.u;
  };
  VP8TopSamples.prototype.get$v = function() {
    return this.v;
  };
  function VP8L(input, br, webp, image, _lastPixel, _lastRow, _colorCacheSize, _colorCache, _huffmanMask, _huffmanSubsampleBits, _huffmanXsize, _huffmanImage, _numHtreeGroups, _htreeGroups, _transforms, _transformsSeen, _pixels, _pixels8, _argbCache, _opaque, _ioWidth, _ioHeight) {
    this.input = input;
    this.br = br;
    this.webp = webp;
    this.image = image;
    this._lastPixel = _lastPixel;
    this._lastRow = _lastRow;
    this._colorCacheSize = _colorCacheSize;
    this._colorCache = _colorCache;
    this._huffmanMask = _huffmanMask;
    this._huffmanSubsampleBits = _huffmanSubsampleBits;
    this._huffmanXsize = _huffmanXsize;
    this._huffmanImage = _huffmanImage;
    this._numHtreeGroups = _numHtreeGroups;
    this._htreeGroups = _htreeGroups;
    this._transforms = _transforms;
    this._transformsSeen = _transformsSeen;
    this._pixels = _pixels;
    this._pixels8 = _pixels8;
    this._argbCache = _argbCache;
    this._opaque = _opaque;
    this._ioWidth = _ioWidth;
    this._ioHeight = _ioHeight;
  }
  VP8L.builtin$cls = "VP8L";
  if (!"name" in VP8L)
    VP8L.name = "VP8L";
  $desc = $collectedClasses.VP8L;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8L.prototype = $desc;
  function VP8LBitReader(bitPos, _input, _buffer, _buffer8) {
    this.bitPos = bitPos;
    this._input = _input;
    this._buffer = _buffer;
    this._buffer8 = _buffer8;
  }
  VP8LBitReader.builtin$cls = "VP8LBitReader";
  if (!"name" in VP8LBitReader)
    VP8LBitReader.name = "VP8LBitReader";
  $desc = $collectedClasses.VP8LBitReader;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8LBitReader.prototype = $desc;
  function VP8LColorCache(colors, hashShift) {
    this.colors = colors;
    this.hashShift = hashShift;
  }
  VP8LColorCache.builtin$cls = "VP8LColorCache";
  if (!"name" in VP8LColorCache)
    VP8LColorCache.name = "VP8LColorCache";
  $desc = $collectedClasses.VP8LColorCache;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8LColorCache.prototype = $desc;
  function VP8LTransform(type, xsize, ysize, data, bits) {
    this.type = type;
    this.xsize = xsize;
    this.ysize = ysize;
    this.data = data;
    this.bits = bits;
  }
  VP8LTransform.builtin$cls = "VP8LTransform";
  if (!"name" in VP8LTransform)
    VP8LTransform.name = "VP8LTransform";
  $desc = $collectedClasses.VP8LTransform;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VP8LTransform.prototype = $desc;
  VP8LTransform.prototype.get$type = function(receiver) {
    return this.type;
  };
  VP8LTransform.prototype.get$data = function(receiver) {
    return this.data;
  };
  function _VP8LMultipliers(data) {
    this.data = data;
  }
  _VP8LMultipliers.builtin$cls = "_VP8LMultipliers";
  if (!"name" in _VP8LMultipliers)
    _VP8LMultipliers.name = "_VP8LMultipliers";
  $desc = $collectedClasses._VP8LMultipliers;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _VP8LMultipliers.prototype = $desc;
  _VP8LMultipliers.prototype.get$data = function(receiver) {
    return this.data;
  };
  function WebPAlpha(input, width, height, method, filter, preProcessing, rsrv, isAlphaDecoded, _vp8l, _use8bDecode) {
    this.input = input;
    this.width = width;
    this.height = height;
    this.method = method;
    this.filter = filter;
    this.preProcessing = preProcessing;
    this.rsrv = rsrv;
    this.isAlphaDecoded = isAlphaDecoded;
    this._vp8l = _vp8l;
    this._use8bDecode = _use8bDecode;
  }
  WebPAlpha.builtin$cls = "WebPAlpha";
  if (!"name" in WebPAlpha)
    WebPAlpha.name = "WebPAlpha";
  $desc = $collectedClasses.WebPAlpha;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WebPAlpha.prototype = $desc;
  WebPAlpha.prototype.get$width = function(receiver) {
    return this.width;
  };
  WebPAlpha.prototype.get$height = function(receiver) {
    return this.height;
  };
  function WebPFrame(x, y, width, height, duration, clearFrame, _reserved, _framePosition, _frameSize) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.duration = duration;
    this.clearFrame = clearFrame;
    this._reserved = _reserved;
    this._framePosition = _framePosition;
    this._frameSize = _frameSize;
  }
  WebPFrame.builtin$cls = "WebPFrame";
  if (!"name" in WebPFrame)
    WebPFrame.name = "WebPFrame";
  $desc = $collectedClasses.WebPFrame;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WebPFrame.prototype = $desc;
  WebPFrame.prototype.get$x = function(receiver) {
    return this.x;
  };
  WebPFrame.prototype.set$x = function(receiver, v) {
    return this.x = v;
  };
  WebPFrame.prototype.get$y = function(receiver) {
    return this.y;
  };
  WebPFrame.prototype.set$y = function(receiver, v) {
    return this.y = v;
  };
  WebPFrame.prototype.get$width = function(receiver) {
    return this.width;
  };
  WebPFrame.prototype.get$height = function(receiver) {
    return this.height;
  };
  WebPFrame.prototype.set$duration = function(receiver, v) {
    return this.duration = v;
  };
  WebPFrame.prototype.set$clearFrame = function(v) {
    return this.clearFrame = v;
  };
  WebPFrame.prototype.get$_frameSize = function() {
    return this._frameSize;
  };
  function _HuffmanTree(lutBits, lutSymbol, lutJump, tree, maxNodes, numNodes) {
    this.lutBits = lutBits;
    this.lutSymbol = lutSymbol;
    this.lutJump = lutJump;
    this.tree = tree;
    this.maxNodes = maxNodes;
    this.numNodes = numNodes;
  }
  _HuffmanTree.builtin$cls = "_HuffmanTree";
  if (!"name" in _HuffmanTree)
    _HuffmanTree.name = "_HuffmanTree";
  $desc = $collectedClasses._HuffmanTree;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HuffmanTree.prototype = $desc;
  _HuffmanTree.prototype.get$numNodes = function() {
    return this.numNodes;
  };
  function _HTreeGroup(htrees) {
    this.htrees = htrees;
  }
  _HTreeGroup.builtin$cls = "_HTreeGroup";
  if (!"name" in _HTreeGroup)
    _HTreeGroup.name = "_HTreeGroup";
  $desc = $collectedClasses._HTreeGroup;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _HTreeGroup.prototype = $desc;
  _HTreeGroup.prototype.get$htrees = function() {
    return this.htrees;
  };
  function WebPInfo(hasAlpha, hasAnimation, format, iccp, exif, xmp, animLoopCount, frames, progressCallback, _frame, _numFrames, _alphaData, _alphaSize, _vp8Position, _vp8Size, width, height, backgroundColor) {
    this.hasAlpha = hasAlpha;
    this.hasAnimation = hasAnimation;
    this.format = format;
    this.iccp = iccp;
    this.exif = exif;
    this.xmp = xmp;
    this.animLoopCount = animLoopCount;
    this.frames = frames;
    this.progressCallback = progressCallback;
    this._frame = _frame;
    this._numFrames = _numFrames;
    this._alphaData = _alphaData;
    this._alphaSize = _alphaSize;
    this._vp8Position = _vp8Position;
    this._vp8Size = _vp8Size;
    this.width = width;
    this.height = height;
    this.backgroundColor = backgroundColor;
  }
  WebPInfo.builtin$cls = "WebPInfo";
  if (!"name" in WebPInfo)
    WebPInfo.name = "WebPInfo";
  $desc = $collectedClasses.WebPInfo;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WebPInfo.prototype = $desc;
  function WebPDecoder(info, _input, progressCallback) {
    this.info = info;
    this._input = _input;
    this.progressCallback = progressCallback;
  }
  WebPDecoder.builtin$cls = "WebPDecoder";
  if (!"name" in WebPDecoder)
    WebPDecoder.name = "WebPDecoder";
  $desc = $collectedClasses.WebPDecoder;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WebPDecoder.prototype = $desc;
  function HdrImage(slices, red, green, blue, alpha, depth) {
    this.slices = slices;
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
    this.depth = depth;
  }
  HdrImage.builtin$cls = "HdrImage";
  if (!"name" in HdrImage)
    HdrImage.name = "HdrImage";
  $desc = $collectedClasses.HdrImage;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HdrImage.prototype = $desc;
  HdrImage.prototype.get$alpha = function(receiver) {
    return this.alpha;
  };
  function HdrSlice(name, width, height, type, data) {
    this.name = name;
    this.width = width;
    this.height = height;
    this.type = type;
    this.data = data;
  }
  HdrSlice.builtin$cls = "HdrSlice";
  if (!"name" in HdrSlice)
    HdrSlice.name = "HdrSlice";
  $desc = $collectedClasses.HdrSlice;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HdrSlice.prototype = $desc;
  HdrSlice.prototype.get$name = function(receiver) {
    return this.name;
  };
  HdrSlice.prototype.get$width = function(receiver) {
    return this.width;
  };
  HdrSlice.prototype.get$height = function(receiver) {
    return this.height;
  };
  HdrSlice.prototype.get$type = function(receiver) {
    return this.type;
  };
  HdrSlice.prototype.get$data = function(receiver) {
    return this.data;
  };
  function hdrToImage__knee() {
  }
  hdrToImage__knee.builtin$cls = "hdrToImage__knee";
  if (!"name" in hdrToImage__knee)
    hdrToImage__knee.name = "hdrToImage__knee";
  $desc = $collectedClasses.hdrToImage__knee;
  if ($desc instanceof Array)
    $desc = $desc[1];
  hdrToImage__knee.prototype = $desc;
  function hdrToImage__gamma(_knee_0) {
    this._knee_0 = _knee_0;
  }
  hdrToImage__gamma.builtin$cls = "hdrToImage__gamma";
  if (!"name" in hdrToImage__gamma)
    hdrToImage__gamma.name = "hdrToImage__gamma";
  $desc = $collectedClasses.hdrToImage__gamma;
  if ($desc instanceof Array)
    $desc = $desc[1];
  hdrToImage__gamma.prototype = $desc;
  function Image(width, height, xOffset, yOffset, duration, disposeMethod, blendMethod, data, _format) {
    this.width = width;
    this.height = height;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
    this.duration = duration;
    this.disposeMethod = disposeMethod;
    this.blendMethod = blendMethod;
    this.data = data;
    this._format = _format;
  }
  Image.builtin$cls = "Image";
  if (!"name" in Image)
    Image.name = "Image";
  $desc = $collectedClasses.Image;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Image.prototype = $desc;
  Image.prototype.get$width = function(receiver) {
    return this.width;
  };
  Image.prototype.get$height = function(receiver) {
    return this.height;
  };
  Image.prototype.set$duration = function(receiver, v) {
    return this.duration = v;
  };
  Image.prototype.get$data = function(receiver) {
    return this.data;
  };
  function ImageException(message) {
    this.message = message;
  }
  ImageException.builtin$cls = "ImageException";
  if (!"name" in ImageException)
    ImageException.name = "ImageException";
  $desc = $collectedClasses.ImageException;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ImageException.prototype = $desc;
  function InputBuffer(buffer, start, end, offset, bigEndian) {
    this.buffer = buffer;
    this.start = start;
    this.end = end;
    this.offset = offset;
    this.bigEndian = bigEndian;
  }
  InputBuffer.builtin$cls = "InputBuffer";
  if (!"name" in InputBuffer)
    InputBuffer.name = "InputBuffer";
  $desc = $collectedClasses.InputBuffer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  InputBuffer.prototype = $desc;
  InputBuffer.prototype.get$buffer = function(receiver) {
    return this.buffer;
  };
  InputBuffer.prototype.get$start = function(receiver) {
    return this.start;
  };
  InputBuffer.prototype.get$end = function() {
    return this.end;
  };
  InputBuffer.prototype.get$offset = function(receiver) {
    return this.offset;
  };
  InputBuffer.prototype.set$offset = function(receiver, v) {
    return this.offset = v;
  };
  InputBuffer.prototype.get$bigEndian = function() {
    return this.bigEndian;
  };
  function OutputBuffer(length, bigEndian, _buffer) {
    this.length = length;
    this.bigEndian = bigEndian;
    this._buffer = _buffer;
  }
  OutputBuffer.builtin$cls = "OutputBuffer";
  if (!"name" in OutputBuffer)
    OutputBuffer.name = "OutputBuffer";
  $desc = $collectedClasses.OutputBuffer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  OutputBuffer.prototype = $desc;
  OutputBuffer.prototype.get$length = function(receiver) {
    return this.length;
  };
  OutputBuffer.prototype.set$length = function(receiver, v) {
    return this.length = v;
  };
  function RandomImageSampler(_numSamples, _samples, xPixelStart, xPixelEnd, yPixelStart, yPixelEnd) {
    this._numSamples = _numSamples;
    this._samples = _samples;
    this.xPixelStart = xPixelStart;
    this.xPixelEnd = xPixelEnd;
    this.yPixelStart = yPixelStart;
    this.yPixelEnd = yPixelEnd;
  }
  RandomImageSampler.builtin$cls = "RandomImageSampler";
  if (!"name" in RandomImageSampler)
    RandomImageSampler.name = "RandomImageSampler";
  $desc = $collectedClasses.RandomImageSampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RandomImageSampler.prototype = $desc;
  function TileImageSampler(tileSize, _numSamples, _samples, xPixelStart, xPixelEnd, yPixelStart, yPixelEnd) {
    this.tileSize = tileSize;
    this._numSamples = _numSamples;
    this._samples = _samples;
    this.xPixelStart = xPixelStart;
    this.xPixelEnd = xPixelEnd;
    this.yPixelStart = yPixelStart;
    this.yPixelEnd = yPixelEnd;
  }
  TileImageSampler.builtin$cls = "TileImageSampler";
  if (!"name" in TileImageSampler)
    TileImageSampler.name = "TileImageSampler";
  $desc = $collectedClasses.TileImageSampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TileImageSampler.prototype = $desc;
  function DiffuseAreaLight(Lemit, shapeSet, area, nSamples, lightToWorld, worldToLight) {
    this.Lemit = Lemit;
    this.shapeSet = shapeSet;
    this.area = area;
    this.nSamples = nSamples;
    this.lightToWorld = lightToWorld;
    this.worldToLight = worldToLight;
  }
  DiffuseAreaLight.builtin$cls = "DiffuseAreaLight";
  if (!"name" in DiffuseAreaLight)
    DiffuseAreaLight.name = "DiffuseAreaLight";
  $desc = $collectedClasses.DiffuseAreaLight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DiffuseAreaLight.prototype = $desc;
  function DistantLight(lightDir, L, nSamples, lightToWorld, worldToLight) {
    this.lightDir = lightDir;
    this.L = L;
    this.nSamples = nSamples;
    this.lightToWorld = lightToWorld;
    this.worldToLight = worldToLight;
  }
  DistantLight.builtin$cls = "DistantLight";
  if (!"name" in DistantLight)
    DistantLight.name = "DistantLight";
  $desc = $collectedClasses.DistantLight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DistantLight.prototype = $desc;
  function GoniometricLight(lightPos, intensity, mipmap, nSamples, lightToWorld, worldToLight) {
    this.lightPos = lightPos;
    this.intensity = intensity;
    this.mipmap = mipmap;
    this.nSamples = nSamples;
    this.lightToWorld = lightToWorld;
    this.worldToLight = worldToLight;
  }
  GoniometricLight.builtin$cls = "GoniometricLight";
  if (!"name" in GoniometricLight)
    GoniometricLight.name = "GoniometricLight";
  $desc = $collectedClasses.GoniometricLight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GoniometricLight.prototype = $desc;
  function GoniometricLight_closure(this_0, completer_1) {
    this.this_0 = this_0;
    this.completer_1 = completer_1;
  }
  GoniometricLight_closure.builtin$cls = "GoniometricLight_closure";
  if (!"name" in GoniometricLight_closure)
    GoniometricLight_closure.name = "GoniometricLight_closure";
  $desc = $collectedClasses.GoniometricLight_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GoniometricLight_closure.prototype = $desc;
  function InfiniteAreaLight(radianceMap, distribution, nSamples, lightToWorld, worldToLight) {
    this.radianceMap = radianceMap;
    this.distribution = distribution;
    this.nSamples = nSamples;
    this.lightToWorld = lightToWorld;
    this.worldToLight = worldToLight;
  }
  InfiniteAreaLight.builtin$cls = "InfiniteAreaLight";
  if (!"name" in InfiniteAreaLight)
    InfiniteAreaLight.name = "InfiniteAreaLight";
  $desc = $collectedClasses.InfiniteAreaLight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  InfiniteAreaLight.prototype = $desc;
  function InfiniteAreaLight_closure(this_0, L_1, completer_2) {
    this.this_0 = this_0;
    this.L_1 = L_1;
    this.completer_2 = completer_2;
  }
  InfiniteAreaLight_closure.builtin$cls = "InfiniteAreaLight_closure";
  if (!"name" in InfiniteAreaLight_closure)
    InfiniteAreaLight_closure.name = "InfiniteAreaLight_closure";
  $desc = $collectedClasses.InfiniteAreaLight_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  InfiniteAreaLight_closure.prototype = $desc;
  function _InfiniteAreaCube(light, scene, time, pEpsilon, computeVis) {
    this.light = light;
    this.scene = scene;
    this.time = time;
    this.pEpsilon = pEpsilon;
    this.computeVis = computeVis;
  }
  _InfiniteAreaCube.builtin$cls = "_InfiniteAreaCube";
  if (!"name" in _InfiniteAreaCube)
    _InfiniteAreaCube.name = "_InfiniteAreaCube";
  $desc = $collectedClasses._InfiniteAreaCube;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _InfiniteAreaCube.prototype = $desc;
  _InfiniteAreaCube.prototype.get$time = function() {
    return this.time;
  };
  _InfiniteAreaCube.prototype.set$time = function(v) {
    return this.time = v;
  };
  function PointLight(lightPos, intensity, nSamples, lightToWorld, worldToLight) {
    this.lightPos = lightPos;
    this.intensity = intensity;
    this.nSamples = nSamples;
    this.lightToWorld = lightToWorld;
    this.worldToLight = worldToLight;
  }
  PointLight.builtin$cls = "PointLight";
  if (!"name" in PointLight)
    PointLight.name = "PointLight";
  $desc = $collectedClasses.PointLight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PointLight.prototype = $desc;
  function ProjectionLight(projectionMap, lightPos, intensity, lightProjection, hither, yon, screenX0, screenX1, screenY0, screenY1, cosTotalWidth, nSamples, lightToWorld, worldToLight) {
    this.projectionMap = projectionMap;
    this.lightPos = lightPos;
    this.intensity = intensity;
    this.lightProjection = lightProjection;
    this.hither = hither;
    this.yon = yon;
    this.screenX0 = screenX0;
    this.screenX1 = screenX1;
    this.screenY0 = screenY0;
    this.screenY1 = screenY1;
    this.cosTotalWidth = cosTotalWidth;
    this.nSamples = nSamples;
    this.lightToWorld = lightToWorld;
    this.worldToLight = worldToLight;
  }
  ProjectionLight.builtin$cls = "ProjectionLight";
  if (!"name" in ProjectionLight)
    ProjectionLight.name = "ProjectionLight";
  $desc = $collectedClasses.ProjectionLight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ProjectionLight.prototype = $desc;
  function ProjectionLight_closure(this_0, fov_1, completer_2) {
    this.this_0 = this_0;
    this.fov_1 = fov_1;
    this.completer_2 = completer_2;
  }
  ProjectionLight_closure.builtin$cls = "ProjectionLight_closure";
  if (!"name" in ProjectionLight_closure)
    ProjectionLight_closure.name = "ProjectionLight_closure";
  $desc = $collectedClasses.ProjectionLight_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ProjectionLight_closure.prototype = $desc;
  function SpotLight(lightPos, intensity, cosTotalWidth, cosFalloffStart, nSamples, lightToWorld, worldToLight) {
    this.lightPos = lightPos;
    this.intensity = intensity;
    this.cosTotalWidth = cosTotalWidth;
    this.cosFalloffStart = cosFalloffStart;
    this.nSamples = nSamples;
    this.lightToWorld = lightToWorld;
    this.worldToLight = worldToLight;
  }
  SpotLight.builtin$cls = "SpotLight";
  if (!"name" in SpotLight)
    SpotLight.name = "SpotLight";
  $desc = $collectedClasses.SpotLight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SpotLight.prototype = $desc;
  function GlassMaterial(Kr, Kt, index, bumpMap) {
    this.Kr = Kr;
    this.Kt = Kt;
    this.index = index;
    this.bumpMap = bumpMap;
  }
  GlassMaterial.builtin$cls = "GlassMaterial";
  if (!"name" in GlassMaterial)
    GlassMaterial.name = "GlassMaterial";
  $desc = $collectedClasses.GlassMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GlassMaterial.prototype = $desc;
  function KdSubsurfaceMaterial(Kd, Kr, meanfreepath, eta, bumpMap) {
    this.Kd = Kd;
    this.Kr = Kr;
    this.meanfreepath = meanfreepath;
    this.eta = eta;
    this.bumpMap = bumpMap;
  }
  KdSubsurfaceMaterial.builtin$cls = "KdSubsurfaceMaterial";
  if (!"name" in KdSubsurfaceMaterial)
    KdSubsurfaceMaterial.name = "KdSubsurfaceMaterial";
  $desc = $collectedClasses.KdSubsurfaceMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  KdSubsurfaceMaterial.prototype = $desc;
  function MatteMaterial(Kd, sigma, bumpMap) {
    this.Kd = Kd;
    this.sigma = sigma;
    this.bumpMap = bumpMap;
  }
  MatteMaterial.builtin$cls = "MatteMaterial";
  if (!"name" in MatteMaterial)
    MatteMaterial.name = "MatteMaterial";
  $desc = $collectedClasses.MatteMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MatteMaterial.prototype = $desc;
  function MeasuredMaterial(thetaPhiData, regularHalfangleData, nThetaH, nThetaD, nPhiD, bumpMap) {
    this.thetaPhiData = thetaPhiData;
    this.regularHalfangleData = regularHalfangleData;
    this.nThetaH = nThetaH;
    this.nThetaD = nThetaD;
    this.nPhiD = nPhiD;
    this.bumpMap = bumpMap;
  }
  MeasuredMaterial.builtin$cls = "MeasuredMaterial";
  if (!"name" in MeasuredMaterial)
    MeasuredMaterial.name = "MeasuredMaterial";
  $desc = $collectedClasses.MeasuredMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MeasuredMaterial.prototype = $desc;
  function MeasuredMaterial_closure(this_0, filename_1, c_2) {
    this.this_0 = this_0;
    this.filename_1 = filename_1;
    this.c_2 = c_2;
  }
  MeasuredMaterial_closure.builtin$cls = "MeasuredMaterial_closure";
  if (!"name" in MeasuredMaterial_closure)
    MeasuredMaterial_closure.name = "MeasuredMaterial_closure";
  $desc = $collectedClasses.MeasuredMaterial_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MeasuredMaterial_closure.prototype = $desc;
  function MeasuredMaterial_closure0(this_3, filename_4, c_5) {
    this.this_3 = this_3;
    this.filename_4 = filename_4;
    this.c_5 = c_5;
  }
  MeasuredMaterial_closure0.builtin$cls = "MeasuredMaterial_closure0";
  if (!"name" in MeasuredMaterial_closure0)
    MeasuredMaterial_closure0.name = "MeasuredMaterial_closure0";
  $desc = $collectedClasses.MeasuredMaterial_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MeasuredMaterial_closure0.prototype = $desc;
  function MetalMaterial(eta, k, roughness, bumpMap) {
    this.eta = eta;
    this.k = k;
    this.roughness = roughness;
    this.bumpMap = bumpMap;
  }
  MetalMaterial.builtin$cls = "MetalMaterial";
  if (!"name" in MetalMaterial)
    MetalMaterial.name = "MetalMaterial";
  $desc = $collectedClasses.MetalMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MetalMaterial.prototype = $desc;
  function MirrorMaterial(Kr, bumpMap) {
    this.Kr = Kr;
    this.bumpMap = bumpMap;
  }
  MirrorMaterial.builtin$cls = "MirrorMaterial";
  if (!"name" in MirrorMaterial)
    MirrorMaterial.name = "MirrorMaterial";
  $desc = $collectedClasses.MirrorMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MirrorMaterial.prototype = $desc;
  function MixMaterial(m1, m2, scale) {
    this.m1 = m1;
    this.m2 = m2;
    this.scale = scale;
  }
  MixMaterial.builtin$cls = "MixMaterial";
  if (!"name" in MixMaterial)
    MixMaterial.name = "MixMaterial";
  $desc = $collectedClasses.MixMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MixMaterial.prototype = $desc;
  function PlasticMaterial(Kd, Ks, roughness, bumpMap) {
    this.Kd = Kd;
    this.Ks = Ks;
    this.roughness = roughness;
    this.bumpMap = bumpMap;
  }
  PlasticMaterial.builtin$cls = "PlasticMaterial";
  if (!"name" in PlasticMaterial)
    PlasticMaterial.name = "PlasticMaterial";
  $desc = $collectedClasses.PlasticMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PlasticMaterial.prototype = $desc;
  function ShinyMetalMaterial(Ks, Kr, roughness, bumpMap) {
    this.Ks = Ks;
    this.Kr = Kr;
    this.roughness = roughness;
    this.bumpMap = bumpMap;
  }
  ShinyMetalMaterial.builtin$cls = "ShinyMetalMaterial";
  if (!"name" in ShinyMetalMaterial)
    ShinyMetalMaterial.name = "ShinyMetalMaterial";
  $desc = $collectedClasses.ShinyMetalMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ShinyMetalMaterial.prototype = $desc;
  function SubstrateMaterial(Kd, Ks, nu, nv, bumpMap) {
    this.Kd = Kd;
    this.Ks = Ks;
    this.nu = nu;
    this.nv = nv;
    this.bumpMap = bumpMap;
  }
  SubstrateMaterial.builtin$cls = "SubstrateMaterial";
  if (!"name" in SubstrateMaterial)
    SubstrateMaterial.name = "SubstrateMaterial";
  $desc = $collectedClasses.SubstrateMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SubstrateMaterial.prototype = $desc;
  function SubsurfaceMaterial(scale, Kr, sigma_a, sigma_prime_s, eta, bumpMap) {
    this.scale = scale;
    this.Kr = Kr;
    this.sigma_a = sigma_a;
    this.sigma_prime_s = sigma_prime_s;
    this.eta = eta;
    this.bumpMap = bumpMap;
  }
  SubsurfaceMaterial.builtin$cls = "SubsurfaceMaterial";
  if (!"name" in SubsurfaceMaterial)
    SubsurfaceMaterial.name = "SubsurfaceMaterial";
  $desc = $collectedClasses.SubsurfaceMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SubsurfaceMaterial.prototype = $desc;
  function TranslucentMaterial(Kd, Ks, roughness, reflect, transmit, bumpMap) {
    this.Kd = Kd;
    this.Ks = Ks;
    this.roughness = roughness;
    this.reflect = reflect;
    this.transmit = transmit;
    this.bumpMap = bumpMap;
  }
  TranslucentMaterial.builtin$cls = "TranslucentMaterial";
  if (!"name" in TranslucentMaterial)
    TranslucentMaterial.name = "TranslucentMaterial";
  $desc = $collectedClasses.TranslucentMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TranslucentMaterial.prototype = $desc;
  function UberMaterial(Kd, Ks, Kr, Kt, opacity, roughness, eta, bumpMap) {
    this.Kd = Kd;
    this.Ks = Ks;
    this.Kr = Kr;
    this.Kt = Kt;
    this.opacity = opacity;
    this.roughness = roughness;
    this.eta = eta;
    this.bumpMap = bumpMap;
  }
  UberMaterial.builtin$cls = "UberMaterial";
  if (!"name" in UberMaterial)
    UberMaterial.name = "UberMaterial";
  $desc = $collectedClasses.UberMaterial;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UberMaterial.prototype = $desc;
  function GraphicsState(doubleTextures, spectrumTextures, materialParams, material, namedMaterials, currentNamedMaterial, areaLightParams, areaLight, reverseOrientation) {
    this.doubleTextures = doubleTextures;
    this.spectrumTextures = spectrumTextures;
    this.materialParams = materialParams;
    this.material = material;
    this.namedMaterials = namedMaterials;
    this.currentNamedMaterial = currentNamedMaterial;
    this.areaLightParams = areaLightParams;
    this.areaLight = areaLight;
    this.reverseOrientation = reverseOrientation;
  }
  GraphicsState.builtin$cls = "GraphicsState";
  if (!"name" in GraphicsState)
    GraphicsState.name = "GraphicsState";
  $desc = $collectedClasses.GraphicsState;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GraphicsState.prototype = $desc;
  GraphicsState.prototype.get$doubleTextures = function() {
    return this.doubleTextures;
  };
  GraphicsState.prototype.get$spectrumTextures = function() {
    return this.spectrumTextures;
  };
  GraphicsState.prototype.get$materialParams = function() {
    return this.materialParams;
  };
  GraphicsState.prototype.set$materialParams = function(v) {
    return this.materialParams = v;
  };
  GraphicsState.prototype.get$material = function() {
    return this.material;
  };
  GraphicsState.prototype.set$material = function(v) {
    return this.material = v;
  };
  GraphicsState.prototype.get$namedMaterials = function() {
    return this.namedMaterials;
  };
  GraphicsState.prototype.set$currentNamedMaterial = function(v) {
    return this.currentNamedMaterial = v;
  };
  GraphicsState.prototype.get$areaLightParams = function() {
    return this.areaLightParams;
  };
  GraphicsState.prototype.set$areaLightParams = function(v) {
    return this.areaLightParams = v;
  };
  GraphicsState.prototype.get$areaLight = function() {
    return this.areaLight;
  };
  GraphicsState.prototype.set$areaLight = function(v) {
    return this.areaLight = v;
  };
  GraphicsState.prototype.get$reverseOrientation = function() {
    return this.reverseOrientation;
  };
  GraphicsState.prototype.set$reverseOrientation = function(v) {
    return this.reverseOrientation = v;
  };
  function Pbrt(resourceManager, _currentApiState, _curTransform, _activeTransformBits, _namedCoordinateSystems, _renderOptions, _graphicsState, _pushedGraphicsStates, _pushedTransforms, _pushedActiveTransformBits, _renderer, _scene) {
    this.resourceManager = resourceManager;
    this._currentApiState = _currentApiState;
    this._curTransform = _curTransform;
    this._activeTransformBits = _activeTransformBits;
    this._namedCoordinateSystems = _namedCoordinateSystems;
    this._renderOptions = _renderOptions;
    this._graphicsState = _graphicsState;
    this._pushedGraphicsStates = _pushedGraphicsStates;
    this._pushedTransforms = _pushedTransforms;
    this._pushedActiveTransformBits = _pushedActiveTransformBits;
    this._renderer = _renderer;
    this._scene = _scene;
  }
  Pbrt.builtin$cls = "Pbrt";
  if (!"name" in Pbrt)
    Pbrt.name = "Pbrt";
  $desc = $collectedClasses.Pbrt;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Pbrt.prototype = $desc;
  Pbrt.prototype.get$_renderOptions = function() {
    return this._renderOptions;
  };
  function Pbrt_renderScene_closure(this_0, t_1, c_2) {
    this.this_0 = this_0;
    this.t_1 = t_1;
    this.c_2 = c_2;
  }
  Pbrt_renderScene_closure.builtin$cls = "Pbrt_renderScene_closure";
  if (!"name" in Pbrt_renderScene_closure)
    Pbrt_renderScene_closure.name = "Pbrt_renderScene_closure";
  $desc = $collectedClasses.Pbrt_renderScene_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Pbrt_renderScene_closure.prototype = $desc;
  function Pbrt_renderScene__closure(this_3, t_4, c_5) {
    this.this_3 = this_3;
    this.t_4 = t_4;
    this.c_5 = c_5;
  }
  Pbrt_renderScene__closure.builtin$cls = "Pbrt_renderScene__closure";
  if (!"name" in Pbrt_renderScene__closure)
    Pbrt_renderScene__closure.name = "Pbrt_renderScene__closure";
  $desc = $collectedClasses.Pbrt_renderScene__closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Pbrt_renderScene__closure.prototype = $desc;
  function PbrtLexer(_inputStack, _identifierStr, _numValue, _lastChar, _curToken, _curTokenStr) {
    this._inputStack = _inputStack;
    this._identifierStr = _identifierStr;
    this._numValue = _numValue;
    this._lastChar = _lastChar;
    this._curToken = _curToken;
    this._curTokenStr = _curTokenStr;
  }
  PbrtLexer.builtin$cls = "PbrtLexer";
  if (!"name" in PbrtLexer)
    PbrtLexer.name = "PbrtLexer";
  $desc = $collectedClasses.PbrtLexer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtLexer.prototype = $desc;
  function _PbrtLexerInput(input, path, line, position) {
    this.input = input;
    this.path = path;
    this.line = line;
    this.position = position;
  }
  _PbrtLexerInput.builtin$cls = "_PbrtLexerInput";
  if (!"name" in _PbrtLexerInput)
    _PbrtLexerInput.name = "_PbrtLexerInput";
  $desc = $collectedClasses._PbrtLexerInput;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _PbrtLexerInput.prototype = $desc;
  _PbrtLexerInput.prototype.get$path = function(receiver) {
    return this.path;
  };
  _PbrtLexerInput.prototype.get$line = function() {
    return this.line;
  };
  _PbrtLexerInput.prototype.set$line = function(v) {
    return this.line = v;
  };
  function PbrtParser(pbrt, resourceManager) {
    this.pbrt = pbrt;
    this.resourceManager = resourceManager;
  }
  PbrtParser.builtin$cls = "PbrtParser";
  if (!"name" in PbrtParser)
    PbrtParser.name = "PbrtParser";
  $desc = $collectedClasses.PbrtParser;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser.prototype = $desc;
  function PbrtParser_parse_closure(this_0, file_1, t_2, c_3) {
    this.this_0 = this_0;
    this.file_1 = file_1;
    this.t_2 = t_2;
    this.c_3 = c_3;
  }
  PbrtParser_parse_closure.builtin$cls = "PbrtParser_parse_closure";
  if (!"name" in PbrtParser_parse_closure)
    PbrtParser_parse_closure.name = "PbrtParser_parse_closure";
  $desc = $collectedClasses.PbrtParser_parse_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser_parse_closure.prototype = $desc;
  function PbrtParser_parse__closure(this_4, file_5, t_6, c_7, input_8) {
    this.this_4 = this_4;
    this.file_5 = file_5;
    this.t_6 = t_6;
    this.c_7 = c_7;
    this.input_8 = input_8;
  }
  PbrtParser_parse__closure.builtin$cls = "PbrtParser_parse__closure";
  if (!"name" in PbrtParser_parse__closure)
    PbrtParser_parse__closure.name = "PbrtParser_parse__closure";
  $desc = $collectedClasses.PbrtParser_parse__closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser_parse__closure.prototype = $desc;
  function PbrtParser_parse___closure(t_9, c_10) {
    this.t_9 = t_9;
    this.c_10 = c_10;
  }
  PbrtParser_parse___closure.builtin$cls = "PbrtParser_parse___closure";
  if (!"name" in PbrtParser_parse___closure)
    PbrtParser_parse___closure.name = "PbrtParser_parse___closure";
  $desc = $collectedClasses.PbrtParser_parse___closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser_parse___closure.prototype = $desc;
  function PbrtParser__loadIncludes_closure(cmd_0) {
    this.cmd_0 = cmd_0;
  }
  PbrtParser__loadIncludes_closure.builtin$cls = "PbrtParser__loadIncludes_closure";
  if (!"name" in PbrtParser__loadIncludes_closure)
    PbrtParser__loadIncludes_closure.name = "PbrtParser__loadIncludes_closure";
  $desc = $collectedClasses.PbrtParser__loadIncludes_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser__loadIncludes_closure.prototype = $desc;
  function PbrtParser__loadIncludes_closure0(this_1, c_2) {
    this.this_1 = this_1;
    this.c_2 = c_2;
  }
  PbrtParser__loadIncludes_closure0.builtin$cls = "PbrtParser__loadIncludes_closure0";
  if (!"name" in PbrtParser__loadIncludes_closure0)
    PbrtParser__loadIncludes_closure0.name = "PbrtParser__loadIncludes_closure0";
  $desc = $collectedClasses.PbrtParser__loadIncludes_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser__loadIncludes_closure0.prototype = $desc;
  function PbrtParser__loadIncludes__closure(c_3) {
    this.c_3 = c_3;
  }
  PbrtParser__loadIncludes__closure.builtin$cls = "PbrtParser__loadIncludes__closure";
  if (!"name" in PbrtParser__loadIncludes__closure)
    PbrtParser__loadIncludes__closure.name = "PbrtParser__loadIncludes__closure";
  $desc = $collectedClasses.PbrtParser__loadIncludes__closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser__loadIncludes__closure.prototype = $desc;
  function PbrtParser__loadIncludes__closure0(c_4) {
    this.c_4 = c_4;
  }
  PbrtParser__loadIncludes__closure0.builtin$cls = "PbrtParser__loadIncludes__closure0";
  if (!"name" in PbrtParser__loadIncludes__closure0)
    PbrtParser__loadIncludes__closure0.name = "PbrtParser__loadIncludes__closure0";
  $desc = $collectedClasses.PbrtParser__loadIncludes__closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser__loadIncludes__closure0.prototype = $desc;
  function PbrtParser__loadIncludes_closure1(c_5) {
    this.c_5 = c_5;
  }
  PbrtParser__loadIncludes_closure1.builtin$cls = "PbrtParser__loadIncludes_closure1";
  if (!"name" in PbrtParser__loadIncludes_closure1)
    PbrtParser__loadIncludes_closure1.name = "PbrtParser__loadIncludes_closure1";
  $desc = $collectedClasses.PbrtParser__loadIncludes_closure1;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser__loadIncludes_closure1.prototype = $desc;
  function PbrtParser__parse_closure(c_0) {
    this.c_0 = c_0;
  }
  PbrtParser__parse_closure.builtin$cls = "PbrtParser__parse_closure";
  if (!"name" in PbrtParser__parse_closure)
    PbrtParser__parse_closure.name = "PbrtParser__parse_closure";
  $desc = $collectedClasses.PbrtParser__parse_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser__parse_closure.prototype = $desc;
  function PbrtParser__parseCommand_closure() {
  }
  PbrtParser__parseCommand_closure.builtin$cls = "PbrtParser__parseCommand_closure";
  if (!"name" in PbrtParser__parseCommand_closure)
    PbrtParser__parseCommand_closure.name = "PbrtParser__parseCommand_closure";
  $desc = $collectedClasses.PbrtParser__parseCommand_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PbrtParser__parseCommand_closure.prototype = $desc;
  function RenderIsolate(CONNECTING, CONNECTED, STOPPED, status, taskNum, taskCount, receivePort, sendPort, manager, rng, requests) {
    this.CONNECTING = CONNECTING;
    this.CONNECTED = CONNECTED;
    this.STOPPED = STOPPED;
    this.status = status;
    this.taskNum = taskNum;
    this.taskCount = taskCount;
    this.receivePort = receivePort;
    this.sendPort = sendPort;
    this.manager = manager;
    this.rng = rng;
    this.requests = requests;
  }
  RenderIsolate.builtin$cls = "RenderIsolate";
  if (!"name" in RenderIsolate)
    RenderIsolate.name = "RenderIsolate";
  $desc = $collectedClasses.RenderIsolate;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderIsolate.prototype = $desc;
  function RenderIsolate_start_closure(this_0) {
    this.this_0 = this_0;
  }
  RenderIsolate_start_closure.builtin$cls = "RenderIsolate_start_closure";
  if (!"name" in RenderIsolate_start_closure)
    RenderIsolate_start_closure.name = "RenderIsolate_start_closure";
  $desc = $collectedClasses.RenderIsolate_start_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderIsolate_start_closure.prototype = $desc;
  function RenderIsolate__render_closure(this_0) {
    this.this_0 = this_0;
  }
  RenderIsolate__render_closure.builtin$cls = "RenderIsolate__render_closure";
  if (!"name" in RenderIsolate__render_closure)
    RenderIsolate__render_closure.name = "RenderIsolate__render_closure";
  $desc = $collectedClasses.RenderIsolate__render_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderIsolate__render_closure.prototype = $desc;
  function RenderIsolate__render_closure0(this_1, taskNum_2, timer_3) {
    this.this_1 = this_1;
    this.taskNum_2 = taskNum_2;
    this.timer_3 = timer_3;
  }
  RenderIsolate__render_closure0.builtin$cls = "RenderIsolate__render_closure0";
  if (!"name" in RenderIsolate__render_closure0)
    RenderIsolate__render_closure0.name = "RenderIsolate__render_closure0";
  $desc = $collectedClasses.RenderIsolate__render_closure0;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderIsolate__render_closure0.prototype = $desc;
  function RenderManagerInterface() {
  }
  RenderManagerInterface.builtin$cls = "RenderManagerInterface";
  if (!"name" in RenderManagerInterface)
    RenderManagerInterface.name = "RenderManagerInterface";
  $desc = $collectedClasses.RenderManagerInterface;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderManagerInterface.prototype = $desc;
  function RenderOptions(transformStartTime, transformEndTime, filterName, filterParams, filmName, filmParams, outputImage, previewCallback, samplerName, samplerParams, acceleratorName, acceleratorParams, rendererName, surfIntegratorName, volIntegratorName, rendererParams, surfIntegratorParams, volIntegratorParams, cameraName, cameraParams, cameraToWorld, lights, primitives, volumeRegions, instances, currentInstance, taskNum, taskCount) {
    this.transformStartTime = transformStartTime;
    this.transformEndTime = transformEndTime;
    this.filterName = filterName;
    this.filterParams = filterParams;
    this.filmName = filmName;
    this.filmParams = filmParams;
    this.outputImage = outputImage;
    this.previewCallback = previewCallback;
    this.samplerName = samplerName;
    this.samplerParams = samplerParams;
    this.acceleratorName = acceleratorName;
    this.acceleratorParams = acceleratorParams;
    this.rendererName = rendererName;
    this.surfIntegratorName = surfIntegratorName;
    this.volIntegratorName = volIntegratorName;
    this.rendererParams = rendererParams;
    this.surfIntegratorParams = surfIntegratorParams;
    this.volIntegratorParams = volIntegratorParams;
    this.cameraName = cameraName;
    this.cameraParams = cameraParams;
    this.cameraToWorld = cameraToWorld;
    this.lights = lights;
    this.primitives = primitives;
    this.volumeRegions = volumeRegions;
    this.instances = instances;
    this.currentInstance = currentInstance;
    this.taskNum = taskNum;
    this.taskCount = taskCount;
  }
  RenderOptions.builtin$cls = "RenderOptions";
  if (!"name" in RenderOptions)
    RenderOptions.name = "RenderOptions";
  $desc = $collectedClasses.RenderOptions;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RenderOptions.prototype = $desc;
  function TransformSet(t) {
    this.t = t;
  }
  TransformSet.builtin$cls = "TransformSet";
  if (!"name" in TransformSet)
    TransformSet.name = "TransformSet";
  $desc = $collectedClasses.TransformSet;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TransformSet.prototype = $desc;
  TransformSet.prototype.get$t = function() {
    return this.t;
  };
  function AggregateTestRenderer(nIterations, primitives, bboxes) {
    this.nIterations = nIterations;
    this.primitives = primitives;
    this.bboxes = bboxes;
  }
  AggregateTestRenderer.builtin$cls = "AggregateTestRenderer";
  if (!"name" in AggregateTestRenderer)
    AggregateTestRenderer.name = "AggregateTestRenderer";
  $desc = $collectedClasses.AggregateTestRenderer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AggregateTestRenderer.prototype = $desc;
  function MetropolisRenderer(taskNum, taskCount, camera, bidirectional, nDirectPixelSamples, nPixelSamples, maxDepth, largeStepsPerPixel, nBootstrap, maxConsecutiveRejects, directLighting) {
    this.taskNum = taskNum;
    this.taskCount = taskCount;
    this.camera = camera;
    this.bidirectional = bidirectional;
    this.nDirectPixelSamples = nDirectPixelSamples;
    this.nPixelSamples = nPixelSamples;
    this.maxDepth = maxDepth;
    this.largeStepsPerPixel = largeStepsPerPixel;
    this.nBootstrap = nBootstrap;
    this.maxConsecutiveRejects = maxConsecutiveRejects;
    this.directLighting = directLighting;
  }
  MetropolisRenderer.builtin$cls = "MetropolisRenderer";
  if (!"name" in MetropolisRenderer)
    MetropolisRenderer.name = "MetropolisRenderer";
  $desc = $collectedClasses.MetropolisRenderer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MetropolisRenderer.prototype = $desc;
  function _PathSample(bsdfSample, rrSample) {
    this.bsdfSample = bsdfSample;
    this.rrSample = rrSample;
  }
  _PathSample.builtin$cls = "_PathSample";
  if (!"name" in _PathSample)
    _PathSample.name = "_PathSample";
  $desc = $collectedClasses._PathSample;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _PathSample.prototype = $desc;
  _PathSample.prototype.get$bsdfSample = function() {
    return this.bsdfSample;
  };
  _PathSample.prototype.get$rrSample = function() {
    return this.rrSample;
  };
  _PathSample.prototype.set$rrSample = function(v) {
    return this.rrSample = v;
  };
  function _LightingSample(bsdfSample, lightNum, lightSample) {
    this.bsdfSample = bsdfSample;
    this.lightNum = lightNum;
    this.lightSample = lightSample;
  }
  _LightingSample.builtin$cls = "_LightingSample";
  if (!"name" in _LightingSample)
    _LightingSample.name = "_LightingSample";
  $desc = $collectedClasses._LightingSample;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _LightingSample.prototype = $desc;
  _LightingSample.prototype.get$bsdfSample = function() {
    return this.bsdfSample;
  };
  _LightingSample.prototype.get$lightNum = function() {
    return this.lightNum;
  };
  _LightingSample.prototype.set$lightNum = function(v) {
    return this.lightNum = v;
  };
  function _PathVertex(isect, wPrev, wNext, bsdf, specularBounce, nSpecularComponents, alpha) {
    this.isect = isect;
    this.wPrev = wPrev;
    this.wNext = wNext;
    this.bsdf = bsdf;
    this.specularBounce = specularBounce;
    this.nSpecularComponents = nSpecularComponents;
    this.alpha = alpha;
  }
  _PathVertex.builtin$cls = "_PathVertex";
  if (!"name" in _PathVertex)
    _PathVertex.name = "_PathVertex";
  $desc = $collectedClasses._PathVertex;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _PathVertex.prototype = $desc;
  _PathVertex.prototype.get$isect = function() {
    return this.isect;
  };
  _PathVertex.prototype.get$bsdf = function() {
    return this.bsdf;
  };
  _PathVertex.prototype.get$specularBounce = function() {
    return this.specularBounce;
  };
  _PathVertex.prototype.get$alpha = function(receiver) {
    return this.alpha;
  };
  function _MLTSample(cameraSample, lightNumSample, lightRaySamples, cameraPathSamples, lightPathSamples, lightingSamples) {
    this.cameraSample = cameraSample;
    this.lightNumSample = lightNumSample;
    this.lightRaySamples = lightRaySamples;
    this.cameraPathSamples = cameraPathSamples;
    this.lightPathSamples = lightPathSamples;
    this.lightingSamples = lightingSamples;
  }
  _MLTSample.builtin$cls = "_MLTSample";
  if (!"name" in _MLTSample)
    _MLTSample.name = "_MLTSample";
  $desc = $collectedClasses._MLTSample;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _MLTSample.prototype = $desc;
  _MLTSample.prototype.get$cameraSample = function() {
    return this.cameraSample;
  };
  function _MLTTask(taskNum, dx, dy, currentPixelSample, x0, x1, y0, y1, t0, t1, b, initialSample, scene, camera, renderer, lightDistribution) {
    this.taskNum = taskNum;
    this.dx = dx;
    this.dy = dy;
    this.currentPixelSample = currentPixelSample;
    this.x0 = x0;
    this.x1 = x1;
    this.y0 = y0;
    this.y1 = y1;
    this.t0 = t0;
    this.t1 = t1;
    this.b = b;
    this.initialSample = initialSample;
    this.scene = scene;
    this.camera = camera;
    this.renderer = renderer;
    this.lightDistribution = lightDistribution;
  }
  _MLTTask.builtin$cls = "_MLTTask";
  if (!"name" in _MLTTask)
    _MLTTask.name = "_MLTTask";
  $desc = $collectedClasses._MLTTask;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _MLTTask.prototype = $desc;
  function SamplerRenderer(taskNum, taskCount, sampler, camera, surfaceIntegrator, volumeIntegrator) {
    this.taskNum = taskNum;
    this.taskCount = taskCount;
    this.sampler = sampler;
    this.camera = camera;
    this.surfaceIntegrator = surfaceIntegrator;
    this.volumeIntegrator = volumeIntegrator;
  }
  SamplerRenderer.builtin$cls = "SamplerRenderer";
  if (!"name" in SamplerRenderer)
    SamplerRenderer.name = "SamplerRenderer";
  $desc = $collectedClasses.SamplerRenderer;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SamplerRenderer.prototype = $desc;
  function _SamplerRendererTask(scene, renderer, camera, mainSampler, origSample, taskNum, taskCount) {
    this.scene = scene;
    this.renderer = renderer;
    this.camera = camera;
    this.mainSampler = mainSampler;
    this.origSample = origSample;
    this.taskNum = taskNum;
    this.taskCount = taskCount;
  }
  _SamplerRendererTask.builtin$cls = "_SamplerRendererTask";
  if (!"name" in _SamplerRendererTask)
    _SamplerRendererTask.name = "_SamplerRendererTask";
  $desc = $collectedClasses._SamplerRendererTask;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SamplerRendererTask.prototype = $desc;
  function AdaptiveSampler(pixels, pixel, pixelIndex, minSamples, maxSamples, sampleBuf, method, supersamplePixel, xPixelStart, xPixelEnd, yPixelStart, yPixelEnd, samplesPerPixel, shutterOpen, shutterClose) {
    this.pixels = pixels;
    this.pixel = pixel;
    this.pixelIndex = pixelIndex;
    this.minSamples = minSamples;
    this.maxSamples = maxSamples;
    this.sampleBuf = sampleBuf;
    this.method = method;
    this.supersamplePixel = supersamplePixel;
    this.xPixelStart = xPixelStart;
    this.xPixelEnd = xPixelEnd;
    this.yPixelStart = yPixelStart;
    this.yPixelEnd = yPixelEnd;
    this.samplesPerPixel = samplesPerPixel;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
  }
  AdaptiveSampler.builtin$cls = "AdaptiveSampler";
  if (!"name" in AdaptiveSampler)
    AdaptiveSampler.name = "AdaptiveSampler";
  $desc = $collectedClasses.AdaptiveSampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AdaptiveSampler.prototype = $desc;
  function BestCandidateSampler(tableWidth, tableOffset, xTileStart, xTileEnd, yTileStart, yTileEnd, xTile, yTile, sampleOffsets, xPixelStart, xPixelEnd, yPixelStart, yPixelEnd, samplesPerPixel, shutterOpen, shutterClose) {
    this.tableWidth = tableWidth;
    this.tableOffset = tableOffset;
    this.xTileStart = xTileStart;
    this.xTileEnd = xTileEnd;
    this.yTileStart = yTileStart;
    this.yTileEnd = yTileEnd;
    this.xTile = xTile;
    this.yTile = yTile;
    this.sampleOffsets = sampleOffsets;
    this.xPixelStart = xPixelStart;
    this.xPixelEnd = xPixelEnd;
    this.yPixelStart = yPixelStart;
    this.yPixelEnd = yPixelEnd;
    this.samplesPerPixel = samplesPerPixel;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
  }
  BestCandidateSampler.builtin$cls = "BestCandidateSampler";
  if (!"name" in BestCandidateSampler)
    BestCandidateSampler.name = "BestCandidateSampler";
  $desc = $collectedClasses.BestCandidateSampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BestCandidateSampler.prototype = $desc;
  function BestCandidateSampler_getMoreSamples_WRAP() {
  }
  BestCandidateSampler_getMoreSamples_WRAP.builtin$cls = "BestCandidateSampler_getMoreSamples_WRAP";
  if (!"name" in BestCandidateSampler_getMoreSamples_WRAP)
    BestCandidateSampler_getMoreSamples_WRAP.name = "BestCandidateSampler_getMoreSamples_WRAP";
  $desc = $collectedClasses.BestCandidateSampler_getMoreSamples_WRAP;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BestCandidateSampler_getMoreSamples_WRAP.prototype = $desc;
  function HaltonSampler(wantedSamples, currentSample, xPixelStart, xPixelEnd, yPixelStart, yPixelEnd, samplesPerPixel, shutterOpen, shutterClose) {
    this.wantedSamples = wantedSamples;
    this.currentSample = currentSample;
    this.xPixelStart = xPixelStart;
    this.xPixelEnd = xPixelEnd;
    this.yPixelStart = yPixelStart;
    this.yPixelEnd = yPixelEnd;
    this.samplesPerPixel = samplesPerPixel;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
  }
  HaltonSampler.builtin$cls = "HaltonSampler";
  if (!"name" in HaltonSampler)
    HaltonSampler.name = "HaltonSampler";
  $desc = $collectedClasses.HaltonSampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HaltonSampler.prototype = $desc;
  function LowDiscrepancySampler(pixels, pixel, pixelIndex, nPixelSamples, sampleBuf, xPixelStart, xPixelEnd, yPixelStart, yPixelEnd, samplesPerPixel, shutterOpen, shutterClose) {
    this.pixels = pixels;
    this.pixel = pixel;
    this.pixelIndex = pixelIndex;
    this.nPixelSamples = nPixelSamples;
    this.sampleBuf = sampleBuf;
    this.xPixelStart = xPixelStart;
    this.xPixelEnd = xPixelEnd;
    this.yPixelStart = yPixelStart;
    this.yPixelEnd = yPixelEnd;
    this.samplesPerPixel = samplesPerPixel;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
  }
  LowDiscrepancySampler.builtin$cls = "LowDiscrepancySampler";
  if (!"name" in LowDiscrepancySampler)
    LowDiscrepancySampler.name = "LowDiscrepancySampler";
  $desc = $collectedClasses.LowDiscrepancySampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LowDiscrepancySampler.prototype = $desc;
  function RandomSampler(continuous, pixels, pixel, pixelIndex, imageSamples, lensSamples, timeSamples, samplePos, xPixelStart, xPixelEnd, yPixelStart, yPixelEnd, samplesPerPixel, shutterOpen, shutterClose) {
    this.continuous = continuous;
    this.pixels = pixels;
    this.pixel = pixel;
    this.pixelIndex = pixelIndex;
    this.imageSamples = imageSamples;
    this.lensSamples = lensSamples;
    this.timeSamples = timeSamples;
    this.samplePos = samplePos;
    this.xPixelStart = xPixelStart;
    this.xPixelEnd = xPixelEnd;
    this.yPixelStart = yPixelStart;
    this.yPixelEnd = yPixelEnd;
    this.samplesPerPixel = samplesPerPixel;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
  }
  RandomSampler.builtin$cls = "RandomSampler";
  if (!"name" in RandomSampler)
    RandomSampler.name = "RandomSampler";
  $desc = $collectedClasses.RandomSampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RandomSampler.prototype = $desc;
  function StratifiedSampler(xPixelSamples, yPixelSamples, nPixelSamples, jitterSamples, pixels, pixel, pixelIndex, imageSamples, lensSamples, timeSamples, xPixelStart, xPixelEnd, yPixelStart, yPixelEnd, samplesPerPixel, shutterOpen, shutterClose) {
    this.xPixelSamples = xPixelSamples;
    this.yPixelSamples = yPixelSamples;
    this.nPixelSamples = nPixelSamples;
    this.jitterSamples = jitterSamples;
    this.pixels = pixels;
    this.pixel = pixel;
    this.pixelIndex = pixelIndex;
    this.imageSamples = imageSamples;
    this.lensSamples = lensSamples;
    this.timeSamples = timeSamples;
    this.xPixelStart = xPixelStart;
    this.xPixelEnd = xPixelEnd;
    this.yPixelStart = yPixelStart;
    this.yPixelEnd = yPixelEnd;
    this.samplesPerPixel = samplesPerPixel;
    this.shutterOpen = shutterOpen;
    this.shutterClose = shutterClose;
  }
  StratifiedSampler.builtin$cls = "StratifiedSampler";
  if (!"name" in StratifiedSampler)
    StratifiedSampler.name = "StratifiedSampler";
  $desc = $collectedClasses.StratifiedSampler;
  if ($desc instanceof Array)
    $desc = $desc[1];
  StratifiedSampler.prototype = $desc;
  function ConeShape(radius, height, phiMax, objectToWorld, worldToObject, reverseOrientation, transformSwapsHandedness, shapeId) {
    this.radius = radius;
    this.height = height;
    this.phiMax = phiMax;
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.transformSwapsHandedness = transformSwapsHandedness;
    this.shapeId = shapeId;
  }
  ConeShape.builtin$cls = "ConeShape";
  if (!"name" in ConeShape)
    ConeShape.name = "ConeShape";
  $desc = $collectedClasses.ConeShape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ConeShape.prototype = $desc;
  ConeShape.prototype.get$height = function(receiver) {
    return this.height;
  };
  function CylinderShape(radius, zmin, zmax, phiMax, objectToWorld, worldToObject, reverseOrientation, transformSwapsHandedness, shapeId) {
    this.radius = radius;
    this.zmin = zmin;
    this.zmax = zmax;
    this.phiMax = phiMax;
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.transformSwapsHandedness = transformSwapsHandedness;
    this.shapeId = shapeId;
  }
  CylinderShape.builtin$cls = "CylinderShape";
  if (!"name" in CylinderShape)
    CylinderShape.name = "CylinderShape";
  $desc = $collectedClasses.CylinderShape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CylinderShape.prototype = $desc;
  function DiskShape(height, radius, innerRadius, phiMax, objectToWorld, worldToObject, reverseOrientation, transformSwapsHandedness, shapeId) {
    this.height = height;
    this.radius = radius;
    this.innerRadius = innerRadius;
    this.phiMax = phiMax;
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.transformSwapsHandedness = transformSwapsHandedness;
    this.shapeId = shapeId;
  }
  DiskShape.builtin$cls = "DiskShape";
  if (!"name" in DiskShape)
    DiskShape.name = "DiskShape";
  $desc = $collectedClasses.DiskShape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DiskShape.prototype = $desc;
  DiskShape.prototype.get$height = function(receiver) {
    return this.height;
  };
  function HyperboloidShape(p1, p2, zmin, zmax, phiMax, rmax, a, c, objectToWorld, worldToObject, reverseOrientation, transformSwapsHandedness, shapeId) {
    this.p1 = p1;
    this.p2 = p2;
    this.zmin = zmin;
    this.zmax = zmax;
    this.phiMax = phiMax;
    this.rmax = rmax;
    this.a = a;
    this.c = c;
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.transformSwapsHandedness = transformSwapsHandedness;
    this.shapeId = shapeId;
  }
  HyperboloidShape.builtin$cls = "HyperboloidShape";
  if (!"name" in HyperboloidShape)
    HyperboloidShape.name = "HyperboloidShape";
  $desc = $collectedClasses.HyperboloidShape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HyperboloidShape.prototype = $desc;
  HyperboloidShape.prototype.get$c = function() {
    return this.c;
  };
  function HyperboloidShape_area_SQR() {
  }
  HyperboloidShape_area_SQR.builtin$cls = "HyperboloidShape_area_SQR";
  if (!"name" in HyperboloidShape_area_SQR)
    HyperboloidShape_area_SQR.name = "HyperboloidShape_area_SQR";
  $desc = $collectedClasses.HyperboloidShape_area_SQR;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HyperboloidShape_area_SQR.prototype = $desc;
  function HyperboloidShape_area_QUAD() {
  }
  HyperboloidShape_area_QUAD.builtin$cls = "HyperboloidShape_area_QUAD";
  if (!"name" in HyperboloidShape_area_QUAD)
    HyperboloidShape_area_QUAD.name = "HyperboloidShape_area_QUAD";
  $desc = $collectedClasses.HyperboloidShape_area_QUAD;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HyperboloidShape_area_QUAD.prototype = $desc;
  function LoopSubdivisionShape(nLevels, vertices, faces, objectToWorld, worldToObject, reverseOrientation, transformSwapsHandedness, shapeId) {
    this.nLevels = nLevels;
    this.vertices = vertices;
    this.faces = faces;
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.transformSwapsHandedness = transformSwapsHandedness;
    this.shapeId = shapeId;
  }
  LoopSubdivisionShape.builtin$cls = "LoopSubdivisionShape";
  if (!"name" in LoopSubdivisionShape)
    LoopSubdivisionShape.name = "LoopSubdivisionShape";
  $desc = $collectedClasses.LoopSubdivisionShape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  LoopSubdivisionShape.prototype = $desc;
  function _SDEdgeMap(_edgeMap) {
    this._edgeMap = _edgeMap;
  }
  _SDEdgeMap.builtin$cls = "_SDEdgeMap";
  if (!"name" in _SDEdgeMap)
    _SDEdgeMap.name = "_SDEdgeMap";
  $desc = $collectedClasses._SDEdgeMap;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SDEdgeMap.prototype = $desc;
  function _SDVertex(P, startFace, child, regular, boundary) {
    this.P = P;
    this.startFace = startFace;
    this.child = child;
    this.regular = regular;
    this.boundary = boundary;
  }
  _SDVertex.builtin$cls = "_SDVertex";
  if (!"name" in _SDVertex)
    _SDVertex.name = "_SDVertex";
  $desc = $collectedClasses._SDVertex;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SDVertex.prototype = $desc;
  _SDVertex.prototype.get$P = function() {
    return this.P;
  };
  _SDVertex.prototype.set$P = function(v) {
    return this.P = v;
  };
  _SDVertex.prototype.get$startFace = function() {
    return this.startFace;
  };
  _SDVertex.prototype.set$startFace = function(v) {
    return this.startFace = v;
  };
  _SDVertex.prototype.get$child = function() {
    return this.child;
  };
  _SDVertex.prototype.set$child = function(v) {
    return this.child = v;
  };
  _SDVertex.prototype.get$boundary = function() {
    return this.boundary;
  };
  function _SDFace(v, f, children) {
    this.v = v;
    this.f = f;
    this.children = children;
  }
  _SDFace.builtin$cls = "_SDFace";
  if (!"name" in _SDFace)
    _SDFace.name = "_SDFace";
  $desc = $collectedClasses._SDFace;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SDFace.prototype = $desc;
  _SDFace.prototype.get$v = function() {
    return this.v;
  };
  _SDFace.prototype.get$f = function() {
    return this.f;
  };
  _SDFace.prototype.get$children = function(receiver) {
    return this.children;
  };
  function _SDEdge(v, f, f0edgeNum) {
    this.v = v;
    this.f = f;
    this.f0edgeNum = f0edgeNum;
  }
  _SDEdge.builtin$cls = "_SDEdge";
  if (!"name" in _SDEdge)
    _SDEdge.name = "_SDEdge";
  $desc = $collectedClasses._SDEdge;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _SDEdge.prototype = $desc;
  _SDEdge.prototype.get$v = function() {
    return this.v;
  };
  _SDEdge.prototype.get$f = function() {
    return this.f;
  };
  _SDEdge.prototype.get$f0edgeNum = function() {
    return this.f0edgeNum;
  };
  function ParaboloidShape(radius, zmin, zmax, phiMax, objectToWorld, worldToObject, reverseOrientation, transformSwapsHandedness, shapeId) {
    this.radius = radius;
    this.zmin = zmin;
    this.zmax = zmax;
    this.phiMax = phiMax;
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.transformSwapsHandedness = transformSwapsHandedness;
    this.shapeId = shapeId;
  }
  ParaboloidShape.builtin$cls = "ParaboloidShape";
  if (!"name" in ParaboloidShape)
    ParaboloidShape.name = "ParaboloidShape";
  $desc = $collectedClasses.ParaboloidShape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ParaboloidShape.prototype = $desc;
  function SphereShape(radius, phiMax, zmin, zmax, thetaMin, thetaMax, objectToWorld, worldToObject, reverseOrientation, transformSwapsHandedness, shapeId) {
    this.radius = radius;
    this.phiMax = phiMax;
    this.zmin = zmin;
    this.zmax = zmax;
    this.thetaMin = thetaMin;
    this.thetaMax = thetaMax;
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.transformSwapsHandedness = transformSwapsHandedness;
    this.shapeId = shapeId;
  }
  SphereShape.builtin$cls = "SphereShape";
  if (!"name" in SphereShape)
    SphereShape.name = "SphereShape";
  $desc = $collectedClasses.SphereShape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SphereShape.prototype = $desc;
  function TriangleMeshShape(ntris, nverts, vertexIndex, p, n, s, uvs, alphaTexture, objectToWorld, worldToObject, reverseOrientation, transformSwapsHandedness, shapeId) {
    this.ntris = ntris;
    this.nverts = nverts;
    this.vertexIndex = vertexIndex;
    this.p = p;
    this.n = n;
    this.s = s;
    this.uvs = uvs;
    this.alphaTexture = alphaTexture;
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.transformSwapsHandedness = transformSwapsHandedness;
    this.shapeId = shapeId;
  }
  TriangleMeshShape.builtin$cls = "TriangleMeshShape";
  if (!"name" in TriangleMeshShape)
    TriangleMeshShape.name = "TriangleMeshShape";
  $desc = $collectedClasses.TriangleMeshShape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TriangleMeshShape.prototype = $desc;
  TriangleMeshShape.prototype.get$p = function(receiver) {
    return this.p;
  };
  TriangleMeshShape.prototype.get$n = function() {
    return this.n;
  };
  function TriangleShape(mesh, index, objectToWorld, worldToObject, reverseOrientation, transformSwapsHandedness, shapeId) {
    this.mesh = mesh;
    this.index = index;
    this.objectToWorld = objectToWorld;
    this.worldToObject = worldToObject;
    this.reverseOrientation = reverseOrientation;
    this.transformSwapsHandedness = transformSwapsHandedness;
    this.shapeId = shapeId;
  }
  TriangleShape.builtin$cls = "TriangleShape";
  if (!"name" in TriangleShape)
    TriangleShape.name = "TriangleShape";
  $desc = $collectedClasses.TriangleShape;
  if ($desc instanceof Array)
    $desc = $desc[1];
  TriangleShape.prototype = $desc;
  function AmbientOcclusionIntegrator(nSamples, minDist, maxDist) {
    this.nSamples = nSamples;
    this.minDist = minDist;
    this.maxDist = maxDist;
  }
  AmbientOcclusionIntegrator.builtin$cls = "AmbientOcclusionIntegrator";
  if (!"name" in AmbientOcclusionIntegrator)
    AmbientOcclusionIntegrator.name = "AmbientOcclusionIntegrator";
  $desc = $collectedClasses.AmbientOcclusionIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  AmbientOcclusionIntegrator.prototype = $desc;
  AmbientOcclusionIntegrator.prototype.get$nSamples = function() {
    return this.nSamples;
  };
  AmbientOcclusionIntegrator.prototype.get$maxDist = function() {
    return this.maxDist;
  };
  function DiffusePRTIntegrator(lmax, nSamples, c_in) {
    this.lmax = lmax;
    this.nSamples = nSamples;
    this.c_in = c_in;
  }
  DiffusePRTIntegrator.builtin$cls = "DiffusePRTIntegrator";
  if (!"name" in DiffusePRTIntegrator)
    DiffusePRTIntegrator.name = "DiffusePRTIntegrator";
  $desc = $collectedClasses.DiffusePRTIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DiffusePRTIntegrator.prototype = $desc;
  DiffusePRTIntegrator.prototype.get$nSamples = function() {
    return this.nSamples;
  };
  function DirectLightingIntegrator(strategy, maxDepth, lightSampleOffsets, bsdfSampleOffsets, lightNumOffset) {
    this.strategy = strategy;
    this.maxDepth = maxDepth;
    this.lightSampleOffsets = lightSampleOffsets;
    this.bsdfSampleOffsets = bsdfSampleOffsets;
    this.lightNumOffset = lightNumOffset;
  }
  DirectLightingIntegrator.builtin$cls = "DirectLightingIntegrator";
  if (!"name" in DirectLightingIntegrator)
    DirectLightingIntegrator.name = "DirectLightingIntegrator";
  $desc = $collectedClasses.DirectLightingIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DirectLightingIntegrator.prototype = $desc;
  function GlossyPRTIntegrator(Kd, Ks, roughness, lmax, nSamples, c_in, B) {
    this.Kd = Kd;
    this.Ks = Ks;
    this.roughness = roughness;
    this.lmax = lmax;
    this.nSamples = nSamples;
    this.c_in = c_in;
    this.B = B;
  }
  GlossyPRTIntegrator.builtin$cls = "GlossyPRTIntegrator";
  if (!"name" in GlossyPRTIntegrator)
    GlossyPRTIntegrator.name = "GlossyPRTIntegrator";
  $desc = $collectedClasses.GlossyPRTIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  GlossyPRTIntegrator.prototype = $desc;
  GlossyPRTIntegrator.prototype.get$nSamples = function() {
    return this.nSamples;
  };
  function IGIIntegrator(lightSampleOffsets, bsdfSampleOffsets, nLightPaths, nLightSets, gLimit, nGatherSamples, rrThreshold, maxSpecularDepth, vlSetOffset, gatherSampleOffset, virtualLights) {
    this.lightSampleOffsets = lightSampleOffsets;
    this.bsdfSampleOffsets = bsdfSampleOffsets;
    this.nLightPaths = nLightPaths;
    this.nLightSets = nLightSets;
    this.gLimit = gLimit;
    this.nGatherSamples = nGatherSamples;
    this.rrThreshold = rrThreshold;
    this.maxSpecularDepth = maxSpecularDepth;
    this.vlSetOffset = vlSetOffset;
    this.gatherSampleOffset = gatherSampleOffset;
    this.virtualLights = virtualLights;
  }
  IGIIntegrator.builtin$cls = "IGIIntegrator";
  if (!"name" in IGIIntegrator)
    IGIIntegrator.name = "IGIIntegrator";
  $desc = $collectedClasses.IGIIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IGIIntegrator.prototype = $desc;
  function _VirtualLight(p, n, pathContrib, rayEpsilon) {
    this.p = p;
    this.n = n;
    this.pathContrib = pathContrib;
    this.rayEpsilon = rayEpsilon;
  }
  _VirtualLight.builtin$cls = "_VirtualLight";
  if (!"name" in _VirtualLight)
    _VirtualLight.name = "_VirtualLight";
  $desc = $collectedClasses._VirtualLight;
  if ($desc instanceof Array)
    $desc = $desc[1];
  _VirtualLight.prototype = $desc;
  _VirtualLight.prototype.get$p = function(receiver) {
    return this.p;
  };
  _VirtualLight.prototype.get$n = function() {
    return this.n;
  };
  _VirtualLight.prototype.get$pathContrib = function() {
    return this.pathContrib;
  };
  function IrradianceCacheIntegrator(minSamplePixelSpacing, maxSamplePixelSpacing, minWeight, cosMaxSampleAngleDifference, nSamples, maxSpecularDepth, maxIndirectDepth, lightSampleOffsets, bsdfSampleOffsets, octree) {
    this.minSamplePixelSpacing = minSamplePixelSpacing;
    this.maxSamplePixelSpacing = maxSamplePixelSpacing;
    this.minWeight = minWeight;
    this.cosMaxSampleAngleDifference = cosMaxSampleAngleDifference;
    this.nSamples = nSamples;
    this.maxSpecularDepth = maxSpecularDepth;
    this.maxIndirectDepth = maxIndirectDepth;
    this.lightSampleOffsets = lightSampleOffsets;
    this.bsdfSampleOffsets = bsdfSampleOffsets;
    this.octree = octree;
  }
  IrradianceCacheIntegrator.builtin$cls = "IrradianceCacheIntegrator";
  if (!"name" in IrradianceCacheIntegrator)
    IrradianceCacheIntegrator.name = "IrradianceCacheIntegrator";
  $desc = $collectedClasses.IrradianceCacheIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IrradianceCacheIntegrator.prototype = $desc;
  IrradianceCacheIntegrator.prototype.get$nSamples = function() {
    return this.nSamples;
  };
  function IrradianceSample(E, n, p, wAvg, maxDist) {
    this.E = E;
    this.n = n;
    this.p = p;
    this.wAvg = wAvg;
    this.maxDist = maxDist;
  }
  IrradianceSample.builtin$cls = "IrradianceSample";
  if (!"name" in IrradianceSample)
    IrradianceSample.name = "IrradianceSample";
  $desc = $collectedClasses.IrradianceSample;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IrradianceSample.prototype = $desc;
  IrradianceSample.prototype.get$n = function() {
    return this.n;
  };
  IrradianceSample.prototype.get$p = function(receiver) {
    return this.p;
  };
  IrradianceSample.prototype.get$maxDist = function() {
    return this.maxDist;
  };
  function IrradiancePrimeTask(scene, camera, renderer, sampler, origSample, irradianceCache) {
    this.scene = scene;
    this.camera = camera;
    this.renderer = renderer;
    this.sampler = sampler;
    this.origSample = origSample;
    this.irradianceCache = irradianceCache;
  }
  IrradiancePrimeTask.builtin$cls = "IrradiancePrimeTask";
  if (!"name" in IrradiancePrimeTask)
    IrradiancePrimeTask.name = "IrradiancePrimeTask";
  $desc = $collectedClasses.IrradiancePrimeTask;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IrradiancePrimeTask.prototype = $desc;
  function IrradProcess(p, n, minWeight, cosMaxSampleAngleDifference, sumWt, nFound, E, wAvg) {
    this.p = p;
    this.n = n;
    this.minWeight = minWeight;
    this.cosMaxSampleAngleDifference = cosMaxSampleAngleDifference;
    this.sumWt = sumWt;
    this.nFound = nFound;
    this.E = E;
    this.wAvg = wAvg;
  }
  IrradProcess.builtin$cls = "IrradProcess";
  if (!"name" in IrradProcess)
    IrradProcess.name = "IrradProcess";
  $desc = $collectedClasses.IrradProcess;
  if ($desc instanceof Array)
    $desc = $desc[1];
  IrradProcess.prototype = $desc;
  IrradProcess.prototype.get$p = function(receiver) {
    return this.p;
  };
  IrradProcess.prototype.get$n = function() {
    return this.n;
  };
  function PathIntegrator(maxDepth, lightSampleOffsets, lightNumOffset, bsdfSampleOffsets, pathSampleOffsets) {
    this.maxDepth = maxDepth;
    this.lightSampleOffsets = lightSampleOffsets;
    this.lightNumOffset = lightNumOffset;
    this.bsdfSampleOffsets = bsdfSampleOffsets;
    this.pathSampleOffsets = pathSampleOffsets;
  }
  PathIntegrator.builtin$cls = "PathIntegrator";
  if (!"name" in PathIntegrator)
    PathIntegrator.name = "PathIntegrator";
  $desc = $collectedClasses.PathIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PathIntegrator.prototype = $desc;
  function PhotonMapIntegrator(nCausticPhotonsWanted, nIndirectPhotonsWanted, nLookup, maxDistSquared, maxSpecularDepth, maxPhotonDepth, finalGather, gatherSamples, cosGatherAngle, lightSampleOffsets, bsdfSampleOffsets, bsdfGatherSampleOffsets, indirGatherSampleOffsets, nCausticPaths, nIndirectPaths, causticMap, indirectMap, radianceMap) {
    this.nCausticPhotonsWanted = nCausticPhotonsWanted;
    this.nIndirectPhotonsWanted = nIndirectPhotonsWanted;
    this.nLookup = nLookup;
    this.maxDistSquared = maxDistSquared;
    this.maxSpecularDepth = maxSpecularDepth;
    this.maxPhotonDepth = maxPhotonDepth;
    this.finalGather = finalGather;
    this.gatherSamples = gatherSamples;
    this.cosGatherAngle = cosGatherAngle;
    this.lightSampleOffsets = lightSampleOffsets;
    this.bsdfSampleOffsets = bsdfSampleOffsets;
    this.bsdfGatherSampleOffsets = bsdfGatherSampleOffsets;
    this.indirGatherSampleOffsets = indirGatherSampleOffsets;
    this.nCausticPaths = nCausticPaths;
    this.nIndirectPaths = nIndirectPaths;
    this.causticMap = causticMap;
    this.indirectMap = indirectMap;
    this.radianceMap = radianceMap;
  }
  PhotonMapIntegrator.builtin$cls = "PhotonMapIntegrator";
  if (!"name" in PhotonMapIntegrator)
    PhotonMapIntegrator.name = "PhotonMapIntegrator";
  $desc = $collectedClasses.PhotonMapIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PhotonMapIntegrator.prototype = $desc;
  function Photon(p, alpha, wi) {
    this.p = p;
    this.alpha = alpha;
    this.wi = wi;
  }
  Photon.builtin$cls = "Photon";
  if (!"name" in Photon)
    Photon.name = "Photon";
  $desc = $collectedClasses.Photon;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Photon.prototype = $desc;
  Photon.prototype.get$p = function(receiver) {
    return this.p;
  };
  Photon.prototype.get$alpha = function(receiver) {
    return this.alpha;
  };
  Photon.prototype.get$wi = function() {
    return this.wi;
  };
  function RadiancePhoton(p, n, Lo) {
    this.p = p;
    this.n = n;
    this.Lo = Lo;
  }
  RadiancePhoton.builtin$cls = "RadiancePhoton";
  if (!"name" in RadiancePhoton)
    RadiancePhoton.name = "RadiancePhoton";
  $desc = $collectedClasses.RadiancePhoton;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RadiancePhoton.prototype = $desc;
  RadiancePhoton.prototype.get$p = function(receiver) {
    return this.p;
  };
  RadiancePhoton.prototype.get$n = function() {
    return this.n;
  };
  RadiancePhoton.prototype.get$Lo = function() {
    return this.Lo;
  };
  function PhotonShootingTask(taskNum, time, integrator, abortTasks, nDirectPaths, directPhotons, indirectPhotons, causticPhotons, radiancePhotons, rpReflectances, rpTransmittances, nshot, lightDistribution, scene, renderer) {
    this.taskNum = taskNum;
    this.time = time;
    this.integrator = integrator;
    this.abortTasks = abortTasks;
    this.nDirectPaths = nDirectPaths;
    this.directPhotons = directPhotons;
    this.indirectPhotons = indirectPhotons;
    this.causticPhotons = causticPhotons;
    this.radiancePhotons = radiancePhotons;
    this.rpReflectances = rpReflectances;
    this.rpTransmittances = rpTransmittances;
    this.nshot = nshot;
    this.lightDistribution = lightDistribution;
    this.scene = scene;
    this.renderer = renderer;
  }
  PhotonShootingTask.builtin$cls = "PhotonShootingTask";
  if (!"name" in PhotonShootingTask)
    PhotonShootingTask.name = "PhotonShootingTask";
  $desc = $collectedClasses.PhotonShootingTask;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PhotonShootingTask.prototype = $desc;
  PhotonShootingTask.prototype.get$time = function() {
    return this.time;
  };
  PhotonShootingTask.prototype.set$time = function(v) {
    return this.time = v;
  };
  function ComputeRadianceTask(taskNum, numTasks, radiancePhotons, rpReflectances, rpTransmittances, nLookup, maxDistSquared, nDirectPaths, nIndirectPaths, nCausticPaths, directMap, indirectMap, causticMap) {
    this.taskNum = taskNum;
    this.numTasks = numTasks;
    this.radiancePhotons = radiancePhotons;
    this.rpReflectances = rpReflectances;
    this.rpTransmittances = rpTransmittances;
    this.nLookup = nLookup;
    this.maxDistSquared = maxDistSquared;
    this.nDirectPaths = nDirectPaths;
    this.nIndirectPaths = nIndirectPaths;
    this.nCausticPaths = nCausticPaths;
    this.directMap = directMap;
    this.indirectMap = indirectMap;
    this.causticMap = causticMap;
  }
  ComputeRadianceTask.builtin$cls = "ComputeRadianceTask";
  if (!"name" in ComputeRadianceTask)
    ComputeRadianceTask.name = "ComputeRadianceTask";
  $desc = $collectedClasses.ComputeRadianceTask;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ComputeRadianceTask.prototype = $desc;
  function ClosePhoton(photon, distanceSquared) {
    this.photon = photon;
    this.distanceSquared = distanceSquared;
  }
  ClosePhoton.builtin$cls = "ClosePhoton";
  if (!"name" in ClosePhoton)
    ClosePhoton.name = "ClosePhoton";
  $desc = $collectedClasses.ClosePhoton;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ClosePhoton.prototype = $desc;
  ClosePhoton.prototype.get$photon = function() {
    return this.photon;
  };
  ClosePhoton.prototype.get$distanceSquared = function() {
    return this.distanceSquared;
  };
  function PhotonProcess(photons, nLookup, nFound) {
    this.photons = photons;
    this.nLookup = nLookup;
    this.nFound = nFound;
  }
  PhotonProcess.builtin$cls = "PhotonProcess";
  if (!"name" in PhotonProcess)
    PhotonProcess.name = "PhotonProcess";
  $desc = $collectedClasses.PhotonProcess;
  if ($desc instanceof Array)
    $desc = $desc[1];
  PhotonProcess.prototype = $desc;
  function RadiancePhotonProcess(n, photon) {
    this.n = n;
    this.photon = photon;
  }
  RadiancePhotonProcess.builtin$cls = "RadiancePhotonProcess";
  if (!"name" in RadiancePhotonProcess)
    RadiancePhotonProcess.name = "RadiancePhotonProcess";
  $desc = $collectedClasses.RadiancePhotonProcess;
  if ($desc instanceof Array)
    $desc = $desc[1];
  RadiancePhotonProcess.prototype = $desc;
  RadiancePhotonProcess.prototype.get$n = function() {
    return this.n;
  };
  RadiancePhotonProcess.prototype.get$photon = function() {
    return this.photon;
  };
  function WhittedIntegrator(maxDepth) {
    this.maxDepth = maxDepth;
  }
  WhittedIntegrator.builtin$cls = "WhittedIntegrator";
  if (!"name" in WhittedIntegrator)
    WhittedIntegrator.name = "WhittedIntegrator";
  $desc = $collectedClasses.WhittedIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WhittedIntegrator.prototype = $desc;
  function BilerpTexture(mapping, v00, v01, v10, v11) {
    this.mapping = mapping;
    this.v00 = v00;
    this.v01 = v01;
    this.v10 = v10;
    this.v11 = v11;
  }
  BilerpTexture.builtin$cls = "BilerpTexture";
  if (!"name" in BilerpTexture)
    BilerpTexture.name = "BilerpTexture";
  $desc = $collectedClasses.BilerpTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  BilerpTexture.prototype = $desc;
  function Checkerboard3DTexture(mapping, tex1, tex2) {
    this.mapping = mapping;
    this.tex1 = tex1;
    this.tex2 = tex2;
  }
  Checkerboard3DTexture.builtin$cls = "Checkerboard3DTexture";
  if (!"name" in Checkerboard3DTexture)
    Checkerboard3DTexture.name = "Checkerboard3DTexture";
  $desc = $collectedClasses.Checkerboard3DTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  Checkerboard3DTexture.prototype = $desc;
  function CheckerboardTexture(mapping, tex1, tex2, aaMethod) {
    this.mapping = mapping;
    this.tex1 = tex1;
    this.tex2 = tex2;
    this.aaMethod = aaMethod;
  }
  CheckerboardTexture.builtin$cls = "CheckerboardTexture";
  if (!"name" in CheckerboardTexture)
    CheckerboardTexture.name = "CheckerboardTexture";
  $desc = $collectedClasses.CheckerboardTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CheckerboardTexture.prototype = $desc;
  function CheckerboardTexture_evaluate_BUMPINT() {
  }
  CheckerboardTexture_evaluate_BUMPINT.builtin$cls = "CheckerboardTexture_evaluate_BUMPINT";
  if (!"name" in CheckerboardTexture_evaluate_BUMPINT)
    CheckerboardTexture_evaluate_BUMPINT.name = "CheckerboardTexture_evaluate_BUMPINT";
  $desc = $collectedClasses.CheckerboardTexture_evaluate_BUMPINT;
  if ($desc instanceof Array)
    $desc = $desc[1];
  CheckerboardTexture_evaluate_BUMPINT.prototype = $desc;
  function DotsTexture(mapping, outsideDot, insideDot) {
    this.mapping = mapping;
    this.outsideDot = outsideDot;
    this.insideDot = insideDot;
  }
  DotsTexture.builtin$cls = "DotsTexture";
  if (!"name" in DotsTexture)
    DotsTexture.name = "DotsTexture";
  $desc = $collectedClasses.DotsTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  DotsTexture.prototype = $desc;
  function FBmTexture(omega, octaves, spectrum, mapping) {
    this.omega = omega;
    this.octaves = octaves;
    this.spectrum = spectrum;
    this.mapping = mapping;
  }
  FBmTexture.builtin$cls = "FBmTexture";
  if (!"name" in FBmTexture)
    FBmTexture.name = "FBmTexture";
  $desc = $collectedClasses.FBmTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  FBmTexture.prototype = $desc;
  function ImageTexture(mipmap, mapping) {
    this.mipmap = mipmap;
    this.mapping = mapping;
  }
  ImageTexture.builtin$cls = "ImageTexture";
  if (!"name" in ImageTexture)
    ImageTexture.name = "ImageTexture";
  $desc = $collectedClasses.ImageTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ImageTexture.prototype = $desc;
  function ImageTexture_closure(this_0, doTri_1, maxAniso_2, wrap_3, scale_4, gamma_5, spectrum_6, completer_7) {
    this.this_0 = this_0;
    this.doTri_1 = doTri_1;
    this.maxAniso_2 = maxAniso_2;
    this.wrap_3 = wrap_3;
    this.scale_4 = scale_4;
    this.gamma_5 = gamma_5;
    this.spectrum_6 = spectrum_6;
    this.completer_7 = completer_7;
  }
  ImageTexture_closure.builtin$cls = "ImageTexture_closure";
  if (!"name" in ImageTexture_closure)
    ImageTexture_closure.name = "ImageTexture_closure";
  $desc = $collectedClasses.ImageTexture_closure;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ImageTexture_closure.prototype = $desc;
  function MarbleTexture(octaves, omega, scale, variation, mapping) {
    this.octaves = octaves;
    this.omega = omega;
    this.scale = scale;
    this.variation = variation;
    this.mapping = mapping;
  }
  MarbleTexture.builtin$cls = "MarbleTexture";
  if (!"name" in MarbleTexture)
    MarbleTexture.name = "MarbleTexture";
  $desc = $collectedClasses.MarbleTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MarbleTexture.prototype = $desc;
  function MixTexture(tex1, tex2, amount) {
    this.tex1 = tex1;
    this.tex2 = tex2;
    this.amount = amount;
  }
  MixTexture.builtin$cls = "MixTexture";
  if (!"name" in MixTexture)
    MixTexture.name = "MixTexture";
  $desc = $collectedClasses.MixTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  MixTexture.prototype = $desc;
  function ScaleTexture(tex1, tex2) {
    this.tex1 = tex1;
    this.tex2 = tex2;
  }
  ScaleTexture.builtin$cls = "ScaleTexture";
  if (!"name" in ScaleTexture)
    ScaleTexture.name = "ScaleTexture";
  $desc = $collectedClasses.ScaleTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ScaleTexture.prototype = $desc;
  function UVTexture(mapping) {
    this.mapping = mapping;
  }
  UVTexture.builtin$cls = "UVTexture";
  if (!"name" in UVTexture)
    UVTexture.name = "UVTexture";
  $desc = $collectedClasses.UVTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  UVTexture.prototype = $desc;
  function WindyTexture(mapping, spectrum) {
    this.mapping = mapping;
    this.spectrum = spectrum;
  }
  WindyTexture.builtin$cls = "WindyTexture";
  if (!"name" in WindyTexture)
    WindyTexture.name = "WindyTexture";
  $desc = $collectedClasses.WindyTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WindyTexture.prototype = $desc;
  function WrinkledTexture(omega, octaves, spectrum, mapping) {
    this.omega = omega;
    this.octaves = octaves;
    this.spectrum = spectrum;
    this.mapping = mapping;
  }
  WrinkledTexture.builtin$cls = "WrinkledTexture";
  if (!"name" in WrinkledTexture)
    WrinkledTexture.name = "WrinkledTexture";
  $desc = $collectedClasses.WrinkledTexture;
  if ($desc instanceof Array)
    $desc = $desc[1];
  WrinkledTexture.prototype = $desc;
  function EmissionIntegrator(stepSize, tauSampleOffset, scatterSampleOffset) {
    this.stepSize = stepSize;
    this.tauSampleOffset = tauSampleOffset;
    this.scatterSampleOffset = scatterSampleOffset;
  }
  EmissionIntegrator.builtin$cls = "EmissionIntegrator";
  if (!"name" in EmissionIntegrator)
    EmissionIntegrator.name = "EmissionIntegrator";
  $desc = $collectedClasses.EmissionIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  EmissionIntegrator.prototype = $desc;
  function SingleScatteringIntegrator(stepSize, tauSampleOffset, scatterSampleOffset) {
    this.stepSize = stepSize;
    this.tauSampleOffset = tauSampleOffset;
    this.scatterSampleOffset = scatterSampleOffset;
  }
  SingleScatteringIntegrator.builtin$cls = "SingleScatteringIntegrator";
  if (!"name" in SingleScatteringIntegrator)
    SingleScatteringIntegrator.name = "SingleScatteringIntegrator";
  $desc = $collectedClasses.SingleScatteringIntegrator;
  if ($desc instanceof Array)
    $desc = $desc[1];
  SingleScatteringIntegrator.prototype = $desc;
  function ExponentialDensityRegion(extent, a, b, upDir, sig_a, sig_s, le, g, worldToVolume) {
    this.extent = extent;
    this.a = a;
    this.b = b;
    this.upDir = upDir;
    this.sig_a = sig_a;
    this.sig_s = sig_s;
    this.le = le;
    this.g = g;
    this.worldToVolume = worldToVolume;
  }
  ExponentialDensityRegion.builtin$cls = "ExponentialDensityRegion";
  if (!"name" in ExponentialDensityRegion)
    ExponentialDensityRegion.name = "ExponentialDensityRegion";
  $desc = $collectedClasses.ExponentialDensityRegion;
  if ($desc instanceof Array)
    $desc = $desc[1];
  ExponentialDensityRegion.prototype = $desc;
  function HomogeneousVolumeRegion(sig_a, sig_s, le, g, extent, worldToVolume) {
    this.sig_a = sig_a;
    this.sig_s = sig_s;
    this.le = le;
    this.g = g;
    this.extent = extent;
    this.worldToVolume = worldToVolume;
  }
  HomogeneousVolumeRegion.builtin$cls = "HomogeneousVolumeRegion";
  if (!"name" in HomogeneousVolumeRegion)
    HomogeneousVolumeRegion.name = "HomogeneousVolumeRegion";
  $desc = $collectedClasses.HomogeneousVolumeRegion;
  if ($desc instanceof Array)
    $desc = $desc[1];
  HomogeneousVolumeRegion.prototype = $desc;
  function VolumeGridDensity(_density, nx, ny, nz, extent, sig_a, sig_s, le, g, worldToVolume) {
    this._density = _density;
    this.nx = nx;
    this.ny = ny;
    this.nz = nz;
    this.extent = extent;
    this.sig_a = sig_a;
    this.sig_s = sig_s;
    this.le = le;
    this.g = g;
    this.worldToVolume = worldToVolume;
  }
  VolumeGridDensity.builtin$cls = "VolumeGridDensity";
  if (!"name" in VolumeGridDensity)
    VolumeGridDensity.name = "VolumeGridDensity";
  $desc = $collectedClasses.VolumeGridDensity;
  if ($desc instanceof Array)
    $desc = $desc[1];
  VolumeGridDensity.prototype = $desc;
  VolumeGridDensity.prototype.get$nx = function() {
    return this.nx;
  };
  VolumeGridDensity.prototype.get$nz = function() {
    return this.nz;
  };
  VolumeGridDensity.prototype.set$nz = function(v) {
    return this.nz = v;
  };
  return [HtmlElement, AnchorElement, AnimationEvent, AreaElement, AudioElement, AutocompleteErrorEvent, BRElement, BaseElement, BeforeLoadEvent, BeforeUnloadEvent, Blob, BodyElement, ButtonElement, CDataSection, CanvasElement, CharacterData, CloseEvent, Comment, CompositionEvent, ContentElement, CssFontFaceLoadEvent, CustomEvent, DListElement, DataListElement, DetailsElement, DeviceMotionEvent, DeviceOrientationEvent, DialogElement, DivElement, Document, DocumentFragment, DomError, DomException, Element, EmbedElement, ErrorEvent, Event, EventTarget, FieldSetElement, File, FileError, FocusEvent, FormElement, HRElement, HashChangeEvent, HeadElement, HeadingElement, HtmlCollection, HtmlDocument, HtmlFormControlsCollection, HtmlHtmlElement, HtmlOptionsCollection, HttpRequest, HttpRequestEventTarget, IFrameElement, ImageElement, InputElement, InstallEvent, InstallPhaseEvent, KeyboardEvent, KeygenElement, LIElement, LabelElement, LegendElement, LinkElement, MapElement, MediaElement, MediaError, MediaKeyError, MediaKeyEvent, MediaKeyMessageEvent, MediaKeyNeededEvent, MediaStream, MediaStreamEvent, MediaStreamTrackEvent, MenuElement, MessageEvent, MetaElement, MeterElement, MidiConnectionEvent, MidiInput, MidiMessageEvent, MidiOutput, MidiPort, ModElement, MouseEvent, Navigator, NavigatorUserMediaError, Node, NodeList, OListElement, ObjectElement, OptGroupElement, OptionElement, OutputElement, OverflowEvent, PageTransitionEvent, ParagraphElement, ParamElement, PopStateEvent, PositionError, PreElement, ProcessingInstruction, ProgressElement, ProgressEvent, QuoteElement, ResourceProgressEvent, RtcDataChannelEvent, RtcDtmfToneChangeEvent, RtcIceCandidateEvent, ScriptElement, SecurityPolicyViolationEvent, SelectElement, ShadowElement, ShadowRoot, SourceElement, SpanElement, SpeechInputEvent, SpeechRecognitionError, SpeechRecognitionEvent, SpeechSynthesisEvent, StorageEvent, StyleElement, TableCaptionElement, TableCellElement, TableColElement, TableElement, TableRowElement, TableSectionElement, TemplateElement, Text, TextAreaElement, TextEvent, TitleElement, TouchEvent, TrackElement, TrackEvent, TransitionEvent, UIEvent, UListElement, UnknownElement, VideoElement, WheelEvent, Window, XmlDocument, _Attr, _ClientRect, _DocumentType, _HTMLAppletElement, _HTMLDirectoryElement, _HTMLFontElement, _HTMLFrameElement, _HTMLFrameSetElement, _HTMLMarqueeElement, _MutationEvent, _NamedNodeMap, _Notation, _XMLHttpRequestProgressEvent, VersionChangeEvent, AElement, AltGlyphElement, AnimateElement, AnimateMotionElement, AnimateTransformElement, AnimatedEnumeration, AnimatedLength, AnimatedLengthList, AnimatedNumber, AnimatedNumberList, AnimatedString, AnimatedTransformList, AnimationElement, CircleElement, ClipPathElement, DefsElement, DescElement, DiscardElement, EllipseElement, FEBlendElement, FEColorMatrixElement, FEComponentTransferElement, FECompositeElement, FEConvolveMatrixElement, FEDiffuseLightingElement, FEDisplacementMapElement, FEDistantLightElement, FEFloodElement, FEFuncAElement, FEFuncBElement, FEFuncGElement, FEFuncRElement, FEGaussianBlurElement, FEImageElement, FEMergeElement, FEMergeNodeElement, FEMorphologyElement, FEOffsetElement, FEPointLightElement, FESpecularLightingElement, FESpotLightElement, FETileElement, FETurbulenceElement, FilterElement, ForeignObjectElement, GElement, GeometryElement, GraphicsElement, ImageElement0, LineElement, LinearGradientElement, MarkerElement, MaskElement, MetadataElement, PathElement, PatternElement, PointList, PolygonElement, PolylineElement, RadialGradientElement, RectElement, ScriptElement0, SetElement, StopElement, StyleElement0, SvgElement, SvgSvgElement, SwitchElement, SymbolElement, TSpanElement, TextContentElement, TextElement, TextPathElement, TextPositioningElement, TitleElement0, UseElement, ViewElement, ZoomEvent, _GradientElement, _SVGAltGlyphDefElement, _SVGAltGlyphItemElement, _SVGComponentTransferFunctionElement, _SVGCursorElement, _SVGFEDropShadowElement, _SVGFontElement, _SVGFontFaceElement, _SVGFontFaceFormatElement, _SVGFontFaceNameElement, _SVGFontFaceSrcElement, _SVGFontFaceUriElement, _SVGGlyphElement, _SVGGlyphRefElement, _SVGHKernElement, _SVGMPathElement, _SVGMissingGlyphElement, _SVGVKernElement, AudioProcessingEvent, OfflineAudioCompletionEvent, ContextEvent, SqlError, NativeByteBuffer, NativeTypedData, NativeByteData, NativeFloat32List, NativeFloat64List, NativeInt16List, NativeInt32List, NativeInt8List, NativeUint16List, NativeUint32List, NativeUint8ClampedList, NativeUint8List, JS_CONST, Interceptor, JSBool, JSNull, JavaScriptObject, PlainJavaScriptObject, UnknownJavaScriptObject, JSArray, JSNumber, JSInt, JSDouble, JSString, _CodeUnits, startRootIsolate_closure, startRootIsolate_closure0, _Manager, _IsolateContext, _IsolateContext_handlePing_closure, _EventLoop, _EventLoop__runHelper_next, _IsolateEvent, _MainManagerStub, IsolateNatives__processWorkerMessage_closure, IsolateNatives__startIsolate_runStartFunction, _BaseSendPort, _NativeJsSendPort, _NativeJsSendPort_send_closure, _WorkerSendPort, RawReceivePortImpl, ReceivePortImpl, _JsSerializer, _JsCopier, _JsDeserializer, _JsVisitedMap, _MessageTraverserVisitedMap, _MessageTraverser, _Copier, _Copier_visitMap_closure, _Serializer, _Deserializer, TimerImpl, TimerImpl_internalCallback, TimerImpl_internalCallback0, CapabilityImpl, ConstantMap, ConstantStringMap, ConstantStringMap_values_closure, _ConstantMapKeyIterable, GeneralConstantMap, ReflectionInfo, TypeErrorDecoder, NullError, JsNoSuchMethodError, UnknownJsTypeError, unwrapException_saveStackTrace, _StackTrace, invokeClosure_closure, invokeClosure_closure0, invokeClosure_closure1, invokeClosure_closure2, invokeClosure_closure3, Closure, TearOffClosure, BoundClosure, RuntimeError, RuntimeType, RuntimeFunctionType, DynamicRuntimeType, TypeImpl, initHooks_closure, initHooks_closure0, initHooks_closure1, BruteForceAccel, BVHAccel, BVHAccel__recursiveBuild_ComparePoints, BVHAccel__recursiveBuild_CompareToMid, BVHAccel__recursiveBuild_CompareToBucket, _BVHPrimitiveInfo, _BVHBucketInfo, _BVHBuildNode, _LinearBVHNode, GridAccel, _Voxel, KdTreeAccel, KdTreeAccel__buildTree_closure, _KdToDo, _KdAccelNode, _BoundEdge, ArchiveException, InputStream, OutputStream, HuffmanTable, Inflate, ZLibDecoder, EnvironmentCamera, OrthographicCamera, PerspectiveCamera, AnimatedTransform, BBox, Camera, CameraSample, nth_element_closure, DifferentialGeometry, Film, Filter, ImageSampler, Integrator, Intersection, KdTree, _CompareNode, _KdNode, AreaLight, Light, LightSample, LightSampleOffsets, ShapeSet, VisibilityTester, Material, Matrix4x4, MIPMap, _ResampleWeight, Distribution1D, Distribution2D, PermutedHalton, Normal, Octree, _OctreeNode, OutputImage, ParamSet, ParamSet_addSpectrumFiles_closure, ParamSet_addSpectrumFiles_closure0, ParamSet__readFloatFile__isdigit, ParamSet__readFloatFile__isspace, ParamSetItem, Point, Aggregate, GeometricPrimitive, Primitive, TransformedPrimitive, ProjectiveCamera, Quaternion, Ray, RayDifferential, Anisotropic, Blinn, BRDFToBTDF, BSDF, BSDFSample, BSDFSampleOffsets, BxDF, Fresnel, FresnelBlend, FresnelConductor, FresnelDielectric, FresnelNoOp, IrregIsotropicBRDFSample, IrregularIsotropicBRDF, IrregularIsotropicBRDF_f_proc, Lambertian, Microfacet, MicrofacetDistribution, OrenNayar, RegularHalfangleBRDF, RegularHalfangleBRDF_f_REMAP, ScaledBxDF, SpecularReflection, SpecularTransmission, Renderer, ResourceManager, ResourceManager_requestFile_closure, ResourceManager_requestImage_closure, ResourceManager_waitUntilReady_closure, RGBColor, RNG, Sample, SampledSpectrum, _Spectrum, Sampler, Scene, Shape, Spectrum, Spectrum_SortSpectrumSamples_closure, Spectrum_AverageSpectrumSamples_INTERP, Spectrum_AverageSpectrumSamples_SEG_AVG, SpectrumImage, SphericalHarmonics_RotateXPlus_O, SphericalHarmonics__legendrep_P, StatTracker, StatsCounter, SurfaceIntegrator, ConstantTexture, CylindricalMapping2D, IdentityMapping3D, PlanarMapping2D, SphericalMapping2D, Texture, TextureMapping2D, TextureMapping3D, UVMapping2D, TextureParams, Transform, Vector, AggregateVolume, DensityRegion, VolumeRegion, VolumeIntegrator, XYZColor, ListIterable, SubListIterable, ListIterator, MappedIterable, EfficientLengthMappedIterable, MappedIterator, WhereIterable, WhereIterator, SkipIterable, EfficientLengthSkipIterable, SkipIterator, FixedLengthListMixin, UnmodifiableListMixin, UnmodifiableListBase, _AsyncError, Future, Future_wait_handleError, Future_wait_closure, _Completer, _AsyncCompleter, _Future, _Future__addListener_closure, _Future__chainForeignFuture_closure, _Future__chainForeignFuture_closure0, _Future__asyncComplete_closure, _Future__asyncComplete_closure0, _Future__asyncCompleteError_closure, _Future__propagateToListeners_handleValueCallback, _Future__propagateToListeners_handleError, _Future__propagateToListeners_handleWhenCompleteCallback, _Future__propagateToListeners_handleWhenCompleteCallback_closure, _Future__propagateToListeners_handleWhenCompleteCallback_closure0, _AsyncCallbackEntry, Stream, Stream_forEach_closure, Stream_forEach__closure, Stream_forEach__closure0, Stream_forEach_closure0, Stream_length_closure, Stream_length_closure0, Stream_isEmpty_closure, Stream_isEmpty_closure0, Stream_first_closure, Stream_first_closure0, StreamSubscription, _StreamController, _StreamController__subscribe_closure, _StreamController__recordCancel_complete, _SyncStreamControllerDispatch, _AsyncStreamControllerDispatch, _AsyncStreamController, _StreamController__AsyncStreamControllerDispatch, _SyncStreamController, _StreamController__SyncStreamControllerDispatch, _ControllerStream, _ControllerSubscription, _EventSink, _BufferingStreamSubscription, _BufferingStreamSubscription__sendError_sendError, _BufferingStreamSubscription__sendDone_sendDone, _StreamImpl, _DelayedEvent, _DelayedData, _DelayedError, _DelayedDone, _PendingEvents, _PendingEvents_schedule_closure, _StreamImplEvents, _cancelAndError_closure, _cancelAndErrorClosure_closure, _cancelAndValue_closure, _ForwardingStream, _ForwardingStreamSubscription, _SkipStream, _BaseZone, _BaseZone_bindCallback_closure, _BaseZone_bindCallback_closure0, _BaseZone_bindUnaryCallback_closure, _BaseZone_bindUnaryCallback_closure0, _rootHandleUncaughtError_closure, _rootHandleUncaughtError__closure, _RootZone, _HashMap, _HashMap_values_closure, HashMapKeyIterable, HashMapKeyIterator, _LinkedHashMap, _LinkedHashMap_values_closure, _LinkedHashMap_addAll_closure, LinkedHashMapCell, LinkedHashMapKeyIterable, LinkedHashMapKeyIterator, _HashSet, _IdentityHashSet, HashSetIterator, _LinkedHashSet, LinkedHashSetCell, LinkedHashSetIterator, _HashSetBase, IterableBase, ListBase, ListMixin, Maps_mapToString_closure, ListQueue, _ListQueueIterator, NoSuchMethodError_toString_closure, Comparable, DateTime, Duration, Duration_toString_sixDigits, Duration_toString_twoDigits, Error, NullThrownError, ArgumentError, RangeError, UnsupportedError, UnimplementedError, StateError, ConcurrentModificationError, OutOfMemoryError, StackOverflowError, CyclicInitializationError, _ExceptionImplementation, FormatException, IntegerDivisionByZeroException, Expando, Function, Iterator, Map, Null, Object, Pattern, StackTrace, Stopwatch, StringBuffer, Symbol, _ChildrenElementList, Interceptor_ListMixin, Interceptor_ListMixin_ImmutableListMixin, HttpRequest_request_closure0, HttpRequest_request_closure, _ChildNodeListLazy, Interceptor_ListMixin0, Interceptor_ListMixin_ImmutableListMixin0, Interceptor_ListMixin1, Interceptor_ListMixin_ImmutableListMixin1, EventStreamProvider, _EventStream, _EventStreamSubscription, ImmutableListMixin, FixedSizeListIterator, Capability, SendPort, _JSRandom, Float32List, Uint32List, Uint8List, NativeTypedArray, NativeTypedArrayOfDouble, NativeTypedArray_ListMixin, NativeTypedArray_ListMixin_FixedLengthListMixin, NativeTypedArrayOfInt, NativeTypedArray_ListMixin0, NativeTypedArray_ListMixin_FixedLengthListMixin0, RenderManager, RenderManager_loadFile_closure, RenderManager_loadFile_closure0, RenderManager__loadFile_closure, RenderManager__loadFile_closure0, RenderManager__loadFile_closure1, ImageFilm, BoxFilter, GaussianFilter, LanczosSincFilter, MitchellFilter, TriangleFilter, convertNativeToDart_AcceptStructuredClone_findSlot, convertNativeToDart_AcceptStructuredClone_readSlot, convertNativeToDart_AcceptStructuredClone_writeSlot, convertNativeToDart_AcceptStructuredClone_walk, FilteredElementList, FilteredElementList__filtered_closure, FilteredElementList_removeRange_closure, DecodeInfo, Decoder, ExrAttribute, ExrB44Compressor, ExrChannel, ExrCompressor, ExrHufDec, ExrImage, ExrPart, ExrPizCompressor, _PizChannelData, ExrPxr24Compressor, ExrRleCompressor, ExrZipCompressor, ExrDecoder, GifColorMap, GifImageDesc, GifInfo, GifDecoder, JpegAdobe, JpegComponent, JpegData, JpegFrame, JpegJfif, JpegScan, JpegDecoder, PngFrame, PngInfo, PngDecoder, PsdLayerAdditionalData, PsdLayerSectionDivider, PsdBlendingRanges, PsdChannel, PsdImage, PsdImageResource, PsdLayer, PsdLayerData, PsdMask, PsdDecoder, TiffBitReader, TiffEntry, TiffFaxDecoder, TiffImage, TiffInfo, LzwDecoder, TiffDecoder, VP8, VP8__upsample_LOAD_UV, VP8BitReader, VP8Filter, VP8FrameHeader, VP8PictureHeader, VP8SegmentHeader, VP8BandProbas, VP8Proba, VP8FilterHeader, VP8FInfo, VP8MB, VP8QuantMatrix, VP8MBData, VP8TopSamples, VP8L, VP8LBitReader, VP8LColorCache, VP8LTransform, _VP8LMultipliers, WebPAlpha, WebPFrame, _HuffmanTree, _HTreeGroup, WebPInfo, WebPDecoder, HdrImage, HdrSlice, hdrToImage__knee, hdrToImage__gamma, Image, ImageException, InputBuffer, OutputBuffer, RandomImageSampler, TileImageSampler, DiffuseAreaLight, DistantLight, GoniometricLight, GoniometricLight_closure, InfiniteAreaLight, InfiniteAreaLight_closure, _InfiniteAreaCube, PointLight, ProjectionLight, ProjectionLight_closure, SpotLight, GlassMaterial, KdSubsurfaceMaterial, MatteMaterial, MeasuredMaterial, MeasuredMaterial_closure, MeasuredMaterial_closure0, MetalMaterial, MirrorMaterial, MixMaterial, PlasticMaterial, ShinyMetalMaterial, SubstrateMaterial, SubsurfaceMaterial, TranslucentMaterial, UberMaterial, GraphicsState, Pbrt, Pbrt_renderScene_closure, Pbrt_renderScene__closure, PbrtLexer, _PbrtLexerInput, PbrtParser, PbrtParser_parse_closure, PbrtParser_parse__closure, PbrtParser_parse___closure, PbrtParser__loadIncludes_closure, PbrtParser__loadIncludes_closure0, PbrtParser__loadIncludes__closure, PbrtParser__loadIncludes__closure0, PbrtParser__loadIncludes_closure1, PbrtParser__parse_closure, PbrtParser__parseCommand_closure, RenderIsolate, RenderIsolate_start_closure, RenderIsolate__render_closure, RenderIsolate__render_closure0, RenderManagerInterface, RenderOptions, TransformSet, AggregateTestRenderer, MetropolisRenderer, _PathSample, _LightingSample, _PathVertex, _MLTSample, _MLTTask, SamplerRenderer, _SamplerRendererTask, AdaptiveSampler, BestCandidateSampler, BestCandidateSampler_getMoreSamples_WRAP, HaltonSampler, LowDiscrepancySampler, RandomSampler, StratifiedSampler, ConeShape, CylinderShape, DiskShape, HyperboloidShape, HyperboloidShape_area_SQR, HyperboloidShape_area_QUAD, LoopSubdivisionShape, _SDEdgeMap, _SDVertex, _SDFace, _SDEdge, ParaboloidShape, SphereShape, TriangleMeshShape, TriangleShape, AmbientOcclusionIntegrator, DiffusePRTIntegrator, DirectLightingIntegrator, GlossyPRTIntegrator, IGIIntegrator, _VirtualLight, IrradianceCacheIntegrator, IrradianceSample, IrradiancePrimeTask, IrradProcess, PathIntegrator, PhotonMapIntegrator, Photon, RadiancePhoton, PhotonShootingTask, ComputeRadianceTask, ClosePhoton, PhotonProcess, RadiancePhotonProcess, WhittedIntegrator, BilerpTexture, Checkerboard3DTexture, CheckerboardTexture, CheckerboardTexture_evaluate_BUMPINT, DotsTexture, FBmTexture, ImageTexture, ImageTexture_closure, MarbleTexture, MixTexture, ScaleTexture, UVTexture, WindyTexture, WrinkledTexture, EmissionIntegrator, SingleScatteringIntegrator, ExponentialDensityRegion, HomogeneousVolumeRegion, VolumeGridDensity];
}
